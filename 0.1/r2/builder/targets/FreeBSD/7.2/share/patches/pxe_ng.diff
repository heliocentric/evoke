diff -ruN sys/boot/i386/pxe_ng/Makefile sys/boot/i386/pxe_ng/Makefile
--- sys/boot/i386/pxe_ng/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/Makefile	2009-03-02 21:40:47.000000000 -0500
@@ -0,0 +1,50 @@
+# pxe_ng project
+#
+LIB=		pxe_ng
+INTERNALLIB=
+
+SRCS=	pxe_isr.S pxe_mem.c pxe_buffer.c pxe_await.c pxe_arp.c pxe_ip.c \
+	pxe_core.c pxe_icmp.c pxe_udp.c pxe_filter.c pxe_dns.c		\
+	pxe_dhcp.c pxe_segment.c pxe_tcp.c pxe_sock.c 			\
+	pxe_connection.c pxe_http.c pxe_httpls.c httpfs.c
+
+CFLAGS+=	-I${.CURDIR}/../../common -I${.CURDIR}/btx/lib \
+		-I${.CURDIR}/../../../contrib/dev/acpica \
+		-I${.CURDIR}/../../.. -I. -I$(.CURDIR)/.. -I${.CURDIR}/libi386/
+# the location of libstand
+CFLAGS+=	-I${.CURDIR}/libstand/
+
+#debug flag
+#CFLAGS+=	-DPXE_DEBUG
+#CFLAGS+=	-DPXE_DEBUG_HELL
+
+# core module debug
+#CFLAGS+=	-DPXE_CORE_DEBUG_HELL
+#CFLAGS+=	-DPXE_CORE_DEBUG
+# TCP module debug 
+#CFLAGS+=	-DPXE_TCP_DEBUG
+#CFLAGS+=	-DPXE_TCP_DEBUG_HELL
+# IP module debug
+#CFLAGS+=	-DPXE_IP_DEBUG
+#CFLAGS+=	-DPXE_IP_DEBUG_HELL
+# ARP module debug
+#CFLAGS+=	-DPXE_ARP_DEBUG
+#CFLAGS+=	-DPXE_ARP_DEBUG_HELL
+# httpfs module
+#CFLAGS+=	-DPXE_HTTP_DEBUG
+#CFLAGS+=	-DPXE_HTTP_DEBUG_HELL
+
+# define to get more PXE related code and testing functions
+#CFLAGS+=	-DPXE_MORE
+
+# define to get some speed up by bigger requests
+CFLAGS+=	-DPXE_HTTPFS_CACHING
+
+# define to send packets freqently to speed up connection
+#CFLAGS+=	-DPXE_TCP_AGRESSIVE
+
+# define to automatically choose non keep-alive method of
+# working, if keep-alive is not supported by server
+CFLAGS+=	-DPXE_HTTP_AUTO_KEEPALIVE
+
+.include <bsd.lib.mk>
diff -ruN sys/boot/i386/pxe_ng/README sys/boot/i386/pxe_ng/README
--- sys/boot/i386/pxe_ng/README	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/README	2009-03-02 20:14:23.000000000 -0500
@@ -0,0 +1,1256 @@
+Contents
+----------
+
+1. Introduction
+
+	1.2. Setting up
+
+		1.2.1. DHCP configuration
+		1.2.2. TFTP configuration
+		1.2.3. Web-server configuration
+		1.2.4. loader.rc configuratuion
+
+2. Project organisation
+
+	2.1. Code modules
+	2.2. Naming conventions
+	2.3. Understanding logical structure of code
+
+3. API usage
+
+	3.1. Base information
+	3.2. PXE sockets API overview
+
+		3.2.1. PXE API socket details
+
+	3.3. Quick Reference to API, available for user code
+
+		3.3.1. pxe_arp module
+		3.3.2. pxe_await module
+		3.3.3. pxe_buffer module
+		3.3.4. pxe_connection module
+		3.3.5. pxe_core module
+		3.3.6. pxe_dhcp module
+		3.3.7. pxe_dns module
+		3.3.8. pxe_filter module
+		3.3.9. pxe_http module
+		3.3.10. httpfs module
+		3.3.11. pxe_icmp module
+		3.3.12. pxe_ip module
+		3.3.13. pxe_isr module
+		3.3.14. pxe_mem module
+		3.3.15. pxe_sock module
+		3.3.16. pxe_segment module
+		3.3.17. pxe_tcp module
+		3.3.18. pxe_udp module
+
+4. Debugging, testing and tuning pxe_http library.
+
+	4.1. Using 'pxe' loader's command
+	4.2. Defining debug macroses
+	4.3. Tuning
+	4.4. NFS loading with pxe_http
+
+1. Introduction 
+----------------
+
+		pxe_http library is user space implementation of simplified
+	TCP/IP4 stack with support of sockets. Socket implementation is similar
+	to common sockets, but differs, so I call this variant of sockets -
+	"PXE sockets"
+
+		features (read: simpliest ever implementation of):
+			* supports TCP/UDP PXE sockets
+			* DHCP client
+			* DNS client
+			* http based filesystem
+			* ICMP echo
+
+1.1. Requirements
+------------------
+
+			To use pxeboot with extensions from pxe_http library
+		you need:
+		* DHCP server
+			- any DHCP server with support of some options
+			  (see below).  In example of configuration files
+			  ISC DHCP v.3.0.5 was used.
+		* TFTP server
+		* Web server - I've used Apache 1.3.34
+
+
+1.2. Setting it up
+-------------------
+
+		In most cases, it's the same as for usual pxeboot. Main
+	difference is in configuration file of DHCP server and in usage of
+	Web-server.
+
+
+1.2.1. DHCP configuration
+-------------------------
+
+		Here is example of configuration:
+
+		# /etc/dhcpd.conf example
+		#
+		ddns-update-style none;
+		server-name "DHCPserver";
+		server-identifier 192.168.0.4;
+		default-lease-time 7200;
+		max-lease-time 7200;
+	
+		#
+		# significant options for correct working of pxeboot
+		#
+
+		# your LAN subnet mask
+		option subnet-mask 255.255.255.0;
+
+		# default gateway to use
+		option routers 192.168.0.1;
+
+		# name of file to download via TFTP
+		filename "pxeboot";
+
+		# name server, used for resolving of domain names
+		option domain-name-servers 192.168.0.1;
+
+		# ip address of web server
+		option www-server 192.168.0.2;
+
+		# path, where nessesary files are stored on web server
+		option root-path "th.lan:/path/to/root";
+
+		subnet 192.168.0.0 netmask 255.255.255.0 {
+        		next-server 192.168.0.4;
+	        	range 192.168.0.10 192.168.0.20;
+		}
+        	
+		/*  end of example */
+
+	NOTES:
+		1. www-server option is used only if root-path is absent in
+		   DHCP reply. In that case assumed, that /boot directory is
+		   placed in DocumentRoot of web-server.
+		2. format of root-path has such format: "server:/path". It's
+		   possible use both IP's and domain names for server. /path is
+		   relative to DocumentRoot of web-server. In example above
+		   files are stored at /usr/local/www/data/path/to/root,
+		   assuming that /usr/local/www/data - is DocumentRoot.
+		3. DHCP options are not greater then 255 bytes. So, root-path
+		   must satisfy this requirement.
+
+
+1.2.2. TFTP configuration
+--------------------------
+
+		Same as usually. pxe_http doesn't directly use this protocol.
+
+
+1.2.3. Web-server configuration
+--------------------------------
+
+		Just copy all from "/boot" directory to
+	/DocumentRoot/path/to/root.
+	
+	NOTES:
+		1. Need to be sure, that partial downloading and keep-alive
+		   connections are supported by server. e.g. for Apache 1.x,
+		   check this options:
+
+			KeepAlive On
+			MaxKeepAliveRequests 10		# well, choose best for
+							# server
+			KeepAliveTimeout 15		# more then 2 seconds
+							# is good enough
+							
+		1.1 Non keep-alive connections supported if macro 
+		    PXE_HTTP_AUTO_KEEPALIVE defined. In this case, non keep-alive
+		    connections will be used if keep-alive are unavailable. 
+
+		2. loader checks gzipped versions of files first, it's good
+		   idea to compress every needed file. e.g.
+				beastie.4th.gz
+				device.hints
+				frames.4th.gz
+				loader.4th.gz
+				loader.conf
+				loader.help.gz
+				loader.rc
+				mfsroot.gz
+				screen.4th.gz
+				support.4th.gz
+				/kernel/kernel.gz
+
+1.2.4. loader.rc configuratuion
+--------------------------------
+
+		HTTP downloading of kernel is not all need to startup system
+	correctly. The main question is where will be root filesystem after
+	booting of kernel. The simpliest way - is to use RAM drive with
+	installation tools or ready to work system.
+		Here is example of changes to loader.rc, that instructs loader
+	to download RAM-drive image (in this example, common mfsroot.gz found
+	in boot.flp floppy image file)
+
+
+	\ Includes additional commands
+	include /boot/loader.4th
+
+	\ Reads and processes loader.conf variables
+	start
+
+	\ Tests for password -- executes autoboot first if a password was defined
+	check-password
+
+	\ Load in the boot menu
+	include /boot/beastie.4th
+
+	\ pxe_http changes:
+	echo "loading RAM-drive image"
+	load -t mfs_root /boot/mfsroot
+	set vfs.root.mountfrom="ufs:/dev/md0c"
+	\
+
+	\ Start the boot menu
+	beastie-start
+
+	/* end of example */
+
+		Of course, it's possible to set any other filesystem to work
+	as root, e,g, NFS and not use RAM drive.
+		
+2. Project organisation
+------------------------
+
+2.1. Code modules
+------------------
+
+	All project code is divided into following modules:
+		pxe_arp        - ARP protocol				(3.3.1)
+		pxe_await      - provides functions for awaiting	(3.3.2)
+		pxe_buffer     - implements cyclic buffers		(3.3.3)
+		pxe_connection - TCP connection related functions	(3.3.4)
+		pxe_core       - provides calls to PXE API		(3.3.5)
+		pxe_dhcp       - DHCP client				(3.3.6)
+		pxe_dns        - DNS client				(3.3.7)
+		pxe_filter     - incoming packet filters		(3.3.8)
+		pxe_http       - HTTP related functions			(3.3.9)
+		httpfs         - http based file system			(3.3.10)
+		pxe_icmp       - ICMP protocol				(3.3.11)
+		pxe_ip         - IP protocol				(3.3.12)
+		pxe_isr        - assembler side support for PXE API
+				 calling				(3.3.13)
+		pxe_mem        - memory work routines			(3.3.14)
+		pxe_sock       - simple sockets				(3.3.15)
+		pxe_segment    - TCP segments				(3.3.16)
+		pxe_tcp        - TCP protocol				(3.3.17)
+		pxe_udp        - UDP protocol				(3.3.18)
+
+2.2. Naming conventions
+------------------------
+
+		Most of functions, that may be called directly by user API uses
+	pxe_ prefix.
+		Functions related to some module have subprefix of this module,
+	e.g. pxe_dhcp_query() - function related to DHCP module.
+		All structures, that are used have typedef equivalent with
+	naming in upper case. e.g. struct pxe_ipaddr has equivalent PXE_IPADDR.
+	This is done to have similar to existing pxe.h declarations from libi386.
+
+
+2.3. Understanding logical structure of code
+---------------------------------------------
+
+		Logicallly all modules may be divided to parts.
+
+	        Part 1: PXE API related modules (pxe_isr, pxe_core)
+		Part 2: base protocols related (pxe_ip, pxe_udp)
+		Part 3: sockets related (pxe_sock)
+		Part 4: other protocols (pxe_dns, pxe_dhcp)
+		Part 5: utility (pxe_mem, pxe_buffer)
+
+		Some modules may be used independently, other depend on some
+	lower level modules.
+
+		In run-time, many calls to sockets functions start packet
+	recieving or packet sending functions. Sending is more simplier and may
+	be assumed in many cases just as wrappers to PXE API. But receiving is
+	a little bit more complicated. Receiving functions start
+	pxe_core_recv_packets()	function in cycle to get packets.
+		After receiving of packet, it's handling depends on it's type:
+	ARP, IP or other. ARP packets directly provided to handler
+	pxe_arp_protocol(), IP packets are provided to registered handler of IP
+	stack protocol, other packets are ignored.
+		Registration of handler (except ARP) is performed during
+	initialisation time of module with usage of pxe_core_register() function,
+	which register handler for IP stack protocol number.
+		So, packet is provided to handler, but it may be fragmented,
+	thus before processing it must be recieved completely. But in some cases
+	packet may be not interesting for protocol (unexpected packet, dublicated
+	or something else) and it's possible to determiny if this packet useful
+	just by examining of packet header.
+		If packet is fragmented - it firstly provided to handler with
+	flag PXE_CORE_FRAG. Handler returns appropriate value if is interested in
+	whole packet, packet is read completely from input queue of fragments and
+	provided again with flag PXE_CORE_HANDLE. Otherwise packet is dropped
+	in core by reading of all it's fragments from incoming queue.
+		Packet structure provides just buffer with received packet and
+	size of packet. All pxe_core module send/recieve functions work with
+	PXE_PACKET structure.
+		TCP and UDP protocols are checking filters in theirs handlers.
+	This helps to filter out packets that are not interesting for protocol
+	(e.g. to port that is not listening)
+		Socket and filter structures are separated. Socket provides
+	buffers for incoming and outcoming data. Filters may be used without
+	sockets, e.g. for TCP connections in TIME_WAIT state. For active
+	connection filter is used to determiny in which receiving buffer (in
+	which socket) must be placed incoming data.
+
+
+3. API usage
+-------------
+
+		Here much attention paid to sockets, other pxe_http API
+	may be used less frequently.
+
+3.1. Base information
+-----------------------
+
+		User code must perform initialisation of pxe_core module (which
+	is performed currently in loader during pxe_enable() call). After this
+	sockets related functions become available.
+
+	pxe_core_init() performs initialisation of pxe_core module and starts
+	initialisation routines of other modules. It inits TCP, UDP, ARP and
+	etc modules, however in most of cases it's possible skip theirs
+	initialisation if module's functions are unused.
+		Work is finished by pxe_core_shutdown() function.
+
+
+3.2. PXE sockets API overview
+-------------------------------
+
+		PXE sockets API differs from common sockets. It's more simplier
+	and has some limitations due user space implementations. All socket
+	related functions are declared in pxe_sock.h header
+
+		Socket is created by pxe_socket() call. After usage socket must
+	be closed by pxe_close() call. Result of pxe_socket() is integer
+	descriptor associated with socket. After creating socket is unbinded
+	and not connected.
+		pxe_sendto(), pxe_connect(), pxe_bind() functions performs
+	binding and connecting. After successful calling of one of them - socket
+	is in active state. It's possible to perform reading and sending from/to
+	socket. Cause socket API may use buffers to optimize packet sending
+	process, user code must call pxe_flush() functions to be sure, that
+	data is really processed to sending module.
+		While receiving need to keep in memory, that if UDP datagram is
+	not readed completely by one call of pxe_recv() in this implementation
+	rest of datagram is omited and lost for user code.
+		All incoming and outcoming data is written to socket buffers,
+	that have default sizes 16Kb and 4Kb. If buffers are full, next calls
+	related to writing or reading data will fail.
+
+
+3.2.1. PXE API socket details
+------------------------------
+
+	/* Here is simple example of API usage. */
+
+	int socket = pxe_socket();
+	/* if result is not -1, then socket variable contains value,
+	 * assosiated with socket structure. Call differs from common sockets,
+	 * there are no domain, type and protocol parameters.
+	 * Cause domain is always AF_INET now. others are use in pxe_connect()
+	 * call.
+	 */
+	
+	int result = pxe_connect(socket, &hh->addr, 80, PXE_TCP_PROTOCOL);
+	/*  This call creates filter, associates it with socket and establishes
+	 * communication if needed.
+	 * Parameters are socket, remote ip address (PXE_IPADDR), remote port
+	 * and one of PXE_UDP_PROTOCOL and PXE_TCP_PROTOCOL protocols.
+	 */
+	
+	if (result == -1) {
+		pxe_close(socket);
+		/* any socket must be closed, even if it was not really used
+		 * or conencted. pxe_close() call releases used internal
+		 * structures. After this call any other operations with
+		 * 'socket' descriptor are invalid. 
+		 */
+		return (0);
+	}
+
+	/* pxe_send() function sends data to socket. As usual, there is no
+	 * guarantee, that whole buffer is transmited. And actually for TCP
+	 * protocol, this call just places data to buffer. User code have no
+	 * knowledge if data is really sent to network. if current segment is
+	 * not fullly used, data may stay in buffer infinitely.
+	 */	
+	if (len != pxe_send(socket, hh->buf, len)) {
+		/* failed to send data, at least whole buffer */
+		pxe_close(socket);
+		return (0);
+	}
+
+	/* if user code need guarantee, that data is sent to remote host, it
+	 * must call pxe_flush(). It forces sending of any data, that must be
+	 * sent.
+	 */
+	if (pxe_flush(socket) == -1) {
+		/* failed to flush socket */
+		pxe_close(socket);
+		return (0);
+	}
+
+	/* perform reading cycle */
+
+	while (count < maxsize) {
+		/* pxe_recv() is similar to recv() call for common sockets,
+		 * but have no flags parameter
+		 */
+		result = pxe_recv(socket, &data[count], maxsize - count);
+		
+		if (result == -1) {	/* failed to recv */
+			break;
+		}
+		
+		if (result == 0)	/* nothing received yet */
+			continue;       
+
+		count += result;
+	}
+
+	pxe_close(socket);
+
+
+	/* End of example */
+
+
+3.3 Quick Reference to API, available for user code
+----------------------------------------------------
+
+		This overview covers functions and macro definitions that
+	may be usefull for user code.
+
+
+3.3.1 pxe_arp module
+---------------------
+
+		This module is used mainly by internal code while sending IP
+	packets.
+
+macro definitions:
+
+MAX_ARP_ENTRIES		- how much may be ARP table in size. If ARP table full
+			and new	MAC must be placed, then one of older entry is
+			replaced by new. Default number is 4.
+
+PXE_MAX_ARP_TRY		- how much trys will be peformed when sending ARP
+			requests, before say MAC search failed. Default: 3
+
+PXE_TIME_TO_DIE		- how much time to wait ARP reply in milliseconds.
+			Default: 5000 ms.
+
+PXE_ARP_SNIFF		- sometimes it's usefull to get senders MACs from
+			incoming requests (this may save time, MAC may be found
+			in table without requesting it by ARP module itself).
+			But if network is big enough - ARP table will be
+			updated too often. By default this option is defined.
+
+
+functions:
+
+void pxe_arp_init()
+	- inits pxe_arp module. Usually this call is performed from
+	pxe_core_init()
+
+const MAC_ADDR *pxe_arp_ip4mac(const PXE_IPADDR *addr)
+	- returns MAC address for requested IP address
+
+void pxe_arp_stats()
+	- shows ARP table. Available if defined PXE_MORE macro.
+
+
+3.3.2 pxe_await module
+-----------------------
+
+		Implements awaiting mechanism. Many operations are performed
+	similar	in protocol implementations. Usually, packet is sended and
+	application awaits for reply. pxe_await() function helps to simplify
+	code in such case.
+		It starts await callback function with some flags and counts
+	timeouts, try count. 
+
+		Here is example of awaiting:
+
+	/* we start awaiting, with dns_await() calllback function, maximum 4
+	 * trys, each try 20 seconds and waiting data static_wait_data.
+	 * Waiting data - is some data associated with current awaiting, it's
+	 * used by await callback function.
+	 */
+	if (!pxe_await(dns_await, 4, 20000, &static_wait_data))
+		return (NULL);
+
+	/*  pxe_await() returns 1 if awaiting was successfull (await function
+	 * returned PXE_AWAIT_COMPLETED flag)
+	 */
+
+	/* it's an awaiting function. pxe_await() provides current function,
+	 * current try number, time exceeded from start of try, pointer to
+	 * associated wait data.
+	 */
+	int
+	dns_await(uint8_t function, uint16_t try_number, uint32_t timeout,
+		  void *data)
+	{
+		/* cast to our type of wait data */
+		PXE_DNS_WAIT_DATA	*wait_data = (PXE_DNS_WAIT_DATA *)data;
+
+		switch(function) {
+
+		case PXE_AWAIT_STARTTRY:
+			/* is called at start of each try 
+			 * Here must be performed any await initialisation
+			 * (e.g. request packet sending )
+			 */
+			if (!dns_request(wait_data)) {
+				/* if initialisation of try failed, try more */
+				return (PXE_AWAIT_NEXTTRY); 
+			}
+			/* otherwise return success result of await function */
+			break;
+		
+		case PXE_AWAIT_FINISHTRY: 
+			/* this function is called at the end of any try (even
+			 * if try was successful). Here cleanup must be
+			 * performed.
+			 */
+			if (wait_data->socket != -1)
+				pxe_close(wait_data->socket);
+			
+			wait_data->id += 1;
+			break;
+
+		case PXE_AWAIT_NEWPACKETS:
+			/* while waiting this function called if new packets
+			 * were received by pxe_core_recv_packets(). Actually
+			 * it may be not packets we are waiting for, may be
+			 * even not packets with out protocol. Here we must
+			 * check for new usefull for us packets, receive 
+			 * new data if any.
+			 */
+			size = pxe_recv(wait_data->socket, wait_data->data,
+				    wait_data->size);
+
+			parse_dns_reply(wait_data);
+			
+			if (wait_data->result.ip != 0) {
+				/* return success of awaiting. This may be
+				 * returned from any function
+				 */
+			        return (PXE_AWAIT_COMPLETED);
+			}
+			
+			/* if await was not completed, continue waiting */
+			return (PXE_AWAIT_CONTINUE);
+			break;
+	
+			case PXE_AWAIT_END:
+			/* this called if await is ended without any result */
+			default:
+				break;
+		}
+	
+		return (PXE_AWAIT_OK);
+	}
+
+	/* end of example */
+
+		So, wait data used for providing and receiving data while
+	awaiting. pxe_await() performs unified working with code, needed for
+	waiting of incoming packets.
+
+macro definitions:
+
+TIME_DELTA_MS		- delay between iterations during awaitng. At each
+			iteration are checked:
+			* receiving of new packet. If received - awaiting
+			 function with PXE_AWAIT_NEWPACKETS function is called.
+			* try timeout. if timeout exceeds maximum timeout -
+			 awaiting  function with PXE_AWAIT_FINISHTRY and
+			 PXE_AWAIT_STARTTRY flags sequentially are called.
+			* try count. if try count exceeds maximum - awaiting
+			 function with PXE_AWAIT_ENDED flag is called. This
+			 means that await failed.
+			 Default: 1
+
+TIME_DELTA		- default: 1000, same as TIME_DELTA_MS, but in ticks
+			 for delay.
+
+
+3.3.3 pxe_buffer module
+------------------------
+	
+		This module provides reading and writing of cyclic buffers.
+	It's not used directly by user code.
+
+macro definitions:
+
+PXE_POOL_SLOTS 		- if defined, then statical allocation of buffers is
+			used. Otherwise buffers are allocated at run-time from
+			heap with pxe_alloc() function. Current statical
+			allocation algorithm is simple and square, there are
+			two big buffers data storages divided in slots (by
+			default 2).
+				Each slot has size equal to
+			PXE_DEFAULT_RECV_BUFSIZE or PXE_DEFAULT_SEND_BUFSIZE.
+			Depending on requested size in pxe_buffer_alloc()
+			function data allocated from one of stoarge and
+			related	slot marked busy. When pxe_buffer_free() called,
+			slot marked as free.
+				Default: undefined
+
+PXE_DEFAULT_RECV_BUFSIZE - size of receiving buffer. Default: 16392
+
+PXE_DEFAULT_SEND_BUFSIZE - size of sending buffer. Default: 4096
+
+
+3.3.4 pxe_connection module
+----------------------------
+
+		This module is one of TCP related modules. It implements
+	connection entity. TCP connection is logical structure, that have
+	needed by TCP protocol counters and states.
+		User code is not directly works with this module.
+
+macro definitions:
+
+PXE_MAX_TCP_CONNECTIONS		- how much simultaneous connections may be.
+
+
+functions:
+
+void pxe_connection_stats()
+	- returns connections statistics. Available if PXE_MORE macro is
+	defined.
+
+
+3.3.5 pxe_core module
+----------------------
+
+		This module performs lowlevel work with PXE API: initialisation,
+	receiving/sending of packets, provides information functions.
+		In most cases, user code doesn't uses this module directly.
+
+macro definitions:
+
+PXE_BUFFER_SIZE 	- size of core buffers, used in PXE API calling,
+			  Default: 4096
+
+PXE_CORE_STATIC_BUFFERS	- if defined, core buffers are allocated statically.
+			Otherwise they are allocated in heap. Default: defined
+
+functions:
+
+int pxe_core_recv_packets()
+	- recieves all packets waiting in incoming queue of NIC, and calls
+	appropriate protocols if needed
+
+
+void pxe_core_register(uint8_t ip_proto, pxe_protocol_call proc)
+	- registers IP stack protocol, associates protocol number and handler.
+
+const MAC_ADDR *pxe_get_mymac()
+	- returns MAC of NIC, for which PXE API is used.
+
+const PXE_IPADDR *pxe_get_ip(uint8_t id)
+	- returns of stored IP, for provided id.
+	id may be:
+		PXE_IP_MY		- NIC IP address
+		PXE_IP_NET		- network adrress
+		PXE_IP_NETMASK		- network mask
+		PXE_IP_NAMESERVER	- nameserver to use in name resolving
+		PXE_IP_GATEWAY		- default gateway
+		PXE_IP_BROADCAST	- broadcast address
+		PXE_IP_SERVER		- server from which loading of pxeboot
+					  was performed
+		PXE_IP_WWW		- IP address of http-server
+		PXE_IP_ROOT		- IP adddress of server, where root
+					  file system is situated.
+
+void pxe_set_ip(uint8_t id, const PXE_IPADDR *ip)
+	- sets value by it's id.
+
+time_t	pxe_get_secs()
+	- returns time in seconds. Used in timeout and resend checking.
+
+types:
+
+typedef int (*pxe_protocol_call)(PXE_PACKET *pack, uint8_t function)
+	- protocol callback function type
+
+
+3.3.6. pxe_dhcp module
+-----------------------
+
+		This module implements simple DHCP client, used to obtain
+	gateway, nameserver and other information.
+
+
+macro definitions:
+
+PXE_BOOTP_USE_LIBSTAND	- use bootp() function provided by libstand instead
+	of own DHCP client. NOTE: bootp() doesn't set nameip (nameserver ip
+	structure), thus DNS resolving will be impossible. Default: undefined
+	
+	NOTE: to use bootp(), also UDP_DEFAULT_SOCKET macro must be defined.
+
+
+functions:
+
+void pxe_dhcp_query(uint32_t xid)
+	- sends DHCPDISCOVER packet and sets core_ips, if gets reply.
+
+
+3.3.6. pxe_dns module
+----------------------
+
+		This module provides domain name resolving. Actually
+	A and CNAME resource records are supported.
+
+macro definitions:
+
+PXE_MAX_DNS_TIMEOUT	- max time to wait DNS reply in milliseconds.
+			Default: 10 seconds
+
+PXE_MAX_DNS_TRYS	- how many times to try to resend request,
+			if there is no reply. Default: 3
+
+PXE_DNS_MAX_PACKET_SIZE	- maximum UDP packet size in bytes. Default: 512.
+			This DNS client doesn't support TCP for resolving.
+
+functions:
+
+const PXE_IPADDR *pxe_gethostbyname(char *name)
+	- returns IP, if resolved, for provided domain name. 
+
+uint32_t pxe_convert_ipstr(char *str)
+	- converts string value of ipv4 to uint32_t value.
+
+
+3.3.8. pxe_filter module
+-------------------------
+
+		This module is not supposed to be used by user code directly.
+	It implements filtering of incoming IP packets. It's used by UDP and
+	TCP modules for sorting packets in appropriate socket.
+		Module provides functions for adding and removing filters.
+	Each filter contains source/destination ip:port definition and masks
+	for all of them. Usage of masks gives opportunity to recieve data
+	from subnet, or subset of ports.
+
+functions:
+
+void pxe_filter_init()
+	- inits filter module structures such as list of free filter entries.
+
+void pxe_filter_stats()
+	- show active filters information. Used for debugging. Available if
+	PXE_MORE macro defined.
+
+
+3.3.9. pxe_http module
+-----------------------
+
+		pxe_http implements functions for getting files via HTTP.
+	Most of it's functions are used only by httpfs module.
+		At opening file pxe_exists() function is called, which
+	gets filesize (if possible) by HEAD method of request and opens
+	connection to file. Result of pxe_exists() call is keep-alive
+	connection to file.
+		pxe_get() function gets needed data and reestablishes
+	connection if needed.
+		if PXE_MORE defined - pxe_get_close() function becomes
+	available. It opens connection, gets portion of data and closes
+	connection. It's rather not optimal usage of http connections,
+	but some times it may be needed (e.g. for servers, where keep
+	alive connections are prohibited).
+
+macro definitions:
+
+PXE_MAX_HTTP_HDRLEN	- buffer size for generating/getting http header.
+			Default: 1024 bytes.
+
+functions:
+
+int pxe_fetch(char *server, char *filename, off_t from, size_t size)
+	- testing function, gets file from server ()may be partially) and
+	outputs received data to screen. Available if PXE_MORE defined.
+
+
+3.3.10. httpfs module
+----------------------
+
+		httpfs is filesystem, available via HTTP. It is read-only
+	filesystem, mainly with sequential access to files. It exports
+	file operations structure and is not used directly by user code.
+		httpfs module may support some kind of caching: it requests
+	more data per request then it's needed at http_read() call and
+	reads this data later. Such approach speed ups connections speed
+	and reduces server load.
+		This opportunity is available if PXE_HTTPFS_CACHING macro
+	is defined.
+
+
+3.3.11. pxe_icmp module
+------------------------
+
+		pxe_icmp module provides some basic functionality of ICMP
+	protocol: echo requesting/replying.
+		Module is unavailable, if PXE_MORE undefined.
+
+
+macro definitions:
+
+PXE_ICMP_TIMEOUT	- timeout in milliseconds when waiting echo reply.
+		Default: 5000 ms.
+
+
+functions:
+
+int pxe_ping(const PXE_IPADDR *ip, int count, int flags)
+	- works similar to usual ping, sends echo request and shows timeout
+	before echo reply.
+
+int pxe_icmp_init()
+	- inits module
+
+
+3.3.12. pxe_ip module
+----------------------
+
+		This module implemets IP protocol functions, also it works
+	with routing table. It also declares PXE_IPADDR, that is used widely.
+
+macro definitions:
+
+PXE_MAX_ROUTES	- route table size. Default: 4, usually used 2 entries.
+
+
+functions:
+
+uint16_t pxe_ip_checksum(const void *data, size_t size)
+	- calculates checksum for provided block of data.
+
+
+void pxe_ip_route_init(const PXE_IPADDR *def_gw)
+	- inits routing table, sets default gateway
+
+
+int pxe_ip_route_add(const PXE_IPADDR *net, uint32_t mask,
+	const PXE_IPADDR *gw)
+	- adds route to routing table 
+
+int pxe_ip_route_del(const PXE_IPADDR *net, uint32_t mask,
+	const PXE_IPADDR *gw)
+	- dels route from routing table 
+
+uint32_t pxe_ip_get_netmask(const PXE_IPADDR *ip)
+	- returns class based netmask for ip.
+
+int pxe_ip_route_default(const PXE_IPADDR *gw)
+	- adds default gateway 
+
+int pxe_ip_send(void *data, const PXE_IPADDR *dst, uint8_t protocol,
+	uint16_t size)
+	-  sends ip packet with provided data. There must be space for
+	IP header in buffer, pointed by data.
+
+void pxe_ip_route_stat()
+	- show route table. Available if PXE_MORE defined
+
+
+3.3.13. pxe_isr module
+-----------------------
+
+		Contains assembler side functions, used in pxe_core.
+	User code has no direct access to them.
+		There supported: installation/removing of interrupt handler,
+	interrupt handler and wrapper for PXE API calls.
+
+
+3.3.14. pxe_mem module
+-----------------------
+
+		Actually this module just a wrapper to bcopy(), alloc() and free()
+	functions. That's done to make pxe_http library more portable.
+		But in fact, pxe_http depends much on other libstand functions,
+	such as printf(), strcpy() and etc. So this module is not very usefull and
+	will be probably removed in future.
+
+
+3.3.15. pxe_sock module
+------------------------
+
+		Most used by user code module. Contains implementation of
+	pxe_http sockets API.
+
+
+macro definitions:
+
+PXE_DEFAULT_SOCKETS	- count of sockets used at the same time. If all
+			socket structures are used, next socket creating calls
+			and API that depends on it, will fail. Default: 4
+
+
+PXE_SOCKET_TIMEOUT	- how long pxe_recv() will be wiating incoming data per
+			call before return error. Default: 30000 ms
+
+PXE_SOCKET_CHECK_TIMEOUT - If pxe_recv() waits incoming data and have big free
+			space in buffer, and in case of TCP protocol it may notice
+			remote server about this by sending empty packet (with
+			no data) acking current state, so remote host updates
+			knowledge about	receiving window of client and sends new
+			data.
+				That option specifies how long pxe_recv() will
+			be waiting before checking TCP connection. In fast
+			environments like LAN it speed ups connection when huge
+			amount of data is transmitted, in WAN it's not very
+			useful.
+				Default: 100 ms. This option works only if
+			PXE_TCP_AGRESSIVE macro is defined.
+
+PXE_SOCKET_ACCURATE	- adds extra socket validating at head of every
+			socket related function, available to user.
+			By default: defined.
+
+functions:
+
+void	pxe_sock_init()
+	- inits socket API module.
+
+void	pxe_sock_stats()
+	- prints out to screen socket usage statistics. Available if PXE_MORE
+	macro defined.
+
+int	pxe_sock_state(int socket)
+	- return current socket state. May be one of this states:
+	PXE_SOCKET_BINDED, PXE_SOCKET_CONNECTED, PXE_SOCKET_ESTABLISHED.
+	It may be used for checking, if connection was breaked.
+
+
+int	pxe_sendto(int socket, const PXE_IPADDR *dst, uint16_t port,
+	    void *data, uint16_t size)
+	-  sends to provided ip/port, updating filter for socket. If
+	socket is not connected, connects it. Blocking operation.
+
+int	pxe_connect(int socket, const PXE_IPADDR *ip, uint16_t port,
+	    uint8_t proto)
+	- establishes connection to remote host and updates needed filter
+	structures.
+
+int	pxe_send(int socket, void *buf, uint16_t buflen)
+	- sends data to socket, blocking operation till successfull sending
+	or error.
+
+int	pxe_recv(int socket, void *buf, uint16_t buflen)
+	- receives data from socket. Blocks till timeout, error or
+	successfull result.
+
+int	pxe_socket()
+	- creates new socket. Every socket must be closed after usage by
+	pxe_close() call.
+
+int	pxe_bind(int socket, const PXE_IPADDR *ip, uint16_t port,
+	    uint8_t proto)
+	- binds local ip, port for socket. Used e,g, by DHCP.
+
+int	pxe_flush(int socket)
+	- flushes sending buffer. After this call user code may be sure that
+	data was transmitted to network, but may be not received by remote
+	host yet.
+
+int	pxe_close(int socket)
+	- closes socket.
+
+uint16_t pxe_next_port()
+	- returns next available local port. It just increments at each call.
+
+
+3.3.16. pxe_segment module
+---------------------------
+
+		Part of TCP related modules. Contains functions used internally
+	for creating and sending TCP segments.
+		pxe_segment module uses memory space of sending buffer manually
+	without buffer writing functions. 
+		Buffer is divided to PXE_TCP_BLOCK_COUNT blocks, each block
+	is divided to PXE_TCP_CHUNK_COUNT chunks, by default 64 chunks at all
+	with size 64 bytes for each (for default buffer size 4096).
+		Packets may be "small" (e.g. system packets ACK, RST and etc)
+	and contain no user data. In such case usualy will be enough one chunk
+	for packet. Also packets may be "big", but not bigger than one block
+	size minus segment descriptor structure. If packet exclusevely uses
+	all chunks in block it gives about 460 user data per segment.
+		For client-side usage this must be enough.
+
+macro definitions:
+
+PXE_RESEND_TIME		- if during this time segment was not acked, it will be
+			resent. At every resend try this value will be increased.
+			Default: 1 second
+
+PXE_RESEND_TRYS		- how much resend trys to do. Default: 3
+
+PXE_TCP_BLOCK_COUNT     - how much blocks in memory buffer for segments.
+
+PXE_TCP_CHUNK_COUNT     - how much chhunks in buffer for segments.
+
+
+3.3.17. pxe_tcp module
+-----------------------
+
+		TCP related module. Implements handling of incoming packets,
+	it's functions are used internally.
+
+macro definitions:
+
+PXE_TCP_MSL		- maximum segment life time in milliseconds.
+			Used only in TINE_WAIT state. Default: 60000 ms.
+
+PXE_TCP_SYSBUF_SIZE	-  buffer size used for system messages for packets
+			without real connection. It may be for closed or
+			unxexisting connections. In such case there is no
+			bufer for outcoming segments, but module needs to send
+			at least RST. Default: 64 bytes.
+
+PXE_TCP_MSS		- maximum segment size. For Ethernet LAN it's 1460,
+			but for internet connections it may be useful to
+			use smaller segment size, e.g. 1260. Default: 1260
+
+functions:
+
+void pxe_tcp_init()
+	- inits TCP module. Usually started automatically from pxe_core_init()
+
+
+3.3.18. pxe_udp module
+-----------------------
+
+        	Implements UDP protocol. May be used without sockets API.
+
+macro definitions:
+
+UDP_DEFAULT_SOCKET	- if defined, "default UDP socket" is created. All
+			filtered out data goes to this socket. It was added
+			to support udpread() and udpsend() functions, used
+			by libstand itself. Also it may be used for working
+			with UDP module, skipping direct work with sockets API.
+			Default: undefined.
+
+functions:
+
+void pxe_udp_init()
+	- UDP module init
+
+void pxe_udp_shutdown()
+	- UDP module shutdown routine
+
+int pxe_udp_send(void *data, const PXE_IPADDR *dst, uint16_t dst_port,
+	uint16_t src_port, uint16_t size)
+	- sends udp packet.
+
+
+int pxe_udp_read(PXE_SOCKET *sock, void *tobuf, uint16_t buflen,
+	PXE_UDP_DGRAM *dgram_out)
+	-  reads data from udp socket. if sock == NULL, "default"
+	socket is assumed.
+
+
+4. Debugging, testing and tuning pxe_http library.
+--------------------------------------------------
+
+		pxe_http library has built-in testing functions, that may be
+	started from loader's console. For this PXE_MORE macro must be defined
+	while compiling loader and pxe_http itself.
+		After this 'pxe' command appears in list of available commands.
+	
+	
+4.1. Using 'pxe' loader's command
+----------------------------------
+
+		This commands helps to test working od pxe_http library and
+	contains one really usefull function ping.
+		While loading pxe_http gets gateway, nameserver & etc
+	information from DHCP server. In case if there is any error (e.g.
+	DHCP packet contains no information about nameserver) this must be
+	set manually for correct working of code.
+
+	command 'arp':
+		- this command test ARP protocol related functions.
+
+		 Example: pxe arp stats 
+				-  shows current arp table. It contains same
+				values as usual.
+			  pxe arp ip4.addres 
+				- trys to get MAC address of provided ip using
+				ARP protocol.
+
+	command 'await':
+		- used to test how implemented ICMP echo request and ARP
+		 request replying.
+
+		 Example: pxe await 
+				- starts infinte loop, in which will be
+				processed received packets. It's usefull for
+				testing ARP and ICMP request/replies. "Infinte"
+				means there is no exit from it without resetting
+				of PC.
+
+	command 'filters':
+		- shows current filters usage information.
+
+ 		 Example: pxe filters
+				- shows current filters usage. If all is ok,
+				sockets closed correctly, filters are free -
+				you will see something like "0/8 filters".
+				If there is connected socket, or there was
+				error somewhere in implementation - you will
+				see filters related info (source/destination
+				ip/ports, binded socket).
+
+	command 'ns':
+		- used to see and modify default nameserver.
+
+		 Example: pxe ns
+				- shows nameserver
+
+		 	  pxe ns ip4.addr
+				- sets nameserver to specified ip address.
+
+
+	command 'ping':
+		- performs similar actions to well known ping command. It sends
+		 echo requests and gets replies, calculating timeouts.
+
+		 Example: pxe ping ip4.addr
+				- performs sending five icmp echo requests to
+				specified ip address.
+
+	command 'resolve':
+		- performs sending DNS requests and extracts A or CNAME answers
+		 from nameserver replies. 
+
+		 Example: pxe resolve domain.name
+				- performs domain name resolution, using default
+				nameserver.
+
+	command 'route':
+		- works with routing table and used for ip based protocols.
+		 IP packet routed to first found route, routes are searched
+		 sequentially from start of table to end.
+
+		 Example: pxe route print 
+				- shows current routing table.
+
+			  pxe route add default ip4.addr
+				- sets default gateway
+
+			  pxe route add net4.addr gw4.addr
+				- sets gateway for network. Mask for network is
+				generated automatically from net address, CIDR
+				is not supported.
+
+			  pxe route del net4.addf gw4.addr 
+				- removes route from table.
+
+	command 'socket':
+		- currently just shows statistics related to active sockets.
+
+		 Example: pxe socket stats
+				- show active sockets information.
+
+
+4.2. Defining debug macroses
+-----------------------------
+
+		All debug macroses divided in groups to provide more flexible
+	debugging of exact module. There are two levels of debugging:
+	first just adds _DEBUG suffix to macro, next _DEBUG_HELL. Second one
+	as expected from it's naming - provides more information.
+		All this macro definitions are situated in project Makefile.
+
+
+macro definitions:
+
+PXE_DEBUG
+PXE_DEBUG_HELL		- common modules debuging. This macroses adds debug
+			information output toi all modules, that are not
+			covered by macroses below.
+
+			NOTE: defining PXE_DEBUG macro doesn't defines
+			 e.g. PXE_CORE_DEBUG. It must be set manually.
+
+PXE_CORE_DEBUG
+PXE_CORE_DEBUG_HELL	- pxe_core module debuging
+
+PXE_TCP_DEBUG
+PXE_TCP_DEBUG_HELL	- related to TCP modules debuging
+
+PXE_IP_DEBUG
+PXE_IP_DEBUG_HELL	- IP module debug. Includes routing.
+
+PXE_ARP_DEBUG
+PXE_ARP_DEBUG_HELL	- ARP module debug
+
+PXE_HTTP_DEBUG
+PXE_HTTP_DEBUG_HELL	- httpfs and pxe_http module debugging
+
+PXE_MORE		- adds functions, used to out to screen information
+			about filters, sockets and etc usage.
+
+4.3. Tuning
+------------
+
+		Well, pxe_http library developed as library that implements
+	client sockets API. But, it may be used in different environments and
+	thus may have different behaviour e,g, in LAN and in WAN.
+		In most cases it works well in both cases, but if not - here is
+	some hints that may be usefull.
+
+		In LAN usually packet loss is small and speed is fast, so
+	it may be good idea to define PXE_TCP_AGRESSIVE macro (see 3.3.15).
+		PXE_TCP_MSS may me set to 1460 without any doubts.
+		Buffer sizes may be set higher (3.3.3). 16K for incoming
+	traffic is good enough for WAN connections, but for LAN it may be set
+	higher. If big UDP datagrams are sended, send buffer must be set to
+	such space, in which it may fit.
+		Also all timeouts may be smaller. For example, first candidate
+	for it is TIME_DELTA (3.3.2)
+
+		Next point - what buffers use: statically allocated or
+	dinamically. Default variant is best (at least, I think so) but
+	it may be not bad idea to play with PXE_CORE_STATIC_BUFFERS and 
+	PXE_POOL_COUNT.
+
+		It may be usefull to turn off httpfs caching. Using of
+	caching speed ups getting of file, but anyway undefining of
+	PXE_HTTPFS_CACHING still gives working code.
+
+
+4.4. NFS loading with pxe_http
+-------------------------------
+
+		Original pxeboot has ability to load kernel, loader.rc and etc.
+	pke_http may provide udpread()/udpsend() functions needed for that.
+
+		undefine:	loader/Makefile: LOADER_HTTP_SUPPORT
+		define:		pxe_http/pxe_udp.h: UDP_DEFAULT_SOCKET
+				pxe_http/pxe_dhcp.h: PXE_BOOTP_USE_LIBSTAND
+				libi386/Makefile: PXEHTTP_UDP_FOR_LIBSTAND
+
+	After that - NFS loader must work, as well as TFTP.		
\ No newline at end of file
diff -ruN sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.c sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.c
--- sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.c	2009-03-02 20:18:12.000000000 -0500
@@ -0,0 +1,1158 @@
+/*-
+ * Copyright (c) 2004 Takanori Watanabe
+ * All rights reserved.
+  *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/acpi_support/acpi_sony.c,v 1.10 2006/11/01 03:45:24 kevlo Exp $");
+
+#include "opt_acpi.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/bus.h>
+#include <sys/module.h>
+#include <sys/malloc.h>
+#include <sys/sysctl.h>
+#include <sys/stdint.h>
+#include <sys/proc.h>
+
+#include <contrib/dev/acpica/acpi.h>
+#include "acpi_if.h"
+#include <dev/acpica/acpivar.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/rman.h>
+
+#include <machine/pci_cfgreg.h>
+#include <dev/pci/pcivar.h>
+#include <dev/pci/pcireg.h>
+
+#include "acpi_sony.h"
+
+/*
+ * Declarations
+ */
+#define _COMPONENT	ACPI_OEM
+
+ACPI_MODULE_NAME("Sony")
+ACPI_SERIAL_DECL(sony, "Sony extras");
+
+static int	acpi_sony_probe(device_t dev);
+static int	acpi_sony_attach(device_t dev);
+static int 	acpi_sony_detach(device_t dev);
+static int	acpi_snc_sysctl(SYSCTL_HANDLER_ARGS);
+static int	acpi_spic_sysctl(SYSCTL_HANDLER_ARGS);
+static void	acpi_snc_notify_handler(ACPI_HANDLE h, uint32_t notify, void *context);
+static void	acpi_spic_intr(void * arg);
+/*
+static d_open_t		acpi_sony_spic_open;
+static d_close_t		acpi_sony_spic_close;
+static d_read_t		acpi_sony_spic_read;
+static d_ioctl_t		acpi_sony_spic_ioctl;
+static d_poll_t		acpi_sony_spic_poll;
+
+static struct cdevsw spic_cdevsw = {
+	.d_version =	D_VERSION,
+	.d_flags =	D_NEEDGIANT,
+	.d_open =	acpi_sony_spic_open,
+	.d_close =	acpi_sony_spic_close,
+	.d_read =	acpi_sony_spic_read,
+	.d_ioctl =	acpi_sony_spic_ioctl,
+	.d_poll =	acpi_sony_spic_poll,
+	.d_name =	"spic",
+};
+*/
+
+static device_method_t acpi_sony_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, acpi_sony_probe),
+	DEVMETHOD(device_attach, acpi_sony_attach),
+	DEVMETHOD(device_detach, acpi_sony_detach),
+
+	{0, 0}
+};
+
+static driver_t	acpi_sony_driver = {
+	"acpi_sony",
+	acpi_sony_methods,
+	sizeof(struct acpi_sony_softc),
+};
+
+static devclass_t	acpi_sony_devclass;
+
+DRIVER_MODULE(acpi_sony, acpi, acpi_sony_driver, acpi_sony_devclass, 0, 0);
+MODULE_DEPEND(acpi_sony, acpi, 1, 1, 1);
+
+static char	*sony_snc_id[] = {"SNY5001", NULL};
+static char	*sony_spic_id[] = {"SNY6001", NULL};
+
+/*
+ * SPIC related functions
+ */
+
+/* acpi_spic_type()	- returns type of SPIC.
+ * in:
+ *	dev	- SPIC device_t structure
+ * out:
+ *	one of SPIC_TYPE constants
+ */
+static enum SPIC_TYPE
+acpi_spic_type(device_t dev)
+{
+	enum SPIC_TYPE			model = SPIC_TYPE2;
+    	const struct spic_pciid	*p = spic_pciids;
+	device_t				device;
+    
+	while (p->vid != 0) {
+		device = pci_find_device(p->vid, p->did);
+		
+		if (device != NULL) {
+			model = p->type;
+			break;
+		}
+		
+		++p;
+	}
+
+	device_printf(dev, "assuming type%d model\n", model + 1);
+
+	return (model);
+}
+
+/* acpi_spic_write_port1()	- writes value to 1st SPIC port.
+ * in:
+ *	sc	- driver softc structure
+ *	val	- value to write
+ * out:
+ *	none
+ */
+static void
+acpi_spic_write_port1(struct acpi_sony_softc *sc, uint8_t val)
+{
+    
+	DELAY(10);
+    
+	outb(sc->port_addr, val);
+}
+
+/* acpi_spic_write_port2()	- writes value to 2nd SPIC port.
+ * in:
+ *	sc	- driver softc structure
+ *	val	- value to write
+ * out:
+ *	none
+ */
+static void
+acpi_spic_write_port2(struct acpi_sony_softc *sc, uint8_t val)
+{
+    
+	DELAY(10);
+    
+	outb(sc->port_addr + 4, val);
+}
+
+/* acpi_spic_read_port1()	- reads value from 1st SPIC port.
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	readed value
+ */
+static uint8_t
+acpi_spic_read_port1(struct acpi_sony_softc *sc)
+{
+    
+	DELAY(10);
+    
+	return (inb(sc->port_addr));
+}
+
+/* acpi_spic_read_port2()	- reads value from 2nd SPIC port.
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	readed value
+ */
+static uint8_t
+acpi_spic_read_port2(struct acpi_sony_softc *sc)
+{
+    
+	DELAY(10);
+    
+	return (inb(sc->port_addr + 4));
+}
+
+/* acpi_spic_busy_wait() - synching with port
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	none
+ */
+static void
+acpi_spic_busy_wait(struct acpi_sony_softc *sc)
+{
+	int i= 0;
+
+	while (acpi_spic_read_port2(sc) & 2) {
+		DELAY(10);
+	    
+		if (++i > 10000) {
+			printf("acpi_spic_busy_wait() abort\n");
+			return;
+		}
+	}
+}
+
+/* acpi_spic_call1() - first variant of call
+ * in:
+ *	sc	- driver softc structure
+ *	dev	- which device to query
+ * out:
+ *	returned value
+ */
+static uint8_t
+acpi_spic_call1(struct acpi_sony_softc *sc, uint8_t dev)
+{
+    
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port2(sc, dev);
+	acpi_spic_read_port2(sc);
+    
+	return (acpi_spic_read_port1(sc));
+}
+
+/* acpi_spic_call1() - second variant of call
+ * in:
+ *	sc	- driver softc structure
+ *	dev	- which device to query
+ *	fn	- function to call
+ * out:
+ *	returned value
+ */
+static uint8_t
+acpi_spic_call2(struct acpi_sony_softc *sc, uint8_t dev,
+	uint8_t fn)
+{
+    
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port2(sc, dev);
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port1(sc, fn);
+    
+	return (acpi_spic_read_port1(sc));
+}
+
+#ifdef code_for_camera_works
+static uint8_t
+acpi_spic_call3(struct acpi_sony_softc *sc, uint8_t dev, uint8_t fn,
+	uint8_t v)
+{
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port2(sc, dev);
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port1(sc, fn);
+	acpi_spic_busy_wait(sc);
+	acpi_spic_write_port1(sc, v);
+    
+	return (acpi_spic_read_port1(sc));
+}
+#endif
+
+/* acpi_spic_crs() - dumps currently used by device resources
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	none
+ */
+static void
+acpi_spic_crs(struct acpi_sony_softc *sc)
+{
+    	ACPI_STATUS	status;
+	ACPI_BUFFER	buffer;
+ 
+	struct {
+		ACPI_RESOURCE io;
+		ACPI_RESOURCE intr;
+		ACPI_RESOURCE endtag;
+	} *resource;	
+
+	/* init acpi_buffer */
+	resource = AcpiOsAllocate(sizeof(*resource) );
+    
+	if (resource == NULL) /* failed to alllocate resource structure */
+		return;
+
+	buffer.Length = sizeof(*resource) ;
+	buffer.Pointer = resource;
+    
+	status = AcpiGetCurrentResources(sc->handle, &buffer);
+
+	/* check for total failure */
+	if (ACPI_FAILURE(status)) {
+		device_printf(sc->dev, "failed to get current resources.\n");
+		return;
+	}
+
+	device_printf(sc->dev, "Current resources = IO: 0x%x/%d, IRQ: 0x%x\n",
+		      resource->io.Data.Io.Minimum, resource->io.Data.Io.AddressLength,
+		      resource->intr.Data.Irq.Interrupts[0]);
+}
+
+/* acpi_spic_dis() - disables SPIC by calling of _DIS method
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	none
+ */
+static void
+acpi_spic_dis(struct acpi_sony_softc *sc)
+{
+    
+	if (ACPI_FAILURE(AcpiEvaluateObject(sc->handle,
+			"_DIS", NULL, NULL)))
+	{
+	    	device_printf(sc->dev, "failed to disable\n");
+		return;
+	}
+
+	device_printf(sc->dev, "device is disabled\n");
+}
+
+/* acpi_spic_srs() - calls _SRC method to set allocated resources
+ * in:
+ *	sc	- driver softc structure
+ * out:
+ *	0		- all is ok
+ *	not 0	- some error occured
+ */
+static int
+acpi_spic_srs(struct acpi_sony_softc *sc)
+{
+	ACPI_STATUS	status;
+	ACPI_BUFFER	buffer;
+	int			result = 0;
+ 
+	struct {
+		ACPI_RESOURCE io;
+		ACPI_RESOURCE intr;
+		ACPI_RESOURCE endtag;
+	} *resource;	
+
+	/* init acpi_buffer */
+	resource = AcpiOsAllocate(sizeof(*resource));
+    
+	if (resource == NULL) /* failed to alllocate resource structure */
+		return (ENOMEM);
+
+	buffer.Length = sizeof(*resource) ;
+	buffer.Pointer = resource;
+
+	/* setup io resource */
+	resource->io.Type = ACPI_RESOURCE_TYPE_IO;
+	resource->io.Length = sizeof(ACPI_RESOURCE);
+	memcpy(&(resource->io.Data.Io), &(sc->io), sizeof(ACPI_RESOURCE_IO));
+
+	/* setup irq resource */
+	resource->intr.Type = ACPI_RESOURCE_TYPE_IRQ;
+	resource->intr.Length = sizeof(ACPI_RESOURCE);
+	memcpy(&resource->intr.Data.Irq, &(sc->interrupt),
+			sizeof(ACPI_RESOURCE_IRQ));
+    
+	resource->endtag.Type = ACPI_RESOURCE_TYPE_END_TAG;
+
+	/* Attempt to set the resource */
+	status = AcpiSetCurrentResources(sc->handle, &buffer);
+
+	/* check for total failure */
+	if (ACPI_FAILURE(status)) {
+		device_printf(sc->dev, "failed to set resources.\n");
+		result = ENODEV;
+	}
+
+end:
+	AcpiOsFree(resource);
+    
+	return (result);
+}
+
+/* acpi_spic_try_irq() - trys to allocate irq, found while walking
+ *		ACPI resources for SPIC
+ * in:
+ *	sc			- driver softc structure
+ *	intn		- irq index in provided resource
+ *	resources	- ACPI resource containing IRQ data 
+ * out:
+ *	1	- all is ok
+ *	0	- some error occured
+ */
+static int
+acpi_spic_try_irq(struct acpi_sony_softc *sc, uint8_t intn,
+	ACPI_RESOURCE *resource)
+{
+   
+	if (!(sc->intr_res = bus_alloc_resource(sc->dev, SYS_RES_IRQ,
+						&sc->intr_rid,
+						resource->Data.Irq.Interrupts[intn],
+						resource->Data.Irq.Interrupts[intn], 1,
+						RF_ACTIVE | RF_SHAREABLE)))
+	{
+		return (0);
+	}
+	
+	sc->intr = (uint16_t)rman_get_start(sc->intr_res);
+    
+	memcpy(&(sc->interrupt), &(resource->Data.Irq),
+	       sizeof(ACPI_RESOURCE_IRQ));
+    
+	sc->interrupt.Interrupts[0] = sc->intr;
+	sc->interrupt.InterruptCount = 1;
+        
+    	device_printf(sc->dev,"using IRQ 0x%x\n", sc->intr);
+    
+	return (1);
+}
+
+/* acpi_spic_try_io() - trys to allocate io resource, found while walking
+ *		ACPI resources for SPIC
+ * in:
+ *	sc			- driver softc structure
+  *	resources	- ACPI resource containing IO data 
+ * out:
+ *	1	- all is ok
+ *	0	- some error occured
+ */
+static int
+acpi_spic_try_io(struct acpi_sony_softc *sc, ACPI_RESOURCE *resource)
+{
+	if (!(sc->port_res = bus_alloc_resource(sc->dev, SYS_RES_IOPORT,
+						&sc->port_rid,
+						resource->Data.Io.Minimum,
+						resource->Data.Io.Maximum,
+						resource->Data.Io.AddressLength,
+						RF_ACTIVE | RF_SHAREABLE)))
+	{
+		return (0);
+	}
+	
+	device_printf(sc->dev, "using IO ports 0x%x-0x%x/%d\n",
+                resource->Data.Io.Minimum,
+		resource->Data.Io.Maximum,
+		resource->Data.Io.AddressLength);
+    
+	sc->port_addr = (uint16_t)rman_get_start(sc->port_res);
+	
+	memcpy(&(sc->io), &(resource->Data.Io), sizeof(ACPI_RESOURCE_IO));
+        
+	return (1);
+}
+
+/* acpi_spic_walk_prs() - callback function used in walking of
+ *		ACPI resources for SPIC
+ * in:
+ *	resource	- found ACPI resource
+  *	context		- context (driver softc structure) 
+ * out:
+ *	AE_CTRL_TERMINATE	- if found, or any error
+ *	AE_OK				- processed resource
+ */
+static ACPI_STATUS
+acpi_spic_walk_prs(ACPI_RESOURCE *resource, void *context)
+{
+	struct acpi_sony_softc *sc = (struct acpi_sony_softc *)context;
+    
+	if (sc->port_res && sc->intr_res)
+		return (AE_CTRL_TERMINATE);
+	
+	switch (resource->Type) {
+	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
+	case ACPI_RESOURCE_TYPE_END_DEPENDENT:
+		return AE_OK;
+	    
+	case ACPI_RESOURCE_TYPE_IRQ:
+		
+		/* already allocated */
+		if (sc->intr_res)
+			return AE_OK;
+	    
+		for (int i = 0; i < resource->Data.Irq.InterruptCount; ++i)
+			if (acpi_spic_try_irq(sc, i, resource))
+				break;
+				
+                return (AE_OK);
+	    
+	case ACPI_RESOURCE_TYPE_IO:
+		
+		if (sc->port_res)
+			return (AE_OK);
+	    
+ 		if (resource->Data.Io.AddressLength <= 0)
+			return (AE_OK);
+			     
+		acpi_spic_try_io(sc, resource);
+	    
+		return (AE_OK);
+	
+	case ACPI_RESOURCE_TYPE_END_TAG:
+		return (AE_OK);
+	}
+    
+	return (AE_CTRL_TERMINATE);
+}
+
+/* acpi_spic_attach() - attaches driver for SPIC
+ * in:
+ *	sc			- driver softc structure
+* out:
+ *	0		- all is ok
+ *	not 0	- some error
+ */
+static int
+acpi_spic_attach(struct acpi_sony_softc *sc)
+{
+	int result = 0;
+	int i = 0;
+	
+	ACPI_STATUS	status;
+    
+	devclass_t	ec_devclass;
+
+	sc->model = acpi_spic_type(sc->dev);
+	sc->evport_offset = spic_types[sc->model].evport_offset;
+	sc->events = spic_types[sc->model].events;
+
+	if (!(ec_devclass = devclass_find ("acpi_ec"))) {
+		device_printf(sc->dev, "Couldn't find acpi_ec devclass\n");
+		return (EINVAL);
+	}
+	
+	if (!(sc->ec_dev = devclass_get_device(ec_devclass, 0))) {
+		device_printf(sc->dev, "Couldn't find acpi_ec device\n");
+		return (EINVAL);
+	}
+	
+	sc->ec_handle = acpi_get_handle(sc->ec_dev);
+
+    	for (i = 0 ; acpi_spic_oids[i].name != NULL; i++){
+		SYSCTL_ADD_PROC(&(sc->sysctl_ctx),
+			SYSCTL_CHILDREN(sc->sysctl_tree),
+			OID_AUTO, acpi_spic_oids[i].name,
+			acpi_spic_oids[i].access,
+			sc, i, acpi_spic_sysctl, "I",
+			acpi_spic_oids[i].comment);
+	}
+
+	acpi_spic_crs(sc);
+    
+	status = AcpiWalkResources(sc->handle, "_PRS", acpi_spic_walk_prs, sc);
+
+	if (	(sc->port_res == NULL) ||
+		(sc->intr_res == NULL))
+	{
+		device_printf(sc->dev, "failed to allocate resources\n");
+		return (ENXIO);
+	}
+
+	if ( (result = acpi_spic_srs(sc))  == 0) {
+    
+		result = bus_setup_intr(sc->dev, sc->intr_res, INTR_TYPE_MISC, NULL,
+					acpi_spic_intr, sc, &sc->icookie);
+
+		acpi_spic_call1(sc, 0x82);
+		acpi_spic_call2(sc, 0x81, 0xff);
+		acpi_spic_call1(sc, 0x82);
+	    
+		//make_dev(&spic_cdevsw, 0, 0, 0, 0600, "jogdial");
+	}
+
+	return (result);
+}
+
+/* acpi_spic_sysctl_get() - used to get values for SPIC oids
+ * in:
+ *	sc			- driver softc structure
+ *	method		- method code
+* out:
+ *	integer value of oid
+ */
+static int
+acpi_spic_sysctl_get(struct acpi_sony_softc *sc, int method)
+{
+	ACPI_INTEGER    val_ec;
+	int             val = 0;
+    
+    	ACPI_FUNCTION_TRACE((char *)(uintptr_t)__func__);
+
+	switch (method) {
+		case ACPI_SONY_METHOD_BLUETOOTH_POWER:
+			val = sc->power_bluetooth;
+			break;
+	    
+		case ACPI_SONY_METHOD_FAN:
+			ACPI_EC_READ(sc->ec_dev, SONY_EC_FANSPEED, &val_ec, 1);
+			val = val_ec;
+			break;
+
+		default:
+			break;
+	}
+
+	return (val);
+}
+
+/* acpi_spic_sysctl_set() - used to set values for SPIC oids
+ * in:
+ *	sc			- driver softc structure
+ *	method		- method code
+ *	arg 		- value to set
+* out:
+ *	0		- all is ok
+ *	not 0	- some error
+ */
+static int
+acpi_spic_sysctl_set(struct acpi_sony_softc *sc, int method, int arg)
+{
+	ACPI_INTEGER		val_ec;
+	
+	ACPI_FUNCTION_TRACE((char *)(uintptr_t)__func__);
+
+	switch (method) {
+	    case ACPI_SONY_METHOD_FAN:
+			val_ec = arg;
+			ACPI_EC_WRITE(sc->ec_dev, SONY_EC_FANSPEED, val_ec, 1);
+			break;
+	
+	case ACPI_SONY_METHOD_BLUETOOTH_POWER:
+	 	if (sc->power_bluetooth == arg)
+			return (0);
+
+		acpi_spic_call2(sc, 0x96, arg);
+		acpi_spic_call1(sc, 0x82);
+		sc->power_bluetooth = arg;
+	    
+		break;
+	    
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+/* acpi_spic_sysctl() - called when needed to set or get
+ *				values for SPIC oids
+ * in:
+ *	SYSCTL_HANDLER_ARGS
+* out:
+ *	0		- success
+ *	not 0	- some error
+ */
+static int
+acpi_spic_sysctl(SYSCTL_HANDLER_ARGS)
+{
+        struct acpi_sony_softc	*sc;
+        int						arg;
+	int						error = 0;
+	int						function;
+	int						method;
+
+        sc = (struct acpi_sony_softc *)oidp->oid_arg1;
+        function = oidp->oid_arg2;
+        method = acpi_spic_oids[function].method;
+
+	arg = acpi_spic_sysctl_get(sc, method);
+	error = sysctl_handle_int(oidp, &arg, 0, req);
+	
+	if (error != 0 || req->newptr == NULL)
+		goto out;
+
+	error = acpi_spic_sysctl_set(sc, method, arg);
+
+out:
+	return (error);
+}
+
+/* acpi_spic_report_event() - used to report about occured SPIC event
+ * in:
+ *	sc			- driver softc structure
+ *	event		- SPIC event code
+ *	mask		- mask of event
+ *	mapped_event- one of SPIC_EVENT_.. codes
+* out:
+ *	none
+ */
+static void
+acpi_spic_report_event(struct acpi_sony_softc *sc, uint8_t event,
+	uint8_t mask, uint8_t mapped_event)
+{
+#ifdef ACPI_SONY_VERBOSE
+	if (mapped_event != SPIC_EVENT_NONE)
+		device_printf(sc->dev, "event 0x%x/0x%x => 0x%x (%s)\n",
+			event, mask, mapped_event, event_descriptors[mapped_event - 1].name);
+#endif
+    	
+	/* notify devd, system "ACPI", subsystem "SPIC" */
+	acpi_UserNotify("SPIC", sc->handle, mapped_event);
+    
+	/* clear event */
+	acpi_spic_call2(sc, 0x81, 0xff);
+}
+
+/* acpi_spic4_pkey_handler() - special programmable key handling for type4
+ *		cause of stamina/speed switch generates same event number as
+ *		programmable key 2 in second turn
+ * in:
+ *	sc			- driver softc structure
+ *	group		- event group
+ *	mask		- mask of event
+ *	event		- SPIC event code
+* out:
+ *	1			- event handled
+ *	0			- event not handled
+ */
+static int
+acpi_spic4_pkey_handler(struct acpi_sony_softc *sc,
+	struct spic_event_group *group, uint8_t mask, uint8_t event)
+{
+	
+	switch (sc->prev_event) {
+	case 0:
+	case 0x5c:
+		break;
+	    
+	case 0x61:
+		if (event == 0x02)
+			acpi_spic_report_event(sc, event, mask,
+				SPIC_EVENT_TOGGLE_SPEED);
+	    
+		return (1);
+	
+	case 0x5f:
+		/* i have not received such mask on my laptop */
+		
+	default:
+		device_printf(sc->dev,
+					"pkey_handler: unknown event 0x%x/0x%x "
+					"(prev: 0x%x)\n",
+					event, mask, sc->prev_event);
+	    
+		return (0);
+	}
+    
+	return acpi_spic_default_handler(sc, group, mask, event);
+}
+
+/* acpi_spic4_extra_handler() - special handling for type4 model
+ * in:
+ *	sc			- driver softc structure
+ *	group		- event group
+ *	mask		- mask of event
+ *	event		- SPIC event code
+* out:
+*	1			- event handled
+ *	0			- event not handled
+ */
+static int
+acpi_spic4_extra_handler(struct acpi_sony_softc *sc,
+	struct spic_event_group *group, uint8_t mask, uint8_t event)
+{
+	switch (event) {
+		case 0x5c:
+		case 0x5f:
+			acpi_spic_call1(sc, 0xA0);
+			break;
+
+		case 0x61:
+			acpi_spic_call1(sc, 0xB3);
+			break;
+
+		default:	/* event was unhandled */
+			device_printf(sc->dev, "type4 unhandled 0x%x/0x%x\n",
+				event, mask);
+			return (0);
+	}
+
+	if (sc->prev_event == 0) {
+		/*device_printf(sc->dev, "type4 special event 0x%x/0x%x\n",
+		      event, mask);
+		*/
+		sc->prev_event = event;
+	} else {
+		sc->prev_event = 0;
+	}
+    
+	return (1);
+}
+
+/* acpi_spic_default_handler() - default handler for all event groups
+ * in:
+ *	sc			- driver softc structure
+ *	group		- event group
+ *	mask		- mask of event
+ *	event		- SPIC event code
+ * out:
+ *	1			- event handled
+ *	0			- event not handled
+ */
+static int
+acpi_spic_default_handler(struct acpi_sony_softc *sc,
+	struct spic_event_group *group, uint8_t mask, uint8_t event)
+{
+	struct spic_event	*event_entry = group->events;
+		    
+	while (event_entry->event != 0) {
+		
+		if (event_entry->code > event)
+			break;	/* no event with needed code */
+	    
+		if (event_entry->code == event) {
+			/* found needed code */
+			acpi_spic_report_event(sc, event, mask, event_entry->event);
+			
+			return (1);
+		}
+		
+		++event_entry;
+	}
+    
+	return (0);
+}
+
+/* acpi_spic_intr() - SPIC ISR
+ * in:
+ *	arg		- provided argument (driver softc structure)
+ * out:
+ *	none
+ */
+static void
+acpi_spic_intr(void * arg)
+{
+	struct acpi_sony_softc *sc = (struct acpi_sony_softc *)arg;
+    
+	if (sc == NULL)
+		return;
+    
+	uint8_t event = inb(sc->port_addr);
+	uint8_t mask = inb(sc->port_addr + sc->evport_offset);
+    
+	if ( (event == 0x00) || (event == 0xff))
+		return;		/* ignore */
+
+	struct spic_event_group	*group = sc->events;
+	
+	/* searching needed group by mask */
+	while (group->events != NULL) {
+	    
+		if (group->mask > mask) {
+			break;	/* no group with needed mask */
+		}
+	    
+		if (group->mask == mask) {	/* processing */
+			if (	(group->handler != NULL) &&
+				(group->handler(sc, group, mask, event)))
+				return;		/* handler processed event */
+		    
+			if (acpi_spic_default_handler(sc, group, mask, event))
+				return;		/* default handler processed event */	
+		}
+		
+		++group;
+	}
+    
+	device_printf(sc->dev, "event 0x%x/0x%x unhandled\n", event, mask);
+	
+	/*clear event */
+	acpi_spic_call2(sc, 0x81, 0xff);
+    
+	return;
+}
+
+/*
+ * SNC related
+ */
+
+/* acpi_snc_attach() - attaches driver for SNC
+ * in:
+ *	sc			- driver softc structure
+ * out:
+*	not 0		- failed
+ *	0			- success
+ */
+static int
+acpi_snc_attach(struct acpi_sony_softc *sc)
+{
+	int			i;
+	int			tst;
+	ACPI_HANDLE	tst_handle;
+	
+	/* adding oids */
+	for (i = 0 ; acpi_snc_oids[i].nodename != NULL; i++){
+	    
+		/* skip if SNC not supports get method */
+		if (ACPI_FAILURE(acpi_GetInteger(sc->handle,
+			acpi_snc_oids[i].getmethod, &tst)))
+			continue;
+	    
+		/* skip if SNC not supports set method */
+		if (acpi_snc_oids[i].setmethod &&
+			ACPI_FAILURE(acpi_GetHandleInScope(sc->handle,
+				acpi_snc_oids[i].setmethod, &tst_handle)))
+			continue;
+
+		SYSCTL_ADD_PROC(&(sc->sysctl_ctx),
+			SYSCTL_CHILDREN(sc->sysctl_tree),
+			OID_AUTO, acpi_snc_oids[i].nodename,
+			CTLTYPE_INT | ((acpi_snc_oids[i].setmethod != NULL) ?
+				CTLFLAG_RW : CTLFLAG_RD),
+			sc->dev, i, acpi_snc_sysctl, "I",
+			acpi_snc_oids[i].comment);
+	}
+  
+	/* initialize special machine types (C, FZ, etc) */
+    
+	if (ACPI_SUCCESS(acpi_GetHandleInScope(sc->handle,
+				"SN02", &tst_handle)))
+	{
+		/* seems model has needed methods */
+		if (	ACPI_FAILED(acpi_SetInteger(sc->handle, "SN02", 0x4)) ||
+			ACPI_FAILED(acpi_SetInteger(sc->handle,  "SN07", 0x2))||
+			ACPI_FAILED(acpi_SetInteger(sc->handle, "SN02", 0x10)) ||
+			ACPI_FAILED(acpi_SetInteger(sc->handle, "SN07", 0x0)) ||
+			ACPI_FAILED(acpi_SetInteger(sc->handle, "SN03", 0x2)) ||
+			ACPI_FAILED(acpi_SetInteger(sc->handle, "SN07", 0x101)))
+		{
+			device_printf(sc->dev, "failed to perform additional initialization\n");;
+		}
+	}
+    
+    	AcpiInstallNotifyHandler(sc->handle, ACPI_DEVICE_NOTIFY,
+		acpi_snc_notify_handler, sc);
+ 
+	return (0);
+}
+
+/* acpi_snc_sysctl() - called when needed to set or get
+ *				values for SNC oids
+ * in:
+ *	SYSCTL_HANDLER_ARGS
+* out:
+ *	0		- success
+ *	not 0	- some error
+ */
+static int 
+acpi_snc_sysctl(SYSCTL_HANDLER_ARGS)
+{
+	device_t	dev = arg1;
+	int 		function = oidp->oid_arg2;
+	int		error = 0, val;
+
+	acpi_GetInteger(acpi_get_handle(dev),
+	    acpi_snc_oids[function].getmethod, &val);
+
+	error = sysctl_handle_int(oidp, &val, 0, req);
+
+	if (error || !req->newptr || !acpi_snc_oids[function].setmethod)
+		return (error);
+
+	acpi_SetInteger(acpi_get_handle(dev),
+	    acpi_snc_oids[function].setmethod, val);
+
+	return (0);
+}
+
+static int
+acpi_snc_setinteger(acpi_sony_softc *sc, char* method, int32_t val, int32_t result)
+{
+	ACPI_OBJECT_LIST params;
+	ACPI_OBJECT in_obj;
+	ACPI_BUFFER output;
+	ACPI_OBJECT out_obj;
+	ACPI_STATUS status;
+
+	params.Count = 1;
+	params.Pointer = &in_obj;
+
+	in_obj.Type = ACPI_TYPE_INTEGER;
+	in_obj.Integer.Value = val;
+
+	output.Length = sizeof(out_obj);
+	output.Pointer = &out_obj;
+
+	status = AcpiEvaluateObject(handle, method, &params, &output);
+
+        if (status == AE_OK) {
+		if (result != NULL) {
+			if (out_obj.type != ACPI_TYPE_INTEGER) {
+				device_printf(sc->dev,  "method returned gibberish\n");
+				return (0);
+			}
+			
+			*result = out_obj.integer.value;
+		}
+		return (1);
+	}
+
+	device_printf(sc->dev, "evaluation failed\n");
+
+	return (0);
+}
+
+static void
+acpi_snc_notify_handler(ACPI_HANDLE h, uint32_t notify, void *context)
+{
+	ACPI_FUNCTION_TRACE_U32((char *)(uintptr_t)__func__, notify);
+    
+	struct acpi_sony_softc	*sc = context;
+    
+	if (notify == 0x92) {
+		if (ACPI_FAILURE(acpi_SetInteger(handle, "SN07", 0x0202)))
+			device_printf(sc->dev, "unable to decode event 0x%.2x\n", notify);
+		else {}
+			/* ev = result & 0xFF; */
+	}
+
+}
+
+/*
+ * Common
+ */
+
+/* acpi_sony_probe() - probing for device
+ * in:
+ *	dev	- probed device
+* out:
+ *	0	- wanna attach
+ *	<0	- some error
+ */
+static int
+acpi_sony_probe(device_t dev)
+{
+	struct acpi_sony_softc *sc;
+
+	sc = device_get_softc(dev);
+    
+	if (acpi_disabled("sony") || device_get_unit(dev) > 1)
+		return (ENXIO);
+
+	if (ACPI_ID_PROBE(device_get_parent(dev), dev, sony_snc_id)) {
+		device_set_desc(dev, "Sony notebook controller");
+		return (0);
+	}
+    
+    	if (ACPI_ID_PROBE(device_get_parent(dev), dev, sony_spic_id)) {
+		device_set_desc(dev, "Sony Programable I/O controller");
+		return (0);
+	}
+
+	return (ENXIO);
+}
+
+/* acpi_sony_attach() - attaches driver to device
+ * in:
+ *	dev	- device to attach to
+* out:
+ *	0	- all is ok
+ *	<0	- some error
+ */
+static int
+acpi_sony_attach(device_t dev)
+{
+	struct acpi_sony_softc	*sc;
+        	
+	ACPI_FUNCTION_TRACE((char *)(uintptr_t)__func__);
+
+	sc = device_get_softc(dev);
+	bzero(sc, sizeof(struct acpi_sony_softc));
+	sc->dev = dev;
+	sc->handle = acpi_get_handle(sc->dev);
+    
+    	if (ACPI_ID_PROBE(device_get_parent(dev), dev, sony_spic_id)) {
+		sc->is_spic = 1;
+	}
+
+	ACPI_SERIAL_BEGIN(sony);
+    
+	/* sc->sysctl_ctx = device_get_sysctl_ctx(dev); */
+	sysctl_ctx_init(&(sc->sysctl_ctx));
+	sc->sysctl_tree = SYSCTL_ADD_NODE( &(sc->sysctl_ctx), SYSCTL_STATIC_CHILDREN(_hw),
+		OID_AUTO, "vaio", CTLFLAG_RW, 0, "VAIO notebook control");
+    
+	//sc->sysctl_tree = device_get_sysctl_tree(dev);
+
+	if (sc->is_spic == 0) {	/* attaching SNC driver */
+		acpi_snc_attach(sc);
+	} else {					/* attaching SPIC driver */
+		acpi_spic_attach(sc);
+	}
+    
+	ACPI_SERIAL_END(sony);
+	
+	return (0);
+}
+
+/* acpi_sony_detach() - detaches from device
+ * in:
+ *	dev	- device to detach from
+* out:
+ *	0	- wanna attach
+ *	<0	- some error
+ */
+static int 
+acpi_sony_detach(device_t dev)
+{
+	struct acpi_sony_softc *sc;
+
+	sc = device_get_softc(dev);
+    
+	if (sc->is_spic == 0) {
+		AcpiRemoveNotifyHandler(sc->handle, ACPI_DEVICE_NOTIFY,   acpi_snc_notify_handler);
+	} else {
+		
+		acpi_spic_call2(sc, 0x81, 0);	/* disabling events */
+		
+		acpi_spic_dis(sc);			/* disabling device */
+
+#ifdef ACPI_SONY_VERBOSE
+		acpi_spic_crs(sc);
+#endif
+
+		if (sc->intr_res != NULL) {
+			bus_teardown_intr(sc->dev, sc->intr_res, sc->icookie);
+	    
+			bus_release_resource(dev, SYS_RES_IRQ,
+			    sc->intr_rid, sc->intr_res); 
+		}
+	    
+		if (sc->port_res != NULL)
+			bus_release_resource(dev, SYS_RES_IOPORT,
+			    sc->port_rid, sc->port_res);
+	
+	//	destroy_dev(&spic_cdevsw);
+	}
+
+	sysctl_ctx_free(&(sc->sysctl_ctx));
+    
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.h sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.h
--- sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/acpi_sony/acpi_sony.h	2009-03-02 20:18:15.000000000 -0500
@@ -0,0 +1,635 @@
+/* 
+ * ACPI Sony Programmable I/O Control Device and 
+ * Sony Notebook Controller driver for VAIO
+  *
+ * based on:
+ *  - sony-laptop	-	Linux driver for Sony notebooks
+  *						http://www.linux.it/~malattia/wiki/index.php/Sony-laptop
+  *	- acpi_sony		- 	older SNC driver for FreeBSD
+  *	- spic			- 	older SPIC driver for FreeBSD
+  */
+
+#ifndef _ACPI_SONY_H_
+#define _ACPI_SONY_H_
+
+#include <sys/param.h>
+#include <sys/bus.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/rman.h>
+
+#define ACPI_SONY_VERBOSE
+
+enum SPIC_TYPE {
+	SPIC_TYPE1 = 0,
+	SPIC_TYPE2 = 1,
+	SPIC_TYPE3 = 2,
+	SPIC_TYPE4 = 3,
+	SPIC_ALL_TYPES = 4
+};
+
+/* event codes, almost the same as in sony-laptop */
+#define SPIC_EVENT_NONE				 		255
+#define SPIC_EVENT_JOGDIAL_DOWN		 		1
+#define SPIC_EVENT_JOGDIAL_UP				2
+#define SPIC_EVENT_JOGDIAL_DOWN_PRESSED	 	3
+#define SPIC_EVENT_JOGDIAL_UP_PRESSED		4
+#define SPIC_EVENT_JOGDIAL_PRESSED			5
+#define SPIC_EVENT_JOGDIAL_RELEASED			6
+#define SPIC_EVENT_CAPTURE_PRESSED			7
+#define SPIC_EVENT_CAPTURE_RELEASED			8
+#define SPIC_EVENT_CAPTURE_PARTIALPRESSED	9
+#define SPIC_EVENT_CAPTURE_PARTIALRELEASED	10
+#define SPIC_EVENT_FNKEY_ESC					11
+#define SPIC_EVENT_FNKEY_F1					12
+#define SPIC_EVENT_FNKEY_F2					13
+#define SPIC_EVENT_FNKEY_F3					14
+#define SPIC_EVENT_FNKEY_F4					15
+#define SPIC_EVENT_FNKEY_F5					16
+#define SPIC_EVENT_FNKEY_F6					17
+#define SPIC_EVENT_FNKEY_F7					18
+#define SPIC_EVENT_FNKEY_F8					19
+#define SPIC_EVENT_FNKEY_F9					20
+#define SPIC_EVENT_FNKEY_F10					21
+#define SPIC_EVENT_FNKEY_F11					22
+#define SPIC_EVENT_FNKEY_F12					23
+#define SPIC_EVENT_FNKEY_1					24
+#define SPIC_EVENT_FNKEY_2					25
+#define SPIC_EVENT_FNKEY_D					26
+#define SPIC_EVENT_FNKEY_E					27
+#define SPIC_EVENT_FNKEY_F					28
+#define SPIC_EVENT_FNKEY_S					29
+#define SPIC_EVENT_FNKEY_B					30
+#define SPIC_EVENT_BLUETOOTH_PRESSED			31
+#define SPIC_EVENT_PKEY_P1					32
+#define SPIC_EVENT_PKEY_P2					33
+#define SPIC_EVENT_PKEY_P3					34
+#define SPIC_EVENT_BACK_PRESSED				35
+#define SPIC_EVENT_LID_CLOSED				36
+#define SPIC_EVENT_LID_OPENED				37
+#define SPIC_EVENT_BLUETOOTH_ON				38
+#define SPIC_EVENT_BLUETOOTH_OFF				39
+#define SPIC_EVENT_HELP_PRESSED				40
+#define SPIC_EVENT_FNKEY_ONLY				41
+#define SPIC_EVENT_JOGDIAL_FAST_DOWN			42
+#define SPIC_EVENT_JOGDIAL_FAST_UP			43
+#define SPIC_EVENT_JOGDIAL_FAST_DOWN_PRESSED	44
+#define SPIC_EVENT_JOGDIAL_FAST_UP_PRESSED	45
+#define SPIC_EVENT_JOGDIAL_VFAST_DOWN		46
+#define SPIC_EVENT_JOGDIAL_VFAST_UP			47
+#define SPIC_EVENT_JOGDIAL_VFAST_DOWN_PRESSED	48
+#define SPIC_EVENT_JOGDIAL_VFAST_UP_PRESSED	49
+#define SPIC_EVENT_ZOOM_PRESSED				50
+#define SPIC_EVENT_ZOOM_IN_PRESSED			51
+#define SPIC_EVENT_ZOOM_OUT_PRESSED			52
+#define SPIC_EVENT_THUMBPHRASE_PRESSED		53
+#define SPIC_EVENT_MEYE_FACE					54
+#define SPIC_EVENT_MEYE_OPPOSITE				55
+#define SPIC_EVENT_MEMORYSTICK_INSERT		56
+#define SPIC_EVENT_MEMORYSTICK_EJECT			57
+#define SPIC_EVENT_ANYBUTTON_RELEASED		58
+#define SPIC_EVENT_BATTERY_INSERT			59
+#define SPIC_EVENT_BATTERY_REMOVE			60
+#define SPIC_EVENT_FNKEY_RELEASED			61
+#define SPIC_EVENT_WIRELESS_ON				62
+#define SPIC_EVENT_WIRELESS_OFF				63
+#define SPIC_EVENT_TOGGLE_SPEED				64
+#define SPIC_EVENT_TOGGLE_STAMINA			65
+
+/* definitions of some additional methods */
+#define ACPI_SONY_METHOD_FAN				0x0000
+#define ACPI_SONY_METHOD_CAMERA_POWER	0x0001
+#define ACPI_SONY_METHOD_BLUETOOTH_POWER 0x0002
+#define ACPI_SONY_METHOD_WWAN_POWER 		0x0003
+
+/* EC data offset to fan level */
+#define SONY_EC_FANSPEED			0x93
+
+/* PCI vendor definitions, used to determiny SPIC type model */
+#define PCI_VENDOR_ID_INTEL				0x8086
+#define PCI_DEVICE_ID_INTEL_82371AB_3	0x7113
+#define PCI_DEVICE_ID_INTEL_ICH6_1		0x2641
+#define PCI_DEVICE_ID_INTEL_ICH7_1		0x27b9
+#define PCI_DEVICE_ID_INTEL_ICH8_4		0x2815
+
+/* used to define entries for SPIC type detection */
+#define SPIC_PCIID(_vid, _did, _type)		\
+	{ 								\
+		.vid	= PCI_VENDOR_ID_ ## _vid,	\
+		.did	= PCI_DEVICE_ID_ ## _did,	\
+		.type = _type				\
+	}	
+
+#define SPIC_PCIID_END()		\
+	{						\
+		.vid	= 0,				\
+		.did	= 0,				\
+		.type = 0				\
+	}
+
+struct spic_pciid  {
+	uint16_t		vid;
+	uint16_t		did;
+	enum SPIC_TYPE	type;
+};
+
+const struct spic_pciid spic_pciids[] =
+{
+ 	SPIC_PCIID(INTEL, INTEL_82371AB_3, SPIC_TYPE1),
+	SPIC_PCIID(INTEL, INTEL_ICH6_1, SPIC_TYPE3),
+	SPIC_PCIID(INTEL, INTEL_ICH7_1, SPIC_TYPE4),
+	SPIC_PCIID(INTEL, INTEL_ICH8_4, SPIC_TYPE4),
+
+	SPIC_PCIID_END()
+};
+
+/* mapping from SPIC code to event code */
+struct spic_event {
+	uint8_t		code;		/* code, returned by SPIC */
+	uint8_t		event;		/* one of SPIC_EVENT_... */
+};
+
+struct acpi_sony_softc;
+struct spic_event_group;
+
+/* event handler for events */
+typedef int (*acpi_sony_event_handler_t)(struct acpi_sony_softc *sc,  struct spic_event_group *group,
+				uint8_t mask, uint8_t event);
+
+/* default handler for events */
+static int acpi_spic_default_handler(struct acpi_sony_softc *sc,  struct spic_event_group *group,
+				uint8_t mask, uint8_t event);
+
+/* defines group of events by event mask */
+struct spic_event_group {
+	uint8_t		mask;				/* event mask */
+	struct spic_event	*events;		/* pointer to definition of events */
+	acpi_sony_event_handler_t	handler;	/* optional handler of event */
+};
+
+/* used to define event group */
+#define SPIC_EVENT_GROUP(_mask, _events, _handler)	\
+	{ 								\
+		.handler	= _handler,			\
+		.mask	= _mask,				\
+		.events	= _events			\
+	}								
+
+/* marker of groups definition end */ 
+#define SPIC_END_GROUP()				\
+	{ 								\
+		.handler	= NULL,				\
+		.mask	= 0,					\
+		.events	= 0					\
+	}								
+
+/* used to define code <-> event mappings */
+#define SPIC_EVENT(_code, _event)		\
+	{ 								\
+		.code	= _code,				\
+		.event	= SPIC_EVENT_##_event \
+	}								
+
+/* marker of events description end */
+#define SPIC_END_EVENTS()				\
+	{ 								\
+		.code	= 0,					\
+		.event	= 0					\
+	}								
+
+
+/* NOTE:
+ * event's codes and masks MUST BE in ascending order
+ */
+
+/* button release events */
+const struct spic_event release_ev[] = {
+	SPIC_EVENT(0x00, ANYBUTTON_RELEASED),
+    
+	SPIC_END_EVENTS()
+};
+
+/* jogddial events  */
+const struct spic_event jogdial_ev[] = {
+	SPIC_EVENT(0x01, JOGDIAL_DOWN),
+	SPIC_EVENT(0x02, JOGDIAL_FAST_DOWN),
+	SPIC_EVENT(0x03, JOGDIAL_VFAST_DOWN),
+	
+	SPIC_EVENT(0x1d, JOGDIAL_VFAST_UP),
+	SPIC_EVENT(0x1e, JOGDIAL_FAST_UP),
+	SPIC_EVENT(0x1f, JOGDIAL_UP),
+	
+	SPIC_EVENT(0x40, JOGDIAL_PRESSED),
+	
+	SPIC_EVENT(0x41, JOGDIAL_DOWN_PRESSED),
+	SPIC_EVENT(0x42, JOGDIAL_FAST_DOWN_PRESSED),
+	SPIC_EVENT(0x43, JOGDIAL_VFAST_DOWN_PRESSED),
+	
+	SPIC_EVENT(0x5d, JOGDIAL_VFAST_UP_PRESSED),
+	SPIC_EVENT(0x5e, JOGDIAL_FAST_UP_PRESSED),
+	SPIC_EVENT(0x5f, JOGDIAL_UP_PRESSED),
+	
+	SPIC_END_EVENTS()
+};
+
+/* capture button events */
+const struct spic_event capture_ev[] = {
+	SPIC_EVENT(0x01, CAPTURE_PARTIALRELEASED),
+	SPIC_EVENT(0x05, CAPTURE_PARTIALPRESSED),
+	SPIC_EVENT(0x07, CAPTURE_PRESSED),
+	SPIC_EVENT(0x40, CAPTURE_PRESSED),
+	
+	SPIC_END_EVENTS()
+};
+
+/* Fn keys events */
+const struct spic_event fnkey_ev[] = {
+	SPIC_EVENT(0x10, FNKEY_ESC),
+	SPIC_EVENT(0x11, FNKEY_F1),
+	SPIC_EVENT(0x12, FNKEY_F2),
+	SPIC_EVENT(0x13, FNKEY_F3),
+	SPIC_EVENT(0x14, FNKEY_F4),
+	SPIC_EVENT(0x15, FNKEY_F5),
+	SPIC_EVENT(0x16, FNKEY_F6),
+	SPIC_EVENT(0x17, FNKEY_F7),
+	SPIC_EVENT(0x18, FNKEY_F8),
+	SPIC_EVENT(0x19, FNKEY_F9),
+	SPIC_EVENT(0x1a, FNKEY_F10),
+	SPIC_EVENT(0x1b, FNKEY_F11),
+	SPIC_EVENT(0x1c, FNKEY_F12),
+	SPIC_EVENT(0x1f, FNKEY_RELEASED),
+	SPIC_EVENT(0x21, FNKEY_1),
+	SPIC_EVENT(0x22, FNKEY_2),
+	SPIC_EVENT(0x31, FNKEY_D),
+	SPIC_EVENT(0x32, FNKEY_E),
+	SPIC_EVENT(0x33, FNKEY_F),
+	SPIC_EVENT(0x34, FNKEY_S),
+	SPIC_EVENT(0x35, FNKEY_B),
+	SPIC_EVENT(0x36, FNKEY_ONLY),
+	
+	SPIC_END_EVENTS()
+};
+
+/* program key events */
+const struct spic_event pkey_ev[] = {
+	SPIC_EVENT(0x01, PKEY_P1),
+	SPIC_EVENT(0x02, PKEY_P2),
+	SPIC_EVENT(0x03, TOGGLE_STAMINA),
+	SPIC_EVENT(0x04, PKEY_P3),
+	
+	SPIC_END_EVENTS()
+};
+
+/* bluetooth events */
+const struct spic_event bluetooth_ev[] = {
+	SPIC_EVENT(0x55, BLUETOOTH_PRESSED),
+	SPIC_EVENT(0x59, BLUETOOTH_ON),
+	SPIC_EVENT(0x5a, BLUETOOTH_OFF),
+    
+	SPIC_END_EVENTS()
+};
+
+/* wireless events */
+const struct spic_event wireless_ev[] = {
+	SPIC_EVENT(0x59, WIRELESS_ON),
+	SPIC_EVENT(0x5a, WIRELESS_OFF),
+    
+	SPIC_END_EVENTS()
+};
+
+/* back button events */
+const struct spic_event back_ev[] = {
+	SPIC_EVENT(0x20, BACK_PRESSED),
+    
+	SPIC_END_EVENTS()
+};
+
+/* help button events */
+const struct spic_event help_ev[] = {
+	SPIC_EVENT(0x3b, HELP_PRESSED),
+    
+	SPIC_END_EVENTS()
+};
+
+/* lid events */
+const struct spic_event lid_ev[] = {
+	SPIC_EVENT(0x50, LID_OPENED),
+	SPIC_EVENT(0x51, LID_CLOSED),
+	
+	SPIC_END_EVENTS()
+};
+
+/* zoom events */
+const struct spic_event zoom_ev[] = {
+	SPIC_EVENT(0x10, ZOOM_IN_PRESSED),
+	SPIC_EVENT(0x20, ZOOM_OUT_PRESSED),
+	SPIC_EVENT(0x39, ZOOM_PRESSED),
+    
+	SPIC_END_EVENTS()
+};
+
+/* thumbphrase events */
+const struct spic_event thumbphrase_ev[] = {
+	SPIC_EVENT(0x3a, THUMBPHRASE_PRESSED),
+	
+	SPIC_END_EVENTS()
+};
+
+/* motioneye camera events */
+const struct spic_event meye_ev[] = {
+	SPIC_EVENT(0x00, MEYE_FACE),
+	SPIC_EVENT(0x01, MEYE_OPPOSITE),
+    
+	SPIC_END_EVENTS()
+};
+
+/* memorystick events */
+const struct spic_event memorystick_ev[] = {
+	SPIC_EVENT(0x53, MEMORYSTICK_INSERT),
+	SPIC_EVENT(0x54, MEMORYSTICK_EJECT),
+	
+	SPIC_END_EVENTS()
+};
+
+/* battery events */
+const struct spic_event battery_ev[] = {
+	SPIC_EVENT(0x20, BATTERY_INSERT),
+	SPIC_EVENT(0x30, BATTERY_REMOVE),
+
+	SPIC_END_EVENTS()
+};
+
+/* type4 extra events */
+const struct spic_event type4_extra_ev[] = {
+	SPIC_EVENT(0x5c, NONE),
+	SPIC_EVENT(0x5f, NONE),
+	SPIC_EVENT(0x61, NONE),
+	SPIC_END_EVENTS()
+};
+
+/* type4 extra event handler */
+static int acpi_spic4_extra_handler(struct acpi_sony_softc *sc,
+			struct spic_event_group *group, uint8_t mask, uint8_t event);
+
+/* type4 extra event handler */
+static int acpi_spic4_pkey_handler(struct acpi_sony_softc *sc,
+			struct spic_event_group *group, uint8_t mask, uint8_t event);
+
+/* type1 event groups */
+const struct spic_event_group spic_type1_events[] = {
+	SPIC_EVENT_GROUP(0x00, release_ev, NULL),
+	SPIC_EVENT_GROUP(0x10, jogdial_ev, NULL),
+	SPIC_EVENT_GROUP(0x20, fnkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x30, bluetooth_ev, NULL),
+	SPIC_EVENT_GROUP(0x30, lid_ev, NULL),
+	SPIC_EVENT_GROUP(0x30, memorystick_ev, NULL),
+	SPIC_EVENT_GROUP(0x40, pkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x40, battery_ev, NULL),
+	SPIC_EVENT_GROUP(0x60, capture_ev, NULL),
+	SPIC_EVENT_GROUP(0x70, meye_ev, NULL),
+	
+    	SPIC_END_GROUP()
+};
+
+/* type2 event groups */
+const struct spic_event_group spic_type2_events[] = {
+	SPIC_EVENT_GROUP(0x00, release_ev, NULL),
+	SPIC_EVENT_GROUP(0x08, pkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x11, jogdial_ev, NULL),
+	SPIC_EVENT_GROUP(0x11, back_ev, NULL),
+	SPIC_EVENT_GROUP(0x20, thumbphrase_ev, NULL),
+	SPIC_EVENT_GROUP(0x21, fnkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x21, help_ev, NULL),
+	SPIC_EVENT_GROUP(0x21, zoom_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, bluetooth_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, pkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, memorystick_ev, NULL),
+	SPIC_EVENT_GROUP(0x38, lid_ev, NULL),
+	SPIC_EVENT_GROUP(0x41, battery_ev, NULL),
+	SPIC_EVENT_GROUP(0x61, capture_ev, NULL),
+
+	SPIC_END_GROUP()
+};
+
+/* type3 event groups */
+const struct spic_event_group spic_type3_events[] = {
+	SPIC_EVENT_GROUP(0x00, release_ev, NULL),
+	SPIC_EVENT_GROUP(0x21, fnkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, pkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, wireless_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, memorystick_ev, NULL),
+	SPIC_EVENT_GROUP(0x41, battery_ev, NULL),
+	
+	SPIC_END_GROUP()
+};
+
+/* type4 event groups */
+const struct spic_event_group spic_type4_events[] = {
+	SPIC_EVENT_GROUP(0x00, release_ev, NULL),
+    	SPIC_EVENT_GROUP(0x05, pkey_ev, acpi_spic4_pkey_handler),
+	SPIC_EVENT_GROUP(0x05, zoom_ev, NULL),
+	SPIC_EVENT_GROUP(0x05, capture_ev, NULL),
+	SPIC_EVENT_GROUP(0x21, fnkey_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, wireless_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, memorystick_ev, NULL),
+	SPIC_EVENT_GROUP(0x31, type4_extra_ev, acpi_spic4_extra_handler),
+	SPIC_EVENT_GROUP(0x41, battery_ev, NULL),
+	    
+	SPIC_END_GROUP()
+};
+
+const struct   {
+	uint16_t				evport_offset;
+	struct spic_event_group	*events;
+} spic_types[SPIC_ALL_TYPES] = {
+	{ 0x04, spic_type1_events },
+	{ 0x12, spic_type2_events },
+	{ 0x12, spic_type3_events },
+	{ 0x12, spic_type4_events }
+};
+
+/* used to define SNC oids */
+#define SNC_OID(_get, _set, _name, _descript)	\
+	{ 										\
+		.nodename	= _name,					\
+		.getmethod	= _get,					\
+		.setmethod	= _set,					\
+		.comment = _descript					\
+	}
+
+/* ACPI Methods, for which oids may be created */
+const struct {
+	char *nodename;
+	char *getmethod;
+	char *setmethod;
+	char *comment;
+} acpi_snc_oids[] = {
+	SNC_OID("GBRT", "SBRT", "brightness", "Display brightness"),
+	SNC_OID("GPBR", "SPBR", "def_brightness", "Display default brightness"),
+	SNC_OID("GCTR", "SCTR", "contrast", "Display contrast"),
+	SNC_OID("GPCR", "SPCR", "def_contrast", "Display default contrast"),
+	SNC_OID("GAZP", "AZPW", "power_audio", "Audio device power"),
+	SNC_OID("GLNP", "LNPW", "power_lan", "Ethernet device power"),
+	SNC_OID("GWDP", NULL, "power_wlan", "Wireless device power"),
+	SNC_OID("GCDP", "CDPW", "power_cd", "CD power"),
+	SNC_OID("GCDP", "SCDP", "power_cd", "CD power"), 	/* alternative combination */
+	SNC_OID("GLID", NULL, "lid_status", "LID status"),
+	SNC_OID("GHKE", NULL,	"hot_key", "Hot key status"),
+	SNC_OID("GILS", "SILS", "indicator", "Lamp indicator status"),
+	SNC_OID("GMCB", "CMGB", "gain_bass", "Gain bass"),
+	SNC_OID("GPID", NULL,	"processor_id", "Processor id (if applicable)"),
+	/* experimental */
+	
+	/* end of table */
+	{ NULL, NULL, NULL, NULL }
+};
+
+/* used to define SPIC oids */
+#define SPIC_OID(_name, _method, _flags, _descript)	\
+	{ 											\
+		.name	= _name,							\
+		.method	= ACPI_SONY_METHOD_##_method,	\
+		.access	= _flags,						\
+		.comment = _descript						\
+	}
+
+/* additional oids */
+const struct {
+	char	*name;
+	int	method;
+	int	access;
+        char	*comment;
+} acpi_spic_oids[] = {
+	SPIC_OID("fan_speed", FAN, CTLTYPE_INT | CTLFLAG_RW, "Fan speed"),
+	SPIC_OID("power_bluetooth", BLUETOOTH_POWER, CTLTYPE_INT | CTLFLAG_RW, "Bluetooth power state"),
+	   
+	{ NULL, 0, 0, NULL }
+};
+
+/* driver structure for device */
+struct acpi_sony_softc {
+
+	/* device and it's ACPI handle */
+	device_t	dev;
+	ACPI_HANDLE	handle;
+
+	/* embedded controller and it's ACPI handle*/
+	device_t	ec_dev;
+	ACPI_HANDLE	ec_handle;
+    
+	/* 1 if device is SPIC*/
+	int			is_spic;
+
+	// SPIC related only
+	enum SPIC_TYPE			model;
+	uint16_t        			evport_offset;
+	struct spic_event_group	*events;
+
+	struct sysctl_ctx_list	sysctl_ctx;
+	struct sysctl_oid       	*sysctl_tree;
+
+	uint8_t         				power_bluetooth;
+	
+	uint8_t					prev_event;
+	/* start of IO ports range */
+	uint16_t				port_addr;
+	/* IRQ */
+	uint8_t					intr;
+	uint8_t					open_count;
+    
+	/* resource allocation related */
+	struct resource			*port_res;	/* IO ports resource */
+	struct resource			*intr_res;	/* IRQ resource */
+	int     					port_rid;	/* IO ports resource id */
+	int						intr_rid;	/* IRQ resource id */
+	
+	void					*icookie;	/* coockie for interrupt */
+    
+	/* Received via ACPI walking resources */
+	ACPI_RESOURCE_IO		io;
+	ACPI_RESOURCE_IRQ		interrupt;
+ };
+
+#define SPIC_DESCRIPT(event)	\
+	{						\
+		.code = SPIC_EVENT_ ## event,		\
+		.name = #event,		\
+	}
+
+#ifdef ACPI_SONY_VERBOSE
+const struct {
+	uint8_t	code;
+	char	*name;
+} event_descriptors[] =
+{
+	SPIC_DESCRIPT(JOGDIAL_DOWN),
+	SPIC_DESCRIPT(JOGDIAL_UP),
+	SPIC_DESCRIPT(JOGDIAL_DOWN_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_UP_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_RELEASED),
+	SPIC_DESCRIPT(CAPTURE_PRESSED),
+	SPIC_DESCRIPT(CAPTURE_RELEASED),
+	SPIC_DESCRIPT(CAPTURE_PARTIALPRESSED),
+	SPIC_DESCRIPT(CAPTURE_PARTIALRELEASED),
+	SPIC_DESCRIPT(FNKEY_ESC),
+	SPIC_DESCRIPT(FNKEY_F1),
+	SPIC_DESCRIPT(FNKEY_F2),
+	SPIC_DESCRIPT(FNKEY_F3),
+	SPIC_DESCRIPT(FNKEY_F4),
+	SPIC_DESCRIPT(FNKEY_F5),
+	SPIC_DESCRIPT(FNKEY_F6),
+	SPIC_DESCRIPT(FNKEY_F7),
+	SPIC_DESCRIPT(FNKEY_F8),
+	SPIC_DESCRIPT(FNKEY_F9),
+	SPIC_DESCRIPT(FNKEY_F10),
+	SPIC_DESCRIPT(FNKEY_F11),
+	SPIC_DESCRIPT(FNKEY_F12),
+	SPIC_DESCRIPT(FNKEY_1),
+	SPIC_DESCRIPT(FNKEY_2),
+	SPIC_DESCRIPT(FNKEY_D),
+	SPIC_DESCRIPT(FNKEY_E),
+	SPIC_DESCRIPT(FNKEY_F),
+	SPIC_DESCRIPT(FNKEY_S),
+	SPIC_DESCRIPT(FNKEY_B),
+	SPIC_DESCRIPT(BLUETOOTH_PRESSED),
+	SPIC_DESCRIPT(PKEY_P1),
+	SPIC_DESCRIPT(PKEY_P2),
+	SPIC_DESCRIPT(PKEY_P3),
+	SPIC_DESCRIPT(BACK_PRESSED),
+	SPIC_DESCRIPT(LID_CLOSED),
+	SPIC_DESCRIPT(LID_OPENED),
+	SPIC_DESCRIPT(BLUETOOTH_ON),
+	SPIC_DESCRIPT(BLUETOOTH_OFF),
+	SPIC_DESCRIPT(HELP_PRESSED),
+	SPIC_DESCRIPT(FNKEY_ONLY),
+	SPIC_DESCRIPT(JOGDIAL_FAST_DOWN),
+	SPIC_DESCRIPT(JOGDIAL_FAST_UP),
+	SPIC_DESCRIPT(JOGDIAL_FAST_DOWN_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_FAST_UP_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_VFAST_DOWN),
+	SPIC_DESCRIPT(JOGDIAL_VFAST_UP),
+	SPIC_DESCRIPT(JOGDIAL_VFAST_DOWN_PRESSED),
+	SPIC_DESCRIPT(JOGDIAL_VFAST_UP_PRESSED),
+	SPIC_DESCRIPT(ZOOM_PRESSED),
+	SPIC_DESCRIPT(ZOOM_IN_PRESSED),
+	SPIC_DESCRIPT(ZOOM_OUT_PRESSED),
+	SPIC_DESCRIPT(THUMBPHRASE_PRESSED),
+	SPIC_DESCRIPT(MEYE_FACE),
+	SPIC_DESCRIPT(MEYE_OPPOSITE),
+	SPIC_DESCRIPT(MEMORYSTICK_INSERT),
+	SPIC_DESCRIPT(MEMORYSTICK_EJECT),
+	SPIC_DESCRIPT(ANYBUTTON_RELEASED),
+	SPIC_DESCRIPT(BATTERY_INSERT),
+	SPIC_DESCRIPT(BATTERY_REMOVE),
+	SPIC_DESCRIPT(FNKEY_RELEASED),
+	SPIC_DESCRIPT(WIRELESS_ON),
+	SPIC_DESCRIPT(WIRELESS_OFF),
+	SPIC_DESCRIPT(TOGGLE_SPEED),
+	SPIC_DESCRIPT(TOGGLE_STAMINA)
+};
+
+#endif
+
+#endif	/* _ACPI_SONY_H_ */
diff -ruN sys/boot/i386/pxe_ng/btx/Makefile sys/boot/i386/pxe_ng/btx/Makefile
--- sys/boot/i386/pxe_ng/btx/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/Makefile	2009-03-02 20:18:18.000000000 -0500
@@ -0,0 +1,9 @@
+# $FreeBSD: src/sys/boot/i386/btx/lib/Makefile,v 1.13 2004/12/21 08:47:14 ru Exp $
+
+PROG=	crt0.o
+INTERNALPROG=
+NO_MAN=
+SRCS=	btxcsu.s btxsys.s btxv86.s
+LDFLAGS=-Wl,-r
+
+.include <bsd.prog.mk>
diff -ruN sys/boot/i386/pxe_ng/btx/Makefile.inc sys/boot/i386/pxe_ng/btx/Makefile.inc
--- sys/boot/i386/pxe_ng/btx/Makefile.inc	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/Makefile.inc	2009-03-02 20:18:19.000000000 -0500
@@ -0,0 +1,3 @@
+# $FreeBSD: src/sys/boot/i386/btx/Makefile.inc,v 1.2 2004/02/06 21:58:31 ru Exp $
+
+.include "../Makefile.inc"
diff -ruN sys/boot/i386/pxe_ng/btx/btx/Makefile sys/boot/i386/pxe_ng/btx/btx/Makefile
--- sys/boot/i386/pxe_ng/btx/btx/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btx/Makefile	2009-03-02 20:18:28.000000000 -0500
@@ -0,0 +1,33 @@
+# $FreeBSD: src/sys/boot/i386/btx/btx/Makefile,v 1.19 2004/12/21 08:47:13 ru Exp $
+
+PROG=	btx
+INTERNALPROG=
+NO_MAN=
+SRCS=	btx.S
+
+.if defined(PAGING)
+CFLAGS+=-DPAGING
+.endif
+
+.if defined(BOOT_BTX_NOHANG)
+BOOT_BTX_FLAGS=0x1
+.else
+BOOT_BTX_FLAGS=0x0
+.endif
+
+CFLAGS+=-DBTX_FLAGS=${BOOT_BTX_FLAGS}
+
+.if defined(BTX_SERIAL)
+BOOT_COMCONSOLE_PORT?= 0x3f8
+BOOT_COMCONSOLE_SPEED?= 9600
+B2SIOFMT?=	0x3
+
+CFLAGS+=-DBTX_SERIAL -DSIOPRT=${BOOT_COMCONSOLE_PORT} \
+	-DSIOFMT=${B2SIOFMT} -DSIOSPD=${BOOT_COMCONSOLE_SPEED}
+.endif
+
+ORG=	0x9000
+
+LDFLAGS=-N -e start -Ttext ${ORG} -Wl,-S,--oformat,binary
+
+.include <bsd.prog.mk>
diff -ruN sys/boot/i386/pxe_ng/btx/btx/btx.S sys/boot/i386/pxe_ng/btx/btx/btx.S
--- sys/boot/i386/pxe_ng/btx/btx/btx.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btx/btx.S	2009-03-02 20:18:32.000000000 -0500
@@ -0,0 +1,1285 @@
+/*
+ * Copyright (c) 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are freely
+ * permitted provided that the above copyright notice and this
+ * paragraph and the following disclaimer are duplicated in all
+ * such forms.
+ *
+ * This software is provided "AS IS" and without any express or
+ * implied warranties, including, without limitation, the implied
+ * warranties of merchantability and fitness for a particular
+ * purpose.
+ *
+ * $FreeBSD: src/sys/boot/i386/btx/btx/btx.S,v 1.38.2.2 2006/12/07 22:26:51 jhb Exp $
+ */
+
+/*
+ * Memory layout.
+ */
+		.set MEM_BTX,0x1000		# Start of BTX memory
+		.set MEM_ESP0,0x1800		# Supervisor stack
+		.set MEM_BUF,0x1800		# Scratch buffer
+		.set MEM_ESP1,0x1e00		# Link stack
+		.set MEM_IDT,0x1e00		# IDT
+		.set MEM_TSS,0x1f98		# TSS
+		.set MEM_MAP,0x2000		# I/O bit map
+		.set MEM_DIR,0x4000		# Page directory
+		.set MEM_TBL,0x5000		# Page tables
+		.set MEM_ORG,0x9000		# BTX code
+		.set MEM_USR,0xa000		# Start of user memory
+/*
+ * Paging control.
+ */
+		.set PAG_SIZ,0x1000		# Page size
+		.set PAG_CNT,0x1000		# Pages to map
+/*
+ * Segment selectors.
+ */
+		.set SEL_SCODE,0x8		# Supervisor code
+		.set SEL_SDATA,0x10		# Supervisor data
+		.set SEL_RCODE,0x18		# Real mode code
+		.set SEL_RDATA,0x20		# Real mode data
+		.set SEL_UCODE,0x28|3		# User code
+		.set SEL_UDATA,0x30|3		# User data
+		.set SEL_TSS,0x38		# TSS
+		.set SEL_CALLGATE,0x40		# super2user callgate
+/*
+ * Task state segment fields.
+ */
+		.set TSS_ESP0,0x4		# PL 0 ESP
+		.set TSS_SS0,0x8		# PL 0 SS
+		.set TSS_ESP1,0xc		# PL 1 ESP
+		.set TSS_MAP,0x66		# I/O bit map base
+/*
+ * System calls.
+ */
+		.set SYS_EXIT,0x0		# Exit
+		.set SYS_EXEC,0x1		# Exec
+		.set SYS_ISR_INSTALL,0x2	# ISR_install
+/*
+ * V86 constants.
+ */
+		.set V86_FLG,0x208eff		# V86 flag mask
+		.set V86_STK,0x400		# V86 stack allowance
+/*
+ * Dump format control bytes.
+ */
+		.set DMP_X16,0x1		# Word
+		.set DMP_X32,0x2		# Long
+		.set DMP_MEM,0x4		# Memory
+		.set DMP_EOL,0x8		# End of line
+/*
+ * Screen defaults and assumptions.
+ */
+		.set SCR_MAT,0x7		# Mode/attribute
+		.set SCR_COL,0x50		# Columns per row
+		.set SCR_ROW,0x19		# Rows per screen
+/*
+ * BIOS Data Area locations.
+ */
+		.set BDA_MEM,0x413		# Free memory
+		.set BDA_KEYFLAGS,0x417		# Keyboard shift-state flags
+		.set BDA_SCR,0x449		# Video mode
+		.set BDA_POS,0x450		# Cursor position
+		.set BDA_BOOT,0x472		# Boot howto flag
+/*
+ * Derivations, for brevity.
+ */
+		.set _ESP0H,MEM_ESP0>>0x8	# Byte 1 of ESP0
+		.set _ESP1H,MEM_ESP1>>0x8	# Byte 1 of ESP1
+		.set _TSSIO,MEM_MAP-MEM_TSS	# TSS I/O base
+		.set _TSSLM,MEM_DIR-MEM_TSS-1	# TSS limit
+		.set _IDTLM,MEM_TSS-MEM_IDT-1	# IDT limit
+/*
+ * Code segment.
+ */
+		.globl start
+		.code16
+start:						# Start of code
+/*
+ * BTX header.
+ */
+btx_hdr:	.byte 0xeb			# Machine ID
+		.byte 0xe			# Header size
+		.ascii "BTX"			# Magic
+		.byte 0x1			# Major version
+		.byte 0x1			# Minor version
+		.byte BTX_FLAGS			# Flags
+		.word PAG_CNT-MEM_ORG>>0xc	# Paging control
+		.word break-start		# Text size
+		.long 0x0			# Entry address
+/*
+ * Initialization routine.
+ */
+init:		cli				# Disable interrupts
+		xor %ax,%ax			# Zero/segment
+		mov %ax,%ss			# Set up
+		mov $MEM_ESP0,%sp		#  stack
+		mov %ax,%es			# Address
+		mov %ax,%ds			#  data
+		pushl $0x2			# Clear
+		popfl				#  flags
+/*
+ * Initialize memory.
+ */
+		mov $MEM_IDT,%di		# Memory to initialize
+		mov $(MEM_ORG-MEM_IDT)/2,%cx	# Words to zero
+		push %di			# Save
+		rep				# Zero-fill
+		stosw				#  memory
+		pop %di				# Restore
+/*
+ * Create IDT.
+ */
+		mov $idtctl,%si			# Control string
+init.1: 	lodsb				# Get entry
+		cbw				#  count
+		xchg %ax,%cx			#  as word
+		jcxz init.4			# If done
+		lodsb				# Get segment
+		xchg %ax,%dx	 		#  P:DPL:type
+		lodsw				# Get control
+		xchg %ax,%bx			#  set
+		lodsw				# Get handler offset
+		mov $SEL_SCODE,%dh		# Segment selector
+init.2: 	shr %bx				# Handle this int?
+		jnc init.3			# No
+		mov %ax,(%di)			# Set handler offset
+		mov %dh,0x2(%di)		#  and selector
+		mov %dl,0x5(%di)		# Set P:DPL:type
+		add $0x4,%ax			# Next handler
+init.3: 	lea 0x8(%di),%di		# Next entry
+		loop init.2			# Till set done
+		jmp init.1			# Continue
+/*
+ * Initialize TSS.
+ */
+init.4: 	movb $_ESP0H,TSS_ESP0+1(%di)	# Set ESP0
+		movb $SEL_SDATA,TSS_SS0(%di)	# Set SS0
+		movb $_ESP1H,TSS_ESP1+1(%di)	# Set ESP1
+		movb $_TSSIO,TSS_MAP(%di)	# Set I/O bit map base
+#ifdef PAGING
+/*
+ * Create page directory.
+ */
+		xor %edx,%edx			# Page
+		mov $PAG_SIZ>>0x8,%dh		#  size
+		xor %eax,%eax			# Zero
+		mov $MEM_DIR,%di		# Page directory
+		mov $PAG_CNT>>0xa,%cl		# Entries
+		mov $MEM_TBL|0x7,%ax	 	# First entry
+init.5: 	stosl				# Write entry
+		add %dx,%ax			# To next
+		loop init.5			# Till done
+/*
+ * Create page tables.
+ */
+		mov $MEM_TBL,%di		# Page table
+		mov $PAG_CNT>>0x8,%ch		# Entries
+		xor %ax,%ax			# Start address
+init.6: 	mov $0x7,%al			# Set U:W:P flags
+		cmp btx_hdr+0x8,%cx	 	# Standard user page?
+		jb init.7			# Yes
+		cmp $PAG_CNT-MEM_BTX>>0xc,%cx	# BTX memory?
+		jae init.7			# No or first page
+		and $~0x2,%al			# Clear W flag
+		cmp $PAG_CNT-MEM_USR>>0xc,%cx	# User page zero?
+		jne init.7			# No
+		testb $0x80,btx_hdr+0x7		# Unmap it?
+		jz init.7			# No
+		and $~0x1,%al			# Clear P flag
+init.7: 	stosl				# Set entry
+		add %edx,%eax			# Next address
+		loop init.6			# Till done
+#endif
+/*
+ * Bring up the system.
+ */
+		mov $0x2820,%bx			# Set protected mode
+		callw setpic			#  IRQ offsets
+		lidt idtdesc	 		# Set IDT
+#ifdef PAGING
+		xor %eax,%eax			# Set base
+		mov $MEM_DIR>>0x8,%ah		#  of page
+		mov %eax,%cr3			#  directory
+#endif
+		lgdt gdtdesc	 		# Set GDT
+		mov %cr0,%eax			# Switch to protected
+#ifdef PAGING
+		or $0x80000001,%eax             #  mode and enable paging
+#else
+		inc %ax				#  mode
+#endif
+		mov %eax,%cr0			#
+		ljmp $SEL_SCODE,$init.8		# To 32-bit code
+		.code32
+init.8: 	xorl %ecx,%ecx			# Zero
+		movb $SEL_SDATA,%cl		# To 32-bit
+		movw %cx,%ss			#  stack
+/*
+ * Launch user task.
+ */
+		movb $SEL_TSS,%cl		# Set task
+		ltr %cx				#  register
+		movl $MEM_USR,%edx		# User base address
+		movzwl %ss:BDA_MEM,%eax 	# Get free memory
+		shll $0xa,%eax			# To bytes
+		subl $0x1000,%eax		# Less arg space
+		subl %edx,%eax			# Less base
+		movb $SEL_UDATA,%cl		# User data selector
+		pushl %ecx			# Set SS
+		pushl %eax			# Set ESP
+		push $0x202			# Set flags (IF set)
+		push $SEL_UCODE			# Set CS
+		pushl btx_hdr+0xc		# Set EIP
+		pushl %ecx			# Set GS
+		pushl %ecx			# Set FS
+		pushl %ecx			# Set DS
+		pushl %ecx			# Set ES
+		pushl %edx			# Set EAX
+		movb $0x7,%cl			# Set remaining
+init.9:		push $0x0			#  general
+		loop init.9			#  registers
+#ifdef BTX_SERIAL
+		call sio_init			# setup the serial console
+#endif
+		popa				#  and initialize
+		popl %es			# Initialize
+		popl %ds			#  user
+		popl %fs			#  segment
+		popl %gs			#  registers
+		iret				# To user mode
+/*
+ * Exit routine.
+ */
+exit:		cli				# Disable interrupts
+		movl $MEM_ESP0,%esp		# Clear stack
+/*
+ * Turn off paging.
+ */
+		movl %cr0,%eax			# Get CR0
+		andl $~0x80000000,%eax		# Disable
+		movl %eax,%cr0			#  paging
+		xorl %ecx,%ecx			# Zero
+		movl %ecx,%cr3			# Flush TLB
+/*
+ * Restore the GDT in case we caught a kernel trap.
+ */
+		lgdt gdtdesc	 		# Set GDT
+/*
+ * To 16 bits.
+ */
+		ljmpw $SEL_RCODE,$exit.1	# Reload CS
+		.code16
+exit.1: 	mov $SEL_RDATA,%cl		# 16-bit selector
+		mov %cx,%ss			# Reload SS
+		mov %cx,%ds			# Load
+		mov %cx,%es			#  remaining
+		mov %cx,%fs			#  segment
+		mov %cx,%gs			#  registers
+/*
+ * To real-address mode.
+ */
+		dec %ax				# Switch to
+		mov %eax,%cr0			#  real mode
+		ljmp $0x0,$exit.2		# Reload CS
+exit.2: 	xor %ax,%ax			# Real mode segment
+		mov %ax,%ss			# Reload SS
+		mov %ax,%ds			# Address data
+		mov $0x7008,%bx			# Set real mode
+		callw setpic			#  IRQ offsets
+		lidt ivtdesc	 		# Set IVT
+/*
+ * Reboot or await reset.
+ */
+		sti				# Enable interrupts
+		testb $0x1,btx_hdr+0x7		# Reboot?
+exit.3:		jz exit.3			# No
+		movw $0x1234, BDA_BOOT		# Do a warm boot
+		ljmp $0xf000,$0xfff0		# reboot the machine
+/*
+ * Set IRQ offsets by reprogramming 8259A PICs.
+ */
+setpic: 	in $0x21,%al			# Save master
+		push %ax			#  IMR
+		in $0xa1,%al			# Save slave
+		push %ax			#  IMR
+		movb $0x11,%al			# ICW1 to
+		outb %al,$0x20			#  master,
+		outb %al,$0xa0			#  slave
+		movb %bl,%al			# ICW2 to
+		outb %al,$0x21			#  master
+		movb %bh,%al			# ICW2 to
+		outb %al,$0xa1			#  slave
+		movb $0x4,%al			# ICW3 to
+		outb %al,$0x21			#  master
+		movb $0x2,%al			# ICW3 to
+		outb %al,$0xa1			#  slave
+		movb $0x1,%al			# ICW4 to
+		outb %al,$0x21			#  master,
+		outb %al,$0xa1			#  slave
+		pop %ax				# Restore slave
+		outb %al,$0xa1			#  IMR
+		pop %ax				# Restore master
+		outb %al,$0x21			#  IMR
+		retw				# To caller
+		.code32
+/*
+ * Initiate return from V86 mode to user mode.
+ */
+inthlt: 	hlt				# To supervisor mode
+/*
+ * Exception jump table.
+ */
+intx00: 	push $0x0			# Int 0x0: #DE
+		jmp ex_noc			# Divide error
+		push $0x1			# Int 0x1: #DB
+		jmp ex_noc			# Debug
+		push $0x3			# Int 0x3: #BP
+		jmp ex_noc			# Breakpoint
+		push $0x4			# Int 0x4: #OF
+		jmp ex_noc			# Overflow
+		push $0x5			# Int 0x5: #BR
+		jmp ex_noc			# BOUND range exceeded
+		push $0x6			# Int 0x6: #UD
+		jmp ex_noc			# Invalid opcode
+		push $0x7			# Int 0x7: #NM
+		jmp ex_noc			# Device not available
+		push $0x8			# Int 0x8: #DF
+		jmp except			# Double fault
+		push $0xa			# Int 0xa: #TS
+		jmp except			# Invalid TSS
+		push $0xb			# Int 0xb: #NP
+		jmp except			# Segment not present
+		push $0xc			# Int 0xc: #SS
+		jmp except			# Stack segment fault
+		push $0xd			# Int 0xd: #GP
+		jmp ex_v86			# General protection
+		push $0xe			# Int 0xe: #PF
+		jmp except			# Page fault
+intx10: 	push $0x10			# Int 0x10: #MF
+		jmp ex_noc			# Floating-point error
+/*
+ * Handle #GP exception.
+ */
+ex_v86: 	testb $0x2,0x12(%esp,1) 	# V86 mode?
+		jz except			# No
+		jmp v86mon			# To monitor
+/*
+ * Save a zero error code.
+ */
+ex_noc: 	pushl (%esp,1)			# Duplicate int no
+		movb $0x0,0x4(%esp,1)		# Fake error code
+/*
+ * Handle exception.
+ */
+except: 	cld				# String ops inc
+		pushl %ds			# Save
+		pushl %es			#  most
+		pusha				#  registers
+		movb $0x6,%al			# Push loop count
+		testb $0x2,0x3a(%esp,1) 	# V86 mode?
+		jnz except.1			# Yes
+		pushl %gs			# Set GS
+		pushl %fs			# Set FS
+		pushl %ds			# Set DS
+		pushl %es			# Set ES
+		movb $0x2,%al			# Push loop count
+		cmpw $SEL_SCODE,0x44(%esp,1)	# Supervisor mode?
+		jne except.1			# No
+		pushl %ss			# Set SS
+		leal 0x50(%esp,1),%eax		# Set
+		pushl %eax			#  ESP
+		jmp except.2			# Join common code
+except.1:	pushl 0x50(%esp,1)		# Set GS, FS, DS, ES
+		decb %al			#  (if V86 mode), and
+		jne except.1			#  SS, ESP
+except.2:	push $SEL_SDATA			# Set up
+		popl %ds			#  to
+		pushl %ds			#  address
+		popl %es			#  data
+		movl %esp,%ebx			# Stack frame
+		movl $dmpfmt,%esi		# Dump format string
+		pushl %edi			# Dump to
+		call dump			#  buffer
+		popl %esi			#  and
+		call putstr			#  display
+		leal 0x18(%esp,1),%esp		# Discard frame
+		popa				# Restore
+		popl %es			#  registers
+		popl %ds			#  saved
+		cmpb $0x3,(%esp,1)		# Breakpoint?
+		je except.3			# Yes
+		cmpb $0x1,(%esp,1)		# Debug?
+		jne except.2a			# No
+		testl $0x100,0x10(%esp,1)	# Trap flag set?
+		jnz except.3			# Yes
+except.2a:	jmp exit			# Exit
+except.3:	leal 0x8(%esp,1),%esp		# Discard err, int no
+		iret				# From interrupt
+/*
+ * Return to user mode from V86 mode.
+ */
+intrtn: 	cld				# String ops inc
+		pushl %ds			# Address
+		popl %es			#  data
+		leal 0x3c(%ebp),%edx		# V86 Segment registers
+		movl MEM_TSS+TSS_ESP1,%esi	# Link stack pointer
+		lodsl				# INT_V86 args pointer
+		movl %esi,%ebx			# Saved exception frame
+		testl %eax,%eax 		# INT_V86 args?
+		jz intrtn.2			# No
+		movl $MEM_USR,%edi		# User base
+		movl 0x1c(%esi),%ebx		# User ESP
+		movl %eax,(%edi,%ebx,1) 	# Restore to user stack
+		leal 0x8(%edi,%eax,1),%edi	# Arg segment registers
+		testb $0x4,-0x6(%edi)		# Return flags?
+		jz intrtn.1			# No
+		movl 0x30(%ebp),%eax		# Get V86 flags
+		movw %ax,0x18(%esi)		# Set user flags
+intrtn.1:	leal 0x10(%esi),%ebx		# Saved exception frame
+		xchgl %edx,%esi 		# Segment registers
+		movb $0x4,%cl			# Update seg regs
+		rep				#  in INT_V86
+		movsl				#  args
+intrtn.2:	xchgl %edx,%esi			# Segment registers
+		leal 0x28(%ebp),%edi		# Set up seg
+		movb $0x4,%cl			#  regs for
+		rep				#  later
+		movsl				#  pop
+		xchgl %ebx,%esi			# Restore exception
+		movb $0x5,%cl			#  frame to
+		rep				#  supervisor
+		movsl				#  stack
+		movl %esi,MEM_TSS+TSS_ESP1	# Link stack pointer
+		popa				# Restore
+		leal 0x8(%esp,1),%esp		# Discard err, int no
+		popl %es			# Restore
+		popl %ds			#  user
+		popl %fs			#  segment
+		popl %gs			#  registers
+		iret				# To user mode
+/*
+ * V86 monitor.
+ */
+v86mon: 	cld				# String ops inc
+		pushl $SEL_SDATA		# Set up for
+		popl %ds			#  flat addressing
+		pusha				# Save registers
+		movl %esp,%ebp			# Address stack frame
+		movzwl 0x2c(%ebp),%edi		# Load V86 CS
+		shll $0x4,%edi			# To linear
+		movl 0x28(%ebp),%esi		# Load V86 IP
+		addl %edi,%esi			# Code pointer
+		xorl %ecx,%ecx			# Zero
+		movb $0x2,%cl			# 16-bit operands
+		xorl %eax,%eax			# Zero
+v86mon.1:	lodsb				# Get opcode
+		cmpb $0x66,%al			# Operand size prefix?
+		jne v86mon.2			# No
+		movb $0x4,%cl			# 32-bit operands
+		jmp v86mon.1			# Continue
+v86mon.2:	cmpb $0xf4,%al			# HLT?
+		jne v86mon.3			# No
+		cmpl $inthlt+0x1,%esi		# Is inthlt?
+		jne v86mon.7			# No (ignore)
+		jmp intrtn			# Return to user mode
+v86mon.3:	cmpb $0xf,%al			# Prefixed instruction?
+		jne v86mon.4			# No
+		cmpb $0x09,(%esi)		# Is it a WBINVD?
+		je v86wbinvd			# Yes
+		cmpb $0x30,(%esi)		# Is it a WRMSR?
+		je v86wrmsr			# Yes
+		cmpb $0x32,(%esi)		# Is it a RDMSR?
+		je v86rdmsr			# Yes
+		cmpb $0x20,(%esi)		# Is this a MOV reg,CRx?
+		je v86mov			# Yes
+v86mon.4:	cmpb $0xfa,%al			# CLI?
+		je v86cli			# Yes
+		cmpb $0xfb,%al			# STI?
+		je v86sti			# Yes
+		cmpb $0xcc,%al			# INT3?
+		je v86mon.7			# Yes, ignore
+		movzwl 0x38(%ebp),%ebx		# Load V86 SS
+		shll $0x4,%ebx			# To offset
+		pushl %ebx			# Save
+		addl 0x34(%ebp),%ebx		# Add V86 SP
+		movl 0x30(%ebp),%edx		# Load V86 flags
+		cmpb $0x9c,%al			# PUSHF/PUSHFD?
+		je v86pushf			# Yes
+		cmpb $0x9d,%al			# POPF/POPFD?
+		je v86popf			# Yes
+		cmpb $0xcd,%al			# INT imm8?
+		je v86intn			# Yes
+		cmpb $0xcf,%al			# IRET/IRETD?
+		je v86iret			# Yes
+		popl %ebx			# Restore
+		popa				# Restore
+		jmp except			# Handle exception
+v86mon.5:	movl %edx,0x30(%ebp)		# Save V86 flags
+v86mon.6:	popl %edx			# V86 SS adjustment
+		subl %edx,%ebx			# Save V86
+		movl %ebx,0x34(%ebp)		#  SP
+v86mon.7:	subl %edi,%esi			# From linear
+		movl %esi,0x28(%ebp)		# Save V86 IP
+		popa				# Restore
+		leal 0x8(%esp,1),%esp		# Discard int no, error
+		iret				# To V86 mode
+/*
+ * Emulate MOV reg,CRx.
+ */
+v86mov: 	movb 0x1(%esi),%bl		# Fetch Mod R/M byte
+		testb $0x10,%bl			# Read CR2 or CR3?
+		jnz v86mov.1			# Yes
+		movl %cr0,%eax			# Read CR0
+		testb $0x20,%bl			# Read CR4 instead?
+		jz v86mov.2			# No
+		movl %cr4,%eax			# Read CR4
+		jmp v86mov.2
+v86mov.1:	movl %cr2,%eax			# Read CR2
+		testb $0x08,%bl			# Read CR3 instead?
+		jz v86mov.2			# No
+		movl %cr3,%eax			# Read CR3
+v86mov.2:	andl $0x7,%ebx			# Compute offset in
+		shl $2,%ebx			#  frame of destination
+		neg %ebx			#  register
+		movl %eax,0x1c(%ebp,%ebx,1)	# Store CR to reg
+		incl %esi			# Adjust IP
+/*
+ * Return from emulating a 0x0f prefixed instruction
+ */
+v86preret:	incl %esi			# Adjust IP
+		jmp v86mon.7			# Finish up
+/*
+ * Emulate WBINVD
+ */
+v86wbinvd:	wbinvd				# Write back and invalidate
+						#  cache
+		jmp v86preret			# Finish up
+/*
+ * Emulate WRMSR
+ */
+v86wrmsr:	movl 0x18(%ebp),%ecx		# Get user's %ecx (MSR to write)
+		movl 0x14(%ebp),%edx		# Load the value
+		movl 0x1c(%ebp),%eax		#  to write
+		wrmsr				# Write MSR
+		jmp v86preret			# Finish up
+/*
+ * Emulate RDMSR
+ */
+v86rdmsr:	movl 0x18(%ebp),%ecx		# MSR to read
+		rdmsr				# Read the MSR
+		movl %eax,0x1c(%ebp)		# Return the value of
+		movl %edx,0x14(%ebp)		#  the MSR to the user
+		jmp v86preret			# Finish up
+/*
+ * Emulate CLI.
+ */
+v86cli: 	andb $~0x2,0x31(%ebp)		# Clear IF
+		jmp v86mon.7			# Finish up
+/*
+ * Emulate STI.
+ */
+v86sti: 	orb $0x2,0x31(%ebp)		# Set IF
+		jmp v86mon.7			# Finish up
+/*
+ * Emulate PUSHF/PUSHFD.
+ */
+v86pushf:	subl %ecx,%ebx			# Adjust SP
+		cmpb $0x4,%cl			# 32-bit
+		je v86pushf.1			# Yes
+		data16				# 16-bit
+v86pushf.1:	movl %edx,(%ebx)		# Save flags
+		jmp v86mon.6			# Finish up
+/*
+ * Emulate IRET/IRETD.
+ */
+v86iret:	movzwl (%ebx),%esi		# Load V86 IP
+		movzwl 0x2(%ebx),%edi		# Load V86 CS
+		leal 0x4(%ebx),%ebx		# Adjust SP
+		movl %edi,0x2c(%ebp)		# Save V86 CS
+		xorl %edi,%edi			# No ESI adjustment
+/*
+ * Emulate POPF/POPFD (and remainder of IRET/IRETD).
+ */
+v86popf:	cmpb $0x4,%cl			# 32-bit?
+		je v86popf.1			# Yes
+		movl %edx,%eax			# Initialize
+		data16				# 16-bit
+v86popf.1:	movl (%ebx),%eax		# Load flags
+		addl %ecx,%ebx			# Adjust SP
+		andl $V86_FLG,%eax		# Merge
+		andl $~V86_FLG,%edx		#  the
+		orl %eax,%edx			#  flags
+		jmp v86mon.5			# Finish up
+/*
+ * trap int 15, function 87
+ * reads %es:%si from saved registers on stack to find a GDT containing
+ * source and destination locations
+ * reads count of words from saved %cx
+ * returns success by setting %ah to 0
+ */
+int15_87:	pushl %esi			# Save
+		pushl %edi			#  registers
+		movl 0x3C(%ebp),%edi		# Load ES
+		movzwl 0x4(%ebp),%eax		# Load user's SI
+		shll $0x4,%edi			# EDI = (ES << 4) +
+		addl %eax,%edi			#   SI
+		movl 0x11(%edi),%eax		# Read base of
+		movb 0x17(%edi),%al		#  GDT entry
+		ror $8,%eax			#  for source
+		xchgl %eax,%esi			#  into %esi
+		movl 0x19(%edi),%eax		# Read base of
+		movb 0x1f(%edi),%al		#  GDT entry for
+		ror $8,%eax			#  destination
+		xchgl %eax,%edi			#  into %edi
+		pushl %ds			# Make:
+		popl %es			# es = ds
+		movzwl 0x18(%ebp),%ecx		# Get user's CX
+		shll $0x1,%ecx			# Convert count from words
+		rep				# repeat...
+		movsb				#  perform copy.
+		popl %edi			# Restore
+		popl %esi			#  registers
+		movb $0x0,0x1d(%ebp)		# set ah = 0 to indicate
+						#  success
+		andb $0xfe,%dl			# clear CF
+		jmp v86mon.5			# Finish up
+
+/*
+ * Reboot the machine by setting the reboot flag and exiting
+ */
+reboot:		orb $0x1,btx_hdr+0x7		# Set the reboot flag
+		jmp exit			# Terminate BTX and reboot
+
+/*
+ * Emulate INT imm8... also make sure to check if it's int 15/87
+ */
+v86intn:	lodsb				# Get int no
+		cmpb $0x19,%al			# is it int 19?
+		je reboot			#  yes, reboot the machine
+		cmpb $0x15,%al			# is it int 15?
+		jne v86intn.1			#  no, skip parse
+		cmpb $0x87,0x1d(%ebp)		# is it the memcpy subfunction?
+		je int15_87			#  yes
+		cmpw $0x4f53,0x1c(%ebp)		# is it the delete key callout?
+		jne v86intn.1			#  no, handle the int normally
+		movb BDA_KEYFLAGS,%ch		# get the shift key state
+		andb $0xc,%ch			# mask off just Ctrl and Alt
+		cmpb $0xc,%ch			# are both Ctrl and Alt down?
+		je reboot			# yes, reboot the machine
+v86intn.1:	subl %edi,%esi			# From
+		shrl $0x4,%edi			#  linear
+		movw %dx,-0x2(%ebx)		# Save flags
+		movw %di,-0x4(%ebx)		# Save CS
+		leal -0x6(%ebx),%ebx		# Adjust SP
+		movw %si,(%ebx) 		# Save IP
+		shll $0x2,%eax			# Scale
+		movzwl (%eax),%esi		# Load IP
+		movzwl 0x2(%eax),%edi		# Load CS
+		movl %edi,0x2c(%ebp)		# Save CS
+		xorl %edi,%edi			# No ESI adjustment
+		andb $~0x1,%dh			# Clear TF
+		jmp v86mon.5			# Finish up
+/*
+ * Hardware interrupt jump table.
+ */
+intx20: 	push $0x8			# Int 0x20: IRQ0
+		jmp int_hw			# V86 int 0x8
+		push $0x9			# Int 0x21: IRQ1
+		jmp int_hw			# V86 int 0x9
+		push $0xa			# Int 0x22: IRQ2
+		jmp int_hw			# V86 int 0xa
+		push $0xb			# Int 0x23: IRQ3
+		jmp int_hw			# V86 int 0xb
+		push $0xc			# Int 0x24: IRQ4
+		jmp int_hw			# V86 int 0xc
+		push $0xd			# Int 0x25: IRQ5
+		jmp int_hw			# V86 int 0xd
+		push $0xe			# Int 0x26: IRQ6
+		jmp int_hw			# V86 int 0xe
+		push $0xf			# Int 0x27: IRQ7
+		jmp int_hw			# V86 int 0xf
+		push $0x70			# Int 0x28: IRQ8
+		jmp int_hw			# V86 int 0x70
+		push $0x71			# Int 0x29: IRQ9
+		jmp int_hw			# V86 int 0x71
+#		push $0x72			# Int 0x2a: IRQ10
+#		jmp int_hw			# V86 int 0x72
+# just to test, my NIC's IRQ
+		nop
+		jmp user_isr_call
+		push $0x73			# Int 0x2b: IRQ11
+		jmp int_hw			# V86 int 0x73
+		jmp user_isr_call
+		push $0x74			# Int 0x2c: IRQ12
+		jmp int_hw			# V86 int 0x74
+		push $0x75			# Int 0x2d: IRQ13
+		jmp int_hw			# V86 int 0x75
+		push $0x76			# Int 0x2e: IRQ14
+		jmp int_hw			# V86 int 0x76
+		push $0x77			# Int 0x2f: IRQ15
+		jmp int_hw			# V86 int 0x77
+/*
+ * Reflect hardware interrupts.
+ */
+int_hw: 	testb $0x2,0xe(%esp,1)		# V86 mode?
+		jz intusr			# No
+		pushl $SEL_SDATA		# Address
+		popl %ds			#  data
+		xchgl %eax,(%esp,1)		# Swap EAX, int no
+		pushl %ebp			# Address
+		movl %esp,%ebp			#  stack frame
+		pushl %ebx			# Save
+		shll $0x2,%eax			# Get int
+		movl (%eax),%eax		#  vector
+		subl $0x6,0x14(%ebp)		# Adjust V86 ESP
+		movzwl 0x18(%ebp),%ebx		# V86 SS
+		shll $0x4,%ebx			#  * 0x10
+		addl 0x14(%ebp),%ebx		#  + V86 ESP
+		xchgw %ax,0x8(%ebp)		# Swap V86 IP
+		rorl $0x10,%eax 		# Swap words
+		xchgw %ax,0xc(%ebp)		# Swap V86 CS
+		roll $0x10,%eax 		# Swap words
+		movl %eax,(%ebx)		# CS:IP for IRET
+		movl 0x10(%ebp),%eax		# V86 flags
+		movw %ax,0x4(%ebx)		# Flags for IRET
+		andb $~0x3,0x11(%ebp)		# Clear IF, TF
+		popl %ebx			# Restore
+		popl %ebp			#  saved
+		popl %eax			#  registers
+		iret				# To V86 mode
+/*
+ * Invoke V86 interrupt from user mode, with arguments.
+ */
+intx31: 	stc				# Have btx_v86
+		pushl %eax			# Missing int no
+/*
+ * Invoke V86 interrupt from user mode.
+ */
+intusr: 	std				# String ops dec
+		pushl %eax			# Expand
+		pushl %eax			#  stack
+		pushl %eax			#  frame
+		pusha				# Save
+		pushl %gs			# Save
+		movl %esp,%eax			#  seg regs
+		pushl %fs			#  and
+		pushl %ds			#  point
+		pushl %es			#  to them
+		push $SEL_SDATA			# Set up
+		popl %ds			#  to
+		pushl %ds			#  address
+		popl %es			#  data
+		movl $MEM_USR,%ebx		# User base
+		movl %ebx,%edx			#  address
+		jc intusr.1			# If btx_v86
+		xorl %edx,%edx			# Control flags
+		xorl %ebp,%ebp			# btx_v86 pointer
+intusr.1:	leal 0x50(%esp,1),%esi		# Base of frame
+		pushl %esi			# Save
+		addl -0x4(%esi),%ebx		# User ESP
+		movl MEM_TSS+TSS_ESP1,%edi	# Link stack pointer
+		leal -0x4(%edi),%edi		# Adjust for push
+		xorl %ecx,%ecx			# Zero
+		movb $0x5,%cl			# Push exception
+		rep				#  frame on
+		movsl				#  link stack
+		xchgl %eax,%esi 		# Saved seg regs
+		movl 0x40(%esp,1),%eax		# Get int no
+		testl %edx,%edx 		# Have btx_v86?
+		jz intusr.2			# No
+		movl (%ebx),%ebp		# btx_v86 pointer
+		movb $0x4,%cl			# Count
+		addl %ecx,%ebx			# Adjust for pop
+		rep				# Push saved seg regs
+		movsl				#  on link stack
+		addl %ebp,%edx			# Flatten btx_v86 ptr
+		leal 0x14(%edx),%esi		# Seg regs pointer
+		movl 0x4(%edx),%eax		# Get int no/address
+		movzwl 0x2(%edx),%edx		# Get control flags
+intusr.2:	movl %ebp,(%edi)		# Push btx_v86 and
+		movl %edi,MEM_TSS+TSS_ESP1	#  save link stack ptr
+		popl %edi			# Base of frame
+		xchgl %eax,%ebp 		# Save intno/address
+		movl 0x48(%esp,1),%eax		# Get flags
+		testb $0x2,%dl			# Simulate CALLF?
+		jnz intusr.3			# Yes
+		decl %ebx			# Push flags
+		decl %ebx			#  on V86
+		movw %ax,(%ebx) 		#  stack
+intusr.3:	movb $0x4,%cl			# Count
+		subl %ecx,%ebx			# Push return address
+		movl $inthlt,(%ebx)		#  on V86 stack
+		rep				# Copy seg regs to
+		movsl				#  exception frame
+		xchgl %eax,%ecx 		# Save flags
+		movl %ebx,%eax			# User ESP
+		subl $V86_STK,%eax		# Less bytes
+		ja intusr.4			#  to
+		xorl %eax,%eax			#  keep
+intusr.4:	shrl $0x4,%eax			# Gives segment
+		stosl				# Set SS
+		shll $0x4,%eax			# To bytes
+		xchgl %eax,%ebx 		# Swap
+		subl %ebx,%eax			# Gives offset
+		stosl				# Set ESP
+		xchgl %eax,%ecx 		# Get flags
+		btsl $0x11,%eax 		# Set VM
+		andb $~0x1,%ah			# Clear TF
+		stosl				# Set EFL
+		xchgl %eax,%ebp 		# Get int no/address
+		testb $0x1,%dl			# Address?
+		jnz intusr.5			# Yes
+		shll $0x2,%eax			# Scale
+		movl (%eax),%eax		# Load int vector
+intusr.5:	movl %eax,%ecx			# Save
+		shrl $0x10,%eax 		# Gives segment
+		stosl				# Set CS
+		movw %cx,%ax			# Restore
+		stosl				# Set EIP
+		leal 0x10(%esp,1),%esp		# Discard seg regs
+		popa				# Restore
+		iret				# To V86 mode
+/*
+ * System Call.
+ */
+intx30: 	cmpl $SYS_ISR_INSTALL, %eax	# is isr_install?
+		je intx30.2			#  yes
+		cmpl $SYS_EXEC,%eax		# Exec system call?
+		jne intx30.1			# No
+		pushl %ss			# Set up
+		popl %es			#  all
+		pushl %es			#  segment
+		popl %ds			#  registers
+		pushl %ds			#  for the
+		popl %fs			#  program
+		pushl %fs			#  we're
+		popl %gs			#  invoking
+		movl $MEM_USR,%eax		# User base address
+		addl 0xc(%esp,1),%eax		# Change to user
+		leal 0x4(%eax),%esp		#  stack
+#ifdef PAGING
+		movl %cr0,%eax			# Turn
+		andl $~0x80000000,%eax		#  off
+		movl %eax,%cr0			#  paging
+		xorl %eax,%eax			# Flush
+		movl %eax,%cr3			#  TLB
+#endif
+		popl %eax			# Call
+		call *%eax			#  program
+intx30.1:	orb $0x1,%ss:btx_hdr+0x7	# Flag reboot
+		jmp exit			# Exit
+/*
+ *	Here we need to modify IDT in such way, that at interrupt handle
+ *  will be run user_isr_call, which role is to run provided function
+ *  in user space.
+ */
+
+
+intx30.2:
+		cli
+		pushl %edi
+		pushl %ebx
+		pushw %ds
+		pushw %dx
+
+		pushl %ss			# Set up
+		popl %ds			#  registers
+		
+
+ 		movl $MEM_USR,%ebx		# User base address
+		addl 0x18(%esp,1),%ebx		# getting user stack head
+		addl $0x04, %ebx		#  first parameter
+
+		movl (%ebx), %eax
+		movw 0x2(%ebx), %dx
+		xchgw %dx, %bx
+
+/*
+ * updating call gate
+ */
+		movl $callgate, %edi
+		movw %ax, (%edi)		# +0: store offset 00..15
+		shr $0x10 ,%eax			# getting high word
+		movw %ax, 0x06(%edi)		# +6: handler offset 16..31
+/*
+ * installing handler
+ */		
+#		xorl %eax, %eax			# clear 
+#		movw %bx, %ax			# getting interrupt number
+# 		mov $0x08, %bl			# calculating offset
+# 		mulb %bl			#  to IDT entry
+# #
+#		movl $MEM_IDT,%edi		# base address of IDT.
+#		addl %eax, %edi			# calculate address of entry
+#
+# 		movb $SEL_SCODE, %dh		# supervisor code selector
+#		mov  user_isr_call, %ax		# tramp address
+#  		movb $0x8e, %dl			# i386+ interrupt gate, DPL=0
+# 
+# 		movw %ax,(%edi)			# 0: handler offset 0..15
+# 		movb  %dh, 0x2(%edi)		# +2: dest selector
+# 						# +4: 000:word_count=0
+# 		movb %dl, 0x5(%edi)		# +5: P:DPL:type
+ 						# +6: handler offset 16..31
+/*
+ *  NOTE: it seems nothing else must be done
+ */
+
+		popw %dx
+		popw %ds
+		popl %ebx		
+		popl %edi
+		sti	
+		iret				# return from syscall
+
+user_isr_call:
+/*
+ * NOTE: isr must use lret to return and restore SS, ESP, CS, EIP.
+*/
+		pushl %ds			# saving ds
+		pushl %edi
+		movl $SEL_SDATA, %eax		#
+		movl %eax, %ds			
+						
+		movl $callgate, %edi
+		movw (%edi), %ax
+		popl %edi		
+
+		cmpw $0x0000, %ax
+		je isr_ret
+		
+#		movl $SEL_UDATA, %eax
+#		movl %eax, %ds 
+#		pushl	%ds
+#		popl	%fs
+#		pushl	%fs
+#		popl	%gs
+#		pushl	%gs
+#		popl	%es
+		
+		
+		lcall $SEL_CALLGATE,$0x00000000	# far call via callgate selector
+						# offset is ignored
+
+isr_ret:
+		
+
+		popl %ds
+
+		iret				# return from interrupt handler
+		
+
+/*
+ * Dump structure [EBX] to [EDI], using format string [ESI].
+ */
+dump.0: 	stosb				# Save char
+dump:		lodsb				# Load char
+		testb %al,%al			# End of string?
+		jz dump.10			# Yes
+		testb $0x80,%al 		# Control?
+		jz dump.0			# No
+		movb %al,%ch			# Save control
+		movb $'=',%al			# Append
+		stosb				#  '='
+		lodsb				# Get offset
+		pushl %esi			# Save
+		movsbl %al,%esi 		# To
+		addl %ebx,%esi			#  pointer
+		testb $DMP_X16,%ch		# Dump word?
+		jz dump.1			# No
+		lodsw				# Get and
+		call hex16			#  dump it
+dump.1: 	testb $DMP_X32,%ch		# Dump long?
+		jz dump.2			# No
+		lodsl				# Get and
+		call hex32			#  dump it
+dump.2: 	testb $DMP_MEM,%ch		# Dump memory?
+		jz dump.8			# No
+		pushl %ds			# Save
+		testb $0x2,0x52(%ebx)		# V86 mode?
+		jnz dump.3			# Yes
+		verr 0x4(%esi)	 		# Readable selector?
+		jnz dump.3			# No
+		ldsl (%esi),%esi		# Load pointer
+		jmp dump.4			# Join common code
+dump.3: 	lodsl				# Set offset
+		xchgl %eax,%edx 		# Save
+		lodsl				# Get segment
+		shll $0x4,%eax			#  * 0x10
+		addl %edx,%eax			#  + offset
+		xchgl %eax,%esi 		# Set pointer
+dump.4: 	movb $2,%dl			# Num lines
+dump.4a:	movb $0x10,%cl			# Bytes to dump
+dump.5: 	lodsb				# Get byte and
+		call hex8			#  dump it
+		decb %cl			# Keep count
+		jz dump.6a			# If done
+		movb $'-',%al			# Separator
+		cmpb $0x8,%cl			# Half way?
+		je dump.6			# Yes
+		movb $' ',%al			# Use space
+dump.6: 	stosb				# Save separator
+		jmp dump.5			# Continue
+dump.6a:	decb %dl			# Keep count
+		jz dump.7			# If done
+		movb $0xa,%al			# Line feed
+		stosb				# Save one
+		movb $7,%cl			# Leading
+		movb $' ',%al			#  spaces
+dump.6b:	stosb				# Dump
+		decb %cl			#  spaces
+		jnz dump.6b
+		jmp dump.4a			# Next line
+dump.7: 	popl %ds			# Restore
+dump.8: 	popl %esi			# Restore
+		movb $0xa,%al			# Line feed
+		testb $DMP_EOL,%ch		# End of line?
+		jnz dump.9			# Yes
+		movb $' ',%al			# Use spaces
+		stosb				# Save one
+dump.9: 	jmp dump.0			# Continue
+dump.10:	stosb				# Terminate string
+		ret				# To caller
+/*
+ * Convert EAX, AX, or AL to hex, saving the result to [EDI].
+ */
+hex32:		pushl %eax			# Save
+		shrl $0x10,%eax 		# Do upper
+		call hex16			#  16
+		popl %eax			# Restore
+hex16:		call hex16.1			# Do upper 8
+hex16.1:	xchgb %ah,%al			# Save/restore
+hex8:		pushl %eax			# Save
+		shrb $0x4,%al			# Do upper
+		call hex8.1			#  4
+		popl %eax			# Restore
+hex8.1: 	andb $0xf,%al			# Get lower 4
+		cmpb $0xa,%al			# Convert
+		sbbb $0x69,%al			#  to hex
+		das				#  digit
+		orb $0x20,%al			# To lower case
+		stosb				# Save char
+		ret				# (Recursive)
+/*
+ * Output zero-terminated string [ESI] to the console.
+ */
+putstr.0:	call putchr			# Output char
+putstr: 	lodsb				# Load char
+		testb %al,%al			# End of string?
+		jnz putstr.0			# No
+		ret				# To caller
+#ifdef BTX_SERIAL
+		.set SIO_PRT,SIOPRT		# Base port
+		.set SIO_FMT,SIOFMT		# 8N1
+		.set SIO_DIV,(115200/SIOSPD)	# 115200 / SPD
+
+/*
+ * void sio_init(void)
+ */
+sio_init:	movw $SIO_PRT+0x3,%dx		# Data format reg
+		movb $SIO_FMT|0x80,%al		# Set format
+		outb %al,(%dx)			#  and DLAB
+		pushl %edx			# Save
+		subb $0x3,%dl			# Divisor latch reg
+		movw $SIO_DIV,%ax		# Set
+		outw %ax,(%dx)			#  BPS
+		popl %edx			# Restore
+		movb $SIO_FMT,%al		# Clear
+		outb %al,(%dx)			#  DLAB
+		incl %edx			# Modem control reg
+		movb $0x3,%al			# Set RTS,
+		outb %al,(%dx)			#  DTR
+		incl %edx			# Line status reg
+
+/*
+ * void sio_flush(void)
+ */
+sio_flush.0:	call sio_getc.1 		# Get character
+sio_flush:	call sio_ischar 		# Check for character
+		jnz sio_flush.0 		# Till none
+		ret				# To caller
+
+/*
+ * void sio_putc(int c)
+ */
+sio_putc:	movw $SIO_PRT+0x5,%dx		# Line status reg
+		xor %ecx,%ecx			# Timeout
+		movb $0x40,%ch			#  counter
+sio_putc.1:	inb (%dx),%al			# Transmitter
+		testb $0x20,%al 		#  buffer empty?
+		loopz sio_putc.1		# No
+		jz sio_putc.2			# If timeout
+		movb 0x4(%esp,1),%al		# Get character
+		subb $0x5,%dl			# Transmitter hold reg
+		outb %al,(%dx)			# Write character
+sio_putc.2:	ret $0x4			# To caller
+
+/*
+ * int sio_getc(void)
+ */
+sio_getc:	call sio_ischar 		# Character available?
+		jz sio_getc			# No
+sio_getc.1:	subb $0x5,%dl			# Receiver buffer reg
+		inb (%dx),%al			# Read character
+		ret				# To caller
+
+/*
+ * int sio_ischar(void)
+ */
+sio_ischar:	movw $SIO_PRT+0x5,%dx		# Line status register
+		xorl %eax,%eax			# Zero
+		inb (%dx),%al			# Received data
+		andb $0x1,%al			#  ready?
+		ret				# To caller
+
+/*
+ * Output character AL to the serial console.
+ */
+putchr: 	pusha				# Save
+		cmpb $10, %al			# is it a newline?
+		jne putchr.1			#  no?, then leave
+		push $13			# output a carriage
+		call sio_putc			#  return first
+		movb $10, %al			# restore %al
+putchr.1:	pushl %eax			# Push the character
+						#  onto the stack
+		call sio_putc			# Output the character
+		popa				# Restore
+		ret				# To caller
+#else
+/*
+ * Output character AL to the console.
+ */
+putchr: 	pusha				# Save
+		xorl %ecx,%ecx			# Zero for loops
+		movb $SCR_MAT,%ah		# Mode/attribute
+		movl $BDA_POS,%ebx		# BDA pointer
+		movw (%ebx),%dx 		# Cursor position
+		movl $0xb8000,%edi		# Regen buffer (color)
+		cmpb %ah,BDA_SCR-BDA_POS(%ebx)	# Mono mode?
+		jne putchr.1			# No
+		xorw %di,%di			# Regen buffer (mono)
+putchr.1:	cmpb $0xa,%al			# New line?
+		je putchr.2			# Yes
+		xchgl %eax,%ecx 		# Save char
+		movb $SCR_COL,%al		# Columns per row
+		mulb %dh			#  * row position
+		addb %dl,%al			#  + column
+		adcb $0x0,%ah			#  position
+		shll %eax			#  * 2
+		xchgl %eax,%ecx 		# Swap char, offset
+		movw %ax,(%edi,%ecx,1)		# Write attr:char
+		incl %edx			# Bump cursor
+		cmpb $SCR_COL,%dl		# Beyond row?
+		jb putchr.3			# No
+putchr.2:	xorb %dl,%dl			# Zero column
+		incb %dh			# Bump row
+putchr.3:	cmpb $SCR_ROW,%dh		# Beyond screen?
+		jb putchr.4			# No
+		leal 2*SCR_COL(%edi),%esi	# New top line
+		movw $(SCR_ROW-1)*SCR_COL/2,%cx # Words to move
+		rep				# Scroll
+		movsl				#  screen
+		movb $0x20,%al			# Space
+		movb $SCR_COL,%cl		# Columns to clear
+		rep				# Clear
+		stosw				#  line
+		movb $SCR_ROW-1,%dh		# Bottom line
+putchr.4:	movw %dx,(%ebx) 		# Update position
+		popa				# Restore
+		ret				# To caller
+#endif
+
+		.p2align 4
+/*
+ * Global descriptor table.
+ */
+gdt:		.word 0x0,0x0,0x0,0x0		# Null entry
+		.word 0xffff,0x0,0x9a00,0xcf	# SEL_SCODE
+		.word 0xffff,0x0,0x9200,0xcf	# SEL_SDATA
+		.word 0xffff,0x0,0x9a00,0x0	# SEL_RCODE
+		.word 0xffff,0x0,0x9200,0x0	# SEL_RDATA
+		.word 0xffff,MEM_USR,0xfa00,0xcf# SEL_UCODE
+		.word 0xffff,MEM_USR,0xf200,0xcf# SEL_UDATA
+#		.word 0xffff,MEM_USR,0xba00,0xcf# SEL_UCODE
+#		.word 0xffff,MEM_USR,0xb200,0xcf# SEL_UDATA		
+		.word _TSSLM,MEM_TSS,0x8900,0x0 # SEL_TSS
+callgate:	.word 0x0, SEL_UCODE,0xec00,0x0 # SEL_CALLGATE				
+gdt.1:
+/*
+ * Pseudo-descriptors.
+ */
+gdtdesc:	.word gdt.1-gdt-1,gdt,0x0	# GDT
+idtdesc:	.word _IDTLM,MEM_IDT,0x0	# IDT
+ivtdesc:	.word 0x400-0x0-1,0x0,0x0	# IVT
+/*
+ * IDT construction control string.
+ */
+idtctl: 	.byte 0x10,  0x8e		# Int 0x0-0xf
+		.word 0x7dfb,intx00		#  (exceptions)
+		.byte 0x10,  0x8e		# Int 0x10
+		.word 0x1,   intx10		#  (exception)
+		.byte 0x10,  0x8e		# Int 0x20-0x2f
+		.word 0xffff,intx20		#  (hardware)
+		.byte 0x1,   0xee		# int 0x30
+		.word 0x1,   intx30		#  (system call)
+		.byte 0x2,   0xee		# Int 0x31-0x32
+		.word 0x1,   intx31		#  (V86, null)
+		.byte 0x0			# End of string
+/*
+ * Dump format string.
+ */
+dmpfmt: 	.byte '\n'			# "\n"
+		.ascii "int"			# "int="
+		.byte 0x80|DMP_X32,	   0x40 # "00000000  "
+		.ascii "err"			# "err="
+		.byte 0x80|DMP_X32,	   0x44 # "00000000  "
+		.ascii "efl"			# "efl="
+		.byte 0x80|DMP_X32,	   0x50 # "00000000  "
+		.ascii "eip"			# "eip="
+		.byte 0x80|DMP_X32|DMP_EOL,0x48 # "00000000\n"
+		.ascii "eax"			# "eax="
+		.byte 0x80|DMP_X32,	   0x34 # "00000000  "
+		.ascii "ebx"			# "ebx="
+		.byte 0x80|DMP_X32,	   0x28 # "00000000  "
+		.ascii "ecx"			# "ecx="
+		.byte 0x80|DMP_X32,	   0x30 # "00000000  "
+		.ascii "edx"			# "edx="
+		.byte 0x80|DMP_X32|DMP_EOL,0x2c # "00000000\n"
+		.ascii "esi"			# "esi="
+		.byte 0x80|DMP_X32,	   0x1c # "00000000  "
+		.ascii "edi"			# "edi="
+		.byte 0x80|DMP_X32,	   0x18 # "00000000  "
+		.ascii "ebp"			# "ebp="
+		.byte 0x80|DMP_X32,	   0x20 # "00000000  "
+		.ascii "esp"			# "esp="
+		.byte 0x80|DMP_X32|DMP_EOL,0x0	# "00000000\n"
+		.ascii "cs"			# "cs="
+		.byte 0x80|DMP_X16,	   0x4c # "0000  "
+		.ascii "ds"			# "ds="
+		.byte 0x80|DMP_X16,	   0xc	# "0000  "
+		.ascii "es"			# "es="
+		.byte 0x80|DMP_X16,	   0x8	# "0000  "
+		.ascii "  "			# "  "
+		.ascii "fs"			# "fs="
+		.byte 0x80|DMP_X16,	   0x10 # "0000  "
+		.ascii "gs"			# "gs="
+		.byte 0x80|DMP_X16,	   0x14 # "0000  "
+		.ascii "ss"			# "ss="
+		.byte 0x80|DMP_X16|DMP_EOL,0x4	# "0000\n"
+		.ascii "cs:eip" 		# "cs:eip="
+		.byte 0x80|DMP_MEM|DMP_EOL,0x48 # "00 00 ... 00 00\n"
+		.ascii "ss:esp" 		# "ss:esp="
+		.byte 0x80|DMP_MEM|DMP_EOL,0x0	# "00 00 ... 00 00\n"
+		.asciz "BTX halted\n"		# End
+#save_esp:	.word	0x0000,0x0000
+
+/*
+ * End of BTX memory.
+ */
+		.p2align 4
+break:
diff -ruN sys/boot/i386/pxe_ng/btx/btxcsu.s sys/boot/i386/pxe_ng/btx/btxcsu.s
--- sys/boot/i386/pxe_ng/btx/btxcsu.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxcsu.s	2009-03-02 20:18:21.000000000 -0500
@@ -0,0 +1,51 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxcsu.s,v 1.4 2004/08/05 06:00:05 kan Exp $
+
+#
+# BTX C startup code (ELF).
+#
+
+#
+# Globals.
+#
+		.global _start
+#
+# Constants.
+#
+		.set ARGADJ,0xfa0		# Argument adjustment
+#
+# Client entry point.
+#
+_start: 	cld
+		pushl %eax
+		movl $_edata,%edi 
+		movl $_end,%ecx 
+		subl %edi, %ecx
+		xorb %al, %al
+		rep
+		stosb
+		popl __base
+		movl %esp,%eax			# Set
+		addl $ARGADJ,%eax		#  argument
+		movl %eax,__args		#  pointer
+		call main			# Invoke client main()
+		call exit			# Invoke client exit()
+#
+# Data.
+#
+		.comm __base,4			# Client base address
+		.comm __args,4			# Client arguments
diff -ruN sys/boot/i386/pxe_ng/btx/btxldr/Makefile sys/boot/i386/pxe_ng/btx/btxldr/Makefile
--- sys/boot/i386/pxe_ng/btx/btxldr/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxldr/Makefile	2009-03-02 20:18:34.000000000 -0500
@@ -0,0 +1,16 @@
+# $FreeBSD: src/sys/boot/i386/btx/btxldr/Makefile,v 1.18 2004/12/21 08:47:13 ru Exp $
+
+PROG=	btxldr
+INTERNALPROG=
+NO_MAN=
+SRCS=	btxldr.S
+
+CFLAGS+=-DLOADER_ADDRESS=${LOADER_ADDRESS}
+
+.if defined(BTXLDR_VERBOSE)
+CFLAGS+=-DBTXLDR_VERBOSE
+.endif
+
+LDFLAGS=-N -e start -Ttext ${LOADER_ADDRESS} -Wl,-S,--oformat,binary
+
+.include <bsd.prog.mk>
diff -ruN sys/boot/i386/pxe_ng/btx/btxldr/btxldr.S sys/boot/i386/pxe_ng/btx/btxldr/btxldr.S
--- sys/boot/i386/pxe_ng/btx/btxldr/btxldr.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxldr/btxldr.S	2009-03-02 20:18:37.000000000 -0500
@@ -0,0 +1,396 @@
+/*
+ * Copyright (c) 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are freely
+ * permitted provided that the above copyright notice and this
+ * paragraph and the following disclaimer are duplicated in all
+ * such forms.
+ *
+ * This software is provided "AS IS" and without any express or
+ * implied warranties, including, without limitation, the implied
+ * warranties of merchantability and fitness for a particular
+ * purpose.
+ *
+ * $FreeBSD: src/sys/boot/i386/btx/btxldr/btxldr.S,v 1.17 2004/05/14 20:29:30 ru Exp $
+ */
+
+/*
+ * Prototype BTX loader program, written in a couple of hours.  The
+ * real thing should probably be more flexible, and in C.
+ */
+
+/*
+ * Memory locations.
+ */
+		.set MEM_STUB,0x600		# Real mode stub
+		.set MEM_ESP,0x1000		# New stack pointer
+		.set MEM_TBL,0x5000		# BTX page tables
+		.set MEM_ENTRY,0x9010		# BTX entry point
+		.set MEM_DATA,start+0x1000	# Data segment
+/*
+ * Segment selectors.
+ */
+		.set SEL_SCODE,0x8		# 4GB code
+		.set SEL_SDATA,0x10		# 4GB data
+		.set SEL_RCODE,0x18		# 64K code
+		.set SEL_RDATA,0x20		# 64K data
+/*
+ * Paging constants.
+ */
+		.set PAG_SIZ,0x1000		# Page size
+		.set PAG_ENT,0x4		# Page entry size
+/*
+ * Screen constants.
+ */
+		.set SCR_MAT,0x7		# Mode/attribute
+		.set SCR_COL,0x50		# Columns per row
+		.set SCR_ROW,0x19		# Rows per screen
+/*
+ * BIOS Data Area locations.
+ */
+		.set BDA_MEM,0x413		# Free memory
+		.set BDA_SCR,0x449		# Video mode
+		.set BDA_POS,0x450		# Cursor position
+/*
+ * Required by aout gas inadequacy.
+ */
+		.set SIZ_STUB,0x1a		# Size of stub
+/*
+ * We expect to be loaded by boot2 at the origin defined in ./Makefile.
+ */
+		.globl start
+/*
+ * BTX program loader for ELF clients.
+ */
+start:		cld				# String ops inc
+		movl $m_logo,%esi		# Identify
+		call putstr			#  ourselves
+		movzwl BDA_MEM,%eax		# Get base memory
+		shll $0xa,%eax			#  in bytes
+		movl %eax,%ebp			# Base of user stack
+#ifdef BTXLDR_VERBOSE
+		movl $m_mem,%esi		# Display
+		call hexout			#  amount of
+		call putstr			#  base memory
+#endif
+		lgdt gdtdesc			# Load new GDT
+/*
+ * Relocate caller's arguments.
+ */
+#ifdef BTXLDR_VERBOSE
+		movl $m_esp,%esi		# Display
+		movl %esp,%eax			#  caller
+		call hexout			#  stack
+		call putstr			#  pointer
+		movl $m_args,%esi		# Format string
+		leal 0x4(%esp,1),%ebx		# First argument
+		movl $0x6,%ecx			# Count
+start.1:	movl (%ebx),%eax		# Get argument and
+		addl $0x4,%ebx			#  bump pointer
+		call hexout			# Display it
+		loop start.1			# Till done
+		call putstr			# End message
+#endif
+		movl $0x48,%ecx 		# Allocate space
+		subl %ecx,%ebp			#  for bootinfo
+		movl 0x18(%esp,1),%esi		# Source: bootinfo
+		cmpl $0x0, %esi			# If the bootinfo pointer
+		je start_null_bi		#  is null, don't copy it
+		movl %ebp,%edi			# Destination
+		rep				# Copy
+		movsb				#  it
+		movl %ebp,0x18(%esp,1)		# Update pointer
+#ifdef BTXLDR_VERBOSE
+		movl $m_rel_bi,%esi		# Display
+		movl %ebp,%eax			#  bootinfo
+		call hexout			#  relocation
+		call putstr			#  message
+#endif
+start_null_bi:	movl $0x18,%ecx 		# Allocate space
+		subl %ecx,%ebp			#  for arguments
+		leal 0x4(%esp,1),%esi		# Source
+		movl %ebp,%edi			# Destination
+		rep				# Copy
+		movsb				#  them
+#ifdef BTXLDR_VERBOSE
+		movl $m_rel_args,%esi		# Display
+		movl %ebp,%eax			#  argument
+		call hexout			#  relocation
+		call putstr			#  message
+#endif
+/*
+ * Set up BTX kernel.
+ */
+		movl $MEM_ESP,%esp		# Set up new stack
+		movl $MEM_DATA,%ebx		# Data segment
+		movl $m_vers,%esi		# Display BTX
+		call putstr			#  version message
+		movb 0x5(%ebx),%al		# Get major version
+		addb $'0',%al			# Display
+		call putchr			#  it
+		movb $'.',%al			# And a
+		call putchr			#  dot
+		movb 0x6(%ebx),%al		# Get minor
+		xorb %ah,%ah			#  version
+		movb $0xa,%dl			# Divide
+		divb %dl,%al			#  by 10
+		addb $'0',%al			# Display
+		call putchr			#  tens
+		movb %ah,%al			# Get units
+		addb $'0',%al			# Display
+		call putchr			#  units
+		call putstr			# End message
+		movl %ebx,%esi			# BTX image
+		movzwl 0x8(%ebx),%edi		# Compute
+		orl $PAG_SIZ/PAG_ENT-1,%edi	#  the
+		incl %edi			#  BTX
+		shll $0x2,%edi			#  load
+		addl $MEM_TBL,%edi		#  address
+		pushl %edi			# Save load address
+		movzwl 0xa(%ebx),%ecx		# Image size
+#ifdef BTXLDR_VERBOSE
+		pushl %ecx			# Save image size
+#endif
+		rep				# Relocate
+		movsb				#  BTX
+		movl %esi,%ebx			# Keep place
+#ifdef BTXLDR_VERBOSE
+		movl $m_rel_btx,%esi		# Restore
+		popl %eax			#  parameters
+		call hexout			#  and
+#endif
+		popl %ebp			#  display
+#ifdef BTXLDR_VERBOSE
+		movl %ebp,%eax			#  the
+		call hexout			#  relocation
+		call putstr			#  message
+#endif
+		addl $PAG_SIZ,%ebp		# Display
+#ifdef BTXLDR_VERBOSE
+		movl $m_base,%esi		#  the
+		movl %ebp,%eax			#  user
+		call hexout			#  base
+		call putstr			#  address
+#endif
+/*
+ * Set up ELF-format client program.
+ */
+		cmpl $0x464c457f,(%ebx) 	# ELF magic number?
+		je start.3			# Yes
+		movl $e_fmt,%esi		# Display error
+		call putstr			#  message
+start.2:	jmp start.2			# Hang
+start.3:
+#ifdef BTXLDR_VERBOSE
+		movl $m_elf,%esi		# Display ELF
+		call putstr			#  message
+		movl $m_segs,%esi		# Format string
+#endif
+		movl $0x2,%edi			# Segment count
+		movl 0x1c(%ebx),%edx		# Get e_phoff
+		addl %ebx,%edx			# To pointer
+		movzwl 0x2c(%ebx),%ecx		# Get e_phnum
+start.4:	cmpl $0x1,(%edx)		# Is p_type PT_LOAD?
+		jne start.6			# No
+#ifdef BTXLDR_VERBOSE
+		movl 0x4(%edx),%eax		# Display
+		call hexout			#  p_offset
+		movl 0x8(%edx),%eax		# Display
+		call hexout			#  p_vaddr
+		movl 0x10(%edx),%eax		# Display
+		call hexout			#  p_filesz
+		movl 0x14(%edx),%eax		# Display
+		call hexout			#  p_memsz
+		call putstr			# End message
+#endif
+		pushl %esi			# Save
+		pushl %edi			#  working
+		pushl %ecx			#  registers
+		movl 0x4(%edx),%esi		# Get p_offset
+		addl %ebx,%esi			#  as pointer
+		movl 0x8(%edx),%edi		# Get p_vaddr
+		addl %ebp,%edi			#  as pointer
+		movl 0x10(%edx),%ecx		# Get p_filesz
+		rep				# Set up
+		movsb				#  segment
+		movl 0x14(%edx),%ecx		# Any bytes
+		subl 0x10(%edx),%ecx		#  to zero?
+		jz start.5			# No
+		xorb %al,%al			# Then
+		rep				#  zero
+		stosb				#  them
+start.5:	popl %ecx			# Restore
+		popl %edi			#  working
+		popl %esi			#  registers
+		decl %edi			# Segments to do
+		je start.7			# If none
+start.6:	addl $0x20,%edx 		# To next entry
+		loop start.4			# Till done
+start.7:
+#ifdef BTXLDR_VERBOSE
+		movl $m_done,%esi		# Display done
+		call putstr			#  message
+#endif
+		movl $start.8,%esi		# Real mode stub
+		movl $MEM_STUB,%edi		# Destination
+		movl $start.9-start.8,%ecx	# Size
+		rep				# Relocate
+		movsb				#  it
+		ljmp $SEL_RCODE,$MEM_STUB	# To 16-bit code
+		.code16
+start.8:	xorw %ax,%ax			# Data
+		movb $SEL_RDATA,%al		#  selector
+		movw %ax,%ss			# Reload SS
+		movw %ax,%ds			# Reset
+		movw %ax,%es			#  other
+		movw %ax,%fs			#  segment
+		movw %ax,%gs			#  limits
+		movl %cr0,%eax			# Switch to
+		decw %ax			#  real
+		movl %eax,%cr0			#  mode
+		ljmp $0,$MEM_ENTRY		# Jump to BTX entry point
+start.9:
+		.code32
+/*
+ * Output message [ESI] followed by EAX in hex.
+ */
+hexout: 	pushl %eax			# Save
+		call putstr			# Display message
+		popl %eax			# Restore
+		pushl %esi			# Save
+		pushl %edi			#  caller's
+		movl $buf,%edi			# Buffer
+		pushl %edi			# Save
+		call hex32			# To hex
+		xorb %al,%al			# Terminate
+		stosb				#  string
+		popl %esi			# Restore
+hexout.1:	lodsb				# Get a char
+		cmpb $'0',%al			# Leading zero?
+		je hexout.1			# Yes
+		testb %al,%al			# End of string?
+		jne hexout.2			# No
+		decl %esi			# Undo
+hexout.2:	decl %esi			# Adjust for inc
+		call putstr			# Display hex
+		popl %edi			# Restore
+		popl %esi			#  caller's
+		ret				# To caller
+/*
+ * Output zero-terminated string [ESI] to the console.
+ */
+putstr.0:	call putchr			# Output char
+putstr: 	lodsb				# Load char
+		testb %al,%al			# End of string?
+		jne putstr.0			# No
+		ret				# To caller
+/*
+ * Output character AL to the console.
+ */
+putchr: 	pusha				# Save
+		xorl %ecx,%ecx			# Zero for loops
+		movb $SCR_MAT,%ah		# Mode/attribute
+		movl $BDA_POS,%ebx		# BDA pointer
+		movw (%ebx),%dx 		# Cursor position
+		movl $0xb8000,%edi		# Regen buffer (color)
+		cmpb %ah,BDA_SCR-BDA_POS(%ebx)	# Mono mode?
+		jne putchr.1			# No
+		xorw %di,%di			# Regen buffer (mono)
+putchr.1:	cmpb $0xa,%al			# New line?
+		je putchr.2			# Yes
+		xchgl %eax,%ecx 		# Save char
+		movb $SCR_COL,%al		# Columns per row
+		mulb %dh			#  * row position
+		addb %dl,%al			#  + column
+		adcb $0x0,%ah			#  position
+		shll %eax			#  * 2
+		xchgl %eax,%ecx 		# Swap char, offset
+		movw %ax,(%edi,%ecx,1)		# Write attr:char
+		incl %edx			# Bump cursor
+		cmpb $SCR_COL,%dl		# Beyond row?
+		jb putchr.3			# No
+putchr.2:	xorb %dl,%dl			# Zero column
+		incb %dh			# Bump row
+putchr.3:	cmpb $SCR_ROW,%dh		# Beyond screen?
+		jb putchr.4			# No
+		leal 2*SCR_COL(%edi),%esi	# New top line
+		movw $(SCR_ROW-1)*SCR_COL/2,%cx # Words to move
+		rep				# Scroll
+		movsl				#  screen
+		movb $' ',%al			# Space
+		movb $SCR_COL,%cl		# Columns to clear
+		rep				# Clear
+		stosw				#  line
+		movb $SCR_ROW-1,%dh		# Bottom line
+putchr.4:	movw %dx,(%ebx) 		# Update position
+		popa				# Restore
+		ret				# To caller
+/*
+ * Convert EAX, AX, or AL to hex, saving the result to [EDI].
+ */
+hex32:		pushl %eax			# Save
+		shrl $0x10,%eax 		# Do upper
+		call hex16			#  16
+		popl %eax			# Restore
+hex16:		call hex16.1			# Do upper 8
+hex16.1:	xchgb %ah,%al			# Save/restore
+hex8:		pushl %eax			# Save
+		shrb $0x4,%al			# Do upper
+		call hex8.1			#  4
+		popl %eax			# Restore
+hex8.1: 	andb $0xf,%al			# Get lower 4
+		cmpb $0xa,%al			# Convert
+		sbbb $0x69,%al			#  to hex
+		das				#  digit
+		orb $0x20,%al			# To lower case
+		stosb				# Save char
+		ret				# (Recursive)
+
+		.data
+		.p2align 4
+/*
+ * Global descriptor table.
+ */
+gdt:		.word 0x0,0x0,0x0,0x0		# Null entry
+		.word 0xffff,0x0,0x9a00,0xcf	# SEL_SCODE
+		.word 0xffff,0x0,0x9200,0xcf	# SEL_SDATA
+		.word 0xffff,0x0,0x9a00,0x0	# SEL_RCODE
+		.word 0xffff,0x0,0x9200,0x0	# SEL_RDATA
+gdt.1:
+gdtdesc:	.word gdt.1-gdt-1		# Limit
+		.long gdt			# Base
+/*
+ * Messages.
+ */
+m_logo: 	.asciz " \nBTX loader 1.00  "
+m_vers: 	.asciz "BTX version is \0\n"
+e_fmt:		.asciz "Error: Client format not supported\n"
+#ifdef BTXLDR_VERBOSE
+m_mem:		.asciz "Starting in protected mode (base mem=\0)\n"
+m_esp:		.asciz "Arguments passed (esp=\0):\n"
+m_args: 	.asciz"<howto="
+		.asciz" bootdev="
+		.asciz" junk="
+		.asciz" "
+		.asciz" "
+		.asciz" bootinfo=\0>\n"
+m_rel_bi:	.asciz "Relocated bootinfo (size=48) to \0\n"
+m_rel_args:	.asciz "Relocated arguments (size=18) to \0\n"
+m_rel_btx:	.asciz "Relocated kernel (size=\0) to \0\n"
+m_base: 	.asciz "Client base address is \0\n"
+m_elf:		.asciz "Client format is ELF\n"
+m_segs: 	.asciz "text segment: offset="
+		.asciz " vaddr="
+		.asciz " filesz="
+		.asciz " memsz=\0\n"
+		.asciz "data segment: offset="
+		.asciz " vaddr="
+		.asciz " filesz="
+		.asciz " memsz=\0\n"
+m_done: 	.asciz "Loading complete\n"
+#endif
+/*
+ * Uninitialized data area.
+ */
+buf:						# Scratch buffer
diff -ruN sys/boot/i386/pxe_ng/btx/btxsys.s sys/boot/i386/pxe_ng/btx/btxsys.s
--- sys/boot/i386/pxe_ng/btx/btxsys.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxsys.s	2009-03-02 20:18:22.000000000 -0500
@@ -0,0 +1,46 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxsys.s,v 1.2 1999/08/28 00:40:07 peter Exp $
+
+#
+# BTX system calls.
+#
+
+#
+# Globals.
+#
+		.global __exit
+		.global __exec
+		.global __isr_install
+#
+# Constants.
+#
+		.set INT_SYS,0x30		# Interrupt number
+#
+# System call: exit
+#
+__exit: 	xorl %eax,%eax			# BTX system
+		int $INT_SYS			#  call 0x0
+#
+# System call: exec
+#
+__exec: 	movl $0x1,%eax			# BTX system
+		int $INT_SYS			#  call 0x1
+#
+# System call: isr_install
+#
+__isr_install: 	movl $0x2,%eax			# BTX system
+		int $INT_SYS			#  call 0x2
diff -ruN sys/boot/i386/pxe_ng/btx/btxv86.h sys/boot/i386/pxe_ng/btx/btxv86.h
--- sys/boot/i386/pxe_ng/btx/btxv86.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxv86.h	2009-03-02 20:18:24.000000000 -0500
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are freely
+ * permitted provided that the above copyright notice and this
+ * paragraph and the following disclaimer are duplicated in all
+ * such forms.
+ *
+ * This software is provided "AS IS" and without any express or
+ * implied warranties, including, without limitation, the implied
+ * warranties of merchantability and fitness for a particular
+ * purpose.
+ */
+
+/*
+ * $FreeBSD: src/sys/boot/i386/btx/lib/btxv86.h,v 1.5 1999/08/28 00:40:08 peter Exp $
+ */
+
+#ifndef _BTXV86_H_
+#define _BTXV86_H_
+
+#include <sys/types.h>
+
+#define V86_ADDR   0x10000	/* Segment:offset address */
+#define V86_CALLF  0x20000	/* Emulate far call */
+#define V86_FLAGS  0x40000	/* Return flags */
+
+struct __v86 {
+    uint32_t ctl;		/* Control flags */
+    uint32_t addr;		/* Interrupt number or address */
+    uint32_t es;		/* V86 ES register */
+    uint32_t ds;		/* V86 DS register */
+    uint32_t fs;		/* V86 FS register */
+    uint32_t gs;		/* V86 GS register */
+    uint32_t eax;		/* V86 EAX register */
+    uint32_t ecx;		/* V86 ECX register */
+    uint32_t edx;		/* V86 EDX register */
+    uint32_t ebx;		/* V86 EBX register */
+    uint32_t efl;		/* V86 eflags register */
+    uint32_t ebp;		/* V86 EBP register */
+    uint32_t esi;		/* V86 ESI register */
+    uint32_t edi;		/* V86 EDI register */
+};
+
+extern struct __v86 __v86;	/* V86 interface structure */
+void __v86int(void);
+
+#define v86	__v86
+#define v86int	__v86int
+
+extern u_int32_t	__base;
+extern u_int32_t	__args;
+
+#define	PTOV(pa)	((caddr_t)(pa) - __base)
+#define	VTOP(va)	((vm_offset_t)(va) + __base)
+#define	VTOPSEG(va)	(u_int16_t)(VTOP((caddr_t)va) >> 4)
+#define	VTOPOFF(va)	(u_int16_t)(VTOP((caddr_t)va) & 0xf)
+
+void __exit(int) __attribute__((__noreturn__));
+void __exec(caddr_t, ...);
+/*
+ *  Installs interrupt handler function for interrupt int_num.
+ *  caddr_t - in userspace.
+ */
+void __isr_install(uint8_t int_num, caddr_t isr);
+
+#endif /* !_BTXV86_H_ */
diff -ruN sys/boot/i386/pxe_ng/btx/btxv86.s sys/boot/i386/pxe_ng/btx/btxv86.s
--- sys/boot/i386/pxe_ng/btx/btxv86.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/btxv86.s	2009-03-02 20:18:25.000000000 -0500
@@ -0,0 +1,85 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxv86.s,v 1.3 1999/08/28 00:40:08 peter Exp $
+
+#
+# BTX V86 interface.
+#
+
+#
+# Globals.
+#
+		.global __v86int
+#
+# Fields in V86 interface structure.
+#
+		.set V86_CTL,0x0		# Control flags
+		.set V86_ADDR,0x4		# Int number/address
+		.set V86_ES,0x8			# V86 ES
+		.set V86_DS,0xc			# V86 DS
+		.set V86_FS,0x10		# V86 FS
+		.set V86_GS,0x14		# V86 GS
+		.set V86_EAX,0x18		# V86 EAX
+		.set V86_ECX,0x1c		# V86 ECX
+		.set V86_EDX,0x20		# V86 EDX
+		.set V86_EBX,0x24		# V86 EBX
+		.set V86_EFL,0x28		# V86 eflags
+		.set V86_EBP,0x2c		# V86 EBP
+		.set V86_ESI,0x30		# V86 ESI
+		.set V86_EDI,0x34		# V86 EDI
+#
+# Other constants.
+#
+		.set INT_V86,0x31		# Interrupt number
+		.set SIZ_V86,0x38		# Size of V86 structure
+#
+# V86 interface function.
+#
+__v86int:	popl __v86ret			# Save return address
+		pushl $__v86			# Push pointer
+		call __v86_swap			# Load V86 registers
+		int $INT_V86			# To BTX
+		call __v86_swap			# Load user registers
+		addl $0x4,%esp			# Discard pointer
+		pushl __v86ret			# Restore return address
+		ret 				# To user
+#
+# Swap V86 and user registers.
+#
+__v86_swap:	xchgl %ebp,0x4(%esp,1)		# Swap pointer, EBP
+		xchgl %eax,V86_EAX(%ebp)	# Swap EAX
+		xchgl %ecx,V86_ECX(%ebp)	# Swap ECX
+		xchgl %edx,V86_EDX(%ebp)	# Swap EDX
+		xchgl %ebx,V86_EBX(%ebp)	# Swap EBX
+		pushl %eax			# Save
+		pushf 				# Put eflags
+		popl %eax			#  in EAX
+		xchgl %eax,V86_EFL(%ebp)	# Swap
+		pushl %eax			# Put EAX
+		popf 				#  in eflags
+		movl 0x8(%esp,1),%eax		# Load EBP
+		xchgl %eax,V86_EBP(%ebp)	# Swap
+		movl %eax,0x8(%esp,1)		# Save EBP
+		popl %eax			# Restore
+		xchgl %esi,V86_ESI(%ebp)	# Swap ESI
+		xchgl %edi,V86_EDI(%ebp)	# Swap EDI
+		xchgl %ebp,0x4(%esp,1)		# Swap pointer, EBP
+		ret				# To caller
+#
+# V86 interface structure.
+#
+		.comm __v86,SIZ_V86
+		.comm __v86ret,4
diff -ruN sys/boot/i386/pxe_ng/btx/lib/Makefile sys/boot/i386/pxe_ng/btx/lib/Makefile
--- sys/boot/i386/pxe_ng/btx/lib/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/lib/Makefile	2009-03-02 20:18:38.000000000 -0500
@@ -0,0 +1,9 @@
+# $FreeBSD: src/sys/boot/i386/btx/lib/Makefile,v 1.13 2004/12/21 08:47:14 ru Exp $
+
+PROG=	crt0.o
+INTERNALPROG=
+NO_MAN=
+SRCS=	btxcsu.s btxsys.s btxv86.s
+LDFLAGS=-Wl,-r
+
+.include <bsd.prog.mk>
diff -ruN sys/boot/i386/pxe_ng/btx/lib/btxcsu.s sys/boot/i386/pxe_ng/btx/lib/btxcsu.s
--- sys/boot/i386/pxe_ng/btx/lib/btxcsu.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/lib/btxcsu.s	2009-03-02 20:18:40.000000000 -0500
@@ -0,0 +1,51 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxcsu.s,v 1.4 2004/08/05 06:00:05 kan Exp $
+
+#
+# BTX C startup code (ELF).
+#
+
+#
+# Globals.
+#
+		.global _start
+#
+# Constants.
+#
+		.set ARGADJ,0xfa0		# Argument adjustment
+#
+# Client entry point.
+#
+_start: 	cld
+		pushl %eax
+		movl $_edata,%edi 
+		movl $_end,%ecx 
+		subl %edi, %ecx
+		xorb %al, %al
+		rep
+		stosb
+		popl __base
+		movl %esp,%eax			# Set
+		addl $ARGADJ,%eax		#  argument
+		movl %eax,__args		#  pointer
+		call main			# Invoke client main()
+		call exit			# Invoke client exit()
+#
+# Data.
+#
+		.comm __base,4			# Client base address
+		.comm __args,4			# Client arguments
diff -ruN sys/boot/i386/pxe_ng/btx/lib/btxsys.s sys/boot/i386/pxe_ng/btx/lib/btxsys.s
--- sys/boot/i386/pxe_ng/btx/lib/btxsys.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/lib/btxsys.s	2009-03-02 20:18:42.000000000 -0500
@@ -0,0 +1,46 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxsys.s,v 1.2 1999/08/28 00:40:07 peter Exp $
+
+#
+# BTX system calls.
+#
+
+#
+# Globals.
+#
+		.global __exit
+		.global __exec
+		.global __isr_install
+#
+# Constants.
+#
+		.set INT_SYS,0x30		# Interrupt number
+#
+# System call: exit
+#
+__exit: 	xorl %eax,%eax			# BTX system
+		int $INT_SYS			#  call 0x0
+#
+# System call: exec
+#
+__exec: 	movl $0x1,%eax			# BTX system
+		int $INT_SYS			#  call 0x1
+#
+# System call: isr_install
+#
+__isr_install: 	movl $0x2,%eax			# BTX system
+		int $INT_SYS			#  call 0x2
diff -ruN sys/boot/i386/pxe_ng/btx/lib/btxv86.h sys/boot/i386/pxe_ng/btx/lib/btxv86.h
--- sys/boot/i386/pxe_ng/btx/lib/btxv86.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/lib/btxv86.h	2009-03-02 20:19:44.000000000 -0500
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are freely
+ * permitted provided that the above copyright notice and this
+ * paragraph and the following disclaimer are duplicated in all
+ * such forms.
+ *
+ * This software is provided "AS IS" and without any express or
+ * implied warranties, including, without limitation, the implied
+ * warranties of merchantability and fitness for a particular
+ * purpose.
+ */
+
+/*
+ * $FreeBSD: src/sys/boot/i386/btx/lib/btxv86.h,v 1.5 1999/08/28 00:40:08 peter Exp $
+ */
+
+#ifndef _BTXV86_H_
+#define _BTXV86_H_
+
+#include <sys/types.h>
+
+#define V86_ADDR   0x10000	/* Segment:offset address */
+#define V86_CALLF  0x20000	/* Emulate far call */
+#define V86_FLAGS  0x40000	/* Return flags */
+
+struct __v86 {
+    uint32_t ctl;		/* Control flags */
+    uint32_t addr;		/* Interrupt number or address */
+    uint32_t es;		/* V86 ES register */
+    uint32_t ds;		/* V86 DS register */
+    uint32_t fs;		/* V86 FS register */
+    uint32_t gs;		/* V86 GS register */
+    uint32_t eax;		/* V86 EAX register */
+    uint32_t ecx;		/* V86 ECX register */
+    uint32_t edx;		/* V86 EDX register */
+    uint32_t ebx;		/* V86 EBX register */
+    uint32_t efl;		/* V86 eflags register */
+    uint32_t ebp;		/* V86 EBP register */
+    uint32_t esi;		/* V86 ESI register */
+    uint32_t edi;		/* V86 EDI register */
+};
+
+extern struct __v86 __v86;	/* V86 interface structure */
+void __v86int(void);
+
+#define v86	__v86
+#define v86int	__v86int
+
+extern u_int32_t	__base;
+extern u_int32_t	__args;
+
+#define	PTOV(pa)	((caddr_t)(pa) - __base)
+#define	VTOP(va)	((vm_offset_t)(va) + __base)
+#define	VTOPSEG(va)	(u_int16_t)(VTOP((caddr_t)va) >> 4)
+#define	VTOPOFF(va)	(u_int16_t)(VTOP((caddr_t)va) & 0xf)
+
+void __exit(int) __attribute__((__noreturn__));
+void __exec(caddr_t, ...);
+/*
+ *  Installs interrupt handler function for interrupt int_num.
+ *  caddr_t - in userspace.
+ */
+void __isr_install(caddr_t isr, uint16_t int_num);
+
+#endif /* !_BTXV86_H_ */
diff -ruN sys/boot/i386/pxe_ng/btx/lib/btxv86.s sys/boot/i386/pxe_ng/btx/lib/btxv86.s
--- sys/boot/i386/pxe_ng/btx/lib/btxv86.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/btx/lib/btxv86.s	2009-03-02 20:19:46.000000000 -0500
@@ -0,0 +1,85 @@
+#
+# Copyright (c) 1998 Robert Nordier
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+
+# $FreeBSD: src/sys/boot/i386/btx/lib/btxv86.s,v 1.3 1999/08/28 00:40:08 peter Exp $
+
+#
+# BTX V86 interface.
+#
+
+#
+# Globals.
+#
+		.global __v86int
+#
+# Fields in V86 interface structure.
+#
+		.set V86_CTL,0x0		# Control flags
+		.set V86_ADDR,0x4		# Int number/address
+		.set V86_ES,0x8			# V86 ES
+		.set V86_DS,0xc			# V86 DS
+		.set V86_FS,0x10		# V86 FS
+		.set V86_GS,0x14		# V86 GS
+		.set V86_EAX,0x18		# V86 EAX
+		.set V86_ECX,0x1c		# V86 ECX
+		.set V86_EDX,0x20		# V86 EDX
+		.set V86_EBX,0x24		# V86 EBX
+		.set V86_EFL,0x28		# V86 eflags
+		.set V86_EBP,0x2c		# V86 EBP
+		.set V86_ESI,0x30		# V86 ESI
+		.set V86_EDI,0x34		# V86 EDI
+#
+# Other constants.
+#
+		.set INT_V86,0x31		# Interrupt number
+		.set SIZ_V86,0x38		# Size of V86 structure
+#
+# V86 interface function.
+#
+__v86int:	popl __v86ret			# Save return address
+		pushl $__v86			# Push pointer
+		call __v86_swap			# Load V86 registers
+		int $INT_V86			# To BTX
+		call __v86_swap			# Load user registers
+		addl $0x4,%esp			# Discard pointer
+		pushl __v86ret			# Restore return address
+		ret 				# To user
+#
+# Swap V86 and user registers.
+#
+__v86_swap:	xchgl %ebp,0x4(%esp,1)		# Swap pointer, EBP
+		xchgl %eax,V86_EAX(%ebp)	# Swap EAX
+		xchgl %ecx,V86_ECX(%ebp)	# Swap ECX
+		xchgl %edx,V86_EDX(%ebp)	# Swap EDX
+		xchgl %ebx,V86_EBX(%ebp)	# Swap EBX
+		pushl %eax			# Save
+		pushf 				# Put eflags
+		popl %eax			#  in EAX
+		xchgl %eax,V86_EFL(%ebp)	# Swap
+		pushl %eax			# Put EAX
+		popf 				#  in eflags
+		movl 0x8(%esp,1),%eax		# Load EBP
+		xchgl %eax,V86_EBP(%ebp)	# Swap
+		movl %eax,0x8(%esp,1)		# Save EBP
+		popl %eax			# Restore
+		xchgl %esi,V86_ESI(%ebp)	# Swap ESI
+		xchgl %edi,V86_EDI(%ebp)	# Swap EDI
+		xchgl %ebp,0x4(%esp,1)		# Swap pointer, EBP
+		ret				# To caller
+#
+# V86 interface structure.
+#
+		.comm __v86,SIZ_V86
+		.comm __v86ret,4
diff -ruN sys/boot/i386/pxe_ng/devd2dbus/bsdbus.c sys/boot/i386/pxe_ng/devd2dbus/bsdbus.c
--- sys/boot/i386/pxe_ng/devd2dbus/bsdbus.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/devd2dbus/bsdbus.c	2009-03-02 20:19:50.000000000 -0500
@@ -0,0 +1,625 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
+/*
+ * main.c - Auto-generated by Anjuta's Makefile project wizard
+ * 
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "bsdbus.h"
+
+static char* known_bus_path[DBUS_ALL_KNOWN_BUS] = { NULL, NULL};
+
+size_t
+dbus_pad (size_t stream_index, size_t align)
+{
+		size_t pad = stream_index % align;
+		return ((pad == 0) ? 0 : align - pad);
+}
+
+size_t
+dbus_align_index(size_t stream_index, size_t align)
+{
+		size_t pad = stream_index % align;
+		return (stream_index += (pad == 0) ? 0 : align - pad);
+}
+
+void
+dbus_push_elem(struct DBus_message *message, enum DBus_param_type type, void *data, size_t size)
+{
+		struct DBus_body_elem *elem = (struct DBus_body_elem *)malloc(sizeof(struct DBus_body_elem));
+	
+		elem->type = type;
+		elem->data = data;
+		elem->size = size;
+		elem->next = NULL;		
+	
+		if (message->start == NULL) {
+				message->start = elem;
+		} else {
+				message->tail->next = elem;
+		}
+		
+		message->tail = elem;
+		
+		// add padding size
+	//	printf("size = %lu, align = %lu\n", message->size, DBus_field_align[type]);
+		message->size += dbus_pad (message->size, DBus_field_align[type]);
+		// add new body element size
+	//	printf("pad + size = %lu\n", message->size);
+		message->size += size;
+		message->elem_count += 1;
+}
+
+void
+dbus_push_byte(struct DBus_message *message, uint8_t val)
+{
+		uint8_t	*data = (uint8_t *)malloc(1);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_BYTE, data, 1);
+}
+
+void
+dbus_push_boolean(struct DBus_message *message, uint32_t val)
+{
+		uint32_t	*data = (uint32_t *)malloc(4);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_BOOLEAN, data, 4);
+}
+
+void
+dbus_push_int16(struct DBus_message *message, int16_t val)
+{
+		int16_t	*data = (int16_t *)malloc(2);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_INT16, data, 1);
+}
+
+void
+dbus_push_uint16(struct DBus_message *message, uint16_t val)
+{
+		uint16_t	*data = (uint16_t *)malloc(2);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_UINT16, data, 2);
+}
+
+void
+dbus_push_int32(struct DBus_message *message, int32_t val)
+{
+		int32_t	*data = (int32_t *)malloc(4);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_INT32, data, 4);
+}
+
+void
+dbus_push_uint32(struct DBus_message *message, uint32_t val)
+{
+		uint32_t	*data = (uint32_t *)malloc(4);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_UINT32, data, 4);
+}
+
+void
+dbus_push_int64(struct DBus_message *message, int64_t val)
+{
+		int64_t	*data = (int64_t *)malloc(8);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_INT64, data, 8);
+}
+
+void
+dbus_push_uint64(struct DBus_message *message, uint64_t val)
+{
+		uint64_t	*data = (uint64_t *)malloc(8);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_UINT64, data, 8);
+}
+
+void
+dbus_push_double(struct DBus_message *message, double val)
+{
+		double	*data = (double *)malloc(8);
+		*data = val;
+	
+		dbus_push_elem(message, DBUS_PARAM_DOUBLE, data, 8);
+}
+
+void
+dbus_push_struct_align(struct DBus_message *message)
+{
+		dbus_push_elem(message, DBUS_PARAM_STRUCT, NULL, 0);
+}
+
+void
+dbus_push_string(struct DBus_message *message, const char *val)
+{
+		uint32_t	len = (uint32_t)strlen(val);
+		uint8_t		*data = (uint8_t *)malloc(len + 5);
+		
+		*((uint32_t *)data) = len;
+		//data += 4;
+	
+		memcpy(data + 4, val, len);
+		data[len + 4] = '\0';
+	
+		dbus_push_elem(message, DBUS_PARAM_STRING, data, len + 5);
+}
+
+void
+dbus_push_object_path(struct DBus_message *message, const char *val)
+{
+	/* TODO: valid object path check */
+		dbus_push_string (message, val);
+}
+
+void
+dbus_push_signature(struct DBus_message *message, const char *val)
+{
+		uint8_t	len = (uint8_t)strlen(val);
+		uint8_t		*data = (uint8_t *)malloc(len + 2);
+		
+		*data = len;
+		//data += 1;
+	
+		memcpy(data + 1, val, len);
+		data[len + 1] = '\0';
+	
+		dbus_push_elem(message, DBUS_PARAM_SIGNATURE, data, len + 2);
+}
+
+struct DBus_message *
+dbus_alloc_message()
+{
+		struct DBus_message *tmpMessage = malloc(sizeof(struct DBus_message));
+			
+		if (tmpMessage == NULL) {
+				printf("failed to allocate memory for message.\n");
+				return (NULL);
+		}
+	
+		memset(tmpMessage, 0, sizeof(struct DBus_message));
+	
+		return (tmpMessage);
+}
+
+void
+dbus_free_message(struct DBus_message *message)
+{
+		struct DBus_body_elem *elem = message->start;
+	
+		while (elem != NULL) {
+				struct DBus_body_elem *tmp = elem->next;
+				free(elem->data);
+				free(elem);
+				elem = tmp;
+		}
+	
+		free(message);
+}
+
+void *
+dbus_format_message(struct DBus_message *message, int pad)
+{
+	//	printf("dbus_format_message(%lu):\n", message->size);
+	
+		if (message->size == 0) {
+				return (message);
+		}
+	
+		if (pad != DBUS_NO_PADDING) {
+				message->size += dbus_pad(message->size, pad);
+		}
+		// allocating storage for body
+		message->data = malloc(message->size);
+			
+		if (message->data == NULL)
+				return (NULL);
+
+		memset(message->data, 0, message->size);
+	
+		size_t  pos = 0;
+		uint8_t *data = (uint8_t *)message->data;
+	
+		struct DBus_body_elem *elem = message->start;
+	
+		while (elem != NULL) {
+		
+				pos += dbus_pad (pos, DBus_field_align[elem->type]);
+				
+				if (elem->data != NULL) /* may be NULL only for structure */
+						memcpy(data + pos, elem->data, elem->size);
+			
+				pos += elem->size;
+			
+				elem = elem->next;
+		}
+	
+		return (message->data);
+}
+
+enum DBus_communication_state
+dbus_send(struct DBus_connection *connection, struct DBus_message *message,
+	const char *path, const char *interface, const char *name)
+{
+		struct DBus_message					*hdrMsg = dbus_alloc_message ();
+		struct DBus_message_header  hdr;
+
+		printf("dbus_send(): ");
+		hdr.endyFlag = DBUS_LITTLE_ENDIAN;
+		hdr.type = DBUS_METHOD_CALL;
+		hdr.flags = 0;
+		hdr.proto = 1;
+		hdr.length = message->size;
+		hdr.serial = 1;
+
+		
+		dbus_push_struct_align(hdrMsg);
+		dbus_push_byte(hdrMsg, DBUS_PATH);
+		dbus_push_signature(hdrMsg, "o");
+		dbus_push_object_path(hdrMsg, path);
+
+		dbus_push_struct_align(hdrMsg);
+		dbus_push_byte(hdrMsg, DBUS_INTERFACE);
+		dbus_push_signature(hdrMsg, "s");
+		dbus_push_string(hdrMsg, interface);
+
+		dbus_push_struct_align(hdrMsg);
+		dbus_push_byte(hdrMsg, DBUS_MEMBER);
+		dbus_push_signature(hdrMsg, "s");
+		dbus_push_string(hdrMsg, name);
+
+		dbus_push_struct_align(hdrMsg);
+		dbus_push_byte(hdrMsg, DBUS_DESTINATION);
+		dbus_push_signature(hdrMsg, "s");
+		dbus_push_string(hdrMsg, DBUS_SERVICE_DBUS);
+
+		hdr.arrSize = hdrMsg->size;
+		
+		dbus_format_message (hdrMsg, 8);
+	
+		FILE *fd = connection->fd;
+		
+		if (1 != fwrite(&hdr, sizeof(struct DBus_message_header), 1, fd)) {
+				printf("failed to write message header\n");
+				goto error;
+		}
+
+		printf("data = %p, %lu", hdrMsg->data, hdrMsg->size);
+		if (1 != fwrite(hdrMsg->data, hdrMsg->size, 1, fd)) {
+				printf("failed to write message header fields\n");
+				goto error;
+		}
+		
+		printf("; data = %p, %lu: ", message->data, message->size);
+		if (message->size != 0) {
+				if (1 != fwrite(message->data, message->size, 1, fd)) {
+						printf("failed to write message body\n");
+						goto error;
+				}
+		}
+
+		fflush(fd);
+	
+		printf("ok\n");
+	
+		uint8_t reply[512];
+		ssize_t reply_size = 0;
+	
+		usleep(10);
+		reply_size = recv(connection->socket, reply, 512, 0);
+	
+		FILE *fout = fopen("bsdbus.dump", "w+");
+		fwrite(&hdr, sizeof(struct DBus_message_header), 1, fout);
+		fwrite(hdrMsg->data, hdrMsg->size, 1, fout);
+		fwrite(message->data, message->size, 1, fout);
+	
+		if (reply_size > 0) {
+				printf("method return received\n");
+				fwrite(reply, reply_size, 1, fout);
+		}
+	
+		fflush(fout);
+		fclose(fout);
+	
+		
+	//	dbus_free_message(hdrMsg);
+	
+		return (DBUS_COMMUNICATION_OK);
+	
+error:
+	//	dbus_free_message(hdrMsg);
+		
+		return (DBUS_COMMUNICATION_FAILED);
+}
+
+void
+dbus_getuid(char *hex)
+{
+		uid_t uid = getuid();
+	
+		char str[128] = {0};
+	
+		sprintf(str, "%Lu", uid);
+	
+		size_t len = strlen(str);
+	
+		size_t i = 0;
+	
+		for (; i < len; ++i) {
+				sprintf(&hex[2*i], "%2x", str[i]);
+		}
+		
+		hex[2 * len] = '\0';
+}
+
+struct DBus_connection *
+dbus_auth(struct DBus_connection* connection)
+{
+		FILE	*fd = connection->fd;
+		char buf[256];
+		char uid[256];
+	
+		dbus_getuid(uid);
+	
+		sprintf(buf, "AUTH EXTERNAL %s\r\n", uid);
+	
+		size_t res = fwrite(buf, strlen(buf), 1, fd);
+		fflush(fd);
+		
+		if (1 != res) {
+				printf("failed to write AUTH (%d)\n", ferror(fd));
+				return (NULL);
+		}
+
+		printf("wrote string: %s", buf);
+	
+		buf[0] ='\0';
+	
+		while(buf[0] == '\0') {
+				if ( (fgets(buf, 256, fd) == NULL) && (!feof(fd))) {
+						printf("failed to get answer to AUTH (%d)\n", ferror(fd));
+						if (ferror(fd) == EBADF)
+								printf("stream is not readable\n");
+						return (NULL);
+				}
+			
+				usleep(10);
+		}
+	
+		printf("received %s\n", buf);
+	
+		sprintf(buf, "BEGIN\r\n");
+		fwrite(buf, strlen(buf), 1, fd);
+		fflush(fd);
+	
+		return (connection);
+}
+
+struct dbus_credential_msg {
+		struct cmsghdr  hdr;
+		struct cmsgcred cred;
+};
+
+struct DBus_connection *
+dbus_credential(struct DBus_connection* connection)
+{
+		int				written = -1;
+		uint8_t byte = 0;
+
+		struct iovec vec;
+		struct msghdr msg;
+		struct dbus_credential_msg cmsg;
+	
+		vec.iov_base = &byte;
+		vec.iov_len = 1;
+
+		memset (&msg, 0, sizeof (msg));
+		msg.msg_iov = &vec;
+		msg.msg_iovlen = 1;
+
+		msg.msg_control = &cmsg;
+		msg.msg_controllen = sizeof (cmsg);
+  
+		memset (&cmsg, 0, sizeof (cmsg));
+
+		cmsg.hdr.cmsg_len = sizeof (cmsg);
+		cmsg.hdr.cmsg_level = SOL_SOCKET;
+		cmsg.hdr.cmsg_type = SCM_CREDS;
+
+		do {
+				written = sendmsg (connection->socket, &msg, 0);
+		} while (written < 0 && errno == EINTR);
+			
+		if (written != 1) {
+      printf("failed to write credentials byte. %s\n", written == 0 ?
+				 "no bytes written" : "error occured");
+      return (NULL);
+		}
+	
+		printf ("wrote credentials byte\n");
+
+		return (connection);
+}
+
+struct DBus_connection *
+dbus_connect(enum DBus_connection_type conType)
+{
+		if (conType >= DBUS_ALL_KNOWN_BUS) {
+				return (NULL);
+		}
+	
+		if (known_bus_path[conType] == NULL) {
+				const char *path = getenv(DBus_connection_str[conType]);
+			
+				if (path == NULL) {
+						known_bus_path[conType] = strdup(DBus_default_path[conType]);
+				} else {
+			
+						const char *eq = strchr(path, '=');
+			
+						if (eq == NULL)
+								return (NULL);
+			
+						const char *zap = strchr(path, ',');
+			
+						size_t len = (zap != NULL) ? (zap - eq - 1) : strlen(path) - (eq - path) - 1;
+			
+						known_bus_path[conType] = (char *)malloc(len);
+						memcpy(known_bus_path[conType] , eq + 1, len);
+						known_bus_path[conType][len] = '\0';
+				}
+		}
+	
+		struct DBus_connection *tmpStruct =
+					(struct DBus_connection *)malloc(sizeof(struct DBus_connection));
+	
+		memset(tmpStruct, 0, sizeof(struct DBus_connection));
+	
+		if (!dbus_open_connect (tmpStruct, known_bus_path[conType])) {
+				free(tmpStruct);
+				return (NULL);
+		}
+
+		if (!dbus_credential(tmpStruct)) {
+				dbus_disconnect(tmpStruct);
+				return (NULL);
+		}
+			
+		if (!dbus_auth(tmpStruct)) {
+				dbus_disconnect (tmpStruct);
+				return (NULL);
+		}
+	
+		printf("connected to dbus\n");
+
+		return (tmpStruct);
+}
+
+void
+dbus_disconnect(struct DBus_connection *connection)
+{
+		if (connection->socket != -1) {
+				if (connection->fd != NULL)
+						fclose(connection->fd);
+				else
+						close(connection->socket);
+		}
+	
+		printf("disconnected...\n");
+	
+		free(connection);
+}
+
+struct DBus_connection *
+dbus_open_connect(struct DBus_connection *connection, const char *path)
+{
+		struct sockaddr_un	addr;
+		size_t						len;
+	
+		connection->socket = socket(AF_LOCAL, SOCK_STREAM, 0);
+		
+		if (connection->socket < 0) {
+				printf("Failed to open socket\n");
+				return (NULL);
+		}
+	
+		memset(&addr, 0, sizeof(addr));
+	
+		addr.sun_family = PF_LOCAL;
+		len = strlen (path);
+		
+		memcpy (addr.sun_path, path, len);
+		
+		printf("connecting to %s\n", path);	
+	
+		int result = connect(connection->socket, (struct sockaddr *)&addr, 
+							 sizeof(struct sockaddr_un));
+
+		if (result < 0)   {  
+				printf("Failed to connect to socket %s\n", path);
+
+				close(connection->socket);
+				connection->socket = -1;
+			 
+				return (NULL);
+		}
+
+		int flags = fcntl (connection->socket, F_GETFL, 0);
+  
+		if (flags < 0)   {
+				printf("Failed to get socket flags\n");
+				
+				close(connection->socket);
+				connection->socket = -1;
+			 
+				return (NULL);
+		}
+
+	/*	result = fcntl (connection->socket, F_SETFL, flags | O_NONBLOCK);
+	
+		if (result < 0)  {
+  				printf("Failed to set O_NONBLOCK flag on connection socket\n");
+				
+				close(connection->socket);
+				connection->socket = -1;
+			 
+				return (NULL);    
+		}
+*/
+
+
+	connection->fd = fdopen(connection->socket, "r+");
+
+		if (connection->fd == NULL) {
+				printf("Failed to open FILE descriptor\n");
+				close(connection->socket);
+				connection->socket = -1;
+				return (NULL);
+		}
+
+		return (connection);
+}
+
+int main()
+{
+	printf("bsdbus test\n");
+	
+	struct DBus_connection *connection = dbus_connect (DBUS_SESSION_BUS);
+	
+	if (connection == NULL) {
+			printf("Failed to open connection to sesion bus\n");
+			return (1);
+	}
+	
+	struct DBus_message			*msg = dbus_alloc_message();
+	
+	if (dbus_format_message (msg, DBUS_NO_PADDING) == NULL) {
+			printf("failed to format message\n");
+	} else {
+			dbus_send(connection, msg, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS,
+					  "Hello");
+	}
+	
+	// dbus_free_message(msg);
+
+	dbus_disconnect (connection);
+	
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/devd2dbus/bsdbus.h sys/boot/i386/pxe_ng/devd2dbus/bsdbus.h
--- sys/boot/i386/pxe_ng/devd2dbus/bsdbus.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/devd2dbus/bsdbus.h	2009-03-02 20:19:52.000000000 -0500
@@ -0,0 +1,186 @@
+#ifndef BSDBUS_H
+#define BSDBUS_H
+
+#include <stdint.h>
+#include <stdio.h>
+
+enum DBus_connection_state {
+	DBUS_CONNECTED = 0,
+	DBUS_DISCONNECTED = 1
+};
+
+enum DBus_connection_type {
+	DBUS_SYSTEM_BUS = 0,
+	DBUS_SESSION_BUS = 1,
+	DBUS_ALL_KNOWN_BUS = 2
+};
+
+const char DBus_connection_str[DBUS_ALL_KNOWN_BUS][32] = {
+	"DBUS_SYSTEM_BUS_ADDRESS",
+	"DBUS_SESSION_BUS_ADDRESS"
+};
+
+const char DBus_default_path[DBUS_ALL_KNOWN_BUS][32] = {
+	"/var/run/dbus/system-bus-socket",
+	"/var/run/dbus/session-bus-socket"
+};
+
+enum DBus_communication_state {
+	DBUS_COMMUNICATION_FAILED = 0,
+	DBUS_COMMUNICATION_OK = 1
+};
+
+struct DBus_connection
+{
+	enum DBus_connection_type	type;
+	enum DBus_connection_state	state;
+	FILE						*fd;
+	int							socket;
+};
+
+enum DBus_param_type
+{
+	DBUS_PARAM_INVALID = 0,
+	DBUS_PARAM_BYTE = 1,
+	DBUS_PARAM_BOOLEAN = 2,
+	DBUS_PARAM_INT16 = 3,
+	DBUS_PARAM_UINT16 = 4,
+	DBUS_PARAM_INT32 = 5,
+	DBUS_PARAM_UINT32 = 6,
+	DBUS_PARAM_INT64 = 7,
+	DBUS_PARAM_UINT64 = 8,
+	DBUS_PARAM_DOUBLE = 9,
+	DBUS_PARAM_STRING = 10,
+	DBUS_PARAM_OBJECT_PATH = 11,
+	DBUS_PARAM_SIGNATURE = 12,
+	DBUS_PARAM_ARRAY = 13,
+	DBUS_PARAM_STRUCT = 14,
+	DBUS_PARAM_VARIANT = 15,
+	DBUS_PARAM_DICT_ENTRY = 16,
+	DBUS_ALL_TYPES = 17
+};
+struct DBus_body_elem
+{
+	struct DBus_body_elem	*next;
+	enum DBus_param_type		type;
+	void					*data;
+	size_t					size;
+};
+
+struct DBus_message {
+	// outcoming message data
+	struct DBus_body_elem	*start;
+	struct DBus_body_elem	*tail;
+	
+	// raw message data
+	size_t					size;
+	void					*data;
+	
+	// raw incoming data
+	const uint8_t		    *body;
+	const uint8_t		    *header;
+	
+	size_t					elem_count;
+};
+
+struct DBus_connection		*dbus_connect(enum DBus_connection_type conType);
+struct DBus_connection		*dbus_open_connect(struct DBus_connection * connection, const char *path);
+void						dbus_disconnect(struct DBus_connection *connection);
+
+enum DBus_communication_state	dbus_send(struct DBus_connection *connection,
+							struct DBus_message *message,
+						    const char *path, const char *interface, const char *name);
+
+void						dbus_free_message(struct DBus_message *message);
+void						*dbus_format_message(struct DBus_message *message, int pad);
+struct DBus_message			*dbus_alloc_message();
+
+void						dbus_push_elem(struct DBus_message *message, enum DBus_param_type type, void *data, size_t size);
+void						dbus_push_byte(struct DBus_message *message, uint8_t val);
+void						dbus_push_boolean(struct DBus_message *message, uint32_t val);
+void						dbus_push_int16(struct DBus_message *message, int16_t val);
+void						dbus_push_uint16(struct DBus_message *message, uint16_t val);
+void						dbus_push_int32(struct DBus_message *message, int32_t val);
+void						dbus_push_uint32(struct DBus_message *message, uint32_t val);
+void						dbus_push_int64(struct DBus_message *message, int64_t val);
+void						dbus_push_uint64(struct DBus_message *message, uint64_t val);
+void						dbus_push_double(struct DBus_message *message, double val);
+void						dbus_push_string(struct DBus_message *message, const char *val);
+void						dbus_push_object_path(struct DBus_message *message, const char *val);
+void						dbus_push_signature(struct DBus_message *message, const char *val);
+void						dbus_push_struct_align(struct DBus_message *message);
+
+#define RETURN_IF(x)		(if (x) return);
+
+enum DBus_endian {
+	DBUS_BIG_ENDIAN 		= (uint8_t)'B',
+	DBUS_LITTLE_ENDIAN 	= (uint8_t)'l'
+};
+
+enum DBus_message_type {
+	DBUS_MESSAGE_INVALID = 0,
+	DBUS_METHOD_CALL = 1,
+	DBUS_METHOD_RETURN = 2,
+	DBUS_ERROR = 3,
+	DBUS_SIGNAL = 4
+};
+
+enum DBus_message_flags {
+	DBUS_NO_REPLY_EXPECTED = 0x1,
+	DBUS_NO_AUTO_START = 0x2
+};
+
+const uint8_t DBUS_PROTOCOL_VERSION = 1;
+
+struct DBus_message_header
+{
+	uint8_t	endyFlag;
+	uint8_t	type;
+	uint8_t	flags;
+	uint8_t	proto;
+	uint32_t length;
+	uint32_t serial;
+	uint32_t arrSize;
+	/* ended by array of struct (byte, variant) */
+};
+
+struct DBus_tube
+{
+	struct DBus_connection      *connection;
+	struct DBus_message_header  header;
+	struct DBus_message		    *header_fields;
+};
+
+struct DBus_tube *dbus_signal_tube(struct DBus_connection *connection,
+					const char *path, const char *interface, char *signature);
+					
+void			 dbus_tube_send(struct DBus_tube *tube,
+					const char *name,
+				    struct DBus_message *message);
+				    
+void			 dbus_tube_close(struct DBus_tube_open);
+
+enum DBus_field_code {
+	DBUS_INVALID = 0,
+	DBUS_PATH = 1, 
+	DBUS_INTERFACE = 2,
+	DBUS_MEMBER	= 3,
+	DBUS_ERROR_NAME	= 4,
+	DBUS_REPLY_SERIAL = 5,
+	DBUS_DESTINATION = 6,
+	DBUS_SENDER	= 7,
+	DBUS_SIGNATURE = 8,
+	DBUS_ALL_FIELDS = 9
+};
+
+const size_t    DBus_field_align[DBUS_ALL_TYPES] = { 0, 1, 4, 2, 2, 4, 4, 8, 8, 8, 4, 4, 1, 4, 8, 1, 8 };
+const uint8_t   DBus_param_code[DBUS_ALL_TYPES] = { 0, 121, 98, 110, 113, 105, 117, 120, 116, 100, 115, 111, 103, 97, 114, 118, 101 };
+
+const char DBUS_INTERFACE_DBUS[] = "org.freedesktop.DBus";
+const char DBUS_SERVICE_DBUS[] = "org.freedesktop.DBus";
+const char DBUS_PATH_DBUS[] = "/org/freedesktop/DBus";
+
+const int DBUS_NO_PADDING = 0;
+
+#endif /* BSDBUS_H */
+
diff -ruN sys/boot/i386/pxe_ng/httpfs.c sys/boot/i386/pxe_ng/httpfs.c
--- sys/boot/i386/pxe_ng/httpfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/httpfs.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,343 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <sys/types.h>
+#include <stand.h>
+
+#include "pxe_core.h"
+#include "pxe_http.h"
+#include "pxe_ip.h"
+#include "pxe_sock.h"
+
+static int	http_open(const char *path, struct open_file *f);
+static int	http_close(struct open_file *f);
+static int	http_read(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static int	http_write(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static off_t	http_seek(struct open_file *f, off_t offset, int where);
+static int	http_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops	http_fsops = {
+	"httpfs",
+	http_open,
+	http_close,
+	http_read,
+	http_write,
+	http_seek,
+	http_stat,
+	null_readdir
+};
+
+/* http server name. It is set if rootpath option was in DHCP reply */
+char		servername[256] = {0};
+
+void
+handle_cleanup(PXE_HTTP_HANDLE *httpfile)
+{
+	if (httpfile == NULL)
+		return;
+		
+	if (httpfile->buf != NULL)
+		free(httpfile->buf);
+
+	if (httpfile->filename != NULL)
+		free(httpfile->filename);
+
+	if ( (httpfile->servername != NULL) &&
+	     (!servername[0]) )
+		free(httpfile->servername);
+
+	if (httpfile->socket != -1)
+		pxe_close(httpfile->socket);
+	
+	free(httpfile);
+}
+
+static int 
+http_open(const char *path, struct open_file *f)
+{
+#ifdef PXE_HTTP_DEBUG
+	printf("http_open(): %s\n", path);
+#endif
+	PXE_HTTP_HANDLE *httpfile =
+	    (PXE_HTTP_HANDLE *)malloc(sizeof(PXE_HTTP_HANDLE));
+	
+	if (httpfile == NULL)
+		return (ENOMEM);
+
+	pxe_memset(httpfile, 0, sizeof(PXE_HTTP_HANDLE));
+
+	httpfile->offset = 0;
+	httpfile->socket = -1;
+	
+        httpfile->filename = strdup(path);
+	
+	if (httpfile->filename == NULL) {
+		handle_cleanup(httpfile);
+                return (ENOMEM);
+        }
+
+	pxe_memcpy(pxe_get_ip(PXE_IP_WWW), &httpfile->addr, sizeof(PXE_IPADDR));
+	
+	if (servername[0]) {
+		httpfile->servername = servername;
+	} else {
+		httpfile->servername = strdup(inet_ntoa(httpfile->addr.ip));
+	}
+
+#ifdef PXE_DEBUG_HELL	
+	printf("servername: %s\n", httpfile->servername);
+#endif
+	if (httpfile->servername == NULL) {
+		handle_cleanup(httpfile);
+	}
+
+	httpfile->buf = malloc(PXE_MAX_HTTP_HDRLEN);
+	
+	if (httpfile->buf == NULL) {
+		handle_cleanup(httpfile);
+		return (ENOMEM);
+	}
+	
+	httpfile->bufsize = PXE_MAX_HTTP_HDRLEN;
+	
+        if (!pxe_exists(httpfile)) {
+		handle_cleanup(httpfile);
+                return (EEXIST);
+        }
+
+        f->f_fsdata = (void *) httpfile;
+
+#ifdef PXE_HTTP_DEBUG
+	printf("http_open(): %s opened\n", httpfile->filename);
+#endif
+
+	return (0);
+}
+
+static int 
+http_read(struct open_file *f, void *addr, size_t size, size_t *resid)
+{
+	PXE_HTTP_HANDLE *httpfile = (PXE_HTTP_HANDLE *) f->f_fsdata;
+	int		result = -1;
+		
+	if (httpfile == NULL) {
+		printf("http_read(): NULL file descriptor.\n");
+		return (EINVAL);
+	}
+	
+#ifdef PXE_HTTP_DEBUG_HELL
+	printf("http_read(): %s:%llu+%lu\n",
+	    httpfile->filename, httpfile->offset, size);
+#endif
+	if (((httpfile->size != PXE_HTTP_SIZE_UNKNOWN) &&
+	     (httpfile->offset >= httpfile->size)) ||
+	     (size == 0))
+	{
+	    if (resid)
+		*resid = size;
+#ifdef PXE_HTTP_DEBUG_HELL
+	    printf("http_read(): EOF\n");
+#endif
+	    return (0);
+	}
+	
+	size_t to_read = (httpfile->offset + size < httpfile->size) ?
+			    size: httpfile->size - (size_t)httpfile->offset;
+
+#ifndef PXE_HTTPFS_CACHING
+	result = pxe_get(httpfile, to_read, addr);
+#else
+	void	*addr2 = addr;
+	int	part1 = -1;
+	
+	if (httpfile->cache_size < to_read) {
+
+		/* read all we have in buffer */
+		if (httpfile->cache_size != 0) {
+			part1 = pxe_recv(httpfile->socket, addr2,
+				    httpfile->cache_size, PXE_SOCK_BLOCKING);
+#ifdef PXE_HTTP_DEBUG_HELL			
+			printf("http_read(): cache -> %ld/%lu/%lu/%u bytes\n",
+			    part1, to_read, size, httpfile->cache_size);
+#endif
+		}
+
+		if (part1 != -1) {
+			to_read -= part1;
+			addr2 += part1;
+			httpfile->cache_size -= part1;
+		}
+		
+		/* update cache. If auto keep-alive, then skip socket check */
+		PXE_BUFFER *buf = NULL;
+		
+#ifndef PXE_HTTP_AUTO_KEEPALIVE
+		if (httpfile->socket != -1) {
+
+			PXE_BUFFER *buf =
+				    pxe_sock_recv_buffer(httpfile->socket);
+#endif			
+			size_t to_get = httpfile->size - httpfile->offset -
+					((part1 != -1) ? part1 : 0 );
+			
+			if (buf != NULL) {
+				if (to_get > buf->bufsize / 2)
+					to_get = buf->bufsize / 2;
+			} else {
+				if (to_get > PXE_DEFAULT_RECV_BUFSIZE / 2)
+					to_get = PXE_DEFAULT_RECV_BUFSIZE / 2;
+			}
+
+#ifdef PXE_HTTP_DEBUG_HELL
+			printf("http_read(): cache <- %lu bytes\n", to_get);
+#endif			
+			/* if none keep-alive connection, then connection
+			 * is already closed, but we used socket recv buffer
+			 * to store cache data till now. Now, closing socket.
+			 */
+			if ( (httpfile->isKeepAlive == 0) &&
+			     (httpfile->socket != -1) )
+				pxe_close(httpfile->socket);
+				
+			pxe_get(httpfile, to_get, NULL);
+#ifndef PXE_HTTP_AUTO_KEEPALIVE
+		}
+#endif
+	}
+	
+	/* try reading of cache */
+	if (httpfile->cache_size < to_read) {
+		printf("http_read(): read of cache failed\n");
+		return (EINVAL);
+	}
+	
+	result = pxe_recv(httpfile->socket, addr2, to_read, PXE_SOCK_BLOCKING);
+#ifdef PXE_HTTP_DEBUG_HELL
+	printf("http_read(): cache > %ld/%lu/%lu/%u bytes\n",
+	    result, to_read, size, httpfile->cache_size);
+#endif	
+	if (result != -1) {
+		httpfile->cache_size -= to_read;
+		result += (part1 != -1) ? part1 : 0;
+	} else 
+		result = part1;
+
+#endif
+	if (result == -1) {
+		printf("http_read(): failed to read\n");
+		return (EINVAL);
+	}
+
+	httpfile->offset += result;
+
+/* #ifdef PXE_HTTP_DEBUG */
+	if (httpfile->size != PXE_HTTP_SIZE_UNKNOWN)
+		printf("%3llu%%\b\b\b\b",
+		    100LL * httpfile->offset / httpfile->size);
+	else
+		printf("http_read(): %llu byte(s) read\n", httpfile->offset);
+/* #endif */
+	if (resid)
+		*resid = size - result;
+
+	return (0);
+}
+
+static int 
+http_close(struct open_file *f)
+{
+	PXE_HTTP_HANDLE *httpfile = (PXE_HTTP_HANDLE *) f->f_fsdata;
+
+#ifdef PXE_HTTP_DEBUG
+	printf("http_close(): closing file %s\n", httpfile->filename);
+#endif
+	handle_cleanup(httpfile);
+	
+	return (0);
+}
+
+static int 
+http_write(struct open_file *f,	void *start, size_t size, size_t *resid)
+{
+	/* cannot write */
+	return (EROFS);
+}
+
+static int 
+http_stat(struct open_file *f, struct stat *sb)
+{
+	PXE_HTTP_HANDLE *httpfile = (PXE_HTTP_HANDLE *) f->f_fsdata;
+	
+#ifdef PXE_HTTP_DEBUG
+	printf("http_stat(): stat for file %s\n", httpfile->filename);
+#endif
+	sb->st_mode = 0444 | S_IFREG;
+	sb->st_nlink = 1;
+	sb->st_uid = 0;
+	sb->st_gid = 0;
+
+	sb->st_size = (httpfile != NULL) ? httpfile->size : -1;
+	
+	return (0);
+}
+
+static off_t 
+http_seek(struct open_file *f, off_t offset, int where)
+{
+	PXE_HTTP_HANDLE *httpfile = (PXE_HTTP_HANDLE *) f->f_fsdata;
+	
+#ifdef PXE_HTTP_DEBUG
+	printf("http_seek(): file 0x%x\n", httpfile);
+#endif
+
+	if (httpfile == NULL) {	/* to be sure */
+		errno = EINVAL;
+		return (-1);
+	}
+	
+	switch (where) {
+	case SEEK_SET:
+		httpfile->offset = offset;
+		break;
+		
+	case SEEK_CUR:
+		httpfile->offset += offset;
+		break;
+		
+	default:
+		errno = EOFFSET;
+		return (-1);
+	}
+#ifdef PXE_HTTPFS_CACHING
+	/* if we seeked somewhere, cache failed, need clean it */
+	pxe_recv(httpfile->socket, httpfile->cache_size, NULL, PXE_SOCK_BLOCKING);
+	httpfile->cache_size = 0;
+#endif
+	return (httpfile->offset);
+}
diff -ruN sys/boot/i386/pxe_ng/httpfs.h sys/boot/i386/pxe_ng/httpfs.h
--- sys/boot/i386/pxe_ng/httpfs.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/httpfs.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,39 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTPFS_INCLUDED
+#define HTTPFS_INCLUDED
+
+/* 
+ * Implements httpfs - illusion of filesystem through http
+ */
+ 
+#include <stand.h>
+
+extern struct fs_ops http_fsops;
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/libi386/Makefile sys/boot/i386/pxe_ng/libi386/Makefile
--- sys/boot/i386/pxe_ng/libi386/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/Makefile	2009-03-02 21:12:03.000000000 -0500
@@ -0,0 +1,64 @@
+# $FreeBSD: src/sys/boot/i386/libi386/Makefile,v 1.43 2007/10/12 17:09:43 ps Exp $
+#
+LIB=			i386
+INTERNALLIB=
+
+SRCS=	biosacpi.c bioscd.c biosdisk.c biosmem.c biospnp.c \
+	biospci.c biossmap.c bootinfo.c bootinfo32.c bootinfo64.c \
+	comconsole.c devicename.c elf32_freebsd.c \
+	elf64_freebsd.c \
+	i386_copy.c i386_module.c nullconsole.c pxe.c pxetramp.s \
+	smbios.c time.c vidconsole.c amd64_tramp.S
+
+# Enable PXE TFTP or NFS support, not both.
+.if defined(LOADER_TFTP_SUPPORT)
+CFLAGS+=	-DLOADER_TFTP_SUPPORT
+.else
+CFLAGS+=	-DLOADER_NFS_SUPPORT
+.endif
+
+BOOT_COMCONSOLE_PORT?= 0x3f8
+CFLAGS+=	-DCOMPORT=${BOOT_COMCONSOLE_PORT}
+
+BOOT_COMCONSOLE_SPEED?= 9600
+CFLAGS+=	-DCOMSPEED=${BOOT_COMCONSOLE_SPEED}
+
+.ifdef(BOOT_BIOSDISK_DEBUG)
+# Make the disk code more talkative
+CFLAGS+= -DDISK_DEBUG
+.endif
+
+.if !defined(BOOT_HIDE_SERIAL_NUMBERS)
+# Export serial numbers, UUID, and asset tag from loader.
+CFLAGS+= -DSMBIOS_SERIAL_NUMBERS
+.endif
+
+# Include simple terminal emulation (cons25-compatible)
+CFLAGS+= -DTERM_EMU
+
+# Enable PXE debugging
+CDLAGS+= -DPXE_DEBUG
+
+# Allow pxe_http perform udpread/udpwrite
+CFLAGS+= -DPXEHTTP_UDP_FOR_LIBSTAND
+
+# XXX: make alloca() useable
+CFLAGS+= -Dalloca=__builtin_alloca
+
+CFLAGS+=	-I${.CURDIR}/../../../common -I${.CURDIR}/../../btx/lib \
+		-I${.CURDIR}/../../../../contrib/dev/acpica \
+		-I${.CURDIR}/../../../.. -I. -I${.CURDIR}/../../pxe_ng/
+# the location of libstand
+CFLAGS+=	-I${.CURDIR}/../../../../../lib/libstand/
+
+.if ${MACHINE_ARCH} == "amd64"
+CLEANFILES+=	machine
+machine:
+	ln -sf ${.CURDIR}/../../../../i386/include machine
+.endif
+
+.include <bsd.lib.mk>
+
+.if ${MACHINE_ARCH} == "amd64"
+beforedepend ${OBJS}: machine
+.endif
diff -ruN sys/boot/i386/pxe_ng/libi386/amd64_tramp.S sys/boot/i386/pxe_ng/libi386/amd64_tramp.S
--- sys/boot/i386/pxe_ng/libi386/amd64_tramp.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/amd64_tramp.S	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,113 @@
+/*-
+ * Copyright (c) 2003  Peter Wemm <peter@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * Quick and dirty trampoline to get into 64 bit (long) mode and running
+ * with paging enabled so that we enter the kernel at its linked address.
+ */
+#define MSR_EFER	0xc0000080
+#define EFER_LME	0x00000100
+#define CR4_PAE		0x00000020
+#define CR4_PSE		0x00000010
+#define CR0_PG		0x80000000
+
+/* GRRR. Deal with BTX that links us for a non-zero location */
+#define VPBASE	0xa000
+#define VTOP(x)	((x) + VPBASE)
+
+	.data
+
+	.p2align 12,0x40
+
+	.globl	PT4
+PT4:
+	.space	0x1000
+	.globl	PT3
+PT3:
+	.space	0x1000
+	.globl	PT2
+PT2:
+	.space	0x1000
+
+gdtdesc:
+	.word	gdtend - gdt
+	.long	VTOP(gdt)		# low
+	.long	0			# high
+
+gdt:
+	.long	0			# null descriptor
+	.long	0
+	.long	0x00000000		# %cs
+	.long	0x00209800
+	.long	0x00000000		# %ds
+	.long	0x00008000
+gdtend:
+	
+	.text
+	.code32
+
+	.globl	amd64_tramp
+amd64_tramp:
+	/* Be sure that interrupts are disabled */
+	cli
+
+	/* Turn on EFER.LME */
+	movl	$MSR_EFER, %ecx
+	rdmsr
+	orl	$EFER_LME, %eax
+	wrmsr
+
+	/* Turn on PAE */
+	movl	%cr4, %eax
+	orl	$(CR4_PAE | CR4_PSE), %eax
+	movl	%eax, %cr4
+
+	/* Set %cr3 for PT4 */
+	movl	$VTOP(PT4), %eax
+	movl	%eax, %cr3
+
+	/* Turn on paging (implicitly sets EFER.LMA) */
+	movl	%cr0, %eax
+	orl	$CR0_PG, %eax
+	movl	%eax, %cr0
+	
+	/* Now we're in compatability mode. set %cs for long mode */
+	movl	$VTOP(gdtdesc), %eax
+	movl	VTOP(entry_hi), %esi
+	movl	VTOP(entry_lo), %edi
+	lgdt	(%eax)
+	ljmp	$0x8, $VTOP(longmode)
+
+	.code64
+longmode:
+	/* We're still running V=P, jump to entry point */
+	movl	%esi, %eax
+	salq	$32, %rax
+	orq	%rdi, %rax
+	pushq	%rax
+	ret
diff -ruN sys/boot/i386/pxe_ng/libi386/biosacpi.c sys/boot/i386/pxe_ng/libi386/biosacpi.c
--- sys/boot/i386/pxe_ng/libi386/biosacpi.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biosacpi.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,136 @@
+/*-
+ * Copyright (c) 2001 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <machine/stdarg.h>
+#include <bootstrap.h>
+#include <btxv86.h>
+#include "libi386.h"
+
+#include "acfreebsd.h"
+#include "acconfig.h"
+#define ACPI_SYSTEM_XFACE
+#include "actypes.h"
+#include "actbl.h"
+
+/*
+ * Detect ACPI and export information about the APCI BIOS into the
+ * environment.
+ */
+
+static ACPI_TABLE_RSDP	*biosacpi_find_rsdp(void);
+static ACPI_TABLE_RSDP	*biosacpi_search_rsdp(char *base, int length);
+
+#define RSDP_CHECKSUM_LENGTH 20
+
+void
+biosacpi_detect(void)
+{
+    ACPI_TABLE_RSDP	*rsdp;
+    char		buf[24];
+    int			revision;
+
+    /* XXX check the BIOS datestamp */
+
+    /* locate and validate the RSDP */
+    if ((rsdp = biosacpi_find_rsdp()) == NULL)
+	return;
+
+    /* export values from the RSDP */
+    sprintf(buf, "%p", VTOP(rsdp));
+    setenv("hint.acpi.0.rsdp", buf, 1);
+    revision = rsdp->Revision;
+    if (revision == 0)
+	revision = 1;
+    sprintf(buf, "%d", revision);
+    setenv("hint.acpi.0.revision", buf, 1);
+    strncpy(buf, rsdp->OemId, sizeof(rsdp->OemId));
+    buf[sizeof(rsdp->OemId)] = '\0';
+    setenv("hint.acpi.0.oem", buf, 1);
+    sprintf(buf, "0x%08x", rsdp->RsdtPhysicalAddress);
+    setenv("hint.acpi.0.rsdt", buf, 1);
+    if (revision >= 2) {
+	/* XXX extended checksum? */
+	sprintf(buf, "0x%016llx", rsdp->XsdtPhysicalAddress);
+	setenv("hint.acpi.0.xsdt", buf, 1);
+	sprintf(buf, "%d", rsdp->Length);
+	setenv("hint.acpi.0.xsdt_length", buf, 1);
+    }
+    /* XXX other tables? */
+
+    setenv("acpi_load", "YES", 1);
+}
+
+/*
+ * Find the RSDP in low memory.  See section 5.2.2 of the ACPI spec.
+ */
+static ACPI_TABLE_RSDP *
+biosacpi_find_rsdp(void)
+{
+    ACPI_TABLE_RSDP	*rsdp;
+    uint16_t		*addr;
+
+    /* EBDA is the 1 KB addressed by the 16 bit pointer at 0x40E. */
+    addr = (uint16_t *)PTOV(0x40E);
+    if ((rsdp = biosacpi_search_rsdp((char *)(*addr << 4), 0x400)) != NULL)
+	return (rsdp);
+
+    /* Check the upper memory BIOS space, 0xe0000 - 0xfffff. */
+    if ((rsdp = biosacpi_search_rsdp((char *)0xe0000, 0x20000)) != NULL)
+	return (rsdp);
+
+    return (NULL);
+}
+
+static ACPI_TABLE_RSDP *
+biosacpi_search_rsdp(char *base, int length)
+{
+    ACPI_TABLE_RSDP	*rsdp;
+    u_int8_t		*cp, sum;
+    int			ofs, idx;
+
+    /* search on 16-byte boundaries */
+    for (ofs = 0; ofs < length; ofs += 16) {
+	rsdp = (ACPI_TABLE_RSDP *)PTOV(base + ofs);
+
+	/* compare signature, validate checksum */
+	if (!strncmp(rsdp->Signature, ACPI_SIG_RSDP, strlen(ACPI_SIG_RSDP))) {
+	    cp = (u_int8_t *)rsdp;
+	    sum = 0;
+	    for (idx = 0; idx < RSDP_CHECKSUM_LENGTH; idx++)
+		sum += *(cp + idx);
+	    if (sum != 0) {
+		printf("acpi: bad RSDP checksum (%d)\n", sum);
+		continue;
+	    }
+	    return(rsdp);
+	}
+    }
+    return(NULL);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/bioscd.c sys/boot/i386/pxe_ng/libi386/bioscd.c
--- sys/boot/i386/pxe_ng/libi386/bioscd.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/bioscd.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,356 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * Copyright (c) 2001 John H. Baldwin <jhb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * BIOS CD device handling for CD's that have been booted off of via no
+ * emulation booting as defined in the El Torito standard.
+ * 
+ * Ideas and algorithms from:
+ *
+ * - FreeBSD libi386/biosdisk.c
+ *
+ */
+
+#include <stand.h>
+
+#include <sys/param.h>
+#include <machine/bootinfo.h>
+#include <machine/psl.h>
+
+#include <stdarg.h>
+
+#include <bootstrap.h>
+#include <btxv86.h>
+#include "libi386.h"
+
+#define BIOSCD_SECSIZE		2048
+#define BUFSIZE			(1 * BIOSCD_SECSIZE)
+#define	MAXBCDEV		1
+
+/* Major numbers for devices we frontend for. */
+#define ACDMAJOR		117
+#define	CDMAJOR			15
+
+#ifdef DISK_DEBUG
+# define DEBUG(fmt, args...)	printf("%s: " fmt "\n" , __func__ , ## args)
+#else
+# define DEBUG(fmt, args...)
+#endif
+
+struct specification_packet {
+	u_char	sp_size;
+	u_char	sp_bootmedia;
+	u_char	sp_drive;
+	u_char	sp_controller;
+	u_int	sp_lba;
+	u_short	sp_devicespec;
+	u_short	sp_buffersegment;
+	u_short	sp_loadsegment;
+	u_short	sp_sectorcount;
+	u_short	sp_cylsec;
+	u_char	sp_head;
+};
+
+/*
+ * List of BIOS devices, translation from disk unit number to
+ * BIOS unit number.
+ */
+static struct bcinfo {
+	int	bc_unit;		/* BIOS unit number */
+	struct specification_packet bc_sp;
+} bcinfo [MAXBCDEV];
+static int nbcinfo = 0;
+
+static int	bc_read(int unit, daddr_t dblk, int blks, caddr_t dest);
+static int	bc_init(void);
+static int	bc_strategy(void *devdata, int flag, daddr_t dblk,
+		    size_t size, char *buf, size_t *rsize);
+static int	bc_open(struct open_file *f, ...);
+static int	bc_close(struct open_file *f);
+static void	bc_print(int verbose);
+
+struct devsw bioscd = {
+	"cd", 
+	DEVT_CD, 
+	bc_init,
+	bc_strategy, 
+	bc_open, 
+	bc_close, 
+	noioctl,
+	bc_print,
+	NULL
+};
+
+/*
+ * Translate between BIOS device numbers and our private unit numbers.
+ */
+int
+bc_bios2unit(int biosdev)
+{
+	int i;
+    
+	DEBUG("looking for bios device 0x%x", biosdev);
+	for (i = 0; i < nbcinfo; i++) {
+		DEBUG("bc unit %d is BIOS device 0x%x", i, bcinfo[i].bc_unit);
+		if (bcinfo[i].bc_unit == biosdev)
+			return(i);
+	}
+	return(-1);
+}
+
+int
+bc_unit2bios(int unit)
+{
+	if ((unit >= 0) && (unit < nbcinfo))
+		return(bcinfo[unit].bc_unit);
+	return(-1);
+}
+
+/*    
+ * We can't quiz, we have to be told what device to use, so this functoin
+ * doesn't do anything.  Instead, the loader calls bc_add() with the BIOS
+ * device number to add.
+ */
+static int
+bc_init(void) 
+{
+
+	return (0);
+}
+
+int
+bc_add(int biosdev)
+{
+
+	if (nbcinfo >= MAXBCDEV)
+		return (-1);
+	bcinfo[nbcinfo].bc_unit = biosdev;
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x13;
+	v86.eax = 0x4b01;
+	v86.edx = biosdev;
+	v86.ds = VTOPSEG(&bcinfo[nbcinfo].bc_sp);
+	v86.esi = VTOPOFF(&bcinfo[nbcinfo].bc_sp);
+	v86int();
+	if ((v86.eax & 0xff00) != 0)
+		return (-1);
+
+	printf("BIOS CD is cd%d\n", nbcinfo);
+	nbcinfo++;
+	return(0);
+}
+
+/*
+ * Print information about disks
+ */
+static void
+bc_print(int verbose)
+{
+	int i;
+	char line[80];
+    
+	for (i = 0; i < nbcinfo; i++) {
+		sprintf(line, "    cd%d: Device 0x%x\n", i,
+		    bcinfo[i].bc_sp.sp_devicespec);
+		pager_output(line);
+	}
+}
+
+/*
+ * Attempt to open the disk described by (dev) for use by (f).
+ */
+static int 
+bc_open(struct open_file *f, ...)
+{
+	va_list ap;
+	struct i386_devdesc *dev;
+
+	va_start(ap, f);
+	dev = va_arg(ap, struct i386_devdesc *);
+	va_end(ap);
+	if (dev->d_unit >= nbcinfo) {
+		DEBUG("attempt to open nonexistent disk");
+		return(ENXIO);
+	}
+
+	return(0);
+}
+ 
+static int 
+bc_close(struct open_file *f)
+{
+
+	return(0);
+}
+
+static int 
+bc_strategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf,
+    size_t *rsize)
+{
+	struct i386_devdesc *dev;
+	int unit;
+	int blks;
+#ifdef BD_SUPPORT_FRAGS
+	char fragbuf[BIOSCD_SECSIZE];
+	size_t fragsize;
+
+	fragsize = size % BIOSCD_SECSIZE;
+#else
+	if (size % BIOSCD_SECSIZE)
+		return (EINVAL);
+#endif
+
+	if (rw != F_READ)
+		return(EROFS);
+	dev = (struct i386_devdesc *)devdata;
+	unit = dev->d_unit;
+	blks = size / BIOSCD_SECSIZE;
+	if (dblk % (BIOSCD_SECSIZE / DEV_BSIZE) != 0)
+		return (EINVAL);
+	dblk /= (BIOSCD_SECSIZE / DEV_BSIZE);
+	DEBUG("read %d from %d to %p", blks, dblk, buf);
+
+	if (rsize)
+		*rsize = 0;
+	if (blks && bc_read(unit, dblk, blks, buf)) {
+		DEBUG("read error");
+		return (EIO);
+	}
+#ifdef BD_SUPPORT_FRAGS
+	DEBUG("bc_strategy: frag read %d from %d+%d to %p", 
+	    fragsize, dblk, blks, buf + (blks * BIOSCD_SECSIZE));
+	if (fragsize && bc_read(unit, dblk + blks, 1, fragsize)) {
+		DEBUG("frag read error");
+		return(EIO);
+	}
+	bcopy(fragbuf, buf + (blks * BIOSCD_SECSIZE), fragsize);
+#endif	
+	if (rsize)
+		*rsize = size;
+	return (0);
+}
+
+static int
+bc_read(int unit, daddr_t dblk, int blks, caddr_t dest)
+{
+	u_int result, retry;
+	static unsigned short packet[8];
+	int biosdev;
+#ifdef DISK_DEBUG
+	int error;
+#endif
+    
+	/* Just in case some idiot actually tries to read -1 blocks... */
+	if (blks < 0)
+		return (-1);
+
+	/* If nothing to do, just return succcess. */
+	if (blks == 0)
+		return (0);
+
+	biosdev = bc_unit2bios(unit);
+	/*
+	 * Loop retrying the operation a couple of times.  The BIOS
+	 * may also retry.
+	 */
+	for (retry = 0; retry < 3; retry++) {
+		/* If retrying, reset the drive */
+		if (retry > 0) {
+			v86.ctl = V86_FLAGS;
+			v86.addr = 0x13;
+			v86.eax = 0;
+			v86.edx = biosdev;
+			v86int();
+		}
+	    
+		packet[0] = 0x10;
+		packet[1] = blks;
+		packet[2] = VTOPOFF(dest);
+		packet[3] = VTOPSEG(dest);
+		packet[4] = dblk & 0xffff;
+		packet[5] = dblk >> 16;
+		packet[6] = 0;
+		packet[7] = 0;
+		v86.ctl = V86_FLAGS;
+		v86.addr = 0x13;
+		v86.eax = 0x4200;
+		v86.edx = biosdev;
+		v86.ds = VTOPSEG(packet);
+		v86.esi = VTOPOFF(packet);
+		v86int();
+		result = (v86.efl & PSL_C);
+		if (result == 0)
+			break;
+	}
+	
+#ifdef DISK_DEBUG
+	error = (v86.eax >> 8) & 0xff;
+#endif
+	DEBUG("%d sectors from %ld to %p (0x%x) %s", blks, dblk, dest,
+	    VTOP(dest), result ? "failed" : "ok");
+	DEBUG("unit %d  status 0x%x",  unit, error);
+	
+/*	hexdump(dest, (blks * BIOSCD_SECSIZE)); */
+	return(0);
+}
+
+/*
+ * Return a suitable dev_t value for (dev).
+ */
+int
+bc_getdev(struct i386_devdesc *dev)
+{
+    int biosdev, unit;
+    int major;
+    int rootdev;
+
+    unit = dev->d_unit;
+    biosdev = bc_unit2bios(unit);
+    DEBUG("unit %d BIOS device %d", unit, biosdev);
+    if (biosdev == -1)				/* not a BIOS device */
+	return(-1);
+
+    /*
+     * XXX: Need to examine device spec here to figure out if SCSI or
+     * ATAPI.  No idea on how to figure out device number.  All we can
+     * really pass to the kernel is what bus and device on which bus we
+     * were booted from, which dev_t isn't well suited to since those
+     * number don't match to unit numbers very well.  We may just need
+     * to engage in a hack where we pass -C to the boot args if we are
+     * the boot device.
+     */
+    major = ACDMAJOR;
+    unit = 0;	/* XXX */
+
+    /* XXX: Assume partition 'a'. */
+    rootdev = MAKEBOOTDEV(major, 0, unit, 0);
+    DEBUG("dev is 0x%x\n", rootdev);
+    return(rootdev);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/biosdisk.c sys/boot/i386/pxe_ng/libi386/biosdisk.c
--- sys/boot/i386/pxe_ng/libi386/biosdisk.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biosdisk.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,1409 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * BIOS disk device handling.
+ * 
+ * Ideas and algorithms from:
+ *
+ * - NetBSD libi386/biosdisk.c
+ * - FreeBSD biosboot/disk.c
+ *
+ */
+
+#include <stand.h>
+
+#include <sys/disklabel.h>
+#include <sys/diskmbr.h>
+#include <sys/gpt.h>
+#include <machine/bootinfo.h>
+
+#include <stdarg.h>
+#include <uuid.h>
+
+#include <bootstrap.h>
+#include <btxv86.h>
+#include "libi386.h"
+
+#define BIOS_NUMDRIVES		0x475
+#define BIOSDISK_SECSIZE	512
+#define BUFSIZE			(1 * BIOSDISK_SECSIZE)
+#define	MAXBDDEV		MAXDEV
+
+#define DT_ATAPI		0x10		/* disk type for ATAPI floppies */
+#define WDMAJOR			0		/* major numbers for devices we frontend for */
+#define WFDMAJOR		1
+#define FDMAJOR			2
+#define DAMAJOR			4
+
+#ifdef DISK_DEBUG
+# define DEBUG(fmt, args...)	printf("%s: " fmt "\n" , __func__ , ## args)
+#else
+# define DEBUG(fmt, args...)
+#endif
+
+struct gpt_part {
+    int		gp_index;
+    uuid_t	gp_type;
+    uint64_t	gp_start;
+    uint64_t	gp_end;
+};
+
+struct open_disk {
+    int			od_dkunit;		/* disk unit number */
+    int			od_unit;		/* BIOS unit number */
+    int			od_cyl;			/* BIOS geometry */
+    int			od_hds;
+    int			od_sec;
+    int			od_boff;		/* block offset from beginning of BIOS disk */
+    int			od_flags;
+#define BD_MODEINT13		0x0000
+#define BD_MODEEDD1		0x0001
+#define BD_MODEEDD3		0x0002
+#define BD_MODEMASK		0x0003
+#define BD_FLOPPY		0x0004
+#define BD_LABELOK		0x0008
+#define BD_PARTTABOK		0x0010
+#define	BD_GPTOK		0x0020
+    union {
+	struct {
+	    struct disklabel		mbr_disklabel;
+	    int				mbr_nslices;	/* slice count */
+	    struct dos_partition	mbr_slicetab[NEXTDOSPART];
+	} _mbr;
+	struct {
+	    int				gpt_nparts;		
+	    struct gpt_part		*gpt_partitions;
+	} _gpt;
+    } _data;
+};
+
+#define	od_disklabel		_data._mbr.mbr_disklabel
+#define	od_nslices		_data._mbr.mbr_nslices
+#define	od_slicetab		_data._mbr.mbr_slicetab
+#define	od_nparts		_data._gpt.gpt_nparts
+#define	od_partitions		_data._gpt.gpt_partitions
+
+/*
+ * List of BIOS devices, translation from disk unit number to
+ * BIOS unit number.
+ */
+static struct bdinfo
+{
+    int		bd_unit;		/* BIOS unit number */
+    int		bd_flags;
+    int		bd_type;		/* BIOS 'drive type' (floppy only) */
+} bdinfo [MAXBDDEV];
+static int nbdinfo = 0;
+
+static int	bd_getgeom(struct open_disk *od);
+static int	bd_read(struct open_disk *od, daddr_t dblk, int blks,
+		    caddr_t dest);
+static int	bd_write(struct open_disk *od, daddr_t dblk, int blks,
+		    caddr_t dest);
+
+static int	bd_int13probe(struct bdinfo *bd);
+
+static void	bd_printgptpart(struct open_disk *od, struct gpt_part *gp,
+		    char *prefix, int verbose);
+static void	bd_printslice(struct open_disk *od, struct dos_partition *dp,
+		    char *prefix, int verbose);
+static void	bd_printbsdslice(struct open_disk *od, daddr_t offset,
+		    char *prefix, int verbose);
+
+static int	bd_init(void);
+static int	bd_strategy(void *devdata, int flag, daddr_t dblk,
+		    size_t size, char *buf, size_t *rsize);
+static int	bd_realstrategy(void *devdata, int flag, daddr_t dblk,
+		    size_t size, char *buf, size_t *rsize);
+static int	bd_open(struct open_file *f, ...);
+static int	bd_close(struct open_file *f);
+static void	bd_print(int verbose);
+
+struct devsw biosdisk = {
+    "disk", 
+    DEVT_DISK, 
+    bd_init,
+    bd_strategy, 
+    bd_open, 
+    bd_close, 
+    noioctl,
+    bd_print,
+    NULL
+};
+
+static int	bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev);
+static void	bd_closedisk(struct open_disk *od);
+static int	bd_open_mbr(struct open_disk *od, struct i386_devdesc *dev);
+static int	bd_bestslice(struct open_disk *od);
+static void	bd_checkextended(struct open_disk *od, int slicenum);
+static int	bd_open_gpt(struct open_disk *od, struct i386_devdesc *dev);
+static struct gpt_part *bd_best_gptpart(struct open_disk *od);
+
+/*
+ * Translate between BIOS device numbers and our private unit numbers.
+ */
+int
+bd_bios2unit(int biosdev)
+{
+    int		i;
+    
+    DEBUG("looking for bios device 0x%x", biosdev);
+    for (i = 0; i < nbdinfo; i++) {
+	DEBUG("bd unit %d is BIOS device 0x%x", i, bdinfo[i].bd_unit);
+	if (bdinfo[i].bd_unit == biosdev)
+	    return(i);
+    }
+    return(-1);
+}
+
+int
+bd_unit2bios(int unit)
+{
+    if ((unit >= 0) && (unit < nbdinfo))
+	return(bdinfo[unit].bd_unit);
+    return(-1);
+}
+
+/*    
+ * Quiz the BIOS for disk devices, save a little info about them.
+ */
+static int
+bd_init(void) 
+{
+    int		base, unit, nfd = 0;
+
+    /* sequence 0, 0x80 */
+    for (base = 0; base <= 0x80; base += 0x80) {
+	for (unit = base; (nbdinfo < MAXBDDEV); unit++) {
+	    /* check the BIOS equipment list for number of fixed disks */
+	    if((base == 0x80) &&
+	       (nfd >= *(unsigned char *)PTOV(BIOS_NUMDRIVES)))
+	        break;
+
+	    bdinfo[nbdinfo].bd_unit = unit;
+	    bdinfo[nbdinfo].bd_flags = (unit < 0x80) ? BD_FLOPPY : 0;
+
+	    if (!bd_int13probe(&bdinfo[nbdinfo]))
+		break;
+
+	    /* XXX we need "disk aliases" to make this simpler */
+	    printf("BIOS drive %c: is disk%d\n", 
+		   (unit < 0x80) ? ('A' + unit) : ('C' + unit - 0x80), nbdinfo);
+	    nbdinfo++;
+	    if (base == 0x80)
+	        nfd++;
+	}
+    }
+    return(0);
+}
+
+/*
+ * Try to detect a device supported by the legacy int13 BIOS
+ */
+static int
+bd_int13probe(struct bdinfo *bd)
+{
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x13;
+    v86.eax = 0x800;
+    v86.edx = bd->bd_unit;
+    v86int();
+    
+    if (!(v86.efl & 0x1) &&				/* carry clear */
+	((v86.edx & 0xff) > ((unsigned)bd->bd_unit & 0x7f))) {	/* unit # OK */
+	if ((v86.ecx & 0x3f) == 0) {			/* absurd sector size */
+		DEBUG("Invalid geometry for unit %d", bd->bd_unit);
+		return(0);				/* skip device */
+	}
+	bd->bd_flags |= BD_MODEINT13;
+	bd->bd_type = v86.ebx & 0xff;
+
+	/* Determine if we can use EDD with this device. */
+	v86.eax = 0x4100;
+	v86.edx = bd->bd_unit;
+	v86.ebx = 0x55aa;
+	v86int();
+	if (!(v86.efl & 0x1) &&				/* carry clear */
+	    ((v86.ebx & 0xffff) == 0xaa55) &&		/* signature */
+	    (v86.ecx & 0x1)) {				/* packets mode ok */
+	    bd->bd_flags |= BD_MODEEDD1;
+	    if((v86.eax & 0xff00) >= 0x3000)
+	        bd->bd_flags |= BD_MODEEDD3;
+	}
+	return(1);
+    }
+    return(0);
+}
+
+/*
+ * Print information about disks
+ */
+static void
+bd_print(int verbose)
+{
+    int				i, j;
+    char			line[80];
+    struct i386_devdesc		dev;
+    struct open_disk		*od;
+    struct dos_partition	*dptr;
+    
+    for (i = 0; i < nbdinfo; i++) {
+	sprintf(line, "    disk%d:   BIOS drive %c:\n", i, 
+		(bdinfo[i].bd_unit < 0x80) ? ('A' + bdinfo[i].bd_unit) : ('C' + bdinfo[i].bd_unit - 0x80));
+	pager_output(line);
+
+	/* try to open the whole disk */
+	dev.d_unit = i;
+	dev.d_kind.biosdisk.slice = -1;
+	dev.d_kind.biosdisk.partition = -1;
+	
+	if (!bd_opendisk(&od, &dev)) {
+
+	    /* Do we have a GPT table? */
+	    if (od->od_flags & BD_GPTOK) {
+		for (j = 0; j < od->od_nparts; j++) {
+		    sprintf(line, "      disk%dp%d", i,
+			od->od_partitions[j].gp_index);
+		    bd_printgptpart(od, &od->od_partitions[j], line, verbose);
+		}
+
+	    /* Do we have a partition table? */
+	    } else if (od->od_flags & BD_PARTTABOK) {
+		dptr = &od->od_slicetab[0];
+
+		/* Check for a "dedicated" disk */
+		if ((dptr[3].dp_typ == DOSPTYP_386BSD) &&
+		    (dptr[3].dp_start == 0) &&
+		    (dptr[3].dp_size == 50000)) {
+		    sprintf(line, "      disk%d", i);
+		    bd_printbsdslice(od, 0, line, verbose);
+		} else {
+		    for (j = 0; j < od->od_nslices; j++) {
+		        sprintf(line, "      disk%ds%d", i, j + 1);
+			bd_printslice(od, &dptr[j], line, verbose);
+                    }
+                }
+	    }
+	    bd_closedisk(od);
+	}
+    }
+}
+
+static uuid_t efi = GPT_ENT_TYPE_EFI;
+static uuid_t freebsd_boot = GPT_ENT_TYPE_FREEBSD_BOOT;
+static uuid_t freebsd_ufs = GPT_ENT_TYPE_FREEBSD_UFS;
+static uuid_t freebsd_swap = GPT_ENT_TYPE_FREEBSD_SWAP;
+static uuid_t freebsd_zfs = GPT_ENT_TYPE_FREEBSD_ZFS;
+static uuid_t ms_basic_data = GPT_ENT_TYPE_MS_BASIC_DATA;
+
+static void
+bd_printgptpart(struct open_disk *od, struct gpt_part *gp, char *prefix,
+    int verbose)
+{
+    char stats[80];
+    char line[96];
+    uint64_t size;
+    char unit;
+
+    if (verbose) {
+	size = (gp->gp_end + 1 - gp->gp_start) / 2048;
+	unit = 'M';
+	if (size >= 10240000) {
+	    size /= 1048576;
+	    unit = 'T';
+	} else if (size >= 10000) {
+	    size /= 1024;
+	    unit = 'G';
+	}
+	sprintf(stats, " %.6ld%cB", (long)size, unit);
+    } else
+	stats[0] = '\0';
+
+    if (uuid_equal(&gp->gp_type, &efi, NULL))
+	sprintf(line, "%s: EFI%s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &ms_basic_data, NULL))
+	sprintf(line, "%s: FAT/NTFS%s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &freebsd_boot, NULL))
+	sprintf(line, "%s: FreeBSD boot%s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &freebsd_ufs, NULL))
+	sprintf(line, "%s: FreeBSD UFS%s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &freebsd_zfs, NULL))
+	sprintf(line, "%s: FreeBSD ZFS%s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &freebsd_swap, NULL))
+	sprintf(line, "%s: FreeBSD swap%s\n", prefix, stats);
+    else
+	sprintf(line, "%s: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x%s\n",
+	    gp->gp_type.time_low, gp->gp_type.time_mid,
+	    gp->gp_type.time_hi_and_version,
+	    gp->gp_type.clock_seq_hi_and_reserved, gp->gp_type.clock_seq_low,
+	    gp->gp_type.node[0], gp->gp_type.node[1], gp->gp_type.node[2],
+	    gp->gp_type.node[3], gp->gp_type.node[4], gp->gp_type.node[5],
+	    stats);
+    pager_output(line);
+}
+
+/*
+ * Print information about slices on a disk.  For the size calculations we
+ * assume a 512 byte sector.
+ */
+static void
+bd_printslice(struct open_disk *od, struct dos_partition *dp, char *prefix,
+	int verbose)
+{
+	char line[80];
+
+	switch (dp->dp_typ) {
+	case DOSPTYP_386BSD:
+		bd_printbsdslice(od, (daddr_t)dp->dp_start, prefix, verbose);
+		return;
+	case DOSPTYP_LINSWP:
+		if (verbose)
+			sprintf(line, "%s: Linux swap %.6dMB (%d - %d)\n",
+			    prefix, dp->dp_size / 2048,
+			    dp->dp_start, dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: Linux swap\n", prefix);
+		break;
+	case DOSPTYP_LINUX:
+		/*
+		 * XXX
+		 * read the superblock to confirm this is an ext2fs partition?
+		 */
+		if (verbose)
+			sprintf(line, "%s: ext2fs  %.6dMB (%d - %d)\n", prefix,
+			    dp->dp_size / 2048, dp->dp_start,
+			    dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: ext2fs\n", prefix);
+		break;
+	case 0x00:				/* unused partition */
+	case DOSPTYP_EXT:
+		return;
+	case 0x01:
+		if (verbose)
+			sprintf(line, "%s: FAT-12  %.6dMB (%d - %d)\n", prefix,
+			    dp->dp_size / 2048, dp->dp_start,
+			    dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: FAT-12\n", prefix);
+		break;
+	case 0x04:
+	case 0x06:
+	case 0x0e:
+		if (verbose)
+			sprintf(line, "%s: FAT-16  %.6dMB (%d - %d)\n", prefix,
+			    dp->dp_size / 2048, dp->dp_start,
+			    dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: FAT-16\n", prefix);
+		break;
+	case 0x0b:
+	case 0x0c:
+		if (verbose)
+			sprintf(line, "%s: FAT-32  %.6dMB (%d - %d)\n", prefix,
+			    dp->dp_size / 2048, dp->dp_start,
+			    dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: FAT-32\n", prefix);
+		break;
+	default:
+		if (verbose)
+			sprintf(line, "%s: Unknown fs: 0x%x  %.6dMB (%d - %d)\n",
+			    prefix, dp->dp_typ, dp->dp_size / 2048,
+			    dp->dp_start, dp->dp_start + dp->dp_size);
+		else
+			sprintf(line, "%s: Unknown fs: 0x%x\n", prefix,
+			    dp->dp_typ);
+	}
+	pager_output(line);
+}
+
+/*
+ * Print out each valid partition in the disklabel of a FreeBSD slice.
+ * For size calculations, we assume a 512 byte sector size.
+ */
+static void
+bd_printbsdslice(struct open_disk *od, daddr_t offset, char *prefix,
+    int verbose)
+{
+    char		line[80];
+    char		buf[BIOSDISK_SECSIZE];
+    struct disklabel	*lp;
+    int			i;
+
+    /* read disklabel */
+    if (bd_read(od, offset + LABELSECTOR, 1, buf))
+	return;
+    lp =(struct disklabel *)(&buf[0]);
+    if (lp->d_magic != DISKMAGIC) {
+	sprintf(line, "%s: FFS  bad disklabel\n", prefix);
+	pager_output(line);
+	return;
+    }
+    
+    /* Print partitions */
+    for (i = 0; i < lp->d_npartitions; i++) {
+	/*
+	 * For each partition, make sure we know what type of fs it is.  If
+	 * not, then skip it.  However, since floppies often have bogus
+	 * fstypes, print the 'a' partition on a floppy even if it is marked
+	 * unused.
+	 */
+	if ((lp->d_partitions[i].p_fstype == FS_BSDFFS) ||
+            (lp->d_partitions[i].p_fstype == FS_SWAP) ||
+            (lp->d_partitions[i].p_fstype == FS_VINUM) ||
+	    ((lp->d_partitions[i].p_fstype == FS_UNUSED) && 
+	     (od->od_flags & BD_FLOPPY) && (i == 0))) {
+
+	    /* Only print out statistics in verbose mode */
+	    if (verbose)
+	        sprintf(line, "  %s%c: %s  %.6dMB (%d - %d)\n", prefix, 'a' + i,
+		    (lp->d_partitions[i].p_fstype == FS_SWAP) ? "swap" : 
+		    (lp->d_partitions[i].p_fstype == FS_VINUM) ? "vinum" :
+		    "FFS",
+		    lp->d_partitions[i].p_size / 2048,
+		    lp->d_partitions[i].p_offset,
+		    lp->d_partitions[i].p_offset + lp->d_partitions[i].p_size);
+	    else
+	        sprintf(line, "  %s%c: %s\n", prefix, 'a' + i,
+		    (lp->d_partitions[i].p_fstype == FS_SWAP) ? "swap" : 
+		    (lp->d_partitions[i].p_fstype == FS_VINUM) ? "vinum" :
+		    "FFS");
+	    pager_output(line);
+	}
+    }
+}
+
+
+/*
+ * Attempt to open the disk described by (dev) for use by (f).
+ *
+ * Note that the philosophy here is "give them exactly what
+ * they ask for".  This is necessary because being too "smart"
+ * about what the user might want leads to complications.
+ * (eg. given no slice or partition value, with a disk that is
+ *  sliced - are they after the first BSD slice, or the DOS
+ *  slice before it?)
+ */
+static int 
+bd_open(struct open_file *f, ...)
+{
+    va_list			ap;
+    struct i386_devdesc		*dev;
+    struct open_disk		*od;
+    int				error;
+
+    va_start(ap, f);
+    dev = va_arg(ap, struct i386_devdesc *);
+    va_end(ap);
+    if ((error = bd_opendisk(&od, dev)))
+	return(error);
+    
+    /*
+     * Save our context
+     */
+    ((struct i386_devdesc *)(f->f_devdata))->d_kind.biosdisk.data = od;
+    DEBUG("open_disk %p, partition at 0x%x", od, od->od_boff);
+    return(0);
+}
+
+static int
+bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
+{
+    struct open_disk		*od;
+    int				error;
+
+    if (dev->d_unit >= nbdinfo) {
+	DEBUG("attempt to open nonexistent disk");
+	return(ENXIO);
+    }
+    
+    od = (struct open_disk *)malloc(sizeof(struct open_disk));
+    if (!od) {
+	DEBUG("no memory");
+	return (ENOMEM);
+    }
+
+    /* Look up BIOS unit number, intialise open_disk structure */
+    od->od_dkunit = dev->d_unit;
+    od->od_unit = bdinfo[od->od_dkunit].bd_unit;
+    od->od_flags = bdinfo[od->od_dkunit].bd_flags;
+    od->od_boff = 0;
+    error = 0;
+    DEBUG("open '%s', unit 0x%x slice %d partition %d",
+	     i386_fmtdev(dev), dev->d_unit, 
+	     dev->d_kind.biosdisk.slice, dev->d_kind.biosdisk.partition);
+
+    /* Get geometry for this open (removable device may have changed) */
+    if (bd_getgeom(od)) {
+	DEBUG("can't get geometry");
+	error = ENXIO;
+	goto out;
+    }
+
+    /* Determine disk layout. */
+    error = bd_open_gpt(od, dev);
+    if (error)
+	error = bd_open_mbr(od, dev);
+    
+ out:
+    if (error) {
+	free(od);
+    } else {
+	*odp = od;	/* return the open disk */
+    }
+    return(error);
+}
+
+static int
+bd_open_mbr(struct open_disk *od, struct i386_devdesc *dev)
+{
+    struct dos_partition	*dptr;
+    struct disklabel		*lp;
+    int				sector, slice, i;
+    int				error;
+    char			buf[BUFSIZE];
+
+    /*
+     * Following calculations attempt to determine the correct value
+     * for d->od_boff by looking for the slice and partition specified,
+     * or searching for reasonable defaults.
+     */
+
+    /*
+     * Find the slice in the DOS slice table.
+     */
+    od->od_nslices = 0;
+    if (bd_read(od, 0, 1, buf)) {
+	DEBUG("error reading MBR");
+	return (EIO);
+    }
+
+    /* 
+     * Check the slice table magic.
+     */
+    if (((u_char)buf[0x1fe] != 0x55) || ((u_char)buf[0x1ff] != 0xaa)) {
+	/* If a slice number was explicitly supplied, this is an error */
+	if (dev->d_kind.biosdisk.slice > 0) {
+	    DEBUG("no slice table/MBR (no magic)");
+	    return (ENOENT);
+	}
+	sector = 0;
+	goto unsliced;		/* may be a floppy */
+    }
+
+    /*
+     * copy the partition table, then pick up any extended partitions.
+     */
+    bcopy(buf + DOSPARTOFF, &od->od_slicetab,
+      sizeof(struct dos_partition) * NDOSPART);
+    od->od_nslices = 4;			/* extended slices start here */
+    for (i = 0; i < NDOSPART; i++)
+        bd_checkextended(od, i);
+    od->od_flags |= BD_PARTTABOK;
+    dptr = &od->od_slicetab[0];
+
+    /* Is this a request for the whole disk? */
+    if (dev->d_kind.biosdisk.slice == -1) {
+	sector = 0;
+	goto unsliced;
+    }
+
+    /*
+     * if a slice number was supplied but not found, this is an error.
+     */
+    if (dev->d_kind.biosdisk.slice > 0) {
+        slice = dev->d_kind.biosdisk.slice - 1;
+        if (slice >= od->od_nslices) {
+            DEBUG("slice %d not found", slice);
+	    return (ENOENT);
+        }
+    }
+
+    /*
+     * Check for the historically bogus MBR found on true dedicated disks
+     */
+    if ((dptr[3].dp_typ == DOSPTYP_386BSD) &&
+      (dptr[3].dp_start == 0) &&
+      (dptr[3].dp_size == 50000)) {
+        sector = 0;
+        goto unsliced;
+    }
+
+    /* Try to auto-detect the best slice; this should always give a slice number */
+    if (dev->d_kind.biosdisk.slice == 0) {
+	slice = bd_bestslice(od);
+        if (slice == -1) {
+	    return (ENOENT);
+        }
+        dev->d_kind.biosdisk.slice = slice;
+    }
+
+    dptr = &od->od_slicetab[0];
+    /*
+     * Accept the supplied slice number unequivocally (we may be looking
+     * at a DOS partition).
+     */
+    dptr += (dev->d_kind.biosdisk.slice - 1);	/* we number 1-4, offsets are 0-3 */
+    sector = dptr->dp_start;
+    DEBUG("slice entry %d at %d, %d sectors", dev->d_kind.biosdisk.slice - 1, sector, dptr->dp_size);
+
+    /*
+     * If we are looking at a BSD slice, and the partition is < 0, assume the 'a' partition
+     */
+    if ((dptr->dp_typ == DOSPTYP_386BSD) && (dev->d_kind.biosdisk.partition < 0))
+	dev->d_kind.biosdisk.partition = 0;
+
+ unsliced:
+    /* 
+     * Now we have the slice offset, look for the partition in the disklabel if we have
+     * a partition to start with.
+     *
+     * XXX we might want to check the label checksum.
+     */
+    if (dev->d_kind.biosdisk.partition < 0) {
+	od->od_boff = sector;		/* no partition, must be after the slice */
+	DEBUG("opening raw slice");
+    } else {
+	
+	if (bd_read(od, sector + LABELSECTOR, 1, buf)) {
+	    DEBUG("error reading disklabel");
+	    return (EIO);
+	}
+	DEBUG("copy %d bytes of label from %p to %p", sizeof(struct disklabel), buf + LABELOFFSET, &od->od_disklabel);
+	bcopy(buf + LABELOFFSET, &od->od_disklabel, sizeof(struct disklabel));
+	lp = &od->od_disklabel;
+	od->od_flags |= BD_LABELOK;
+
+	if (lp->d_magic != DISKMAGIC) {
+	    DEBUG("no disklabel");
+	    return (ENOENT);
+	}
+	if (dev->d_kind.biosdisk.partition >= lp->d_npartitions) {
+	    DEBUG("partition '%c' exceeds partitions in table (a-'%c')",
+		  'a' + dev->d_kind.biosdisk.partition, 'a' + lp->d_npartitions);
+	    return (EPART);
+	}
+
+#ifdef DISK_DEBUG
+	/* Complain if the partition is unused unless this is a floppy. */
+	if ((lp->d_partitions[dev->d_kind.biosdisk.partition].p_fstype == FS_UNUSED) &&
+	    !(od->od_flags & BD_FLOPPY))
+	    DEBUG("warning, partition marked as unused");
+#endif
+	
+	od->od_boff = 
+		lp->d_partitions[dev->d_kind.biosdisk.partition].p_offset -
+		lp->d_partitions[RAW_PART].p_offset +
+		sector;
+    }
+    return (0);
+}
+
+static void
+bd_checkextended(struct open_disk *od, int slicenum)
+{
+	char	buf[BIOSDISK_SECSIZE];
+	struct dos_partition *dp;
+	u_int base;
+	int i, start, end;
+
+	dp = &od->od_slicetab[slicenum];
+	start = od->od_nslices;
+
+	if (dp->dp_size == 0)
+		goto done;
+	if (dp->dp_typ != DOSPTYP_EXT)
+		goto done;
+	if (bd_read(od, (daddr_t)dp->dp_start, 1, buf))
+		goto done;
+	if (((u_char)buf[0x1fe] != 0x55) || ((u_char)buf[0x1ff] != 0xaa)) {
+		DEBUG("no magic in extended table");
+		goto done;
+	}
+	base = dp->dp_start;
+	dp = (struct dos_partition *)(&buf[DOSPARTOFF]);
+	for (i = 0; i < NDOSPART; i++, dp++) {
+		if (dp->dp_size == 0)
+			continue;
+		if (od->od_nslices == NEXTDOSPART)
+			goto done;
+		dp->dp_start += base;
+		bcopy(dp, &od->od_slicetab[od->od_nslices], sizeof(*dp));
+		od->od_nslices++;
+	}
+	end = od->od_nslices;
+
+	/*
+	 * now, recursively check the slices we just added
+	 */
+	for (i = start; i < end; i++)
+		bd_checkextended(od, i);
+done:
+	return;
+}
+
+/*
+ * Search for a slice with the following preferences:
+ *
+ * 1: Active FreeBSD slice
+ * 2: Non-active FreeBSD slice
+ * 3: Active Linux slice
+ * 4: non-active Linux slice
+ * 5: Active FAT/FAT32 slice
+ * 6: non-active FAT/FAT32 slice
+ */
+#define PREF_RAWDISK	0
+#define PREF_FBSD_ACT	1
+#define PREF_FBSD	2
+#define PREF_LINUX_ACT	3
+#define PREF_LINUX	4
+#define PREF_DOS_ACT	5
+#define PREF_DOS	6
+#define PREF_NONE	7
+
+/*
+ * slicelimit is in the range 0 .. NDOSPART
+ */
+static int
+bd_bestslice(struct open_disk *od)
+{
+	struct dos_partition *dp;
+	int pref, preflevel;
+	int i, prefslice;
+	
+	prefslice = 0;
+	preflevel = PREF_NONE;
+
+	dp = &od->od_slicetab[0];
+	for (i = 0; i < od->od_nslices; i++, dp++) {
+
+		switch (dp->dp_typ) {
+		case DOSPTYP_386BSD:		/* FreeBSD */
+			pref = dp->dp_flag & 0x80 ? PREF_FBSD_ACT : PREF_FBSD;
+			break;
+
+		case DOSPTYP_LINUX:
+			pref = dp->dp_flag & 0x80 ? PREF_LINUX_ACT : PREF_LINUX;
+			break;
+    
+		case 0x01:		/* DOS/Windows */
+		case 0x04:
+		case 0x06:
+		case 0x0b:
+		case 0x0c:
+		case 0x0e:
+			pref = dp->dp_flag & 0x80 ? PREF_DOS_ACT : PREF_DOS;
+			break;
+
+		default:
+		        pref = PREF_NONE;
+		}
+		if (pref < preflevel) {
+			preflevel = pref;
+			prefslice = i + 1;
+		}
+	}
+	return (prefslice);
+}
+
+static int
+bd_open_gpt(struct open_disk *od, struct i386_devdesc *dev)
+{
+    struct dos_partition *dp;
+    struct gpt_hdr *hdr;
+    struct gpt_ent *ent;
+    struct gpt_part *gp;
+    int	entries_per_sec, error, i, part;
+    daddr_t lba, elba;
+    char gpt[BIOSDISK_SECSIZE], tbl[BIOSDISK_SECSIZE];
+
+    /*
+     * Following calculations attempt to determine the correct value
+     * for d->od_boff by looking for the slice and partition specified,
+     * or searching for reasonable defaults.
+     */
+    error = 0;
+
+    /* First, read the MBR and see if we have a PMBR. */
+    if (bd_read(od, 0, 1, tbl)) {
+	DEBUG("error reading MBR");
+	return (EIO);
+    }
+
+    /* Check the slice table magic. */
+    if (((u_char)tbl[0x1fe] != 0x55) || ((u_char)tbl[0x1ff] != 0xaa))
+	return (ENXIO);
+
+    /* Check for GPT slice. */
+    part = 0;
+    dp = (struct dos_partition *)(tbl + DOSPARTOFF);
+    for (i = 0; i < NDOSPART; i++) {
+	if (dp[i].dp_typ == 0xee)
+	    part++;
+	else if (dp[i].dp_typ != 0x00)
+	    return (EINVAL);
+    }
+    if (part != 1)
+	return (EINVAL);
+
+    /* Read primary GPT table header. */
+    if (bd_read(od, 1, 1, gpt)) {
+	DEBUG("error reading GPT header");
+	return (EIO);
+    }
+    hdr = (struct gpt_hdr *)gpt;
+    if (bcmp(hdr->hdr_sig, GPT_HDR_SIG, sizeof(hdr->hdr_sig)) != 0 ||
+	hdr->hdr_lba_self != 1 || hdr->hdr_revision < 0x00010000 ||
+	hdr->hdr_entsz < sizeof(*ent) ||
+	BIOSDISK_SECSIZE % hdr->hdr_entsz != 0) {
+	DEBUG("Invalid GPT header\n");
+	return (EINVAL);
+    }
+
+    /* Now walk the partition table to count the number of valid partitions. */
+    part = 0;
+    entries_per_sec = BIOSDISK_SECSIZE / hdr->hdr_entsz;
+    elba = hdr->hdr_lba_table + hdr->hdr_entries / entries_per_sec;
+    for (lba = hdr->hdr_lba_table; lba < elba; lba++) {
+	if (bd_read(od, lba, 1, tbl)) {
+	    DEBUG("error reading GPT table");
+	    return (EIO);
+	}
+	for (i = 0; i < entries_per_sec; i++) {
+	    ent = (struct gpt_ent *)(tbl + i * hdr->hdr_entsz);
+	    if (uuid_is_nil(&ent->ent_type, NULL) || ent->ent_lba_start == 0 ||
+		ent->ent_lba_end < ent->ent_lba_start)
+		continue;
+	    part++;
+	}
+    }
+
+    /* Save the important information about all the valid partitions. */
+    od->od_nparts = part;
+    if (part != 0) {
+	od->od_partitions = malloc(part * sizeof(struct gpt_part));
+	part = 0;	
+	for (lba = hdr->hdr_lba_table; lba < elba; lba++) {
+	    if (bd_read(od, lba, 1, tbl)) {
+		DEBUG("error reading GPT table");
+		error = EIO;
+		goto out;
+	    }
+	    for (i = 0; i < entries_per_sec; i++) {
+		ent = (struct gpt_ent *)(tbl + i * hdr->hdr_entsz);
+		if (uuid_is_nil(&ent->ent_type, NULL) ||
+		    ent->ent_lba_start == 0 ||
+		    ent->ent_lba_end < ent->ent_lba_start)
+		    continue;
+		od->od_partitions[part].gp_index = (lba - hdr->hdr_lba_table) *
+		    entries_per_sec + i + 1;
+		od->od_partitions[part].gp_type = ent->ent_type;
+		od->od_partitions[part].gp_start = ent->ent_lba_start;
+		od->od_partitions[part].gp_end = ent->ent_lba_end;
+		part++;
+	    }
+	}
+    }
+    od->od_flags |= BD_GPTOK;
+
+    /* Is this a request for the whole disk? */
+    if (dev->d_kind.biosdisk.slice < 0) {
+	od->od_boff = 0;
+	return (0);
+    }
+
+    /*
+     * If a partition number was supplied, then the user is trying to use
+     * an MBR address rather than a GPT address, so fail.
+     */
+    if (dev->d_kind.biosdisk.partition != 0xff) {
+	error = ENOENT;
+	goto out;
+    }
+
+    /* If a slice number was supplied but not found, this is an error. */
+    gp = NULL;
+    if (dev->d_kind.biosdisk.slice > 0) {
+	for (i = 0; i < od->od_nparts; i++) {
+	    if (od->od_partitions[i].gp_index == dev->d_kind.biosdisk.slice) {
+		gp = &od->od_partitions[i];
+		break;
+	    }
+	}
+	if (gp == NULL) {
+            DEBUG("partition %d not found", dev->d_kind.biosdisk.slice);
+	    error = ENOENT;
+	    goto out;
+        }
+    }
+
+    /* Try to auto-detect the best partition. */
+    if (dev->d_kind.biosdisk.slice == 0) {
+	gp = bd_best_gptpart(od);
+	if (gp == NULL) {
+	    error = ENOENT;
+	    goto out;
+	}
+	dev->d_kind.biosdisk.slice = gp->gp_index;
+    }
+    od->od_boff = gp->gp_start;
+
+out:
+    if (error)
+	free(od->od_partitions);
+    return (error);
+}
+
+static struct gpt_part *
+bd_best_gptpart(struct open_disk *od)
+{
+    struct gpt_part *gp, *prefpart;
+    int i, pref, preflevel;
+	
+    prefpart = NULL;
+    preflevel = PREF_NONE;
+
+    gp = od->od_partitions;
+    for (i = 0; i < od->od_nparts; i++, gp++) {
+	/* Windows. XXX: Also Linux. */
+	if (uuid_equal(&gp->gp_type, &ms_basic_data, NULL))
+	    pref = PREF_DOS;
+	/* FreeBSD */
+	else if (uuid_equal(&gp->gp_type, &freebsd_ufs, NULL) ||
+	    uuid_equal(&gp->gp_type, &freebsd_zfs, NULL))
+	    pref = PREF_FBSD;
+	else
+	    pref = PREF_NONE;
+	if (pref < preflevel) {
+	    preflevel = pref;
+	    prefpart = gp;
+	}
+    }
+    return (prefpart);
+}
+
+static int 
+bd_close(struct open_file *f)
+{
+    struct open_disk	*od = (struct open_disk *)(((struct i386_devdesc *)(f->f_devdata))->d_kind.biosdisk.data);
+
+    bd_closedisk(od);
+    return(0);
+}
+
+static void
+bd_closedisk(struct open_disk *od)
+{
+    DEBUG("open_disk %p", od);
+#if 0
+    /* XXX is this required? (especially if disk already open...) */
+    if (od->od_flags & BD_FLOPPY)
+	delay(3000000);
+#endif
+    if (od->od_flags & BD_GPTOK)
+	free(od->od_partitions);
+    free(od);
+}
+
+static int 
+bd_strategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, size_t *rsize)
+{
+    struct bcache_devdata	bcd;
+    struct open_disk	*od = (struct open_disk *)(((struct i386_devdesc *)devdata)->d_kind.biosdisk.data);
+
+    bcd.dv_strategy = bd_realstrategy;
+    bcd.dv_devdata = devdata;
+    return(bcache_strategy(&bcd, od->od_unit, rw, dblk+od->od_boff, size, buf, rsize));
+}
+
+static int 
+bd_realstrategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, size_t *rsize)
+{
+    struct open_disk	*od = (struct open_disk *)(((struct i386_devdesc *)devdata)->d_kind.biosdisk.data);
+    int			blks;
+#ifdef BD_SUPPORT_FRAGS
+    char		fragbuf[BIOSDISK_SECSIZE];
+    size_t		fragsize;
+
+    fragsize = size % BIOSDISK_SECSIZE;
+#else
+    if (size % BIOSDISK_SECSIZE)
+	panic("bd_strategy: %d bytes I/O not multiple of block size", size);
+#endif
+
+    DEBUG("open_disk %p", od);
+    blks = size / BIOSDISK_SECSIZE;
+    if (rsize)
+	*rsize = 0;
+
+    switch(rw){
+    case F_READ:
+	DEBUG("read %d from %d to %p", blks, dblk, buf);
+
+	if (blks && bd_read(od, dblk, blks, buf)) {
+	    DEBUG("read error");
+	    return (EIO);
+	}
+#ifdef BD_SUPPORT_FRAGS
+	DEBUG("bd_strategy: frag read %d from %d+%d to %p",
+	    fragsize, dblk, blks, buf + (blks * BIOSDISK_SECSIZE));
+	if (fragsize && bd_read(od, dblk + blks, 1, fragsize)) {
+	    DEBUG("frag read error");
+	    return(EIO);
+	}
+	bcopy(fragbuf, buf + (blks * BIOSDISK_SECSIZE), fragsize);
+#endif
+	break;
+    case F_WRITE :
+	DEBUG("write %d from %d to %p", blks, dblk, buf);
+
+	if (blks && bd_write(od, dblk, blks, buf)) {
+	    DEBUG("write error");
+	    return (EIO);
+	}
+#ifdef BD_SUPPORT_FRAGS
+	if(fragsize) {
+	    DEBUG("Attempted to write a frag");
+	    return (EIO);
+	}
+#endif
+	break;
+    default:
+	/* DO NOTHING */
+	return (EROFS);
+    }
+
+    if (rsize)
+	*rsize = size;
+    return (0);
+}
+
+/* Max number of sectors to bounce-buffer if the request crosses a 64k boundary */
+#define FLOPPY_BOUNCEBUF	18
+
+struct edd_packet {
+    uint16_t	len;
+    uint16_t	count;
+    uint16_t	offset;
+    uint16_t	seg;
+    uint64_t	lba;
+};
+
+static int
+bd_edd_io(struct open_disk *od, daddr_t dblk, int blks, caddr_t dest, int write)
+{
+    static struct edd_packet packet;
+
+    packet.len = 0x10;
+    packet.count = blks;
+    packet.offset = VTOPOFF(dest);
+    packet.seg = VTOPSEG(dest);
+    packet.lba = dblk;
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x13;
+    if (write)
+	/* Should we Write with verify ?? 0x4302 ? */
+	v86.eax = 0x4300;
+    else
+	v86.eax = 0x4200;
+    v86.edx = od->od_unit;
+    v86.ds = VTOPSEG(&packet);
+    v86.esi = VTOPOFF(&packet);
+    v86int();
+    return (v86.efl & 0x1);
+}
+
+static int
+bd_chs_io(struct open_disk *od, daddr_t dblk, int blks, caddr_t dest, int write)
+{
+    u_int	x, bpc, cyl, hd, sec;
+
+    bpc = (od->od_sec * od->od_hds);	/* blocks per cylinder */
+    x = dblk;
+    cyl = x / bpc;			/* block # / blocks per cylinder */
+    x %= bpc;				/* block offset into cylinder */
+    hd = x / od->od_sec;		/* offset / blocks per track */
+    sec = x % od->od_sec;		/* offset into track */
+
+    /* correct sector number for 1-based BIOS numbering */
+    sec++;
+
+    if (cyl > 1023)
+	/* CHS doesn't support cylinders > 1023. */
+	return (1);
+
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x13;
+    if (write)
+	v86.eax = 0x300 | blks;
+    else
+	v86.eax = 0x200 | blks;
+    v86.ecx = ((cyl & 0xff) << 8) | ((cyl & 0x300) >> 2) | sec;
+    v86.edx = (hd << 8) | od->od_unit;
+    v86.es = VTOPSEG(dest);
+    v86.ebx = VTOPOFF(dest);
+    v86int();
+    return (v86.efl & 0x1);
+}
+
+static int
+bd_io(struct open_disk *od, daddr_t dblk, int blks, caddr_t dest, int write)
+{
+    u_int	x, sec, result, resid, retry, maxfer;
+    caddr_t	p, xp, bbuf, breg;
+    
+    /* Just in case some idiot actually tries to read/write -1 blocks... */
+    if (blks < 0)
+	return (-1);
+
+    resid = blks;
+    p = dest;
+
+    /* Decide whether we have to bounce */
+    if (VTOP(dest) >> 20 != 0 || ((od->od_unit < 0x80) && 
+	((VTOP(dest) >> 16) != (VTOP(dest + blks * BIOSDISK_SECSIZE) >> 16)))) {
+
+	/* 
+	 * There is a 64k physical boundary somewhere in the
+	 * destination buffer, or the destination buffer is above
+	 * first 1MB of physical memory so we have to arrange a
+	 * suitable bounce buffer.  Allocate a buffer twice as large
+	 * as we need to.  Use the bottom half unless there is a break
+	 * there, in which case we use the top half.
+	 */
+	x = min(FLOPPY_BOUNCEBUF, (unsigned)blks);
+	bbuf = alloca(x * 2 * BIOSDISK_SECSIZE);
+	if (((u_int32_t)VTOP(bbuf) & 0xffff0000) ==
+	    ((u_int32_t)VTOP(bbuf + x * BIOSDISK_SECSIZE) & 0xffff0000)) {
+	    breg = bbuf;
+	} else {
+	    breg = bbuf + x * BIOSDISK_SECSIZE;
+	}
+	maxfer = x;		/* limit transfers to bounce region size */
+    } else {
+	breg = bbuf = NULL;
+	maxfer = 0;
+    }
+    
+    while (resid > 0) {
+	/*
+	 * Play it safe and don't cross track boundaries.
+	 * (XXX this is probably unnecessary)
+	 */
+	sec = dblk % od->od_sec;	/* offset into track */
+	x = min(od->od_sec - sec, resid);
+	if (maxfer > 0)
+	    x = min(x, maxfer);		/* fit bounce buffer */
+
+	/* where do we transfer to? */
+	xp = bbuf == NULL ? p : breg;
+
+	/*
+	 * Put your Data In, Put your Data out,
+	 * Put your Data In, and shake it all about 
+	 */
+	if (write && bbuf != NULL)
+	    bcopy(p, breg, x * BIOSDISK_SECSIZE);
+
+	/*
+	 * Loop retrying the operation a couple of times.  The BIOS
+	 * may also retry.
+	 */
+	for (retry = 0; retry < 3; retry++) {
+	    /* if retrying, reset the drive */
+	    if (retry > 0) {
+		v86.ctl = V86_FLAGS;
+		v86.addr = 0x13;
+		v86.eax = 0;
+		v86.edx = od->od_unit;
+		v86int();
+	    }
+
+	    if (od->od_flags & BD_MODEEDD1)
+		result = bd_edd_io(od, dblk, x, xp, write);
+	    else
+		result = bd_chs_io(od, dblk, x, xp, write);
+	    if (result == 0)
+		break;
+	}
+
+	if (write)
+	    DEBUG("%d sectors from %lld to %p (0x%x) %s", x, dblk, p, VTOP(p),
+		result ? "failed" : "ok");
+	else
+	    DEBUG("%d sectors from %p (0x%x) to %lld %s", x, p, VTOP(p), dblk,
+		result ? "failed" : "ok");
+	if (result) {
+	    return(-1);
+	}
+	if (!write && bbuf != NULL)
+	    bcopy(breg, p, x * BIOSDISK_SECSIZE);
+	p += (x * BIOSDISK_SECSIZE);
+	dblk += x;
+	resid -= x;
+    }
+
+/*    hexdump(dest, (blks * BIOSDISK_SECSIZE)); */
+    return(0);
+}
+
+static int
+bd_read(struct open_disk *od, daddr_t dblk, int blks, caddr_t dest)
+{
+
+    return (bd_io(od, dblk, blks, dest, 0));
+}
+
+static int
+bd_write(struct open_disk *od, daddr_t dblk, int blks, caddr_t dest)
+{
+
+    return (bd_io(od, dblk, blks, dest, 1));
+}
+
+static int
+bd_getgeom(struct open_disk *od)
+{
+
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x13;
+    v86.eax = 0x800;
+    v86.edx = od->od_unit;
+    v86int();
+
+    if ((v86.efl & 0x1) ||				/* carry set */
+	((v86.edx & 0xff) <= (unsigned)(od->od_unit & 0x7f)))	/* unit # bad */
+	return(1);
+    
+    /* convert max cyl # -> # of cylinders */
+    od->od_cyl = ((v86.ecx & 0xc0) << 2) + ((v86.ecx & 0xff00) >> 8) + 1;
+    /* convert max head # -> # of heads */
+    od->od_hds = ((v86.edx & 0xff00) >> 8) + 1;
+    od->od_sec = v86.ecx & 0x3f;
+
+    DEBUG("unit 0x%x geometry %d/%d/%d", od->od_unit, od->od_cyl, od->od_hds, od->od_sec);
+    return(0);
+}
+
+/*
+ * Return the BIOS geometry of a given "fixed drive" in a format
+ * suitable for the legacy bootinfo structure.  Since the kernel is
+ * expecting raw int 0x13/0x8 values for N_BIOS_GEOM drives, we
+ * prefer to get the information directly, rather than rely on being
+ * able to put it together from information already maintained for
+ * different purposes and for a probably different number of drives.
+ *
+ * For valid drives, the geometry is expected in the format (31..0)
+ * "000000cc cccccccc hhhhhhhh 00ssssss"; and invalid drives are
+ * indicated by returning the geometry of a "1.2M" PC-format floppy
+ * disk.  And, incidentally, what is returned is not the geometry as
+ * such but the highest valid cylinder, head, and sector numbers.
+ */
+u_int32_t
+bd_getbigeom(int bunit)
+{
+
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x13;
+    v86.eax = 0x800;
+    v86.edx = 0x80 + bunit;
+    v86int();
+    if (v86.efl & 0x1)
+	return 0x4f010f;
+    return ((v86.ecx & 0xc0) << 18) | ((v86.ecx & 0xff00) << 8) |
+	   (v86.edx & 0xff00) | (v86.ecx & 0x3f);
+}
+
+/*
+ * Return a suitable dev_t value for (dev).
+ *
+ * In the case where it looks like (dev) is a SCSI disk, we allow the number of
+ * IDE disks to be specified in $num_ide_disks.  There should be a Better Way.
+ */
+int
+bd_getdev(struct i386_devdesc *dev)
+{
+    struct open_disk		*od;
+    int				biosdev;
+    int 			major;
+    int				rootdev;
+    char			*nip, *cp;
+    int				unitofs = 0, i, unit;
+
+    biosdev = bd_unit2bios(dev->d_unit);
+    DEBUG("unit %d BIOS device %d", dev->d_unit, biosdev);
+    if (biosdev == -1)				/* not a BIOS device */
+	return(-1);
+    if (bd_opendisk(&od, dev) != 0)		/* oops, not a viable device */
+	return(-1);
+
+    if (biosdev < 0x80) {
+	/* floppy (or emulated floppy) or ATAPI device */
+	if (bdinfo[dev->d_unit].bd_type == DT_ATAPI) {
+	    /* is an ATAPI disk */
+	    major = WFDMAJOR;
+	} else {
+	    /* is a floppy disk */
+	    major = FDMAJOR;
+	}
+    } else {
+	/* harddisk */
+	if ((od->od_flags & BD_LABELOK) && (od->od_disklabel.d_type == DTYPE_SCSI)) {
+	    /* label OK, disk labelled as SCSI */
+	    major = DAMAJOR;
+	    /* check for unit number correction hint, now deprecated */
+	    if ((nip = getenv("num_ide_disks")) != NULL) {
+		i = strtol(nip, &cp, 0);
+		/* check for parse error */
+		if ((cp != nip) && (*cp == 0))
+		    unitofs = i;
+	    }
+	} else {
+	    /* assume an IDE disk */
+	    major = WDMAJOR;
+	}
+    }
+    /* default root disk unit number */
+    unit = (biosdev & 0x7f) - unitofs;
+
+    /* XXX a better kludge to set the root disk unit number */
+    if ((nip = getenv("root_disk_unit")) != NULL) {
+	i = strtol(nip, &cp, 0);
+	/* check for parse error */
+	if ((cp != nip) && (*cp == 0))
+	    unit = i;
+    }
+
+    rootdev = MAKEBOOTDEV(major, dev->d_kind.biosdisk.slice + 1, unit,
+	dev->d_kind.biosdisk.partition);
+    DEBUG("dev is 0x%x\n", rootdev);
+    return(rootdev);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/biosmem.c sys/boot/i386/pxe_ng/libi386/biosmem.c
--- sys/boot/i386/pxe_ng/libi386/biosmem.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biosmem.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,101 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Obtain memory configuration information from the BIOS
+ */
+#include <stand.h>
+#include <machine/pc/bios.h>
+#include "libi386.h"
+#include "btxv86.h"
+
+vm_offset_t	memtop, memtop_copyin;
+u_int32_t	bios_basemem, bios_extmem;
+
+static struct bios_smap smap;
+
+void
+bios_getmem(void)
+{
+
+    /* Parse system memory map */
+    v86.ebx = 0;
+    do {
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x15;		/* int 0x15 function 0xe820*/
+	v86.eax = 0xe820;
+	v86.ecx = sizeof(struct bios_smap);
+	v86.edx = SMAP_SIG;
+	v86.es = VTOPSEG(&smap);
+	v86.edi = VTOPOFF(&smap);
+	v86int();
+	if ((v86.efl & 1) || (v86.eax != SMAP_SIG))
+	    break;
+	/* look for a low-memory segment that's large enough */
+	if ((smap.type == SMAP_TYPE_MEMORY) && (smap.base == 0) &&
+	    (smap.length >= (512 * 1024)))
+	    bios_basemem = smap.length;
+	/* look for the first segment in 'extended' memory */
+	if ((smap.type == SMAP_TYPE_MEMORY) && (smap.base == 0x100000)) {
+	    bios_extmem = smap.length;
+	}
+    } while (v86.ebx != 0);
+
+    /* Fall back to the old compatibility function for base memory */
+    if (bios_basemem == 0) {
+	v86.ctl = 0;
+	v86.addr = 0x12;		/* int 0x12 */
+	v86int();
+	
+	bios_basemem = (v86.eax & 0xffff) * 1024;
+    }
+
+    /* Fall back through several compatibility functions for extended memory */
+    if (bios_extmem == 0) {
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x15;		/* int 0x15 function 0xe801*/
+	v86.eax = 0xe801;
+	v86int();
+	if (!(v86.efl & 1)) {
+	    bios_extmem = ((v86.ecx & 0xffff) + ((v86.edx & 0xffff) * 64)) * 1024;
+	}
+    }
+    if (bios_extmem == 0) {
+	v86.ctl = 0;
+	v86.addr = 0x15;		/* int 0x15 function 0x88*/
+	v86.eax = 0x8800;
+	v86int();
+	bios_extmem = (v86.eax & 0xffff) * 1024;
+    }
+
+    /* Set memtop to actual top of memory */
+    memtop = memtop_copyin = 0x100000 + bios_extmem;
+
+}    
+
diff -ruN sys/boot/i386/pxe_ng/libi386/biospci.c sys/boot/i386/pxe_ng/libi386/biospci.c
--- sys/boot/i386/pxe_ng/libi386/biospci.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biospci.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,343 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * PnP enumerator using the PCI BIOS.
+ */
+
+#include <stand.h>
+#include <machine/stdarg.h>
+#include <bootstrap.h>
+#include <isapnp.h>
+#include <btxv86.h>
+#include "libi386.h"
+
+/*
+ * Stupid PCI BIOS interface doesn't let you simply enumerate everything
+ * that's there, instead you have to ask it if it has something.
+ *
+ * So we have to scan by class code, subclass code and sometimes programming
+ * interface.
+ */
+
+struct pci_progif 
+{
+    int		pi_code;
+    const char	*pi_name;
+};
+
+static struct pci_progif progif_null[] = {
+    {0x0,	NULL},
+    {-1,	NULL}
+};
+
+static struct pci_progif progif_display[] = {
+    {0x0,	"VGA"},
+    {0x1,	"8514"},
+    {-1,	NULL}
+};
+
+static struct pci_progif progif_ide[] = {
+    {0x00,	NULL},
+    {0x01,	NULL},
+    {0x02,	NULL},
+    {0x03,	NULL},
+    {0x04,	NULL},
+    {0x05,	NULL},
+    {0x06,	NULL},
+    {0x07,	NULL},
+    {0x08,	NULL},
+    {0x09,	NULL},
+    {0x0a,	NULL},
+    {0x0b,	NULL},
+    {0x0c,	NULL},
+    {0x0d,	NULL},
+    {0x0e,	NULL},
+    {0x0f,	NULL},
+    {0x80,	NULL},
+    {0x81,	NULL},
+    {0x82,	NULL},
+    {0x83,	NULL},
+    {0x84,	NULL},
+    {0x85,	NULL},
+    {0x86,	NULL},
+    {0x87,	NULL},
+    {0x88,	NULL},
+    {0x89,	NULL},
+    {0x8a,	NULL},
+    {0x8b,	NULL},
+    {0x8c,	NULL},
+    {0x8d,	NULL},
+    {0x8e,	NULL},
+    {0x8f,	NULL},
+    {-1,	NULL}
+};
+
+static struct pci_progif progif_serial[] = {
+    {0x0,	"8250"},
+    {0x1,	"16450"},
+    {0x2,	"16550"},
+    {-1,	NULL}
+};
+
+static struct pci_progif progif_parallel[] = {
+    {0x0,	"Standard"},
+    {0x1,	"Bidirectional"},
+    {0x2,	"ECP"},
+    {-1,	NULL}
+};
+
+static struct pci_progif progif_firewire[] = {
+    {0x10,	"OHCI"},
+    {-1,	NULL}
+};
+
+struct pci_subclass 
+{
+    int			ps_subclass;
+    const char		*ps_name;
+    struct pci_progif	*ps_progif;	/* if set, use for programming interface value(s) */
+};
+
+static struct pci_subclass subclass_old[] = {
+    {0x0,	"Old non-VGA",		progif_null},
+    {0x1,	"Old VGA",		progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_subclass subclass_mass[] = {
+    {0x0,	"SCSI",			progif_null},
+    {0x1,	"IDE",			progif_ide},
+    {0x2,	"Floppy disk",		progif_null},
+    {0x3,	"IPI",			progif_null},
+    {0x4,	"RAID",			progif_null},
+    {0x80,	"mass storage",		progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_subclass subclass_net[] = {
+    {0x0,	"Ethernet",		progif_null},
+    {0x1,	"Token ring",		progif_null},
+    {0x2,	"FDDI",			progif_null},
+    {0x3,	"ATM",			progif_null},
+    {0x80,	"network",		progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_subclass subclass_display[] = {
+    {0x0,	NULL,			progif_display},
+    {0x1,	"XGA",			progif_null},
+    {0x80,	"other",		progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_subclass subclass_comms[] = {
+    {0x0,	"serial",		progif_serial},
+    {0x1,	"parallel",		progif_parallel},
+    {0x80,	"communications",	progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_subclass subclass_serial[] = {
+    {0x0,	"FireWire",		progif_firewire},
+    {0x1,	"ACCESS.bus",		progif_null},
+    {0x2,	"SSA",			progif_null},
+    {0x3,	"USB",			progif_null},
+    {0x4,	"Fibrechannel",		progif_null},
+    {-1,	NULL,			NULL}
+};
+
+static struct pci_class
+{
+    int			pc_class;
+    const char		*pc_name;
+    struct pci_subclass	*pc_subclass;
+} pci_classes[] = {
+    {0x0,	"device",	subclass_old},
+    {0x1,	"controller",	subclass_mass},
+    {0x2,	"controller",	subclass_net},
+    {0x3,	"display",	subclass_display},
+    {0x7,	"controller",	subclass_comms},
+    {0xc,	"controller",	subclass_serial},
+    {-1,	NULL,		NULL}
+};
+
+
+static void	biospci_enumerate(void);
+static void	biospci_addinfo(int devid, struct pci_class *pc, struct pci_subclass *psc, struct pci_progif *ppi);
+
+static int	biospci_version;
+static int	biospci_hwcap;
+
+struct pnphandler biospcihandler =
+{
+    "PCI BIOS",
+    biospci_enumerate
+};
+
+static void
+biospci_enumerate(void)
+{
+    int			device_index, err;
+    uint32_t		locator, devid;
+    struct pci_class	*pc;
+    struct pci_subclass *psc;
+    struct pci_progif	*ppi;
+
+    /* Find the PCI BIOS */
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x1a;
+    v86.eax = 0xb101;
+    v86.edi = 0x0;
+    v86int();
+
+    /* Check for OK response */
+    if ((v86.efl & 1) || ((v86.eax & 0xff00) != 0) || (v86.edx != 0x20494350))
+	return;
+
+    biospci_version = v86.ebx & 0xffff;
+    biospci_hwcap = v86.eax & 0xff;
+#if 0
+    printf("PCI BIOS %d.%d%s%s\n", 
+	   bcd2bin((biospci_version >> 8) & 0xf), bcd2bin(biospci_version & 0xf),
+	   (biospci_hwcap & 1) ? " config1" : "", (biospci_hwcap & 2) ? " config2" : "");
+#endif
+    /* Iterate over known classes */
+    for (pc = pci_classes; pc->pc_class >= 0; pc++) {
+	/* Iterate over subclasses */
+	for (psc = pc->pc_subclass; psc->ps_subclass >= 0; psc++) {
+	    /* Iterate over programming interfaces */
+	    for (ppi = psc->ps_progif; ppi->pi_code >= 0; ppi++) {
+
+		/* Scan for matches */
+		for (device_index = 0; ; device_index++) {
+		    /* Look for a match */
+		    err = biospci_find_devclass((pc->pc_class << 16)
+			+ (psc->ps_subclass << 8) + ppi->pi_code,
+			device_index, &locator);
+		    if (err != 0)
+			break;
+
+		    /* Read the device identifier from the nominated device */
+		    err = biospci_read_config(locator, 0, 2, &devid);
+		    if (err != 0)
+			break;
+		    
+		    /* We have the device ID, create a PnP object and save everything */
+		    biospci_addinfo(devid, pc, psc, ppi);
+		}
+	    }
+	}
+    }
+}
+
+static void
+biospci_addinfo(int devid, struct pci_class *pc, struct pci_subclass *psc, struct pci_progif *ppi) 
+{
+    struct pnpinfo	*pi;
+    char		desc[80];
+    
+    
+    /* build the description */
+    desc[0] = 0;
+    if (ppi->pi_name != NULL) {
+	strcat(desc, ppi->pi_name);
+	strcat(desc, " ");
+    }
+    if (psc->ps_name != NULL) {
+	strcat(desc, psc->ps_name);
+	strcat(desc, " ");
+    }
+    if (pc->pc_name != NULL)
+	strcat(desc, pc->pc_name);
+
+    pi = pnp_allocinfo();
+    pi->pi_desc = strdup(desc);
+    sprintf(desc,"0x%08x", devid);
+    pnp_addident(pi, desc);
+    pnp_addinfo(pi);
+}
+
+int
+biospci_find_devclass(uint32_t class, int index, uint32_t *locator)
+{
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x1a;
+	v86.eax = 0xb103;
+	v86.ecx = class;
+	v86.esi = index;
+	v86int();
+
+	 /* error */
+	if ((v86.efl & 1) || (v86.eax & 0xff00))
+		return (-1);
+
+	*locator = v86.ebx;
+	return (0);
+}
+/*
+ * Configuration space access methods.
+ * width = 0(byte), 1(word) or 2(dword).
+ */
+int
+biospci_write_config(uint32_t locator, int offset, int width, uint32_t val)
+{
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x1a;
+	v86.eax = 0xb10b + width;
+	v86.ebx = locator;
+	v86.edi = offset;
+	v86.ecx = val;
+	v86int();
+
+	 /* error */
+	if ((v86.efl & 1) || (v86.eax & 0xff00))
+		return (-1);
+
+	return(0);
+}
+
+int
+biospci_read_config(uint32_t locator, int offset, int width, uint32_t *val)
+{
+	v86.ctl = V86_FLAGS;
+	v86.addr = 0x1a;
+	v86.eax = 0xb108 + width;
+	v86.ebx = locator;
+	v86.edi = offset;
+	v86int();
+
+	 /* error */
+	if ((v86.efl & 1) || (v86.eax & 0xff00))
+		return (-1);
+
+	*val = v86.ecx;
+	return (0);
+}
+
diff -ruN sys/boot/i386/pxe_ng/libi386/biospnp.c sys/boot/i386/pxe_ng/libi386/biospnp.c
--- sys/boot/i386/pxe_ng/libi386/biospnp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biospnp.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,291 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * PnP BIOS enumerator.
+ */
+
+#include <stand.h>
+#include <machine/stdarg.h>
+#include <bootstrap.h>
+#include <isapnp.h>
+#include <btxv86.h>
+
+
+static int	biospnp_init(void);
+static void	biospnp_enumerate(void);
+
+struct pnphandler biospnphandler =
+{
+    "PnP BIOS",
+    biospnp_enumerate
+};
+
+struct pnp_ICstructure
+{
+    u_int8_t	pnp_signature[4]	 __packed;
+    u_int8_t	pnp_version		 __packed;
+    u_int8_t	pnp_length		 __packed;
+    u_int16_t	pnp_BIOScontrol		 __packed;
+    u_int8_t	pnp_checksum		 __packed;
+    u_int32_t	pnp_eventflag		 __packed;
+    u_int16_t	pnp_rmip		 __packed;
+    u_int16_t	pnp_rmcs		 __packed;
+    u_int16_t	pnp_pmip		 __packed;
+    u_int32_t	pnp_pmcs		 __packed;
+    u_int8_t	pnp_OEMdev[4]		 __packed;
+    u_int16_t	pnp_rmds		 __packed;
+    u_int32_t	pnp_pmds		 __packed;
+};
+
+struct pnp_devNode 
+{
+    u_int16_t	dn_size		__packed;
+    u_int8_t	dn_handle	__packed;
+    u_int8_t	dn_id[4]	__packed;
+    u_int8_t	dn_type[3]	__packed;
+    u_int16_t	dn_attrib	__packed;
+    u_int8_t	dn_data[1]	__packed;
+};
+
+struct pnp_isaConfiguration
+{
+    u_int8_t	ic_revision	__packed;
+    u_int8_t	ic_nCSN		__packed;
+    u_int16_t	ic_rdport	__packed;
+    u_int16_t	ic_reserved	__packed;
+};
+
+static struct pnp_ICstructure	*pnp_Icheck = NULL;
+static u_int16_t		pnp_NumNodes;
+static u_int16_t		pnp_NodeSize;
+
+static void	biospnp_scanresdata(struct pnpinfo *pi, struct pnp_devNode *dn);
+static int	biospnp_call(int func, const char *fmt, ...);
+
+#define vsegofs(vptr)	(((u_int32_t)VTOPSEG(vptr) << 16) + VTOPOFF(vptr))
+
+typedef void    v86bios_t(u_int32_t, u_int32_t, u_int32_t, u_int32_t);
+v86bios_t	*v86bios = (v86bios_t *)v86int;
+
+#define	biospnp_f00(NumNodes, NodeSize)			biospnp_call(0x00, "ll", NumNodes, NodeSize)
+#define biospnp_f01(Node, devNodeBuffer, Control)	biospnp_call(0x01, "llw", Node, devNodeBuffer, Control)
+#define biospnp_f40(Configuration)			biospnp_call(0x40, "l", Configuration)
+
+/* PnP BIOS return codes */
+#define PNP_SUCCESS			0x00
+#define PNP_FUNCTION_NOT_SUPPORTED	0x80
+
+/*
+ * Initialisation: locate the PnP BIOS, test that we can call it.
+ * Returns nonzero if the PnP BIOS is not usable on this system.
+ */
+static int
+biospnp_init(void)
+{
+    struct pnp_isaConfiguration	icfg;
+    char			*sigptr;
+    int				result;
+    
+    /* Search for the $PnP signature */
+    pnp_Icheck = NULL;
+    for (sigptr = PTOV(0xf0000); sigptr < PTOV(0xfffff); sigptr += 16)
+	if (!bcmp(sigptr, "$PnP", 4)) {
+	    pnp_Icheck = (struct pnp_ICstructure *)sigptr;
+	    break;
+	}
+	
+    /* No signature, no BIOS */
+    if (pnp_Icheck == NULL)
+	return(1);
+
+    /*
+     * Fetch the system table parameters as a test of the BIOS
+     */
+    result = biospnp_f00(vsegofs(&pnp_NumNodes), vsegofs(&pnp_NodeSize));
+    if (result != PNP_SUCCESS) {
+	return(1);
+    }
+
+    /*
+     * Look for the PnP ISA configuration table 
+     */
+    result = biospnp_f40(vsegofs(&icfg));
+    switch (result) {
+    case PNP_SUCCESS:
+	/* If the BIOS found some PnP devices, take its hint for the read port */
+	if ((icfg.ic_revision == 1) && (icfg.ic_nCSN > 0))
+	    isapnp_readport = icfg.ic_rdport;
+	break;
+    case PNP_FUNCTION_NOT_SUPPORTED:
+	/* The BIOS says there is no ISA bus (should we trust that this works?) */
+	printf("PnP BIOS claims no ISA bus\n");
+	isapnp_readport = -1;
+	break;
+    }
+    return(0);
+}
+
+static void
+biospnp_enumerate(void)
+{
+    u_int8_t		Node;
+    struct pnp_devNode	*devNodeBuffer;
+    int			result;
+    struct pnpinfo	*pi;
+    int			count;
+
+    /* Init/check state */
+    if (biospnp_init())
+	return;
+
+    devNodeBuffer = (struct pnp_devNode *)alloca(pnp_NodeSize);
+    Node = 0;
+    count = 1000;
+    while((Node != 0xff) && (count-- > 0)) {
+	result = biospnp_f01(vsegofs(&Node), vsegofs(devNodeBuffer), 0x1);
+	if (result != PNP_SUCCESS) {
+	    printf("PnP BIOS node %d: error 0x%x\n", Node, result);
+	} else {
+	    pi = pnp_allocinfo();
+	    pnp_addident(pi, pnp_eisaformat(devNodeBuffer->dn_id));
+	    biospnp_scanresdata(pi, devNodeBuffer);
+	    pnp_addinfo(pi);
+	}
+    }
+}
+
+/*
+ * Scan the resource data in the node's data area for compatible device IDs
+ * and descriptions.
+ */
+static void
+biospnp_scanresdata(struct pnpinfo *pi, struct pnp_devNode *dn)
+{
+    u_int	tag, i, rlen, dlen;
+    u_int8_t	*p;
+    char	*str;
+
+    p = dn->dn_data;			/* point to resource data */
+    dlen = dn->dn_size - (p - (u_int8_t *)dn);	/* length of resource data */
+
+    for (i = 0; i < dlen; i+= rlen) {
+	tag = p[i];
+	i++;
+	if (PNP_RES_TYPE(tag) == 0) {
+	    rlen = PNP_SRES_LEN(tag);
+	    /* small resource */
+	    switch (PNP_SRES_NUM(tag)) {
+
+	    case COMP_DEVICE_ID:
+		/* got a compatible device ID */
+		pnp_addident(pi, pnp_eisaformat(p + i));
+		break;
+		
+	    case END_TAG:
+		return;
+	    }
+	} else {
+	    /* large resource */
+	    rlen = *(u_int16_t *)(p + i);
+	    i += sizeof(u_int16_t);
+	    
+	    switch(PNP_LRES_NUM(tag)) {
+
+	    case ID_STRING_ANSI:
+		str = malloc(rlen + 1);
+		bcopy(p + i, str, rlen);
+		str[rlen] = 0;
+		if (pi->pi_desc == NULL) {
+		    pi->pi_desc = str;
+		} else {
+		    free(str);
+		}
+		break;
+	    }
+	}
+    }
+}
+
+
+/*
+ * Make a 16-bit realmode PnP BIOS call.
+ *
+ * The first argument passed is the function number, the last is the
+ * BIOS data segment selector.  Intermediate arguments may be 16 or 
+ * 32 bytes in length, and are described by the format string.
+ *
+ * Arguments to the BIOS functions must be packed on the stack, hence
+ * this evil.
+ */
+static int
+biospnp_call(int func, const char *fmt, ...)
+{
+    va_list	ap;
+    const char	*p;
+    u_int8_t	*argp;
+    u_int32_t	args[4];
+    u_int32_t	i;
+
+    /* function number first */
+    argp = (u_int8_t *)args;
+    *(u_int16_t *)argp = func;
+    argp += sizeof(u_int16_t);
+
+    /* take args according to format */
+    va_start(ap, fmt);
+    for (p = fmt; *p != 0; p++) {
+	switch(*p) {
+
+	case 'w':
+	    i = va_arg(ap, u_int);
+	    *(u_int16_t *)argp = i;
+	    argp += sizeof(u_int16_t);
+	    break;
+	    
+	case 'l':
+	    i = va_arg(ap, u_int32_t);
+	    *(u_int32_t *)argp = i;
+	    argp += sizeof(u_int32_t);
+	    break;
+	}
+    }
+
+    /* BIOS segment last */
+    *(u_int16_t *)argp = pnp_Icheck->pnp_rmds;
+    argp += sizeof(u_int16_t);
+
+    /* prepare for call */
+    v86.ctl = V86_ADDR | V86_CALLF; 
+    v86.addr = ((u_int32_t)pnp_Icheck->pnp_rmcs << 16) + pnp_Icheck->pnp_rmip;
+    
+    /* call with packed stack and return */
+    v86bios(args[0], args[1], args[2], args[3]);
+    return(v86.eax & 0xffff);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/biossmap.c sys/boot/i386/pxe_ng/libi386/biossmap.c
--- sys/boot/i386/pxe_ng/libi386/biossmap.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/biossmap.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,119 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Obtain memory configuration information from the BIOS
+ */
+#include <stand.h>
+#include <sys/param.h>
+#include <sys/linker.h>
+#include <machine/metadata.h>
+#include <machine/pc/bios.h>
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+static struct {
+	struct bios_smap _smap_entry;
+	char pad[8];		/* Bad BIOS writer, no cookie! */
+} smap;
+
+static struct bios_smap *smapbase;
+static int smaplen;
+
+void
+bios_getsmap(void)
+{
+	int n;
+
+	n = 0;
+	smaplen = 0;
+	/* Count up segments in system memory map */
+	v86.ebx = 0;
+	do {
+		v86.ctl = V86_FLAGS;
+		v86.addr = 0x15;		/* int 0x15 function 0xe820*/
+		v86.eax = 0xe820;
+		v86.ecx = sizeof(struct bios_smap);
+		v86.edx = SMAP_SIG;
+		v86.es = VTOPSEG(&smap);
+		v86.edi = VTOPOFF(&smap);
+		v86int();
+		if ((v86.efl & 1) || (v86.eax != SMAP_SIG))
+			break;
+		n++;
+	} while (v86.ebx != 0);
+	if (n == 0)
+		return;
+	n += 10;	/* spare room */
+	smapbase = malloc(n * sizeof(*smapbase));
+
+	/* Save system memory map */
+	v86.ebx = 0;
+	do {
+		v86.ctl = V86_FLAGS;
+		v86.addr = 0x15;		/* int 0x15 function 0xe820*/
+		v86.eax = 0xe820;
+		v86.ecx = sizeof(struct bios_smap);
+		v86.edx = SMAP_SIG;
+		v86.es = VTOPSEG(&smap);
+		v86.edi = VTOPOFF(&smap);
+		v86int();
+		bcopy(&smap, &smapbase[smaplen], sizeof(struct bios_smap));
+		smaplen++;
+		if ((v86.efl & 1) || (v86.eax != SMAP_SIG))
+			break;
+	} while (v86.ebx != 0 && smaplen < n);
+}
+
+void
+bios_addsmapdata(struct preloaded_file *kfp)
+{
+	int len;
+
+	if (smapbase == 0 || smaplen == 0)
+		return;
+	len = smaplen * sizeof(*smapbase);
+	file_addmetadata(kfp, MODINFOMD_SMAP, len, smapbase);
+}
+
+COMMAND_SET(smap, "smap", "show BIOS SMAP", command_smap);
+
+static int
+command_smap(int argc, char *argv[])
+{
+	int i;
+
+	if (smapbase == 0 || smaplen == 0)
+		return (CMD_ERROR);
+	for (i = 0; i < smaplen; i++)
+		printf("SMAP type=%02x base=%016llx len=%016llx\n",
+		    smapbase[i].type, smapbase[i].base, smapbase[i].length);
+	return (CMD_OK);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/bootinfo.c sys/boot/i386/pxe_ng/libi386/bootinfo.c
--- sys/boot/i386/pxe_ng/libi386/bootinfo.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/bootinfo.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,192 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <sys/param.h>
+#include <sys/reboot.h>
+#include <sys/linker.h>
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+/*
+ * Return a 'boothowto' value corresponding to the kernel arguments in
+ * (kargs) and any relevant environment variables.
+ */
+static struct 
+{
+    const char	*ev;
+    int		mask;
+} howto_names[] = {
+    {"boot_askname",	RB_ASKNAME},
+    {"boot_cdrom",	RB_CDROM},
+    {"boot_ddb",	RB_KDB},
+    {"boot_dfltroot",	RB_DFLTROOT},
+    {"boot_gdb",	RB_GDB},
+    {"boot_multicons",	RB_MULTIPLE},
+    {"boot_mute",	RB_MUTE},
+    {"boot_pause",	RB_PAUSE},
+    {"boot_serial",	RB_SERIAL},
+    {"boot_single",	RB_SINGLE},
+    {"boot_verbose",	RB_VERBOSE},
+    {NULL,	0}
+};
+
+int
+bi_getboothowto(char *kargs)
+{
+    char	*cp;
+    char	*curpos, *next, *string;
+    int		howto;
+    int		active;
+    int		i;
+    int		vidconsole;
+
+    /* Parse kargs */
+    howto = 0;
+    if (kargs  != NULL) {
+	cp = kargs;
+	active = 0;
+	while (*cp != 0) {
+	    if (!active && (*cp == '-')) {
+		active = 1;
+	    } else if (active)
+		switch (*cp) {
+		case 'a':
+		    howto |= RB_ASKNAME;
+		    break;
+		case 'C':
+		    howto |= RB_CDROM;
+		    break;
+		case 'd':
+		    howto |= RB_KDB;
+		    break;
+		case 'D':
+		    howto |= RB_MULTIPLE;
+		    break;
+		case 'm':
+		    howto |= RB_MUTE;
+		    break;
+		case 'g':
+		    howto |= RB_GDB;
+		    break;
+		case 'h':
+		    howto |= RB_SERIAL;
+		    break;
+		case 'p':
+		    howto |= RB_PAUSE;
+		    break;
+		case 'r':
+		    howto |= RB_DFLTROOT;
+		    break;
+		case 's':
+		    howto |= RB_SINGLE;
+		    break;
+		case 'v':
+		    howto |= RB_VERBOSE;
+		    break;
+		default:
+		    active = 0;
+		    break;
+		}
+	    cp++;
+	}
+    }
+    /* get equivalents from the environment */
+    for (i = 0; howto_names[i].ev != NULL; i++)
+	if (getenv(howto_names[i].ev) != NULL)
+	    howto |= howto_names[i].mask;
+
+    /* Enable selected consoles */
+    string = next = strdup(getenv("console"));
+    vidconsole = 0;
+    while (next != NULL) {
+	curpos = strsep(&next, " ,");
+	if (*curpos == '\0')
+		continue;
+	if (!strcmp(curpos, "vidconsole"))
+	    vidconsole = 1;
+	else if (!strcmp(curpos, "comconsole"))
+	    howto |= RB_SERIAL;
+	else if (!strcmp(curpos, "nullconsole"))
+	    howto |= RB_MUTE;
+    }
+
+    if (vidconsole && (howto & RB_SERIAL))
+	howto |= RB_MULTIPLE;
+
+    /*
+     * XXX: Note that until the kernel is ready to respect multiple consoles
+     * for the boot messages, the first named console is the primary console
+     */
+    if (!strcmp(string, "vidconsole"))
+	howto &= ~RB_SERIAL;
+
+    free(string);
+
+    return(howto);
+}
+
+void
+bi_setboothowto(int howto)
+{
+    int		i;
+
+    for (i = 0; howto_names[i].ev != NULL; i++)
+	if (howto & howto_names[i].mask)
+	    setenv(howto_names[i].ev, "YES", 1);
+}
+
+/*
+ * Copy the environment into the load area starting at (addr).
+ * Each variable is formatted as <name>=<value>, with a single nul
+ * separating each variable, and a double nul terminating the environment.
+ */
+vm_offset_t
+bi_copyenv(vm_offset_t addr)
+{
+    struct env_var	*ep;
+    
+    /* traverse the environment */
+    for (ep = environ; ep != NULL; ep = ep->ev_next) {
+	i386_copyin(ep->ev_name, addr, strlen(ep->ev_name));
+	addr += strlen(ep->ev_name);
+	i386_copyin("=", addr, 1);
+	addr++;
+	if (ep->ev_value != NULL) {
+	    i386_copyin(ep->ev_value, addr, strlen(ep->ev_value));
+	    addr += strlen(ep->ev_value);
+	}
+	i386_copyin("", addr, 1);
+	addr++;
+    }
+    i386_copyin("", addr, 1);
+    addr++;
+    return(addr);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/bootinfo32.c sys/boot/i386/pxe_ng/libi386/bootinfo32.c
--- sys/boot/i386/pxe_ng/libi386/bootinfo32.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/bootinfo32.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,273 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <sys/param.h>
+#include <sys/reboot.h>
+#include <sys/linker.h>
+#include <machine/bootinfo.h>
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+static struct bootinfo  bi;
+
+/*
+ * Copy module-related data into the load area, where it can be
+ * used as a directory for loaded modules.
+ *
+ * Module data is presented in a self-describing format.  Each datum
+ * is preceded by a 32-bit identifier and a 32-bit size field.
+ *
+ * Currently, the following data are saved:
+ *
+ * MOD_NAME	(variable)		module name (string)
+ * MOD_TYPE	(variable)		module type (string)
+ * MOD_ARGS	(variable)		module parameters (string)
+ * MOD_ADDR	sizeof(vm_offset_t)	module load address
+ * MOD_SIZE	sizeof(size_t)		module size
+ * MOD_METADATA	(variable)		type-specific metadata
+ */
+#define COPY32(v, a, c) {			\
+    u_int32_t	x = (v);			\
+    if (c)					\
+	i386_copyin(&x, a, sizeof(x));		\
+    a += sizeof(x);				\
+}
+
+#define MOD_STR(t, a, s, c) {			\
+    COPY32(t, a, c);				\
+    COPY32(strlen(s) + 1, a, c);		\
+    if (c)					\
+	i386_copyin(s, a, strlen(s) + 1);	\
+    a += roundup(strlen(s) + 1, sizeof(u_long));\
+}
+
+#define MOD_NAME(a, s, c)	MOD_STR(MODINFO_NAME, a, s, c)
+#define MOD_TYPE(a, s, c)	MOD_STR(MODINFO_TYPE, a, s, c)
+#define MOD_ARGS(a, s, c)	MOD_STR(MODINFO_ARGS, a, s, c)
+
+#define MOD_VAR(t, a, s, c) {			\
+    COPY32(t, a, c);				\
+    COPY32(sizeof(s), a, c);			\
+    if (c)					\
+	i386_copyin(&s, a, sizeof(s));		\
+    a += roundup(sizeof(s), sizeof(u_long));	\
+}
+
+#define MOD_ADDR(a, s, c)	MOD_VAR(MODINFO_ADDR, a, s, c)
+#define MOD_SIZE(a, s, c)	MOD_VAR(MODINFO_SIZE, a, s, c)
+
+#define MOD_METADATA(a, mm, c) {		\
+    COPY32(MODINFO_METADATA | mm->md_type, a, c); \
+    COPY32(mm->md_size, a, c);			\
+    if (c)					\
+	i386_copyin(mm->md_data, a, mm->md_size); \
+    a += roundup(mm->md_size, sizeof(u_long));\
+}
+
+#define MOD_END(a, c) {				\
+    COPY32(MODINFO_END, a, c);			\
+    COPY32(0, a, c);				\
+}
+
+static vm_offset_t
+bi_copymodules32(vm_offset_t addr)
+{
+    struct preloaded_file	*fp;
+    struct file_metadata	*md;
+    int				c;
+
+    c = addr != 0;
+    /* start with the first module on the list, should be the kernel */
+    for (fp = file_findfile(NULL, NULL); fp != NULL; fp = fp->f_next) {
+
+	MOD_NAME(addr, fp->f_name, c);	/* this field must come first */
+	MOD_TYPE(addr, fp->f_type, c);
+	if (fp->f_args)
+	    MOD_ARGS(addr, fp->f_args, c);
+	MOD_ADDR(addr, fp->f_addr, c);
+	MOD_SIZE(addr, fp->f_size, c);
+	for (md = fp->f_metadata; md != NULL; md = md->md_next)
+	    if (!(md->md_type & MODINFOMD_NOCOPY))
+		MOD_METADATA(addr, md, c);
+    }
+    MOD_END(addr, c);
+    return(addr);
+}
+
+/*
+ * Load the information expected by an i386 kernel.
+ *
+ * - The 'boothowto' argument is constructed
+ * - The 'bootdev' argument is constructed
+ * - The 'bootinfo' struct is constructed, and copied into the kernel space.
+ * - The kernel environment is copied into kernel space.
+ * - Module metadata are formatted and placed in kernel space.
+ */
+int
+bi_load32(char *args, int *howtop, int *bootdevp, vm_offset_t *bip, vm_offset_t *modulep, vm_offset_t *kernendp)
+{
+    struct preloaded_file	*xp, *kfp;
+    struct i386_devdesc		*rootdev;
+    struct file_metadata	*md;
+    vm_offset_t			addr;
+    vm_offset_t			kernend;
+    vm_offset_t			envp;
+    vm_offset_t			size;
+    vm_offset_t			ssym, esym;
+    char			*rootdevname;
+    int				bootdevnr, i, howto;
+    char			*kernelname;
+    const char			*kernelpath;
+
+    howto = bi_getboothowto(args);
+
+    /* 
+     * Allow the environment variable 'rootdev' to override the supplied device 
+     * This should perhaps go to MI code and/or have $rootdev tested/set by
+     * MI code before launching the kernel.
+     */
+    rootdevname = getenv("rootdev");
+    i386_getdev((void **)(&rootdev), rootdevname, NULL);
+    if (rootdev == NULL) {		/* bad $rootdev/$currdev */
+	printf("can't determine root device\n");
+	return(EINVAL);
+    }
+
+    /* Try reading the /etc/fstab file to select the root device */
+    getrootmount(i386_fmtdev((void *)rootdev));
+
+    /* Do legacy rootdev guessing */
+
+    /* XXX - use a default bootdev of 0.  Is this ok??? */
+    bootdevnr = 0;
+
+    switch(rootdev->d_type) {
+    case DEVT_CD:
+	    /* Pass in BIOS device number. */
+	    bi.bi_bios_dev = bc_unit2bios(rootdev->d_unit);
+	    bootdevnr = bc_getdev(rootdev);
+	    break;
+
+    case DEVT_DISK:
+	/* pass in the BIOS device number of the current disk */
+	bi.bi_bios_dev = bd_unit2bios(rootdev->d_unit);
+	bootdevnr = bd_getdev(rootdev);
+	break;
+
+    case DEVT_NET:
+	    break;
+	    
+    default:
+	printf("WARNING - don't know how to boot from device type %d\n", rootdev->d_type);
+    }
+    if (bootdevnr == -1) {
+	printf("root device %s invalid\n", i386_fmtdev(rootdev));
+	return (EINVAL);
+    }
+    free(rootdev);
+
+    /* find the last module in the chain */
+    addr = 0;
+    for (xp = file_findfile(NULL, NULL); xp != NULL; xp = xp->f_next) {
+	if (addr < (xp->f_addr + xp->f_size))
+	    addr = xp->f_addr + xp->f_size;
+    }
+    /* pad to a page boundary */
+    addr = roundup(addr, PAGE_SIZE);
+
+    /* copy our environment */
+    envp = addr;
+    addr = bi_copyenv(addr);
+
+    /* pad to a page boundary */
+    addr = roundup(addr, PAGE_SIZE);
+
+    kfp = file_findfile(NULL, "elf kernel");
+    if (kfp == NULL)
+      kfp = file_findfile(NULL, "elf32 kernel");
+    if (kfp == NULL)
+	panic("can't find kernel file");
+    kernend = 0;	/* fill it in later */
+    file_addmetadata(kfp, MODINFOMD_HOWTO, sizeof howto, &howto);
+    file_addmetadata(kfp, MODINFOMD_ENVP, sizeof envp, &envp);
+    file_addmetadata(kfp, MODINFOMD_KERNEND, sizeof kernend, &kernend);
+    bios_addsmapdata(kfp);
+
+    /* Figure out the size and location of the metadata */
+    *modulep = addr;
+    size = bi_copymodules32(0);
+    kernend = roundup(addr + size, PAGE_SIZE);
+    *kernendp = kernend;
+
+    /* patch MODINFOMD_KERNEND */
+    md = file_findmetadata(kfp, MODINFOMD_KERNEND);
+    bcopy(&kernend, md->md_data, sizeof kernend);
+
+    /* copy module list and metadata */
+    (void)bi_copymodules32(addr);
+
+    ssym = esym = 0;
+    md = file_findmetadata(kfp, MODINFOMD_SSYM);
+    if (md != NULL)
+	ssym = *((vm_offset_t *)&(md->md_data));
+    md = file_findmetadata(kfp, MODINFOMD_ESYM);
+    if (md != NULL)
+	esym = *((vm_offset_t *)&(md->md_data));
+    if (ssym == 0 || esym == 0)
+	ssym = esym = 0;		/* sanity */
+
+    /* legacy bootinfo structure */
+    kernelname = getenv("kernelname");
+    i386_getdev(NULL, kernelname, &kernelpath);
+    bi.bi_version = BOOTINFO_VERSION;
+    bi.bi_kernelname = 0;		/* XXX char * -> kernel name */
+    bi.bi_nfs_diskless = 0;		/* struct nfs_diskless * */
+    bi.bi_n_bios_used = 0;		/* XXX would have to hook biosdisk driver for these */
+    for (i = 0; i < N_BIOS_GEOM; i++)
+        bi.bi_bios_geom[i] = bd_getbigeom(i);
+    bi.bi_size = sizeof(bi);
+    bi.bi_memsizes_valid = 1;
+    bi.bi_basemem = bios_basemem / 1024;
+    bi.bi_extmem = bios_extmem / 1024;
+    bi.bi_envp = envp;
+    bi.bi_modulep = *modulep;
+    bi.bi_kernend = kernend;
+    bi.bi_kernelname = VTOP(kernelpath);
+    bi.bi_symtab = ssym;       /* XXX this is only the primary kernel symtab */
+    bi.bi_esymtab = esym;
+
+    /* legacy boot arguments */
+    *howtop = howto | RB_BOOTINFO;
+    *bootdevp = bootdevnr;
+    *bip = VTOP(&bi);
+
+    return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/bootinfo64.c sys/boot/i386/pxe_ng/libi386/bootinfo64.c
--- sys/boot/i386/pxe_ng/libi386/bootinfo64.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/bootinfo64.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,252 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <sys/param.h>
+#include <sys/reboot.h>
+#include <sys/linker.h>
+#include <machine/bootinfo.h>
+#include <machine/cpufunc.h>
+#include <machine/psl.h>
+#include <machine/specialreg.h>
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+/*
+ * Copy module-related data into the load area, where it can be
+ * used as a directory for loaded modules.
+ *
+ * Module data is presented in a self-describing format.  Each datum
+ * is preceded by a 32-bit identifier and a 32-bit size field.
+ *
+ * Currently, the following data are saved:
+ *
+ * MOD_NAME	(variable)		module name (string)
+ * MOD_TYPE	(variable)		module type (string)
+ * MOD_ARGS	(variable)		module parameters (string)
+ * MOD_ADDR	sizeof(vm_offset_t)	module load address
+ * MOD_SIZE	sizeof(size_t)		module size
+ * MOD_METADATA	(variable)		type-specific metadata
+ */
+#define COPY32(v, a, c) {			\
+    u_int32_t	x = (v);			\
+    if (c)					\
+	i386_copyin(&x, a, sizeof(x));		\
+    a += sizeof(x);				\
+}
+
+#define MOD_STR(t, a, s, c) {			\
+    COPY32(t, a, c);				\
+    COPY32(strlen(s) + 1, a, c);		\
+    if (c)					\
+	i386_copyin(s, a, strlen(s) + 1);	\
+    a += roundup(strlen(s) + 1, sizeof(u_int64_t));\
+}
+
+#define MOD_NAME(a, s, c)	MOD_STR(MODINFO_NAME, a, s, c)
+#define MOD_TYPE(a, s, c)	MOD_STR(MODINFO_TYPE, a, s, c)
+#define MOD_ARGS(a, s, c)	MOD_STR(MODINFO_ARGS, a, s, c)
+
+#define MOD_VAR(t, a, s, c) {			\
+    COPY32(t, a, c);				\
+    COPY32(sizeof(s), a, c);			\
+    if (c)					\
+	i386_copyin(&s, a, sizeof(s));		\
+    a += roundup(sizeof(s), sizeof(u_int64_t));	\
+}
+
+#define MOD_ADDR(a, s, c)	MOD_VAR(MODINFO_ADDR, a, s, c)
+#define MOD_SIZE(a, s, c)	MOD_VAR(MODINFO_SIZE, a, s, c)
+
+#define MOD_METADATA(a, mm, c) {		\
+    COPY32(MODINFO_METADATA | mm->md_type, a, c); \
+    COPY32(mm->md_size, a, c);			\
+    if (c)					\
+	i386_copyin(mm->md_data, a, mm->md_size); \
+    a += roundup(mm->md_size, sizeof(u_int64_t));\
+}
+
+#define MOD_END(a, c) {				\
+    COPY32(MODINFO_END, a, c);			\
+    COPY32(0, a, c);				\
+}
+
+static vm_offset_t
+bi_copymodules64(vm_offset_t addr)
+{
+    struct preloaded_file	*fp;
+    struct file_metadata	*md;
+    int				c;
+    u_int64_t			v;
+
+    c = addr != 0;
+    /* start with the first module on the list, should be the kernel */
+    for (fp = file_findfile(NULL, NULL); fp != NULL; fp = fp->f_next) {
+
+	MOD_NAME(addr, fp->f_name, c);	/* this field must come first */
+	MOD_TYPE(addr, fp->f_type, c);
+	if (fp->f_args)
+	    MOD_ARGS(addr, fp->f_args, c);
+	v = fp->f_addr;
+	MOD_ADDR(addr, v, c);
+	v = fp->f_size;
+	MOD_SIZE(addr, v, c);
+	for (md = fp->f_metadata; md != NULL; md = md->md_next)
+	    if (!(md->md_type & MODINFOMD_NOCOPY))
+		MOD_METADATA(addr, md, c);
+    }
+    MOD_END(addr, c);
+    return(addr);
+}
+
+/*
+ * Check to see if this CPU supports long mode.
+ */
+static int
+bi_checkcpu(void)
+{
+    char *cpu_vendor;
+    int vendor[3];
+    int eflags, regs[4];
+
+    /* Check for presence of "cpuid". */
+    eflags = read_eflags();
+    write_eflags(eflags ^ PSL_ID);
+    if (!((eflags ^ read_eflags()) & PSL_ID))
+	return (0);
+
+    /* Fetch the vendor string. */
+    do_cpuid(0, regs);
+    vendor[0] = regs[1];
+    vendor[1] = regs[3];
+    vendor[2] = regs[2];
+    cpu_vendor = (char *)vendor;
+
+    /* Check for vendors that support AMD features. */
+    if (strncmp(cpu_vendor, "GenuineIntel", 12) != 0 &&
+	strncmp(cpu_vendor, "AuthenticAMD", 12) != 0)
+	return (0);
+
+    /* Has to support AMD features. */
+    do_cpuid(0x80000000, regs);
+    if (!(regs[0] >= 0x80000001))
+	return (0);
+
+    /* Check for long mode. */
+    do_cpuid(0x80000001, regs);
+    return (regs[3] & AMDID_LM);
+}
+
+/*
+ * Load the information expected by an amd64 kernel.
+ *
+ * - The 'boothowto' argument is constructed
+ * - The 'bootdev' argument is constructed
+ * - The 'bootinfo' struct is constructed, and copied into the kernel space.
+ * - The kernel environment is copied into kernel space.
+ * - Module metadata are formatted and placed in kernel space.
+ */
+int
+bi_load64(char *args, vm_offset_t *modulep, vm_offset_t *kernendp)
+{
+    struct preloaded_file	*xp, *kfp;
+    struct i386_devdesc		*rootdev;
+    struct file_metadata	*md;
+    vm_offset_t			addr;
+    u_int64_t			kernend;
+    u_int64_t			envp;
+    vm_offset_t			size;
+    char			*rootdevname;
+    int				howto;
+
+    if (!bi_checkcpu()) {
+	printf("CPU doesn't support long mode\n");
+	return (EINVAL);
+    }
+
+    howto = bi_getboothowto(args);
+
+    /* 
+     * Allow the environment variable 'rootdev' to override the supplied device 
+     * This should perhaps go to MI code and/or have $rootdev tested/set by
+     * MI code before launching the kernel.
+     */
+    rootdevname = getenv("rootdev");
+    i386_getdev((void **)(&rootdev), rootdevname, NULL);
+    if (rootdev == NULL) {		/* bad $rootdev/$currdev */
+	printf("can't determine root device\n");
+	return(EINVAL);
+    }
+
+    /* Try reading the /etc/fstab file to select the root device */
+    getrootmount(i386_fmtdev((void *)rootdev));
+
+    /* find the last module in the chain */
+    addr = 0;
+    for (xp = file_findfile(NULL, NULL); xp != NULL; xp = xp->f_next) {
+	if (addr < (xp->f_addr + xp->f_size))
+	    addr = xp->f_addr + xp->f_size;
+    }
+    /* pad to a page boundary */
+    addr = roundup(addr, PAGE_SIZE);
+
+    /* copy our environment */
+    envp = addr;
+    addr = bi_copyenv(addr);
+
+    /* pad to a page boundary */
+    addr = roundup(addr, PAGE_SIZE);
+
+    kfp = file_findfile(NULL, "elf kernel");
+    if (kfp == NULL)
+      kfp = file_findfile(NULL, "elf64 kernel");
+    if (kfp == NULL)
+	panic("can't find kernel file");
+    kernend = 0;	/* fill it in later */
+    file_addmetadata(kfp, MODINFOMD_HOWTO, sizeof howto, &howto);
+    file_addmetadata(kfp, MODINFOMD_ENVP, sizeof envp, &envp);
+    file_addmetadata(kfp, MODINFOMD_KERNEND, sizeof kernend, &kernend);
+    bios_addsmapdata(kfp);
+
+    /* Figure out the size and location of the metadata */
+    *modulep = addr;
+    size = bi_copymodules64(0);
+    kernend = roundup(addr + size, PAGE_SIZE);
+    *kernendp = kernend;
+
+    /* patch MODINFOMD_KERNEND */
+    md = file_findmetadata(kfp, MODINFOMD_KERNEND);
+    bcopy(&kernend, md->md_data, sizeof kernend);
+
+    /* copy module list and metadata */
+    (void)bi_copymodules64(addr);
+
+    return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/comconsole.c sys/boot/i386/pxe_ng/libi386/comconsole.c
--- sys/boot/i386/pxe_ng/libi386/comconsole.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/comconsole.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,213 @@
+/*-
+ * Copyright (c) 1998 Michael Smith (msmith@freebsd.org)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <bootstrap.h>
+#include <machine/cpufunc.h>
+#include <dev/ic/ns16550.h>
+#include "libi386.h"
+
+#define COMC_FMT	0x3		/* 8N1 */
+#define COMC_TXWAIT	0x40000		/* transmit timeout */
+#define COMC_BPS(x)	(115200 / (x))	/* speed to DLAB divisor */
+#define COMC_DIV2BPS(x)	(115200 / (x))	/* DLAB divisor to speed */
+
+#ifndef	COMPORT
+#define COMPORT		0x3f8
+#endif
+#ifndef	COMSPEED
+#define COMSPEED	9600
+#endif
+
+static void	comc_probe(struct console *cp);
+static int	comc_init(int arg);
+static void	comc_putchar(int c);
+static int	comc_getchar(void);
+static int	comc_getspeed(void);
+static int	comc_ischar(void);
+static int	comc_parsespeed(const char *string);
+static void	comc_setup(int speed);
+static int	comc_speed_set(struct env_var *ev, int flags,
+		    const void *value);
+
+static int	comc_started;
+static int	comc_curspeed;
+
+struct console comconsole = {
+    "comconsole",
+    "serial port",
+    0,
+    comc_probe,
+    comc_init,
+    comc_putchar,
+    comc_getchar,
+    comc_ischar
+};
+
+static void
+comc_probe(struct console *cp)
+{
+    char speedbuf[16];
+    char *cons, *speedenv;
+    int speed;
+
+    /* XXX check the BIOS equipment list? */
+    cp->c_flags |= (C_PRESENTIN | C_PRESENTOUT);
+
+    if (comc_curspeed == 0) {
+	comc_curspeed = COMSPEED;
+	/*
+	 * Assume that the speed was set by an earlier boot loader if
+	 * comconsole is already the preferred console.
+	 */
+	cons = getenv("console");
+	if ((cons != NULL && strcmp(cons, comconsole.c_name) == 0) ||
+	    getenv("boot_multicons") != NULL) {
+		comc_curspeed = comc_getspeed();
+	}
+	speedenv = getenv("comconsole_speed");
+	if (speedenv != NULL) {
+	    speed = comc_parsespeed(speedenv);
+	    if (speed > 0)
+		comc_curspeed = speed;
+	}
+
+	sprintf(speedbuf, "%d", comc_curspeed);
+	unsetenv("comconsole_speed");
+	env_setenv("comconsole_speed", EV_VOLATILE, speedbuf, comc_speed_set,
+	    env_nounset);
+    }
+}
+
+static int
+comc_init(int arg)
+{
+    if (comc_started && arg == 0)
+	return 0;
+    comc_started = 1;
+
+    comc_setup(comc_curspeed);
+
+    return(0);
+}
+
+static void
+comc_putchar(int c)
+{
+    int wait;
+
+    for (wait = COMC_TXWAIT; wait > 0; wait--)
+        if (inb(COMPORT + com_lsr) & LSR_TXRDY) {
+	    outb(COMPORT + com_data, (u_char)c);
+	    break;
+	}
+}
+
+static int
+comc_getchar(void)
+{
+    return(comc_ischar() ? inb(COMPORT + com_data) : -1);
+}
+
+static int
+comc_ischar(void)
+{
+    return(inb(COMPORT + com_lsr) & LSR_RXRDY);
+}
+
+static int
+comc_speed_set(struct env_var *ev, int flags, const void *value)
+{
+    int speed;
+
+    if (value == NULL || (speed = comc_parsespeed(value)) <= 0) {
+	printf("Invalid speed\n");
+	return (CMD_ERROR);
+    }
+
+    if (comc_started && comc_curspeed != speed)
+	comc_setup(speed);
+
+    env_setenv(ev->ev_name, flags | EV_NOHOOK, value, NULL, NULL);
+
+    return (CMD_OK);
+}
+
+static void
+comc_setup(int speed)
+{
+
+    comc_curspeed = speed;
+
+    outb(COMPORT + com_cfcr, CFCR_DLAB | COMC_FMT);
+    outb(COMPORT + com_dlbl, COMC_BPS(speed) & 0xff);
+    outb(COMPORT + com_dlbh, COMC_BPS(speed) >> 8);
+    outb(COMPORT + com_cfcr, COMC_FMT);
+    outb(COMPORT + com_mcr, MCR_RTS | MCR_DTR);
+
+    do
+        inb(COMPORT + com_data);
+    while (inb(COMPORT + com_lsr) & LSR_RXRDY);
+}
+
+static int
+comc_parsespeed(const char *speedstr)
+{
+    char *p;
+    int speed;
+
+    speed = strtol(speedstr, &p, 0);
+    if (p == speedstr || *p != '\0' || speed <= 0)
+	return (-1);
+
+    return (speed);
+}
+
+static int
+comc_getspeed(void)
+{
+	u_int	divisor;
+	u_char	dlbh;
+	u_char	dlbl;
+	u_char	cfcr;
+
+	cfcr = inb(COMPORT + com_cfcr);
+	outb(COMPORT + com_cfcr, CFCR_DLAB | cfcr);
+
+	dlbl = inb(COMPORT + com_dlbl);
+	dlbh = inb(COMPORT + com_dlbh);
+
+	outb(COMPORT + com_cfcr, cfcr);
+
+	divisor = dlbh << 8 | dlbl;
+
+	/* XXX there should be more sanity checking. */
+	if (divisor == 0)
+		return (COMSPEED);
+	return (COMC_DIV2BPS(divisor));
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/devicename.c sys/boot/i386/pxe_ng/libi386/devicename.c
--- sys/boot/i386/pxe_ng/libi386/devicename.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/devicename.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,258 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <string.h>
+#include <sys/disklabel.h>
+#include "bootstrap.h"
+#include "libi386.h"
+
+static int	i386_parsedev(struct i386_devdesc **dev, const char *devspec, const char **path);
+
+/* 
+ * Point (dev) at an allocated device specifier for the device matching the
+ * path in (devspec). If it contains an explicit device specification,
+ * use that.  If not, use the default device.
+ */
+int
+i386_getdev(void **vdev, const char *devspec, const char **path)
+{
+    struct i386_devdesc **dev = (struct i386_devdesc **)vdev;
+    int				rv;
+    
+    /*
+     * If it looks like this is just a path and no
+     * device, go with the current device.
+     */
+    if ((devspec == NULL) || 
+	(devspec[0] == '/') || 
+	(strchr(devspec, ':') == NULL)) {
+
+	if (((rv = i386_parsedev(dev, getenv("currdev"), NULL)) == 0) &&
+	    (path != NULL))
+		*path = devspec;
+	return(rv);
+    }
+    
+    /*
+     * Try to parse the device name off the beginning of the devspec
+     */
+    return(i386_parsedev(dev, devspec, path));
+}
+
+/*
+ * Point (dev) at an allocated device specifier matching the string version
+ * at the beginning of (devspec).  Return a pointer to the remaining
+ * text in (path).
+ *
+ * In all cases, the beginning of (devspec) is compared to the names
+ * of known devices in the device switch, and then any following text
+ * is parsed according to the rules applied to the device type.
+ *
+ * For disk-type devices, the syntax is:
+ *
+ * disk<unit>[s<slice>][<partition>]:
+ * 
+ */
+static int
+i386_parsedev(struct i386_devdesc **dev, const char *devspec, const char **path)
+{
+    struct i386_devdesc *idev;
+    struct devsw	*dv;
+    int			i, unit, slice, partition, err;
+    char		*cp;
+    const char		*np;
+
+    /* minimum length check */
+    if (strlen(devspec) < 2)
+	return(EINVAL);
+
+    /* look for a device that matches */
+    for (i = 0, dv = NULL; devsw[i] != NULL; i++) {
+	if (!strncmp(devspec, devsw[i]->dv_name, strlen(devsw[i]->dv_name))) {
+	    dv = devsw[i];
+	    break;
+	}
+    }
+    if (dv == NULL)
+	return(ENOENT);
+    idev = malloc(sizeof(struct i386_devdesc));
+    err = 0;
+    np = (devspec + strlen(dv->dv_name));
+        
+    switch(dv->dv_type) {
+    case DEVT_NONE:			/* XXX what to do here?  Do we care? */
+	break;
+
+    case DEVT_DISK:
+	unit = -1;
+	slice = -1;
+	partition = -1;
+	if (*np && (*np != ':')) {
+	    unit = strtol(np, &cp, 10);	/* next comes the unit number */
+	    if (cp == np) {
+		err = EUNIT;
+		goto fail;
+	    }
+	    if (*cp == 'p') {		/* got a GPT partition */
+		np = cp + 1;
+		slice = strtol(np, &cp, 10);
+		if (cp == np) {
+		    err = ESLICE;
+		    goto fail;
+		}
+		if (*cp && (*cp != ':')) {
+		    err = EINVAL;
+		    goto fail;
+		}
+		partition = 0xff;
+	    } else {
+		if (*cp == 's') {		/* got a slice number */
+		    np = cp + 1;
+		    slice = strtol(np, &cp, 10);
+		    if (cp == np) {
+			err = ESLICE;
+			goto fail;
+		    }
+		}
+		if (*cp && (*cp != ':')) {
+		    partition = *cp - 'a';	/* got a partition number */
+		    if ((partition < 0) || (partition >= MAXPARTITIONS)) {
+			err = EPART;
+			goto fail;
+		    }
+		    cp++;
+		}
+	    }
+	}
+	if (*cp && (*cp != ':')) {
+	    err = EINVAL;
+	    goto fail;
+	}
+
+	idev->d_unit = unit;
+	idev->d_kind.biosdisk.slice = slice;
+	idev->d_kind.biosdisk.partition = partition;
+	if (path != NULL)
+	    *path = (*cp == 0) ? cp : cp + 1;
+	break;
+
+    case DEVT_CD:
+    case DEVT_NET:
+	unit = 0;
+
+	if (*np && (*np != ':')) {
+	    unit = strtol(np, &cp, 0);	/* get unit number if present */
+	    if (cp == np) {
+		err = EUNIT;
+		goto fail;
+	    }
+	}
+	if (*cp && (*cp != ':')) {
+	    err = EINVAL;
+	    goto fail;
+	}
+
+	idev->d_unit = unit;
+	if (path != NULL)
+	    *path = (*cp == 0) ? cp : cp + 1;
+	break;
+
+    default:
+	err = EINVAL;
+	goto fail;
+    }
+    idev->d_dev = dv;
+    idev->d_type = dv->dv_type;
+    if (dev == NULL) {
+	free(idev);
+    } else {
+	*dev = idev;
+    }
+    return(0);
+
+ fail:
+    free(idev);
+    return(err);
+}
+
+
+char *
+i386_fmtdev(void *vdev)
+{
+    struct i386_devdesc	*dev = (struct i386_devdesc *)vdev;
+    static char		buf[128];	/* XXX device length constant? */
+    char		*cp;
+    
+    switch(dev->d_type) {
+    case DEVT_NONE:
+	strcpy(buf, "(no device)");
+	break;
+
+    case DEVT_CD:
+	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_unit);
+	break;
+
+    case DEVT_DISK:
+	cp = buf;
+	cp += sprintf(cp, "%s%d", dev->d_dev->dv_name, dev->d_unit);
+	if (dev->d_kind.biosdisk.partition == 0xff) {
+	    cp += sprintf(cp, "p%d", dev->d_kind.biosdisk.slice);
+	} else {
+	    if (dev->d_kind.biosdisk.slice > 0)
+		cp += sprintf(cp, "s%d", dev->d_kind.biosdisk.slice);
+	    if (dev->d_kind.biosdisk.partition >= 0)
+		cp += sprintf(cp, "%c", dev->d_kind.biosdisk.partition + 'a');
+	}
+	strcat(cp, ":");
+	break;
+
+    case DEVT_NET:
+	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_unit);
+	break;
+    }
+    return(buf);
+}
+
+
+/*
+ * Set currdev to suit the value being supplied in (value)
+ */
+int
+i386_setcurrdev(struct env_var *ev, int flags, const void *value)
+{
+    struct i386_devdesc	*ncurr;
+    int			rv;
+
+    if ((rv = i386_parsedev(&ncurr, value, NULL)) != 0)
+	return(rv);
+    free(ncurr);
+    env_setenv(ev->ev_name, flags | EV_NOHOOK, value, NULL, NULL);
+    return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/elf32_freebsd.c sys/boot/i386/pxe_ng/libi386/elf32_freebsd.c
--- sys/boot/i386/pxe_ng/libi386/elf32_freebsd.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/elf32_freebsd.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,84 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/exec.h>
+#include <sys/linker.h>
+#include <string.h>
+#include <machine/bootinfo.h>
+#include <machine/elf.h>
+#include <stand.h>
+
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+static int	elf32_exec(struct preloaded_file *amp);
+static int	elf32_obj_exec(struct preloaded_file *amp);
+
+struct file_format i386_elf = { elf32_loadfile, elf32_exec };
+struct file_format i386_elf_obj = { elf32_obj_loadfile, elf32_obj_exec };
+
+/*
+ * There is an ELF kernel and one or more ELF modules loaded.  
+ * We wish to start executing the kernel image, so make such 
+ * preparations as are required, and do so.
+ */
+static int
+elf32_exec(struct preloaded_file *fp)
+{
+    struct file_metadata	*md;
+    Elf_Ehdr 			*ehdr;
+    vm_offset_t			entry, bootinfop, modulep, kernend;
+    int				boothowto, err, bootdev;
+
+    if ((md = file_findmetadata(fp, MODINFOMD_ELFHDR)) == NULL)
+	return(EFTYPE);			/* XXX actually EFUCKUP */
+    ehdr = (Elf_Ehdr *)&(md->md_data);
+
+    err = bi_load32(fp->f_args, &boothowto, &bootdev, &bootinfop, &modulep, &kernend);
+    if (err != 0)
+	return(err);
+    entry = ehdr->e_entry & 0xffffff;
+
+#ifdef DEBUG
+    printf("Start @ 0x%lx ...\n", entry);
+#endif
+
+    dev_cleanup();
+    __exec((void *)entry, boothowto, bootdev, 0, 0, 0, bootinfop, modulep, kernend);
+
+    panic("exec returned");
+}
+
+static int
+elf32_obj_exec(struct preloaded_file *fp)
+{
+	return (EFTYPE);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/elf64_freebsd.c sys/boot/i386/pxe_ng/libi386/elf64_freebsd.c
--- sys/boot/i386/pxe_ng/libi386/elf64_freebsd.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/elf64_freebsd.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,126 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#define __ELF_WORD_SIZE 64
+#include <sys/param.h>
+#include <sys/exec.h>
+#include <sys/linker.h>
+#include <string.h>
+#include <machine/bootinfo.h>
+#include <machine/elf.h>
+#include <stand.h>
+
+#include "bootstrap.h"
+#include "libi386.h"
+#include "btxv86.h"
+
+static int	elf64_exec(struct preloaded_file *amp);
+static int	elf64_obj_exec(struct preloaded_file *amp);
+
+struct file_format amd64_elf = { elf64_loadfile, elf64_exec };
+struct file_format amd64_elf_obj = { elf64_obj_loadfile, elf64_obj_exec };
+
+#define PG_V	0x001
+#define PG_RW	0x002
+#define PG_U	0x004
+#define PG_PS	0x080
+
+typedef u_int64_t p4_entry_t;
+typedef u_int64_t p3_entry_t;
+typedef u_int64_t p2_entry_t;
+extern p4_entry_t PT4[];
+extern p3_entry_t PT3[];
+extern p2_entry_t PT2[];
+
+u_int32_t entry_hi;
+u_int32_t entry_lo;
+
+extern void amd64_tramp();
+
+/*
+ * There is an ELF kernel and one or more ELF modules loaded.  
+ * We wish to start executing the kernel image, so make such 
+ * preparations as are required, and do so.
+ */
+static int
+elf64_exec(struct preloaded_file *fp)
+{
+    struct file_metadata	*md;
+    Elf_Ehdr 			*ehdr;
+    vm_offset_t			modulep, kernend;
+    int				err;
+    int				i;
+
+    if ((md = file_findmetadata(fp, MODINFOMD_ELFHDR)) == NULL)
+	return(EFTYPE);			/* XXX actually EFUCKUP */
+    ehdr = (Elf_Ehdr *)&(md->md_data);
+
+    err = bi_load64(fp->f_args, &modulep, &kernend);
+    if (err != 0)
+	return(err);
+
+    bzero(PT4, PAGE_SIZE);
+    bzero(PT3, PAGE_SIZE);
+    bzero(PT2, PAGE_SIZE);
+
+    /*
+     * This is kinda brutal, but every single 1GB VM memory segment points to
+     * the same first 1GB of physical memory.  But it is more than adequate.
+     */
+    for (i = 0; i < 512; i++) {
+	/* Each slot of the level 4 pages points to the same level 3 page */
+	PT4[i] = (p4_entry_t)VTOP((uintptr_t)&PT3[0]);
+	PT4[i] |= PG_V | PG_RW | PG_U;
+
+	/* Each slot of the level 3 pages points to the same level 2 page */
+	PT3[i] = (p3_entry_t)VTOP((uintptr_t)&PT2[0]);
+	PT3[i] |= PG_V | PG_RW | PG_U;
+
+	/* The level 2 page slots are mapped with 2MB pages for 1GB. */
+	PT2[i] = i * (2 * 1024 * 1024);
+	PT2[i] |= PG_V | PG_RW | PG_PS | PG_U;
+    }
+
+    entry_lo = ehdr->e_entry & 0xffffffff;
+    entry_hi = (ehdr->e_entry >> 32) & 0xffffffff;
+#ifdef DEBUG
+    printf("Start @ %#llx ...\n", ehdr->e_entry);
+#endif
+
+    dev_cleanup();
+    __exec((void *)VTOP(amd64_tramp), modulep, kernend);
+
+    panic("exec returned");
+}
+
+static int
+elf64_obj_exec(struct preloaded_file *fp)
+{
+	return (EFTYPE);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/i386_copy.c sys/boot/i386/pxe_ng/libi386/i386_copy.c
--- sys/boot/i386/pxe_ng/libi386/i386_copy.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/i386_copy.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,75 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * MD primitives supporting placement of module data 
+ *
+ * XXX should check load address/size against memory top.
+ */
+#include <stand.h>
+
+#include "libi386.h"
+#include "btxv86.h"
+
+ssize_t
+i386_copyin(const void *src, vm_offset_t dest, const size_t len)
+{
+    if (dest + len >= memtop) {
+	errno = EFBIG;
+	return(-1);
+    }
+
+    bcopy(src, PTOV(dest), len);
+    return(len);
+}
+
+ssize_t
+i386_copyout(const vm_offset_t src, void *dest, const size_t len)
+{
+    if (src + len >= memtop) {
+	errno = EFBIG;
+	return(-1);
+    }
+    
+    bcopy(PTOV(src), dest, len);
+    return(len);
+}
+
+
+ssize_t
+i386_readin(const int fd, vm_offset_t dest, const size_t len)
+{
+
+    if (dest + len >= memtop_copyin) {
+	errno = EFBIG;
+	return(-1);
+    }
+
+    return (read(fd, PTOV(dest), len));
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/i386_module.c sys/boot/i386/pxe_ng/libi386/i386_module.c
--- sys/boot/i386/pxe_ng/libi386/i386_module.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/i386_module.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,68 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * i386-specific module functionality.
+ *
+ */
+
+#include <stand.h>
+#include <string.h>
+
+#include "bootstrap.h"
+#include "libi386.h"
+
+/*
+ * Use voodoo to load modules required by current hardware.
+ */
+int
+i386_autoload(void)
+{
+    int		error;
+    int		disabled;
+    char	*rv;
+
+    /* XXX use PnP to locate stuff here */
+
+    /* autoload ACPI support */
+    /* XXX should be in 4th keyed off acpi_load */
+    disabled = 0;
+    rv = getenv("hint.acpi.0.disabled");
+    if (rv != NULL && strncmp(rv, "0", 1) != 0) {
+	disabled = 1;
+    }
+
+    if (getenv("acpi_load") && (!disabled)) {
+	error = mod_load("acpi", NULL, 0, NULL);
+	if (error != 0)
+	    printf("ACPI autoload failed - %s\n", strerror(error));
+    }
+
+    return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/libi386.h sys/boot/i386/pxe_ng/libi386/libi386.h
--- sys/boot/i386/pxe_ng/libi386/libi386.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/libi386.h	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,111 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+
+/*
+ * i386 fully-qualified device descriptor.
+ * Note, this must match the 'struct devdesc' declaration
+ * in bootstrap.h.
+ */
+struct i386_devdesc
+{
+    struct devsw	*d_dev;
+    int			d_type;
+    int			d_unit;
+    union 
+    {
+	struct 
+	{
+	    void	*data;
+	    int		slice;
+	    int		partition;
+	} biosdisk;
+	struct
+	{
+	    void	*data;
+	} bioscd;
+    } d_kind;
+};
+
+int	i386_getdev(void **vdev, const char *devspec, const char **path);
+char	*i386_fmtdev(void *vdev);
+int	i386_setcurrdev(struct env_var *ev, int flags, const void *value);
+
+extern struct devdesc	currdev;	/* our current device */
+
+#define MAXDEV	31			/* maximum number of distinct devices */
+
+/* exported devices XXX rename? */
+extern struct devsw bioscd;
+extern struct devsw biosdisk;
+extern struct devsw pxedisk;
+extern struct fs_ops pxe_fsops;
+
+int	bc_add(int biosdev);		/* Register CD booted from. */
+int	bc_getdev(struct i386_devdesc *dev);	/* return dev_t for (dev) */
+int	bc_bios2unit(int biosdev);	/* xlate BIOS device -> bioscd unit */
+int	bc_unit2bios(int unit);		/* xlate bioscd unit -> BIOS device */
+u_int32_t	bd_getbigeom(int bunit);	/* return geometry in bootinfo format */
+int	bd_bios2unit(int biosdev);		/* xlate BIOS device -> biosdisk unit */
+int	bd_unit2bios(int unit);			/* xlate biosdisk unit -> BIOS device */
+int	bd_getdev(struct i386_devdesc *dev);	/* return dev_t for (dev) */
+
+ssize_t	i386_copyin(const void *src, vm_offset_t dest, const size_t len);
+ssize_t	i386_copyout(const vm_offset_t src, void *dest, const size_t len);
+ssize_t	i386_readin(const int fd, vm_offset_t dest, const size_t len);
+
+struct preloaded_file;
+void	bios_addsmapdata(struct preloaded_file *);
+void	bios_getsmap(void);
+
+void	bios_getmem(void);
+extern u_int32_t	bios_basemem;				/* base memory in bytes */
+extern u_int32_t	bios_extmem;				/* extended memory in bytes */
+extern vm_offset_t	memtop;		/* last address of physical memory + 1 */
+extern vm_offset_t	memtop_copyin;	/* memtop less heap size for the cases */
+					/*  when heap is at the top of extended memory */
+					/*  for other cases - just the same as memtop */
+
+int biospci_find_devclass(uint32_t class, int index, uint32_t *locator);
+int biospci_write_config(uint32_t locator, int offset, int width, uint32_t val);
+int biospci_read_config(uint32_t locator, int offset, int width, uint32_t *val);
+
+void	biosacpi_detect(void);
+
+void	smbios_detect(void);
+
+int	i386_autoload(void);
+
+int	bi_getboothowto(char *kargs);
+void	bi_setboothowto(int howto);
+vm_offset_t	bi_copyenv(vm_offset_t addr);
+int	bi_load32(char *args, int *howtop, int *bootdevp, vm_offset_t *bip,
+	    vm_offset_t *modulep, vm_offset_t *kernend);
+int	bi_load64(char *args, vm_offset_t *modulep, vm_offset_t *kernend);
+
+void	pxe_enable(void *pxeinfo);
diff -ruN sys/boot/i386/pxe_ng/libi386/nullconsole.c sys/boot/i386/pxe_ng/libi386/nullconsole.c
--- sys/boot/i386/pxe_ng/libi386/nullconsole.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/nullconsole.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,88 @@
+/*-
+ * nullconsole.c
+ *
+ * Author: Doug Ambrisko <ambrisko@whistle.com>
+ * Copyright (c) 2000 Whistle Communications, Inc.
+ * All rights reserved.
+ * 
+ * Subject to the following obligations and disclaimer of warranty, use and
+ * redistribution of this software, in source or object code forms, with or
+ * without modifications are expressly permitted by Whistle Communications;
+ * provided, however, that:
+ * 1. Any and all reproductions of the source or object code must include the
+ *    copyright notice above and the following disclaimer of warranties; and
+ * 2. No rights are granted, in any manner or form, to use Whistle
+ *    Communications, Inc. trademarks, including the mark "WHISTLE
+ *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as
+ *    such appears in the above copyright notice or in the software.
+ * 
+ * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,
+ * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
+ * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY
+ * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS
+ * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.
+ * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES
+ * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING
+ * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <bootstrap.h>
+
+static void	nullc_probe(struct console *cp);
+static int	nullc_init(int arg);
+static void	nullc_putchar(int c);
+static int	nullc_getchar(void);
+static int	nullc_ischar(void);
+
+struct console nullconsole = {
+	"nullconsole",
+	"null port",
+	0,
+	nullc_probe,
+	nullc_init,
+	nullc_putchar,
+	nullc_getchar,
+	nullc_ischar
+};
+
+static void
+nullc_probe(struct console *cp)
+{
+	cp->c_flags |= (C_PRESENTIN | C_PRESENTOUT);
+}
+
+static int
+nullc_init(int arg)
+{
+	return(0);
+}
+
+static void
+nullc_putchar(int c)
+{
+}
+
+static int
+nullc_getchar(void)
+{
+	return(-1);
+}
+
+static int
+nullc_ischar(void)
+{
+	return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/pread.c sys/boot/i386/pxe_ng/libi386/pread.c
--- sys/boot/i386/pxe_ng/libi386/pread.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/pread.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,80 @@
+/*
+ * $NetBSD: pread.c,v 1.2 1997/03/22 01:48:38 thorpej Exp $
+ */
+
+/*-
+ * Copyright (c) 1996
+ *	Matthias Drochner.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project
+ *	by Matthias Drochner.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/* read into destination in flat addr space */
+
+#include <stand.h>
+
+#include "libi386.h"
+
+#ifdef SAVE_MEMORY
+#define BUFSIZE (1*1024)
+#else
+#define BUFSIZE (4*1024)
+#endif
+
+static char     buf[BUFSIZE];
+
+int 
+pread(fd, dest, size)
+	int             fd;
+	vm_offset_t         dest;
+	int             size;
+{
+	int             rsize;
+
+	rsize = size;
+	while (rsize > 0) {
+		int             count, got;
+
+		count = (rsize < BUFSIZE ? rsize : BUFSIZE);
+
+		got = read(fd, buf, count);
+		if (got < 0)
+			return (-1);
+
+		/* put to physical space */
+		vpbcopy(buf, dest, got);
+
+		dest += got;
+		rsize -= got;
+		if (got < count)
+			break;	/* EOF */
+	}
+	return (size - rsize);
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/pxe.c sys/boot/i386/pxe_ng/libi386/pxe.c
--- sys/boot/i386/pxe_ng/libi386/pxe.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/pxe.c	2009-03-02 20:19:59.000000000 -0500
@@ -0,0 +1,533 @@
+/*-
+ * Copyright (c) 2000 Alfred Perlstein <alfred@freebsd.org>
+ * Copyright (c) 2000 Paul Saab <ps@freebsd.org>
+ * Copyright (c) 2000 John Baldwin <jhb@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/pxe.c,v 1.23 2007/10/12 17:09:43 ps Exp $");
+
+#include <stand.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <netinet/in_systm.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+
+#include <net.h>
+#include <netif.h>
+#ifdef LOADER_NFS_SUPPORT
+#include <nfsv2.h>
+#endif
+
+#include <iodesc.h>
+
+#include <bootp.h>
+#include <bootstrap.h>
+#include "btxv86.h"
+#include "pxe.h"
+#include "pxe_core.h"
+#include "pxe_dhcp.h"
+#include "pxe_isr.h"
+#include "pxe_ip.h"
+#include "pxe_udp.h"
+
+#define	PXE_TFTP_BUFFER_SIZE	512
+
+#ifndef PXEHTTP_UDP_FOR_LIBSTAND
+extern uint8_t *scratch_buffer;
+extern uint8_t *data_buffer;
+#endif
+
+extern char	servername[256];
+static pxenv_t	*pxenv_p = NULL;        /* PXENV+ */
+static pxe_t	*pxe_p   = NULL;	/* !PXE */
+
+int		pxe_sock = -1;
+static int	pxe_opens = 0;
+
+void		pxe_enable(void *pxeinfo);
+
+static int	pxe_init(void);
+static int	pxe_strategy(void *devdata, int flag, daddr_t dblk,
+			     size_t size, char *buf, size_t *rsize);
+
+static int	pxe_open(struct open_file *f, ...);
+static int	pxe_close(struct open_file *f);
+static void	pxe_cleanup(void);
+static void	pxe_setnfshandle(char *rootpath);
+static void	pxe_print(int verbose);
+
+static int	pxe_netif_match(struct netif *nif, void *machdep_hint);
+static int	pxe_netif_probe(struct netif *nif, void *machdep_hint);
+static void	pxe_netif_init(struct iodesc *desc, void *machdep_hint);
+static int	pxe_netif_get(struct iodesc *desc, void *pkt, size_t len,
+			      time_t timeout);
+
+static int	pxe_netif_put(struct iodesc *desc, void *pkt, size_t len);
+static void	pxe_netif_end(struct netif *nif);
+
+extern struct	netif_stats	pxe_st[];
+
+struct		netif_dif pxe_ifs[] = {
+		/* dif_unit        dif_nsel        dif_stats       dif_private */
+		   {0,             1,              &pxe_st[0],     0}
+		};
+
+struct netif_stats pxe_st[NENTS(pxe_ifs)];
+
+struct netif_driver pxenetif = {
+	"pxenet",
+	pxe_netif_match,
+	pxe_netif_probe,
+	pxe_netif_init,
+	pxe_netif_get,
+	pxe_netif_put,
+	pxe_netif_end,
+	pxe_ifs,
+	NENTS(pxe_ifs)
+};
+
+struct netif_driver *netif_drivers[] = {
+	&pxenetif,
+	NULL
+};
+
+struct devsw pxedisk = {
+	"pxe", 
+	DEVT_NET,
+	pxe_init,
+	pxe_strategy, 
+	pxe_open, 
+	pxe_close, 
+	noioctl,
+	pxe_print,
+	pxe_cleanup
+};
+
+/* pxe_enable() - This function is called by the loader to enable PXE support
+ *		if we  are booted by PXE.
+ * in:
+ *	pxeinfo -  pointer is a pointer to the PXENV+ structure.
+ * out:
+ *	none
+ */
+void
+pxe_enable(void *pxeinfo)
+{
+
+	pxenv_p  = (pxenv_t *)pxeinfo;
+	pxe_p    = (pxe_t *)PTOV(pxenv_p->PXEPtr.segment * 16 +
+				 pxenv_p->PXEPtr.offset);
+}
+
+/* pxe_init() - inits pxe_core structs
+ * in:
+ *	none
+ * out:
+ *	2 - already initialized
+ *	1 - if pxe structures are found & initialized
+ *	0 - failed
+ */
+static int
+pxe_init(void)
+{
+
+	if (__pxe_nic_irq != 0)
+		return (2);
+		
+	return pxe_core_init(pxenv_p, pxe_p);
+}
+
+/* block device strategy function */
+static int
+pxe_strategy(void *devdata, int flag, daddr_t dblk, size_t size,
+		char *buf, size_t *rsize)
+{
+
+	return (EIO);
+}
+
+static void
+pxe_print(int verbose)
+{
+	printf("    pxenet0:    MAC %6D\n", pxe_get_mymac(), ":");
+	printf("        ISR:    at %x:%x (chained at: %x:%x)\n",
+	    __pxe_entry_seg, __pxe_entry_off,
+	    __chained_irq_seg, __chained_irq_off);
+	    
+	return;
+}
+																					     
+static int
+pxe_open(struct open_file *f, ...)
+{
+	va_list	args;
+	char	*devname = NULL;
+	int	i = 0;
+	
+        va_start(args, f);
+	devname = va_arg(args, char*);
+	va_end(args);
+	
+	if (pxe_opens == 0) {
+		/* Find network interface. */
+		if (pxe_sock < 0) {
+	    		pxe_sock = netif_open(devname);
+	    
+			if (pxe_sock < 0) {
+			        printf("pxe_open: netif_open() failed\n");
+				return (ENXIO);
+			}
+	    
+		}
+
+#ifdef 	PXE_BOOTP_USE_LIBSTAND
+		const PXE_IPADDR *addr = pxe_get_ip(PXE_IP_ROOT);
+
+		if ( (addr->ip == 0)) {
+			pxe_dhcp_query(0);
+			pxe_core_update_bootp();
+
+#ifdef PXEHTTP_UDP_FOR_LIBSTAND
+			gateip.s_addr = pxe_get_ip(PXE_IP_GATEWAY)->ip;
+			rootip.s_addr = pxe_get_ip(PXE_IP_ROOT)->ip;
+			netmask = pxe_get_ip(PXE_IP_NETMASK)->ip;
+			myip.s_addr = pxe_get_ip(PXE_IP_MY)->ip;
+			nameip.s_addr = pxe_get_ip(PXE_IP_NAMESERVER)->ip;
+#endif
+    		}
+#endif	/* PXE_BOOTP_USE_LIBSTAND */
+	}
+	++pxe_opens;
+	f->f_devdata = &pxe_sock;
+	
+	return (0);
+}
+
+static int
+pxe_close(struct open_file *f)
+{
+	/* On last close, do netif close, etc. */
+	f->f_devdata = NULL;
+    
+	if (pxe_opens)
+		--pxe_opens;
+	    
+	/* Not last close? */
+	if (pxe_opens > 0)
+		return (0);
+
+#ifdef LOADER_NFS_SUPPORT
+	/* get an NFS filehandle for our root filesystem */
+	pxe_setnfshandle(rootpath);
+#endif
+	if (pxe_sock >= 0) {
+#ifdef PXE_DEBUG
+		printf("pxe_close: calling netif_close()\n");
+#endif
+		netif_close(pxe_sock);
+		pxe_sock = -1;
+	}
+    
+	return (0);
+}
+
+static void
+pxe_cleanup(void)
+{
+	pxe_core_shutdown();
+}
+
+static int
+pxe_netif_match(struct netif *nif, void *machdep_hint)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_netif_match() called.");
+#endif
+	return (1);
+}
+
+
+static int
+pxe_netif_probe(struct netif *nif, void *machdep_hint)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_netif_probe() called.");
+#endif
+
+#ifdef PXEHTTP_UDP_FOR_LIBSTAND
+	if (__pxe_nic_irq == 0)
+		return (-1);
+#else
+        t_PXENV_UDP_OPEN *udpopen_p = (t_PXENV_UDP_OPEN *)scratch_buffer;
+
+        bzero(udpopen_p, sizeof(*udpopen_p));
+
+	const PXE_IPADDR *my = pxe_get_ip(PXE_IP_MY);
+        udpopen_p->src_ip = my->ip;
+	
+        pxe_core_call(PXENV_UDP_OPEN);
+
+	if (udpopen_p->status != 0) {
+	        printf("pxe_netif_probe: failed %x\n", udpopen_p->status);
+	        return (-1);
+	}
+#endif
+	return (0);
+}
+
+static void
+pxe_netif_end(struct netif *nif)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_netif_end() called.");
+#endif
+
+#ifndef PXEHTTP_UDP_FOR_LIBSTAND
+        t_PXENV_UDP_CLOSE *udpclose_p = (t_PXENV_UDP_CLOSE *)scratch_buffer;
+
+        bzero(udpclose_p, sizeof(*udpclose_p));
+
+        pxe_core_call(PXENV_UDP_CLOSE);
+
+	if (udpclose_p->status != 0)
+	        printf("pxe_end failed %x\n", udpclose_p->status);
+#endif
+}
+
+static void
+pxe_netif_init(struct iodesc *desc, void *machdep_hint)
+{
+	
+#ifdef PXE_DEBUG
+	printf("pxe_netif_init(): called.\n");
+#endif
+	uint8_t *mac = (uint8_t *)pxe_get_mymac();
+	
+	int i;
+	for (i = 0; i < 6; ++i)
+		desc->myea[i] = mac[i];
+
+	const PXE_IPADDR *my = pxe_get_ip(PXE_IP_MY);
+	desc->xid = my->ip;
+}
+
+static int
+pxe_netif_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_netif_get(): called.\n");
+#endif
+	return (len);
+}
+
+static int
+pxe_netif_put(struct iodesc *desc, void *pkt, size_t len)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_netif_put(): called.\n");
+#endif
+	return (len);
+}
+
+#if defined(LOADER_NFS_SUPPORT)
+/*
+ * Reach inside the libstand NFS code and dig out an NFS handle
+ * for the root filesystem.
+ */
+struct nfs_iodesc {
+	struct	iodesc	*iodesc;
+	off_t	off;
+	u_char	fh[NFS_FHSIZE];
+	/* structure truncated here */
+};
+
+extern struct	nfs_iodesc nfs_root_node;
+extern int      rpc_port;
+
+static void
+pxe_rpcmountcall()
+{
+	struct	iodesc *d;
+	int     error;
+
+	if (!(d = socktodesc(pxe_sock)))
+		return;
+        d->myport = htons(--rpc_port);
+        d->destip = rootip;
+	if ((error = nfs_getrootfh(d, rootpath, nfs_root_node.fh)) != 0) 
+		printf("NFS MOUNT RPC error: %d\n", error);
+	nfs_root_node.iodesc = d;
+}
+
+static void
+pxe_setnfshandle(char *rootpath)
+{
+	int	i;
+	u_char	*fh;
+	char	buf[2 * NFS_FHSIZE + 3], *cp;
+
+	/*
+	 * If NFS files were never opened, we need to do mount call
+	 * ourselves. Use nfs_root_node.iodesc as flag indicating
+	 * previous NFS usage.
+	 */
+	if (nfs_root_node.iodesc == NULL)
+		pxe_rpcmountcall();
+
+	fh = &nfs_root_node.fh[0];
+	buf[0] = 'X';
+	cp = &buf[1];
+	for (i = 0; i < NFS_FHSIZE; i++, cp += 2)
+		sprintf(cp, "%02x", fh[i]);
+	sprintf(cp, "X");
+	setenv("boot.nfsroot.nfshandle", buf, 1);
+}
+#endif
+
+#ifdef PXEHTTP_UDP_FOR_LIBSTAND
+/* new versions of udp send/recv functions  */
+ssize_t
+sendudp(struct iodesc *h, void *pkt, size_t len)
+{
+#ifdef PXE_DEBUG_HELL
+	printf("sendudp(): sending %u bytes  from me:%u -> %s:%u\n",
+		len, ntohs(h->myport),
+		inet_ntoa(h->destip), ntohs(h->destport));
+#endif
+	void *ipdata = pkt - sizeof(PXE_UDP_PACKET);
+	
+	PXE_IPADDR	dst;
+	dst.ip = h->destip.s_addr;
+
+	if (!pxe_udp_send(ipdata, &dst, ntohs(h->destport),
+		ntohs(h->myport), len + sizeof(PXE_UDP_PACKET)))
+	{
+		printf("sendudp(): failed\n");
+		return (-1);
+	}
+	
+	return (len);
+}
+
+ssize_t
+readudp(struct iodesc *h, void *pkt, size_t len, time_t timeout)
+{
+	PXE_UDP_DGRAM	dgram;
+	struct udphdr	*uh = (struct udphdr *) pkt - 1;
+	
+	/* process any queued incoming packets */
+	pxe_core_recv_packets();
+
+	/* reading from default socket */
+	int recv = pxe_udp_read(NULL, pkt, len, &dgram);
+	
+	if (recv == -1) {
+		printf("readudp(): failed\n");
+		return (-1);
+	}
+#ifdef PXE_DEBUG_HELL
+	printf("readudp(): received %d(%u/%u) bytes from %u port\n",
+	    recv, len, dgram.size, dgram.src_port);
+#endif
+	uh->uh_sport = htons(dgram.src_port);
+	
+	return (recv);
+}
+
+#else /* !defined(PXEHTTP_UDP_FOR_LIBSTAND) */
+/* old variants of udp send/recv functions */
+ssize_t
+sendudp(struct iodesc *h, void *pkt, size_t len)
+{
+        t_PXENV_UDP_WRITE *udpwrite_p = (t_PXENV_UDP_WRITE *)scratch_buffer;
+	        bzero(udpwrite_p, sizeof(*udpwrite_p));
+		
+        udpwrite_p->ip             = h->destip.s_addr;
+        udpwrite_p->dst_port       = h->destport;
+        udpwrite_p->src_port       = h->myport;
+        udpwrite_p->buffer_size    = len;
+        udpwrite_p->buffer.segment = VTOPSEG(pkt);
+        udpwrite_p->buffer.offset  = VTOPOFF(pkt);
+						
+        if (netmask == 0 || SAMENET(myip, h->destip, netmask))
+                udpwrite_p->gw = 0;
+        else
+                udpwrite_p->gw = gateip.s_addr;
+
+        pxe_core_call(PXENV_UDP_WRITE);
+#if 0
+        /* XXX - I dont know why we need this. */
+        delay(1000);
+#endif
+        if (udpwrite_p->status != 0) {
+	        /* XXX: This happens a lot.  It shouldn't. */
+	        if (udpwrite_p->status != 1)
+	    		printf("sendudp failed %x\n", udpwrite_p->status);
+			
+	        return (-1);
+	}
+
+        return (len);
+}
+
+ssize_t
+readudp(struct iodesc *h, void *pkt, size_t len, time_t timeout)
+{
+        t_PXENV_UDP_READ *udpread_p = (t_PXENV_UDP_READ *)scratch_buffer;
+	        struct udphdr *uh = NULL;
+		
+        uh = (struct udphdr *) pkt - 1;
+        bzero(udpread_p, sizeof(*udpread_p));
+				
+        udpread_p->dest_ip        = h->myip.s_addr;
+        udpread_p->d_port         = h->myport;
+        udpread_p->buffer_size    = len;
+        udpread_p->buffer.segment = VTOPSEG(data_buffer);
+        udpread_p->buffer.offset  = VTOPOFF(data_buffer);
+								
+        pxe_core_call(PXENV_UDP_READ);
+										
+#if 0
+        /* XXX - I dont know why we need this. */
+        delay(1000);
+#endif
+        if (udpread_p->status != 0) {
+                /* XXX: This happens a lot.  It shouldn't. */
+                if (udpread_p->status != 1)
+                        printf("readudp failed %x\n", udpread_p->status);
+
+		return (-1);
+	}
+
+        bcopy(data_buffer, pkt, udpread_p->buffer_size);
+        uh->uh_sport = udpread_p->s_port;
+
+        return (udpread_p->buffer_size);
+}
+
+#endif /* PXEHTTP_UDP_FOR_LIBSTAND */
diff -ruN sys/boot/i386/pxe_ng/libi386/pxe.h sys/boot/i386/pxe_ng/libi386/pxe.h
--- sys/boot/i386/pxe_ng/libi386/pxe.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/pxe.h	2009-03-02 20:20:02.000000000 -0500
@@ -0,0 +1,536 @@
+/*
+ * Copyright (c) 2000 Alfred Perlstein <alfred@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 Paul Saab <ps@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 John Baldwin <jhb@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/boot/i386/libi386/pxe.h,v 1.6 2002/09/23 18:54:26 alfred Exp $
+ */
+
+/*
+ * The typedefs and structures declared in this file
+ * clearly violate style(9), the reason for this is to conform to the
+ * typedefs/structure-names used in the Intel literature to avoid confusion.
+ *
+ * It's for your own good. :)
+ */
+
+/* It seems that intel didn't think about ABI,
+ * either that or 16bit ABI != 32bit ABI (which seems reasonable)
+ * I have to thank Intel for the hair loss I incurred trying to figure
+ * out why PXE was mis-reading structures I was passing it (at least
+ * from my point of view)
+ *
+ * Solution: use gcc's '__packed' to correctly align
+ * structures passed into PXE
+ * Question: does this really work for PXE's expected ABI?
+ */
+#ifndef __PXE__H__
+#define __PXE__H__
+
+#define	PACKED		__packed
+
+#define	S_SIZE(s)	s, sizeof(s) - 1
+
+#define	IP_STR		"%d.%d.%d.%d"
+#define	IP_ARGS(ip)					\
+	(int)(ip >> 24) & 0xff, (int)(ip >> 16) & 0xff, \
+	(int)(ip >> 8) & 0xff, (int)ip & 0xff
+
+#define	MAC_STR		"%02x:%02x:%02x:%02x:%02x:%02x"
+#define	MAC_ARGS(mac)					\
+	mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] 
+
+#define	PXENFSROOTPATH	"/pxeroot"
+
+typedef struct {
+	uint16_t		offset;
+	uint16_t		segment;
+} SEGOFF16_t;
+
+typedef struct {
+	uint16_t		Seg_Addr;
+	uint32_t		Phy_Addr;
+	uint16_t		Seg_Size;
+} SEGDESC_t;
+
+typedef	uint16_t		SEGSEL_t;
+typedef	uint16_t		PXENV_STATUS_t;
+typedef	uint32_t		IP4_t;
+typedef	uint32_t		ADDR32_t;
+typedef	uint16_t		UDP_PORT_t;
+
+#define	MAC_ADDR_LEN		16
+typedef	uint8_t			MAC_ADDR[MAC_ADDR_LEN];
+
+/* PXENV+ */
+typedef struct {
+	uint8_t		Signature[6];	/* 'PXENV+' */
+	uint16_t	Version;	/* MSB = major, LSB = minor */
+	uint8_t		Length;		/* structure length */
+	uint8_t		Checksum;	/* checksum pad */
+	SEGOFF16_t	RMEntry;	/* SEG:OFF to PXE entry point */
+	/* don't use PMOffset and PMSelector (from the 2.1 PXE manual) */
+	uint32_t	PMOffset;	/* Protected mode entry */
+	SEGSEL_t	PMSelector;	/* Protected mode selector */
+	SEGSEL_t	StackSeg;	/* Stack segment address */
+	uint16_t	StackSize;	/* Stack segment size (bytes) */
+	SEGSEL_t	BC_CodeSeg;	/* BC Code segment address */
+	uint16_t	BC_CodeSize;	/* BC Code segment size (bytes) */
+	SEGSEL_t	BC_DataSeg;	/* BC Data segment address */
+	uint16_t	BC_DataSize;	/* BC Data segment size (bytes) */
+	SEGSEL_t	UNDIDataSeg;	/* UNDI Data segment address */
+	uint16_t	UNDIDataSize;	/* UNDI Data segment size (bytes) */
+	SEGSEL_t	UNDICodeSeg;	/* UNDI Code segment address */
+	uint16_t	UNDICodeSize;	/* UNDI Code segment size (bytes) */
+	SEGOFF16_t	PXEPtr;		/* SEG:OFF to !PXE struct, 
+					   only present when Version > 2.1 */
+} PACKED pxenv_t;
+
+/* !PXE */
+typedef struct {
+	uint8_t		Signature[4];
+	uint8_t		StructLength;
+	uint8_t		StructCksum;
+	uint8_t		StructRev;
+	uint8_t		reserved_1;
+	SEGOFF16_t	UNDIROMID;
+	SEGOFF16_t	BaseROMID;
+	SEGOFF16_t	EntryPointSP;
+	SEGOFF16_t	EntryPointESP;
+	SEGOFF16_t	StatusCallout;
+	uint8_t		reserved_2;
+	uint8_t		SegDescCn;
+	SEGSEL_t	FirstSelector;
+	SEGDESC_t	Stack;
+	SEGDESC_t	UNDIData;
+	SEGDESC_t	UNDICode;
+	SEGDESC_t	UNDICodeWrite;
+	SEGDESC_t	BC_Data;
+	SEGDESC_t	BC_Code;
+	SEGDESC_t	BC_CodeWrite;
+} PACKED pxe_t;
+
+#define	PXENV_START_UNDI		0x0000
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	ax;
+	uint16_t	bx;
+	uint16_t	dx;
+	uint16_t	di;
+	uint16_t	es;
+} PACKED t_PXENV_START_UNDI;
+
+#define	PXENV_UNDI_STARTUP		0x0001
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_STARTUP;
+
+#define	PXENV_UNDI_CLEANUP		0x0002
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEANUP;
+
+#define	PXENV_UNDI_INITIALIZE		0x0003
+typedef struct {
+	PXENV_STATUS_t	Status;
+	ADDR32_t	ProtocolIni;	/* Phys addr of a copy of the driver module */
+	uint8_t		reserved[8];
+} PACKED t_PXENV_UNDI_INITIALIZE;
+
+
+#define	MAXNUM_MCADDR		8
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	MCastAddrCount;
+	MAC_ADDR	McastAddr[MAXNUM_MCADDR];
+} PACKED t_PXENV_UNDI_MCAST_ADDRESS;
+
+#define	PXENV_UNDI_RESET_ADAPTER	0x0004		
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_RESET;
+
+#define	PXENV_UNDI_SHUTDOWN		0x0005
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_SHUTDOWN;
+
+#define	PXENV_UNDI_OPEN			0x0006
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	OpenFlag;
+	uint16_t	PktFilter;
+#	define FLTR_DIRECTED	0x0001
+#	define FLTR_BRDCST	0x0002
+#	define FLTR_PRMSCS	0x0003
+#	define FLTR_SRC_RTG	0x0004
+
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_OPEN;
+
+#define	PXENV_UNDI_CLOSE		0x0007
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLOSE;
+
+#define	PXENV_UNDI_TRANSMIT		0x0008
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		Protocol;
+#	define P_UNKNOWN	0
+#	define P_IP		1
+#	define P_ARP		2
+#	define P_RARP		3
+
+	uint8_t		XmitFlag;
+#	define XMT_DESTADDR	0x0000
+#	define XMT_BROADCAST	0x0001
+
+	SEGOFF16_t	DestAddr;
+	SEGOFF16_t	TBD;
+	uint32_t	Reserved[2];
+} PACKED t_PXENV_UNDI_TRANSMIT;
+
+#define	MAX_DATA_BLKS		8
+typedef struct {
+	uint16_t	ImmedLength;
+	SEGOFF16_t	Xmit;
+	uint16_t	DataBlkCount;
+	struct	DataBlk {
+		uint8_t		TDPtrType;
+		uint8_t		TDRsvdByte;
+		uint16_t	TDDataLen;
+		SEGOFF16_t	TDDataPtr;
+	} DataBlock[MAX_DATA_BLKS];
+} PACKED t_PXENV_UNDI_TBD;
+
+#define	PXENV_UNDI_SET_MCAST_ADDRESS	0x0009
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_SET_MCAST_ADDR;
+
+#define	PXENV_UNDI_SET_STATION_ADDRESS	0x000A
+typedef struct {
+	PXENV_STATUS_t	Status;
+	MAC_ADDR	StationAddress;		/* Temp MAC addres to use */
+} PACKED t_PXENV_UNDI_SET_STATION_ADDR;
+
+#define	PXENV_UNDI_SET_PACKET_FILTER	0x000B
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		filter;			/* see UNDI_OPEN (0x0006) */
+} PACKED t_PXENV_UNDI_SET_PACKET_FILTER;
+
+#define	PXENV_UNDI_GET_INFORMATION	0x000C
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	BaseIo;			/* Adapter base I/O address */
+	uint16_t	IntNumber;		/* Adapter IRQ number */
+	uint16_t	MaxTranUnit;		/* Adapter maximum transmit unit */
+	uint16_t	HwType;			/* Type of protocol at the hardware addr */
+#	define ETHER_TYPE	1
+#	define EXP_ETHER_TYPE	2
+#	define IEEE_TYPE	6
+#	define ARCNET_TYPE	7
+
+	uint16_t	HwAddrLen;		/* Length of hardware address */
+	MAC_ADDR	CurrentNodeAddress;	/* Current hardware address */
+	MAC_ADDR	PermNodeAddress;	/* Permanent hardware address */
+	SEGSEL_t	ROMAddress;		/* Real mode ROM segment address */
+	uint16_t	RxBufCt;		/* Receive queue length */
+	uint16_t	TxBufCt;		/* Transmit queue length */
+} PACKED t_PXENV_UNDI_GET_INFORMATION;
+
+#define	PXENV_UNDI_GET_STATISTICS	0x000D
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint32_t	XmitGoodFrames;		/* Number of successful transmissions */
+	uint32_t	RcvGoodFrames;		/* Number of good frames received */
+	uint32_t	RcvCRCErrors;		/* Number of frames with CRC errors */
+	uint32_t	RcvResourceErrors;	/* Number of frames dropped */
+} PACKED t_PXENV_UNDI_GET_STATISTICS;
+
+#define	PXENV_UNDI_CLEAR_STATISTICS	0x000E
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEAR_STATISTICS;
+
+#define	PXENV_UNDI_INITIATE_DIAGS	0x000F
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_INITIATE_DIAGS;
+
+#define	PXENV_UNDI_FORCE_INTERRUPT	0x0010
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_FORCE_INTERRUPT;
+
+#define	PXENV_UNDI_GET_MCAST_ADDRESS	0x0011
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		InetAddr;		/* IP mulicast address */
+	MAC_ADDR	MediaAddr;		/* MAC multicast address */
+} PACKED t_PXENV_UNDI_GET_MCAST_ADDR;
+
+#define	PXENV_UNDI_GET_NIC_TYPE		0x0012
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		NicType;		/* Type of NIC */
+#	define PCI_NIC		2
+#	define PnP_NIC		3
+#	define CardBus_NIC	4
+
+	union {
+		struct {
+			uint16_t	Vendor_ID;
+			uint16_t	Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint8_t		Rev;
+			uint16_t	BusDevFunc;
+			uint16_t	SubVendor_ID;
+			uint16_t	SubDevice_ID;
+		} pci, cardbus;
+		struct {
+			uint32_t	EISA_Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint16_t	CardSelNum;
+		} pnp;
+	} info;
+} PACKED t_PXENV_UNDI_GET_NIC_TYPE;
+
+#define	PXENV_UNDI_GET_IFACE_INFO	0x0013
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		IfaceType[16];		/* Name of MAC type in ASCII. */
+	uint32_t	LinkSpeed;		/* Defined in NDIS 2.0 spec */
+	uint32_t	ServiceFlags;		/* Defined in NDIS 2.0 spec */
+	uint32_t	Reserved[4];		/* must be 0 */
+} PACKED t_PXENV_UNDI_GET_NDIS_INFO;
+
+#define PXENV_UNDI_GET_STATE		0x0015
+typedef struct {
+        PXENV_STATUS_t	Status;	
+#define PXE_UNDI_GET_STATE_STARTED	1
+#define PXE_UNDI_GET_STATE_INITIALIZED	2
+#define PXE_UNDI_GET_STATE_OPENED	3
+	uint8_t		UNDIstate;		/* UNDI engine state */
+} PACKED t_PXENV_UNDI_GET_STATE;
+
+#define	PXENV_UNDI_ISR			0x0014
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	FuncFlag;		/* PXENV_UNDI_ISR_OUT_xxx */
+	uint16_t	BufferLength;		/* Length of Frame */
+	uint16_t	FrameLength;		/* Total length of reciever frame */
+	uint16_t	FrameHeaderLength;	/* Length of the media header in Frame */
+	SEGOFF16_t	Frame;			/* receive buffer */
+	uint8_t		ProtType;		/* Protocol type */
+	uint8_t		PktType;		/* Packet Type */
+#	define PXENV_UNDI_ISR_IN_START		1
+#	define PXENV_UNDI_ISR_IN_PROCESS	2
+#	define PXENV_UNDI_ISR_IN_GET_NEXT	3
+
+	/* one of these will be returned for PXENV_UNDI_ISR_IN_START */
+#	define PXENV_UNDI_ISR_OUT_OURS		0
+#	define PXENV_UNDI_ISR_OUT_NOT_OUTS	1
+
+	/*
+	 * one of these will bre returnd for PXEND_UNDI_ISR_IN_PROCESS
+	 * and PXENV_UNDI_ISR_IN_GET_NEXT
+	 */
+#	define PXENV_UNDI_ISR_OUT_DONE		0
+#	define PXENV_UNDI_ISR_OUT_TRANSMIT	2
+#	define PXENV_UNDI_ISR_OUT_RECIEVE	3
+#	define PXENV_UNDI_ISR_OUT_BUSY		4
+} PACKED t_PXENV_UNDI_ISR;
+
+#define	PXENV_STOP_UNDI			0x0015
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_UNDI;
+
+#define	PXENV_TFTP_OPEN			0x0020
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAddress;
+	uint8_t		FileName[128];
+	UDP_PORT_t	TFTPPort;
+	uint16_t	PacketSize;
+} PACKED t_PXENV_TFTP_OPEN;
+
+#define	PXENV_TFTP_CLOSE		0x0021
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_TFTP_CLOSE;
+
+#define	PXENV_TFTP_READ			0x0022
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketNumber;
+	uint16_t	BufferSize;
+	SEGOFF16_t	Buffer;
+} PACKED t_PXENV_TFTP_READ;
+
+#define	PXENV_TFTP_READ_FILE		0x0023
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		FileName[128];
+	uint32_t	BufferSize;
+	ADDR32_t	Buffer;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAdress;
+	IP4_t		McastIPAdress;
+	UDP_PORT_t	TFTPClntPort;
+	UDP_PORT_t	TFTPSrvPort;
+	uint16_t	TFTPOpenTimeOut;
+	uint16_t	TFTPReopenDelay;
+} PACKED t_PXENV_TFTP_READ_FILE;
+
+#define	PXENV_TFTP_GET_FSIZE		0x0025
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAdress;
+	uint8_t		FileName[128];
+	uint32_t	FileSize;
+} PACKED t_PXENV_TFTP_GET_FSIZE;
+
+#define	PXENV_UDP_OPEN			0x0030
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		src_ip;		/* IP address of this station */
+} PACKED t_PXENV_UDP_OPEN;
+
+#define	PXENV_UDP_CLOSE			0x0031
+typedef struct {
+	PXENV_STATUS_t	status;
+} PACKED t_PXENV_UDP_CLOSE;
+
+#define	PXENV_UDP_READ			0x0032
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		src_ip;		/* IP of sender */
+	IP4_t		dest_ip;	/* Only accept packets sent to this IP */
+	UDP_PORT_t	s_port;		/* UDP source port of sender */
+	UDP_PORT_t	d_port;		/* Only accept packets sent to this port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_READ;
+
+#define	PXENV_UDP_WRITE			0x0033
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		ip;		/* dest ip addr */
+	IP4_t		gw;		/* ip gateway */
+	UDP_PORT_t	src_port;	/* source udp port */
+	UDP_PORT_t	dst_port;	/* destination udp port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_WRITE;
+
+#define	PXENV_UNLOAD_STACK		0x0070
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		reserved[10];
+} PACKED t_PXENV_UNLOAD_STACK;
+
+
+#define	PXENV_GET_CACHED_INFO		0x0071
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketType;	/* type (defined right here) */
+#	define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
+#	define PXENV_PACKET_TYPE_DHCP_ACK       2
+#	define PXENV_PACKET_TYPE_BINL_REPLY     3
+	uint16_t	BufferSize;	/* max to copy, leave at 0 for pointer */
+	SEGOFF16_t	Buffer;		/* copy to, leave at 0 for pointer */
+	uint16_t	BufferLimit;	/* max size of buffer in BC dataseg ? */
+} PACKED t_PXENV_GET_CACHED_INFO;
+
+
+/* structure filled in by PXENV_GET_CACHED_INFO 
+ * (how we determine which IP we downloaded the initial bootstrap from)
+ * words can't describe...
+ */
+typedef struct {
+	uint8_t		opcode;
+#	define BOOTP_REQ	1
+#	define BOOTP_REP	2
+	uint8_t		Hardware;	/* hardware type */
+	uint8_t		Hardlen;	/* hardware addr len */
+	uint8_t		Gatehops;	/* zero it */
+	uint32_t	ident;		/* random number chosen by client */
+	uint16_t	seconds;	/* seconds since did initial bootstrap */
+	uint16_t	Flags;		/* seconds since did initial bootstrap */
+#	define BOOTP_BCAST	0x8000		/* ? */
+	IP4_t		cip;		/* Client IP */
+	IP4_t		yip;		/* Your IP */
+	IP4_t		sip;		/* IP to use for next boot stage */
+	IP4_t		gip;		/* Relay IP ? */
+	MAC_ADDR	CAddr;		/* Client hardware address */
+	uint8_t		Sname[64];	/* Server's hostname (Optional) */
+	uint8_t		bootfile[128];	/* boot filename */
+	union {
+#		if 1
+#		define BOOTP_DHCPVEND  1024    /* DHCP extended vendor field size */
+#		else
+#		define BOOTP_DHCPVEND  312	/* DHCP standard vendor field size */
+#		endif
+		uint8_t		d[BOOTP_DHCPVEND];	/* raw array of vendor/dhcp options */
+		struct {
+			uint8_t		magic[4];	/* DHCP magic cookie */
+#			ifndef		VM_RFC1048
+#			define		VM_RFC1048	0x63825363L	/* ? */
+#			endif
+			uint32_t	flags;		/* bootp flags/opcodes */
+			uint8_t		pad[56];	/* I don't think intel knows what a
+							   union does... */
+		} v;
+	} vendor;
+} PACKED BOOTPLAYER;
+
+#define	PXENV_RESTART_TFTP		0x0073
+#define	t_PXENV_RESTART_TFTP		t_PXENV_TFTP_READ_FILE
+
+#define	PXENV_START_BASE		0x0075
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_START_BASE;
+
+#define	PXENV_STOP_BASE			0x0076
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_BASE;
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/libi386/pxetramp.s sys/boot/i386/pxe_ng/libi386/pxetramp.s
--- sys/boot/i386/pxe_ng/libi386/pxetramp.s	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/pxetramp.s	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,38 @@
+#
+# Copyright (c) 2000 Peter Wemm
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms are freely
+# permitted provided that the above copyright notice and this
+# paragraph and the following disclaimer are duplicated in all
+# such forms.
+#
+# This software is provided "AS IS" and without any express or
+# implied warranties, including, without limitation, the implied
+# warranties of merchantability and fitness for a particular
+# purpose.
+#
+# $FreeBSD$
+
+# ph33r this
+
+		.globl  __bangpxeentry, __bangpxeseg, __bangpxeoff
+		.globl  __pxenventry, __pxenvseg, __pxenvoff
+
+		.code16
+		.p2align 4,0x90
+__bangpxeentry:
+		push    %dx			# seg:data
+		push    %ax			# off:data
+		push    %bx			# int16 func
+		.byte   0x9a			# far call
+__bangpxeoff:	.word   0x0000			# offset
+__bangpxeseg:	.word   0x0000			# segment
+		add	$6, %sp			# restore stack
+		.byte	0xcb			# to vm86int
+#
+__pxenventry:
+		.byte   0x9a			# far call
+__pxenvoff:	.word   0x0000			# offset
+__pxenvseg:	.word   0x0000			# segment
+		.byte	0xcb			# to vm86int
diff -ruN sys/boot/i386/pxe_ng/libi386/smbios.c sys/boot/i386/pxe_ng/libi386/smbios.c
--- sys/boot/i386/pxe_ng/libi386/smbios.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/smbios.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,251 @@
+/*-
+ * Copyright (c) 2005, 2006 Jung-uk Kim <jkim@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <bootstrap.h>
+
+#include "btxv86.h"
+#include "libi386.h"
+
+/*
+ * Detect SMBIOS and export information about the SMBIOS into the
+ * environment.
+ *
+ * System Management BIOS Reference Specification, v2.4 Final
+ * http://www.dmtf.org/standards/published_documents/DSP0134.pdf
+ */
+
+/*
+ * Spec. 2.1.1 SMBIOS Structure Table Entry Point
+ *
+ * 'The SMBIOS Entry Point structure, described below, can be located by
+ * application software by searching for the anchor-string on paragraph
+ * (16-byte) boundaries within the physical memory address range
+ * 000F0000h to 000FFFFFh.'
+ */
+#define	SMBIOS_START		0xf0000
+#define	SMBIOS_LENGTH		0x10000
+#define	SMBIOS_STEP		0x10
+#define	SMBIOS_SIG		"_SM_"
+#define	SMBIOS_DMI_SIG		"_DMI_"
+
+static uint8_t	smbios_enabled_sockets = 0;
+static uint8_t	smbios_populated_sockets = 0;
+
+static uint8_t	*smbios_parse_table(const uint8_t *dmi);
+static void	smbios_setenv(const char *name, const uint8_t *dmi,
+		    const int offset);
+static uint8_t	smbios_checksum(const caddr_t addr, const uint8_t len);
+static uint8_t	*smbios_sigsearch(const caddr_t addr, const uint32_t len);
+
+#ifdef SMBIOS_SERIAL_NUMBERS
+static void	smbios_setuuid(const char *name, const uint8_t *dmi,
+		    const int offset);
+#endif
+
+void
+smbios_detect(void)
+{
+	uint8_t		*smbios, *dmi, *addr;
+	uint16_t	i, length, count;
+	uint32_t	paddr;
+	char		buf[4];
+
+	/* locate and validate the SMBIOS */
+	smbios = smbios_sigsearch(PTOV(SMBIOS_START), SMBIOS_LENGTH);
+	if (smbios == NULL)
+		return;
+
+	length = *(uint16_t *)(smbios + 0x16);	/* Structure Table Length */
+	paddr = *(uint32_t *)(smbios + 0x18);	/* Structure Table Address */
+	count = *(uint16_t *)(smbios + 0x1c);	/* No of SMBIOS Structures */
+
+	for (dmi = addr = PTOV(paddr), i = 0;
+	     dmi - addr < length && i < count; i++)
+		dmi = smbios_parse_table(dmi);
+	sprintf(buf, "%d", smbios_enabled_sockets);
+	setenv("smbios.socket.enabled", buf, 1);
+	sprintf(buf, "%d", smbios_populated_sockets);
+	setenv("smbios.socket.populated", buf, 1);
+}
+
+static uint8_t *
+smbios_parse_table(const uint8_t *dmi)
+{
+	uint8_t		*dp;
+
+	switch(dmi[0]) {
+	case 0:		/* Type 0: BIOS */
+		smbios_setenv("smbios.bios.vendor", dmi, 0x04);
+		smbios_setenv("smbios.bios.version", dmi, 0x05);
+		smbios_setenv("smbios.bios.reldate", dmi, 0x08);
+		break;
+
+	case 1:		/* Type 1: System */
+		smbios_setenv("smbios.system.maker", dmi, 0x04);
+		smbios_setenv("smbios.system.product", dmi, 0x05);
+		smbios_setenv("smbios.system.version", dmi, 0x06);
+#ifdef SMBIOS_SERIAL_NUMBERS
+		smbios_setenv("smbios.system.serial", dmi, 0x07);
+		smbios_setuuid("smbios.system.uuid", dmi, 0x08);
+#endif
+		break;
+
+	case 2:		/* Type 2: Base Board (or Module) */
+		smbios_setenv("smbios.planar.maker", dmi, 0x04);
+		smbios_setenv("smbios.planar.product", dmi, 0x05);
+		smbios_setenv("smbios.planar.version", dmi, 0x06);
+#ifdef SMBIOS_SERIAL_NUMBERS
+		smbios_setenv("smbios.planar.serial", dmi, 0x07);
+#endif
+		break;
+
+	case 3:		/* Type 3: System Enclosure or Chassis */
+		smbios_setenv("smbios.chassis.maker", dmi, 0x04);
+		smbios_setenv("smbios.chassis.version", dmi, 0x06);
+#ifdef SMBIOS_SERIAL_NUMBERS
+		smbios_setenv("smbios.chassis.serial", dmi, 0x07);
+		smbios_setenv("smbios.chassis.tag", dmi, 0x08);
+#endif
+		break;
+
+	case 4:		/* Type 4: Processor Information */
+		/*
+		 * Offset 18h: Processor Status
+		 *
+		 * Bit 7	Reserved, must be 0
+		 * Bit 6	CPU Socket Populated
+		 *		1 - CPU Socket Populated
+		 *		0 - CPU Socket Unpopulated
+		 * Bit 5:3	Reserved, must be zero
+		 * Bit 2:0	CPU Status
+		 *		0h - Unknown
+		 *		1h - CPU Enabled
+		 *		2h - CPU Disabled by User via BIOS Setup
+		 *		3h - CPU Disabled by BIOS (POST Error)
+		 *		4h - CPU is Idle, waiting to be enabled
+		 *		5-6h - Reserved
+		 *		7h - Other
+		 */
+		if ((dmi[0x18] & 0x07) == 1)
+			smbios_enabled_sockets++;
+		if (dmi[0x18] & 0x40)
+			smbios_populated_sockets++;
+		break;
+
+	default: /* skip other types */
+		break;
+	}
+	
+	/* find structure terminator */
+	dp = __DECONST(uint8_t *, dmi + dmi[1]);
+	while (dp[0] != 0 || dp[1] != 0)
+		dp++;
+
+	return(dp + 2);
+}
+
+static void
+smbios_setenv(const char *name, const uint8_t *dmi, const int offset)
+{
+	char		*cp = __DECONST(char *, dmi + dmi[1]);
+	int		i;
+
+	/* skip undefined string */
+	if (dmi[offset] == 0)
+		return;
+
+	for (i = 0; i < dmi[offset] - 1; i++)
+		cp += strlen(cp) + 1;
+	setenv(name, cp, 1);
+}
+
+static uint8_t
+smbios_checksum(const caddr_t addr, const uint8_t len)
+{
+	const uint8_t	*cp = addr;
+	uint8_t		sum;
+	int		i;
+
+	for (sum = 0, i = 0; i < len; i++)
+		sum += cp[i];
+
+	return(sum);
+}
+
+static uint8_t *
+smbios_sigsearch(const caddr_t addr, const uint32_t len)
+{
+	caddr_t		cp;
+
+	/* search on 16-byte boundaries */
+	for (cp = addr; cp < addr + len; cp += SMBIOS_STEP) {
+		/* compare signature, validate checksum */
+		if (!strncmp(cp, SMBIOS_SIG, 4)) {
+			if (smbios_checksum(cp, *(uint8_t *)(cp + 0x05)))
+				continue;
+			if (strncmp(cp + 0x10, SMBIOS_DMI_SIG, 5))
+				continue;
+			if (smbios_checksum(cp + 0x10, 0x0f))
+				continue;
+
+			return(cp);
+		}
+	}
+
+	return(NULL);
+}
+
+#ifdef SMBIOS_SERIAL_NUMBERS
+static void
+smbios_setuuid(const char *name, const uint8_t *dmi, const int offset)
+{
+	const uint8_t	*idp = dmi + offset;
+	int		i, f = 0, z = 0;
+	char		uuid[37];
+
+	for (i = 0; i < 16; i++) {
+		if (idp[i] == 0xff)
+			f++;
+		else if (idp[i] == 0x00)
+			z++;
+		else
+			break;
+	}
+	if (f != 16 && z != 16) {
+		sprintf(uuid, "%02x%02x%02x%02x-"
+		    "%02x%02x-%02x%02x-%02x%02x-"
+		    "%02x%02x%02x%02x%02x%02x",
+		    idp[0], idp[1], idp[2], idp[3],
+		    idp[4], idp[5], idp[6], idp[7], idp[8], idp[9],
+		    idp[10], idp[11], idp[12], idp[13], idp[14], idp[15]);
+		setenv(name, uuid, 1);
+	}
+}
+#endif
diff -ruN sys/boot/i386/pxe_ng/libi386/time.c sys/boot/i386/pxe_ng/libi386/time.c
--- sys/boot/i386/pxe_ng/libi386/time.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/time.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,83 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <btxv86.h>
+#include "bootstrap.h"
+#include "libi386.h"
+
+/*
+ * Return the time in seconds since the beginning of the day.
+ *
+ * If we pass midnight, don't wrap back to 0.
+ *
+ * XXX uses undocumented BCD support from libstand.
+ */
+
+time_t
+time(time_t *t)
+{
+    static time_t	lasttime, now;
+    int			hr, minute, sec;
+    
+    v86.ctl = 0;
+    v86.addr = 0x1a;		/* int 0x1a, function 2 */
+    v86.eax = 0x0200;
+    v86int();
+
+    hr = bcd2bin((v86.ecx & 0xff00) >> 8);	/* hour in %ch */
+    minute = bcd2bin(v86.ecx & 0xff);		/* minute in %cl */
+    sec = bcd2bin((v86.edx & 0xff00) >> 8);	/* second in %dh */
+    
+    now = hr * 3600 + minute * 60 + sec;
+    if (now < lasttime)
+	now += 24 * 3600;
+    lasttime = now;
+    
+    if (t != NULL)
+	*t = now;
+    return(now);
+}
+
+/*
+ * Use the BIOS Wait function to pause for (period) microseconds.
+ *
+ * Resolution of this function is variable, but typically around
+ * 1ms.
+ */
+void
+delay(int period)
+{
+    v86.ctl = 0;
+    v86.addr = 0x15;		/* int 0x15, function 0x86 */
+    v86.eax = 0x8600;
+    v86.ecx = period >> 16;
+    v86.edx = period & 0xffff;
+    v86int();
+}
diff -ruN sys/boot/i386/pxe_ng/libi386/vidconsole.c sys/boot/i386/pxe_ng/libi386/vidconsole.c
--- sys/boot/i386/pxe_ng/libi386/vidconsole.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libi386/vidconsole.c	2009-02-20 12:31:41.000000000 -0500
@@ -0,0 +1,632 @@
+/*-
+ * Copyright (c) 1998 Michael Smith (msmith@freebsd.org)
+ * Copyright (c) 1997 Kazutaka YOKOTA (yokota@zodiac.mech.utsunomiya-u.ac.jp)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * 	Id: probe_keyboard.c,v 1.13 1997/06/09 05:10:55 bde Exp
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <stand.h>
+#include <bootstrap.h>
+#include <btxv86.h>
+#include <machine/psl.h>
+#include "libi386.h"
+
+#if KEYBOARD_PROBE
+#include <machine/cpufunc.h>
+
+static int	probe_keyboard(void);
+#endif
+static void	vidc_probe(struct console *cp);
+static int	vidc_init(int arg);
+static void	vidc_putchar(int c);
+static int	vidc_getchar(void);
+static int	vidc_ischar(void);
+
+static int	vidc_started;
+
+#ifdef TERM_EMU
+#define MAXARGS		8
+#define DEFAULT_FGCOLOR	7
+#define DEFAULT_BGCOLOR	0
+
+void		end_term(void);
+void		bail_out(int c);
+void		vidc_term_emu(int c);
+void		get_pos(void);
+void		curs_move(int x, int y);
+void		write_char(int c, int fg, int bg);
+void		scroll_up(int rows, int fg, int bg);
+void		CD(void);
+void		CM(void);
+void		HO(void);
+
+static int	args[MAXARGS], argc;
+static int	fg_c, bg_c, curx, cury;
+static int	esc;
+#endif
+
+
+struct console vidconsole = {
+    "vidconsole",
+    "internal video/keyboard",
+    0,
+    vidc_probe,
+    vidc_init,
+    vidc_putchar,
+    vidc_getchar,
+    vidc_ischar
+};
+
+static void
+vidc_probe(struct console *cp)
+{
+    
+    /* look for a keyboard */
+#if KEYBOARD_PROBE
+    if (probe_keyboard())
+#endif
+    {
+	
+	cp->c_flags |= C_PRESENTIN;
+    }
+
+    /* XXX for now, always assume we can do BIOS screen output */
+    cp->c_flags |= C_PRESENTOUT;
+}
+
+static int
+vidc_init(int arg)
+{
+    int		i;
+
+    if (vidc_started && arg == 0)
+	return (0);
+    vidc_started = 1;
+#ifdef TERM_EMU
+    /* Init terminal emulator */
+    end_term();
+    get_pos();
+    curs_move(curx, cury);
+    fg_c = DEFAULT_FGCOLOR;
+    bg_c = DEFAULT_BGCOLOR;
+#endif
+    for (i = 0; i < 10 && vidc_ischar(); i++)
+	(void)vidc_getchar();
+    return (0);	/* XXX reinit? */
+}
+
+static void
+vidc_biosputchar(int c)
+{
+
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0xe00 | (c & 0xff);
+    v86.ebx = 0x7;
+    v86int();
+}
+
+static void
+vidc_rawputchar(int c)
+{
+    int		i;
+
+    if (c == '\t')
+	/* lame tab expansion */
+	for (i = 0; i < 8; i++)
+	    vidc_rawputchar(' ');
+    else {
+#ifndef TERM_EMU
+        vidc_biosputchar(c);
+#else
+	/* Emulate AH=0eh (teletype output) */
+	switch(c) {
+	case '\a':
+	    vidc_biosputchar(c);
+	    return;
+	case '\r':
+	    curx = 0;
+	    curs_move(curx, cury);
+	    return;
+	case '\n':
+	    cury++;
+	    if (cury > 24) {
+		scroll_up(1, fg_c, bg_c);
+		cury--;
+	    } else {
+		curs_move(curx, cury);
+	    }
+	    return;
+	case '\b':
+	    if (curx > 0) {
+		curx--;
+		curs_move(curx, cury);
+		/* write_char(' ', fg_c, bg_c); XXX destructive(!) */
+		return;
+	    }
+	    return;
+	default:
+	    write_char(c, fg_c, bg_c);
+	    curx++;
+	    if (curx > 79) {
+		curx = 0;
+		cury++;
+	    }
+	    if (cury > 24) {
+		curx = 0;
+		scroll_up(1, fg_c, bg_c);
+		cury--;
+	    }
+	}
+	curs_move(curx, cury);
+#endif
+    }
+}
+
+#ifdef TERM_EMU
+
+/* Get cursor position on the screen. Result is in edx. Sets
+ * curx and cury appropriately.
+ */
+void
+get_pos(void)
+{
+
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0300;
+    v86.ebx = 0x0;
+    v86int();
+    curx = v86.edx & 0x00ff;
+    cury = (v86.edx & 0xff00) >> 8;
+}
+
+/* Move cursor to x rows and y cols (0-based). */
+void
+curs_move(int x, int y)
+{
+
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0200;
+    v86.ebx = 0x0;
+    v86.edx = ((0x00ff & y) << 8) + (0x00ff & x);
+    v86int();
+    curx = x;
+    cury = y;
+    /* If there is ctrl char at this position, cursor would be invisible.
+     * Make it a space instead.
+     */
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0800;
+    v86.ebx = 0x0;
+    v86int();
+#define isvisible(c)	(((c) >= 32) && ((c) < 255))
+    if (!isvisible(v86.eax & 0x00ff)) {
+	write_char(' ', fg_c, bg_c);
+    }
+}
+
+/* Scroll up the whole window by a number of rows. If rows==0,
+ * clear the window. fg and bg are attributes for the new lines
+ * inserted in the window.
+ */
+void
+scroll_up(int rows, int fgcol, int bgcol)
+{
+
+    if (rows == 0)
+	rows = 25;
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0600 + (0x00ff & rows);
+    v86.ebx = (bgcol << 12) + (fgcol << 8);
+    v86.ecx = 0x0;
+    v86.edx = 0x184f;
+    v86int();
+}
+
+/* Write character and attribute at cursor position. */
+void
+write_char(int c, int fgcol, int bgcol)
+{
+
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0900 + (0x00ff & c);
+    v86.ebx = (bgcol << 4) + fgcol;
+    v86.ecx = 0x1;
+    v86int();
+}
+
+/**************************************************************/
+/*
+ * Screen manipulation functions. They use accumulated data in
+ * args[] and argc variables.
+ *
+ */
+
+/* Clear display from current position to end of screen */
+void
+CD(void)
+{
+
+    get_pos();
+    if (curx > 0) {
+	v86.ctl = 0;
+	v86.addr = 0x10;
+	v86.eax = 0x0600;
+	v86.ebx = (bg_c << 4) + fg_c;
+	v86.ecx = (cury << 8) + curx;
+	v86.edx = (cury << 8) + 79;
+	v86int();
+	if (++cury > 24) {
+	    end_term();
+	    return;
+	}
+    }
+    v86.ctl = 0;
+    v86.addr = 0x10;
+    v86.eax = 0x0600;
+    v86.ebx = (bg_c << 4) + fg_c;
+    v86.ecx = (cury << 8) + 0;
+    v86.edx = (24 << 8) + 79;
+    v86int();
+    end_term();
+}
+
+/* Absolute cursor move to args[0] rows and args[1] columns
+ * (the coordinates are 1-based).
+ */
+void
+CM(void)
+{
+
+    if (args[0] > 0)
+	args[0]--;
+    if (args[1] > 0)
+	args[1]--;
+    curs_move(args[1], args[0]);
+    end_term();
+}
+
+/* Home cursor (left top corner) */
+void
+HO(void)
+{
+
+    argc = 1;
+    args[0] = args[1] = 1;
+    CM();
+}
+
+/* Clear internal state of the terminal emulation code */
+void
+end_term(void)
+{
+
+    esc = 0;
+    argc = -1;
+}
+
+/* Gracefully exit ESC-sequence processing in case of misunderstanding */
+void
+bail_out(int c)
+{
+    char buf[16], *ch;
+    int i;
+
+    if (esc) {
+	vidc_rawputchar('\033');
+	if (esc != '\033')
+	    vidc_rawputchar(esc);
+	for (i = 0; i <= argc; ++i) {
+	    sprintf(buf, "%d", args[i]);
+	    ch = buf;
+	    while (*ch)
+		vidc_rawputchar(*ch++);
+	}
+    }
+    vidc_rawputchar(c);
+    end_term();
+}
+
+static void
+get_arg(int c)
+{
+
+    if (argc < 0)
+	argc = 0;
+    args[argc] *= 10;
+    args[argc] += c - '0';
+}
+
+/* Emulate basic capabilities of cons25 terminal */
+void
+vidc_term_emu(int c)
+{
+    static int ansi_col[] = {
+	0, 4, 2, 6, 1, 5, 3, 7,
+    };
+    int t;
+    int i;
+
+    switch (esc) {
+    case 0:
+	switch (c) {
+	case '\033':
+	    esc = c;
+	    break;
+	default:
+	    vidc_rawputchar(c);
+	    break;
+	}
+	break;
+
+    case '\033':
+	switch (c) {
+	case '[':
+	    esc = c;
+	    args[0] = 0;
+	    argc = -1;
+	    break;
+	default:
+	    bail_out(c);
+	    break;
+	}
+	break;
+
+    case '[':
+	switch (c) {
+	case ';':
+	    if (argc < 0)	/* XXX */
+		argc = 0;
+	    else if (argc + 1 >= MAXARGS)
+		bail_out(c);
+	    else
+		args[++argc] = 0;
+	    break;
+	case 'H':
+	    if (argc < 0)
+		HO();
+	    else if (argc == 1)
+		CM();
+	    else
+		bail_out(c);
+	    break;
+	case 'J':
+	    if (argc < 0)
+		CD();
+	    else
+		bail_out(c);
+	    break;
+	case 'm':
+	    if (argc < 0) {
+		fg_c = DEFAULT_FGCOLOR;
+		bg_c = DEFAULT_BGCOLOR;
+	    }
+	    for (i = 0; i <= argc; ++i) {
+		switch (args[i]) {
+		case 0:		/* back to normal */
+		    fg_c = DEFAULT_FGCOLOR;
+		    bg_c = DEFAULT_BGCOLOR;
+		    break;
+		case 1:		/* bold */
+		    fg_c |= 0x8;
+		    break;
+		case 4:		/* underline */
+		case 5:		/* blink */
+		    bg_c |= 0x8;
+		    break;
+		case 7:		/* reverse */
+		    t = fg_c;
+		    fg_c = bg_c;
+		    bg_c = t;
+		    break;
+		case 30: case 31: case 32: case 33:
+		case 34: case 35: case 36: case 37:
+		    fg_c = ansi_col[args[i] - 30];
+		    break;
+		case 39:	/* normal */
+		    fg_c = DEFAULT_FGCOLOR;
+		    break;
+		case 40: case 41: case 42: case 43:
+		case 44: case 45: case 46: case 47:
+		    bg_c = ansi_col[args[i] - 40];
+		    break;
+		case 49:	/* normal */
+		    bg_c = DEFAULT_BGCOLOR;
+		    break;
+		}
+	    }
+	    end_term();
+	    break;
+	default:
+	    if (isdigit(c))
+		get_arg(c);
+	    else
+		bail_out(c);
+	    break;
+	}
+	break;
+
+    default:
+	bail_out(c);
+	break;
+    }
+}
+#endif
+
+static void
+vidc_putchar(int c)
+{
+#ifdef TERM_EMU
+    vidc_term_emu(c);
+#else
+    vidc_rawputchar(c);
+#endif
+}
+
+static int
+vidc_getchar(void)
+{
+
+    if (vidc_ischar()) {
+	v86.ctl = 0;
+	v86.addr = 0x16;
+	v86.eax = 0x0;
+	v86int();
+	return (v86.eax & 0xff);
+    } else {
+	return (-1);
+    }
+}
+
+static int
+vidc_ischar(void)
+{
+
+    v86.ctl = V86_FLAGS;
+    v86.addr = 0x16;
+    v86.eax = 0x100;
+    v86int();
+    return (!(v86.efl & PSL_Z));
+}
+
+#if KEYBOARD_PROBE
+
+#define PROBE_MAXRETRY	5
+#define PROBE_MAXWAIT	400
+#define IO_DUMMY	0x84
+#define IO_KBD		0x060		/* 8042 Keyboard */
+
+/* selected defines from kbdio.h */
+#define KBD_STATUS_PORT 	4	/* status port, read */
+#define KBD_DATA_PORT		0	/* data port, read/write 
+					 * also used as keyboard command
+					 * and mouse command port 
+					 */
+#define KBDC_ECHO		0x00ee
+#define KBDS_ANY_BUFFER_FULL	0x0001
+#define KBDS_INPUT_BUFFER_FULL	0x0002
+#define KBD_ECHO		0x00ee
+
+/* 7 microsec delay necessary for some keyboard controllers */
+static void
+delay7(void)
+{
+    /* 
+     * I know this is broken, but no timer is available yet at this stage...
+     * See also comments in `delay1ms()'.
+     */
+    inb(IO_DUMMY); inb(IO_DUMMY);
+    inb(IO_DUMMY); inb(IO_DUMMY);
+    inb(IO_DUMMY); inb(IO_DUMMY);
+}
+
+/*
+ * This routine uses an inb to an unused port, the time to execute that
+ * inb is approximately 1.25uS.  This value is pretty constant across
+ * all CPU's and all buses, with the exception of some PCI implentations
+ * that do not forward this I/O address to the ISA bus as they know it
+ * is not a valid ISA bus address, those machines execute this inb in
+ * 60 nS :-(.
+ *
+ */
+static void
+delay1ms(void)
+{
+    int i = 800;
+    while (--i >= 0)
+	(void)inb(0x84);
+}
+
+/* 
+ * We use the presence/absence of a keyboard to determine whether the internal
+ * console can be used for input.
+ *
+ * Perform a simple test on the keyboard; issue the ECHO command and see
+ * if the right answer is returned. We don't do anything as drastic as
+ * full keyboard reset; it will be too troublesome and take too much time.
+ */
+static int
+probe_keyboard(void)
+{
+    int retry = PROBE_MAXRETRY;
+    int wait;
+    int i;
+
+    while (--retry >= 0) {
+	/* flush any noise */
+	while (inb(IO_KBD + KBD_STATUS_PORT) & KBDS_ANY_BUFFER_FULL) {
+	    delay7();
+	    inb(IO_KBD + KBD_DATA_PORT);
+	    delay1ms();
+	}
+
+	/* wait until the controller can accept a command */
+	for (wait = PROBE_MAXWAIT; wait > 0; --wait) {
+	    if (((i = inb(IO_KBD + KBD_STATUS_PORT)) 
+                & (KBDS_INPUT_BUFFER_FULL | KBDS_ANY_BUFFER_FULL)) == 0)
+		break;
+	    if (i & KBDS_ANY_BUFFER_FULL) {
+		delay7();
+	        inb(IO_KBD + KBD_DATA_PORT);
+	    }
+	    delay1ms();
+	}
+	if (wait <= 0)
+	    continue;
+
+	/* send the ECHO command */
+	outb(IO_KBD + KBD_DATA_PORT, KBDC_ECHO);
+
+	/* wait for a response */
+	for (wait = PROBE_MAXWAIT; wait > 0; --wait) {
+	     if (inb(IO_KBD + KBD_STATUS_PORT) & KBDS_ANY_BUFFER_FULL)
+		 break;
+	     delay1ms();
+	}
+	if (wait <= 0)
+	    continue;
+
+	delay7();
+	i = inb(IO_KBD + KBD_DATA_PORT);
+#ifdef PROBE_KBD_BEBUG
+        printf("probe_keyboard: got 0x%x.\n", i);
+#endif
+	if (i == KBD_ECHO) {
+	    /* got the right answer */
+	    return (0);
+	}
+    }
+
+    return (1);
+}
+#endif /* KEYBOARD_PROBE */
diff -ruN sys/boot/i386/pxe_ng/libstand/Makefile sys/boot/i386/pxe_ng/libstand/Makefile
--- sys/boot/i386/pxe_ng/libstand/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/Makefile	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,153 @@
+# $FreeBSD$
+# Originally from	$NetBSD: Makefile,v 1.21 1997/10/26 22:08:38 lukem Exp $
+#
+# Notes:
+# - We don't use the libc strerror/sys_errlist because the string table is
+#   quite large.
+#
+
+LIB=		stand
+NO_PROFILE=
+NO_PIC=
+INCS=		stand.h
+MAN=		libstand.3
+
+CFLAGS+= -ffreestanding -Wformat
+CFLAGS+= -I${.CURDIR}
+
+.if ${MACHINE_ARCH} == "i386" || ${MACHINE_ARCH} == "amd64"
+CFLAGS+=	-mpreferred-stack-boundary=2
+CFLAGS+=	-mno-mmx -mno-3dnow -mno-sse -mno-sse2
+.endif
+.if ${MACHINE_ARCH} == "i386"
+CFLAGS+=	-mno-sse3
+.endif
+.if ${MACHINE} == "pc98"
+CFLAGS+=	-Os
+.endif
+.if ${MACHINE_ARCH} == "powerpc"
+CFLAGS+=	-msoft-float -D_STANDALONE
+.endif
+.if ${MACHINE_ARCH} == "amd64"
+CFLAGS+=	-m32 -I.
+.endif
+
+# standalone components and stuff we have modified locally
+SRCS+=	zutil.h __main.c assert.c bcd.c bswap.c environment.c getopt.c gets.c \
+	globals.c pager.c printf.c strdup.c strerror.c strtol.c random.c \
+	sbrk.c twiddle.c zalloc.c zalloc_malloc.c
+
+# private (pruned) versions of libc string functions
+SRCS+=	strcasecmp.c
+
+.PATH: ${.CURDIR}/../libc/net
+
+SRCS+= ntoh.c
+
+# string functions from libc
+.PATH: ${.CURDIR}/../libc/string
+.if ${MACHINE_ARCH} == "i386" || ${MACHINE_ARCH} == "powerpc" || \
+	${MACHINE_ARCH} == "sparc64" || ${MACHINE_ARCH} == "amd64"
+SRCS+=	bcmp.c bcopy.c bzero.c ffs.c index.c memccpy.c memchr.c memcmp.c \
+        memcpy.c memmove.c memset.c qdivrem.c rindex.c strcat.c strchr.c \
+        strcmp.c strcpy.c strcspn.c strlen.c strncat.c strncmp.c strncpy.c \
+	strpbrk.c strrchr.c strsep.c strspn.c strstr.c strtok.c swab.c
+.endif
+.if ${MACHINE_ARCH} == "ia64"
+.PATH: ${.CURDIR}/../libc/ia64/string
+SRCS+=	bcmp.c bcopy.S bzero.S ffs.S index.c memccpy.c memchr.c memcmp.c \
+	memcpy.S memmove.S memset.c rindex.c strcat.c strchr.c \
+	strcmp.c strcpy.c strcspn.c strlen.c \
+	strncat.c strncmp.c strncpy.c strpbrk.c strrchr.c strsep.c \
+	strspn.c strstr.c strtok.c swab.c
+
+.PATH: ${.CURDIR}/../libc/ia64/gen
+SRCS+= __divdi3.S __divsi3.S __moddi3.S __modsi3.S
+SRCS+= __udivdi3.S __udivsi3.S __umoddi3.S __umodsi3.S
+.endif
+.if ${MACHINE_ARCH} == "powerpc"
+.PATH: ${.CURDIR}/../libc/quad
+SRCS+=	ashldi3.c ashrdi3.c
+.PATH: ${.CURDIR}/../libc/powerpc/gen
+SRCS+=	syncicache.c
+.endif
+
+# uuid functions from libc
+.PATH: ${.CURDIR}/../libc/uuid
+SRCS+= uuid_equal.c uuid_is_nil.c
+
+# _setjmp/_longjmp
+.if ${MACHINE_ARCH} == "amd64"
+.PATH: ${.CURDIR}/i386
+.else
+.PATH: ${.CURDIR}/${MACHINE_ARCH}
+.endif
+SRCS+=	_setjmp.S
+
+# decompression functionality from libbz2
+# NOTE: to actually test this functionality after libbz2 upgrade compile
+# loader(8) with LOADER_BZIP2_SUPPORT defined
+.PATH: ${.CURDIR}/../../contrib/bzip2
+CFLAGS+= -DBZ_NO_STDIO -DBZ_NO_COMPRESS
+SRCS+=	libstand_bzlib_private.h
+
+.for file in bzlib.c crctable.c decompress.c huffman.c randtable.c
+SRCS+=	_${file}
+CLEANFILES+=	_${file}
+
+_${file}: ${file}
+	sed "s|bzlib_private\.h|libstand_bzlib_private.h|" ${.ALLSRC} > ${.TARGET}
+.endfor
+
+CLEANFILES+= libstand_bzlib_private.h
+libstand_bzlib_private.h: bzlib_private.h
+	sed -e 's|<stdlib.h>|"stand.h"|' \
+		${.ALLSRC} > ${.TARGET}
+
+# decompression functionality from libz
+.PATH: ${.CURDIR}/../libz
+CFLAGS+=-DHAVE_MEMCPY -I${.CURDIR}/../libz
+SRCS+=	adler32.c crc32.c libstand_zutil.h
+
+.for file in infback.c inffast.c inflate.c inftrees.c zutil.c
+SRCS+=	_${file}
+CLEANFILES+=	_${file}
+
+_${file}: ${file}
+	sed "s|zutil\.h|libstand_zutil.h|" ${.ALLSRC} > ${.TARGET}
+.endfor
+
+# depend on stand.h being able to be included multiple times
+CLEANFILES+= libstand_zutil.h
+libstand_zutil.h: zutil.h
+	sed -e 's|<stddef.h>|"stand.h"|' \
+	    -e 's|<string.h>|"stand.h"|' \
+	    -e 's|<stdlib.h>|"stand.h"|' \
+	    ${.ALLSRC} > ${.TARGET}
+
+# io routines
+SRCS+=	closeall.c dev.c ioctl.c nullfs.c stat.c \
+	fstat.c close.c lseek.c open.c read.c write.c readdir.c
+
+# network routines
+SRCS+=	arp.c ether.c inet_ntoa.c in_cksum.c net.c udp.c netif.c rpc.c
+
+# network info services:
+SRCS+=	bootp.c rarp.c bootparam.c
+
+# boot filesystems
+SRCS+=	ufs.c nfs.c cd9660.c tftp.c gzipfs.c bzipfs.c
+SRCS+=	dosfs.c ext2fs.c
+SRCS+=	splitfs.c
+
+.include <bsd.lib.mk>
+
+.if ${MACHINE_ARCH} == "amd64"
+beforedepend ${OBJS}: machine
+cleandepend: cleanmachine
+cleanmachine:
+	rm -f machine
+
+machine:
+	ln -s ${.CURDIR}/../../sys/i386/include machine
+.endif
diff -ruN sys/boot/i386/pxe_ng/libstand/__main.c sys/boot/i386/pxe_ng/libstand/__main.c
--- sys/boot/i386/pxe_ng/libstand/__main.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/__main.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,43 @@
+/*	$NetBSD: __main.c,v 1.4 1996/03/14 18:52:03 christos Exp $	*/
+
+/*
+ * Copyright (c) 1993 Christopher G. Demetriou
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Christopher G. Demetriou.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+
+void __main(void);
+
+void
+__main()
+{
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/arm/_setjmp.S sys/boot/i386/pxe_ng/libstand/arm/_setjmp.S
--- sys/boot/i386/pxe_ng/libstand/arm/_setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/arm/_setjmp.S	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,106 @@
+/*	$NetBSD: _setjmp.S,v 1.5 2003/04/05 23:08:51 bjh21 Exp $	*/
+
+/*
+ * Copyright (c) 1997 Mark Brinicombe
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Mark Brinicombe
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <machine/asm.h>
+__FBSDID("$FreeBSD$");
+
+#define SOFTFLOAT /* XXX */
+/*
+ * C library -- _setjmp, _longjmp
+ *
+ *	_longjmp(a,v)
+ * will generate a "return(v)" from the last call to
+ *	_setjmp(a)
+ * by restoring registers from the stack.
+ * The previous signal state is NOT restored.
+ *
+ * Note: r0 is the return value
+ *       r1-r3 are scratch registers in functions
+ */
+
+ENTRY(_setjmp)
+	ldr	r1, .L_setjmp_magic
+	str	r1, [r0], #4
+#ifdef SOFTFLOAT
+	add	r0, r0, #52
+#else
+	/* Store fp registers */
+	sfm	f4, 4, [r0], #48
+	/* Store fpsr */
+	rfs	r1
+	str	r1, [r0], #0x0004
+#endif	/* SOFTFLOAT */
+	/* Store integer registers */
+        stmia	r0, {r4-r14}
+
+        mov	r0, #0x00000000
+        mov	r15, r14
+
+.L_setjmp_magic:
+	.word	_JB_MAGIC__SETJMP
+
+ENTRY(_longjmp)
+	ldr	r2, .L_setjmp_magic
+	ldr	r3, [r0], #4
+	teq	r2, r3
+	bne	botch
+
+#ifdef SOFTFLOAT
+	add	r0, r0, #52
+#else
+	/* Restore fp registers */
+	lfm	f4, 4, [r0], #48
+	/* Restore fpsr */
+	ldr	r4, [r0], #0x0004
+	wfs	r4
+#endif	/* SOFTFLOAT */
+       	/* Restore integer registers */
+        ldmia	r0, {r4-r14}
+
+	/* Validate sp and r14 */
+	teq	sp, #0
+	teqne	r14, #0
+	beq	botch
+
+	/* Set return value */
+	mov	r0, r1
+	teq	r0, #0x00000000
+	moveq	r0, #0x00000001
+	mov	r15, r14
+
+	/* validation failed, die die die. */
+botch:
+	bl	PIC_SYM(_C_LABEL(longjmperror), PLT)
+	bl	PIC_SYM(_C_LABEL(abort), PLT)
+	b	. - 8		/* Cannot get here */
diff -ruN sys/boot/i386/pxe_ng/libstand/arp.c sys/boot/i386/pxe_ng/libstand/arp.c
--- sys/boot/i386/pxe_ng/libstand/arp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/arp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,309 @@
+/*	$NetBSD: arp.c,v 1.18 1997/07/07 15:52:49 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: arp.c,v 1.5 93/07/15 05:52:26 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <netinet/in_systm.h>
+
+#include <string.h>
+
+#include "stand.h"
+#include "net.h"
+
+/* Cache stuff */
+#define ARP_NUM 8			/* need at most 3 arp entries */
+
+struct arp_list {
+	struct in_addr	addr;
+	u_char		ea[6];
+} arp_list[ARP_NUM] = {
+	/* XXX - net order `INADDR_BROADCAST' must be a constant */
+	{ {0xffffffff}, BA }
+};
+int arp_num = 1;
+
+/* Local forwards */
+static	ssize_t arpsend(struct iodesc *, void *, size_t);
+static	ssize_t arprecv(struct iodesc *, void *, size_t, time_t);
+
+/* Broadcast an ARP packet, asking who has addr on interface d */
+u_char *
+arpwhohas(d, addr)
+	struct iodesc *d;
+	struct in_addr addr;
+{
+	int i;
+	struct ether_arp *ah;
+	struct arp_list *al;
+	struct {
+		struct ether_header eh;
+		struct {
+			struct ether_arp arp;
+			u_char pad[18]; 	/* 60 - sizeof(...) */
+		} data;
+	} wbuf;
+	struct {
+		struct ether_header eh;
+		struct {
+			struct ether_arp arp;
+			u_char pad[24]; 	/* extra space */
+		} data;
+	} rbuf;
+
+	/* Try for cached answer first */
+	for (i = 0, al = arp_list; i < arp_num; ++i, ++al)
+		if (addr.s_addr == al->addr.s_addr)
+			return (al->ea);
+
+	/* Don't overflow cache */
+	if (arp_num > ARP_NUM - 1) {
+		arp_num = 1;	/* recycle */
+		printf("arpwhohas: overflowed arp_list!\n");
+	}
+
+#ifdef ARP_DEBUG
+ 	if (debug)
+ 	    printf("arpwhohas: send request for %s\n", inet_ntoa(addr));
+#endif
+
+	bzero((char*)&wbuf.data, sizeof(wbuf.data));
+	ah = &wbuf.data.arp;
+	ah->arp_hrd = htons(ARPHRD_ETHER);
+	ah->arp_pro = htons(ETHERTYPE_IP);
+	ah->arp_hln = sizeof(ah->arp_sha); /* hardware address length */
+	ah->arp_pln = sizeof(ah->arp_spa); /* protocol address length */
+	ah->arp_op = htons(ARPOP_REQUEST);
+	MACPY(d->myea, ah->arp_sha);
+	bcopy(&d->myip, ah->arp_spa, sizeof(ah->arp_spa));
+	/* Leave zeros in arp_tha */
+	bcopy(&addr, ah->arp_tpa, sizeof(ah->arp_tpa));
+
+	/* Store ip address in cache (incomplete entry). */
+	al->addr = addr;
+
+	i = sendrecv(d,
+	    arpsend, &wbuf.data, sizeof(wbuf.data),
+	    arprecv, &rbuf.data, sizeof(rbuf.data));
+	if (i == -1) {
+		panic("arp: no response for %s\n",
+			  inet_ntoa(addr));
+	}
+
+	/* Store ethernet address in cache */
+	ah = &rbuf.data.arp;
+#ifdef ARP_DEBUG
+ 	if (debug) {
+		printf("arp: response from %s\n",
+		    ether_sprintf(rbuf.eh.ether_shost));
+		printf("arp: cacheing %s --> %s\n",
+		    inet_ntoa(addr), ether_sprintf(ah->arp_sha));
+	}
+#endif
+	MACPY(ah->arp_sha, al->ea);
+	++arp_num;
+
+	return (al->ea);
+}
+
+static ssize_t
+arpsend(d, pkt, len)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+{
+
+#ifdef ARP_DEBUG
+ 	if (debug)
+		printf("arpsend: called\n");
+#endif
+
+	return (sendether(d, pkt, len, bcea, ETHERTYPE_ARP));
+}
+
+/*
+ * Returns 0 if this is the packet we're waiting for
+ * else -1 (and errno == 0)
+ */
+static ssize_t
+arprecv(d, pkt, len, tleft)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	time_t tleft;
+{
+	ssize_t n;
+	struct ether_arp *ah;
+	u_int16_t etype;	/* host order */
+
+#ifdef ARP_DEBUG
+ 	if (debug)
+		printf("arprecv: ");
+#endif
+
+	n = readether(d, pkt, len, tleft, &etype);
+	errno = 0;	/* XXX */
+	if (n == -1 || n < sizeof(struct ether_arp)) {
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("bad len=%d\n", n);
+#endif
+		return (-1);
+	}
+
+	if (etype != ETHERTYPE_ARP) {
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("not arp type=%d\n", etype);
+#endif
+		return (-1);
+	}
+
+	/* Ethernet address now checked in readether() */
+
+	ah = (struct ether_arp *)pkt;
+	if (ah->arp_hrd != htons(ARPHRD_ETHER) ||
+	    ah->arp_pro != htons(ETHERTYPE_IP) ||
+	    ah->arp_hln != sizeof(ah->arp_sha) ||
+	    ah->arp_pln != sizeof(ah->arp_spa) )
+	{
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("bad hrd/pro/hln/pln\n");
+#endif
+		return (-1);
+	}
+
+	if (ah->arp_op == htons(ARPOP_REQUEST)) {
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("is request\n");
+#endif
+		arp_reply(d, ah);
+		return (-1);
+	}
+
+	if (ah->arp_op != htons(ARPOP_REPLY)) {
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("not ARP reply\n");
+#endif
+		return (-1);
+	}
+
+	/* Is the reply from the source we want? */
+	if (bcmp(&arp_list[arp_num].addr,
+			 ah->arp_spa, sizeof(ah->arp_spa)))
+	{
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("unwanted address\n");
+#endif
+		return (-1);
+	}
+	/* We don't care who the reply was sent to. */
+
+	/* We have our answer. */
+#ifdef ARP_DEBUG
+ 	if (debug)
+		printf("got it\n");
+#endif
+	return (n);
+}
+
+/*
+ * Convert an ARP request into a reply and send it.
+ * Notes:  Re-uses buffer.  Pad to length = 46.
+ */
+void
+arp_reply(d, pkt)
+	struct iodesc *d;
+	void *pkt;		/* the request */
+{
+	struct ether_arp *arp = pkt;
+
+	if (arp->arp_hrd != htons(ARPHRD_ETHER) ||
+	    arp->arp_pro != htons(ETHERTYPE_IP) ||
+	    arp->arp_hln != sizeof(arp->arp_sha) ||
+	    arp->arp_pln != sizeof(arp->arp_spa) )
+	{
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("arp_reply: bad hrd/pro/hln/pln\n");
+#endif
+		return;
+	}
+
+	if (arp->arp_op != htons(ARPOP_REQUEST)) {
+#ifdef ARP_DEBUG
+		if (debug)
+			printf("arp_reply: not request!\n");
+#endif
+		return;
+	}
+
+	/* If we are not the target, ignore the request. */
+	if (bcmp(arp->arp_tpa, &d->myip, sizeof(arp->arp_tpa)))
+		return;
+
+#ifdef ARP_DEBUG
+	if (debug) {
+		printf("arp_reply: to %s\n", ether_sprintf(arp->arp_sha));
+	}
+#endif
+
+	arp->arp_op = htons(ARPOP_REPLY);
+	/* source becomes target */
+	bcopy(arp->arp_sha, arp->arp_tha, sizeof(arp->arp_tha));
+	bcopy(arp->arp_spa, arp->arp_tpa, sizeof(arp->arp_tpa));
+	/* here becomes source */
+	bcopy(d->myea,  arp->arp_sha, sizeof(arp->arp_sha));
+	bcopy(&d->myip, arp->arp_spa, sizeof(arp->arp_spa));
+
+	/*
+	 * No need to get fancy here.  If the send fails, the
+	 * requestor will just ask again.
+	 */
+	(void) sendether(d, pkt, sizeof(*arp) + 18,
+	                 arp->arp_tha, ETHERTYPE_ARP);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/assert.c sys/boot/i386/pxe_ng/libstand/assert.c
--- sys/boot/i386/pxe_ng/libstand/assert.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/assert.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,44 @@
+/*-
+ * Copyright (c) 1998 Michael Smith.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <assert.h>
+
+#include "stand.h"
+
+void
+__assert(const char *func, const char *file, int line, const char *expression)
+{
+	if (func == NULL)
+		printf("Assertion failed: (%s), file %s, line %d.\n",
+		    expression, file, line);
+	else
+		printf("Assertion failed: (%s), function %s, file %s, line "
+		    "%d.\n", expression, func, file, line);
+	exit();
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/bcd.c sys/boot/i386/pxe_ng/libstand/bcd.c
--- sys/boot/i386/pxe_ng/libstand/bcd.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bcd.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,38 @@
+/*
+ * Some data-tables that are often used.
+ * Cannot be copyrighted.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+
+u_char const bcd2bin_data[] = {
+	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 0, 0, 0, 0, 0, 0,
+	10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 0, 0, 0, 0, 0,
+	20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0, 0, 0, 0, 0, 0,
+	30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 0, 0, 0, 0, 0, 0,
+	40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 0, 0, 0, 0, 0, 0,
+	50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 0, 0, 0, 0, 0, 0,
+	60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 0, 0, 0, 0, 0, 0,
+	70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 0, 0, 0, 0, 0, 0,
+	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 0, 0, 0, 0, 0, 0,
+	90, 91, 92, 93, 94, 95, 96, 97, 98, 99
+};
+
+u_char const bin2bcd_data[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99
+};
+
+/* This is actually used with radix [2..36] */
+char const hex2ascii_data[] = "0123456789abcdefghijklmnopqrstuvwxyz";
diff -ruN sys/boot/i386/pxe_ng/libstand/bootp.c sys/boot/i386/pxe_ng/libstand/bootp.c
--- sys/boot/i386/pxe_ng/libstand/bootp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bootp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,414 @@
+/*	$NetBSD: bootp.c,v 1.14 1998/02/16 11:10:54 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: bootp.c,v 1.4 93/09/11 03:13:51 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include <string.h>
+
+#define BOOTP_DEBUGxx
+#define SUPPORT_DHCP
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+#include "bootp.h"
+
+
+struct in_addr servip;
+
+static n_long	nmask, smask;
+
+static time_t	bot;
+
+static	char vm_rfc1048[4] = VM_RFC1048;
+#ifdef BOOTP_VEND_CMU
+static	char vm_cmu[4] = VM_CMU;
+#endif
+
+/* Local forwards */
+static	ssize_t bootpsend(struct iodesc *, void *, size_t);
+static	ssize_t bootprecv(struct iodesc *, void *, size_t, time_t);
+static	int vend_rfc1048(u_char *, u_int);
+#ifdef BOOTP_VEND_CMU
+static	void vend_cmu(u_char *);
+#endif
+
+#ifdef SUPPORT_DHCP
+static char expected_dhcpmsgtype = -1, dhcp_ok;
+struct in_addr dhcp_serverip;
+#endif
+
+/* Fetch required bootp infomation */
+void
+bootp(sock, flag)
+	int sock;
+	int flag;
+{
+	struct iodesc *d;
+	struct bootp *bp;
+	struct {
+		u_char header[HEADER_SIZE];
+		struct bootp wbootp;
+	} wbuf;
+	struct {
+		u_char header[HEADER_SIZE];
+		struct bootp rbootp;
+	} rbuf;
+
+#ifdef BOOTP_DEBUG
+ 	if (debug)
+		printf("bootp: socket=%d\n", sock);
+#endif
+	if (!bot)
+		bot = getsecs();
+	
+	if (!(d = socktodesc(sock))) {
+		printf("bootp: bad socket. %d\n", sock);
+		return;
+	}
+#ifdef BOOTP_DEBUG
+ 	if (debug)
+		printf("bootp: d=%lx\n", (long)d);
+#endif
+
+	bp = &wbuf.wbootp;
+	bzero(bp, sizeof(*bp));
+
+	bp->bp_op = BOOTREQUEST;
+	bp->bp_htype = 1;		/* 10Mb Ethernet (48 bits) */
+	bp->bp_hlen = 6;
+	bp->bp_xid = htonl(d->xid);
+	MACPY(d->myea, bp->bp_chaddr);
+	strncpy(bp->bp_file, bootfile, sizeof(bp->bp_file));
+	bcopy(vm_rfc1048, bp->bp_vend, sizeof(vm_rfc1048));
+#ifdef SUPPORT_DHCP
+	bp->bp_vend[4] = TAG_DHCP_MSGTYPE;
+	bp->bp_vend[5] = 1;
+	bp->bp_vend[6] = DHCPDISCOVER;
+
+	/*
+	 * If we are booting from PXE, we want to send the string
+	 * 'PXEClient' to the DHCP server so you have the option of
+	 * only responding to PXE aware dhcp requests.
+	 */
+	if (flag & BOOTP_PXE) {
+		bp->bp_vend[7] = TAG_CLASSID;
+		bp->bp_vend[8] = 9;
+		bcopy("PXEClient", &bp->bp_vend[9], 9);
+		bp->bp_vend[18] = TAG_END;
+	} else
+		bp->bp_vend[7] = TAG_END;
+#else
+	bp->bp_vend[4] = TAG_END;
+#endif
+
+	d->myip.s_addr = INADDR_ANY;
+	d->myport = htons(IPPORT_BOOTPC);
+	d->destip.s_addr = INADDR_BROADCAST;
+	d->destport = htons(IPPORT_BOOTPS);
+
+#ifdef SUPPORT_DHCP
+	expected_dhcpmsgtype = DHCPOFFER;
+	dhcp_ok = 0;
+#endif
+
+	if(sendrecv(d,
+		    bootpsend, bp, sizeof(*bp),
+		    bootprecv, &rbuf.rbootp, sizeof(rbuf.rbootp))
+	   == -1) {
+	    printf("bootp: no reply\n");
+	    return;
+	}
+
+#ifdef SUPPORT_DHCP
+	if(dhcp_ok) {
+		u_int32_t leasetime;
+		bp->bp_vend[6] = DHCPREQUEST;
+		bp->bp_vend[7] = TAG_REQ_ADDR;
+		bp->bp_vend[8] = 4;
+		bcopy(&rbuf.rbootp.bp_yiaddr, &bp->bp_vend[9], 4);
+		bp->bp_vend[13] = TAG_SERVERID;
+		bp->bp_vend[14] = 4;
+		bcopy(&dhcp_serverip.s_addr, &bp->bp_vend[15], 4);
+		bp->bp_vend[19] = TAG_LEASETIME;
+		bp->bp_vend[20] = 4;
+		leasetime = htonl(300);
+		bcopy(&leasetime, &bp->bp_vend[21], 4);
+		if (flag & BOOTP_PXE) {
+			bp->bp_vend[25] = TAG_CLASSID;
+			bp->bp_vend[26] = 9;
+			bcopy("PXEClient", &bp->bp_vend[27], 9);
+			bp->bp_vend[36] = TAG_END;
+		} else
+			bp->bp_vend[25] = TAG_END;
+
+		expected_dhcpmsgtype = DHCPACK;
+
+		if(sendrecv(d,
+			    bootpsend, bp, sizeof(*bp),
+			    bootprecv, &rbuf.rbootp, sizeof(rbuf.rbootp))
+		   == -1) {
+			printf("DHCPREQUEST failed\n");
+			return;
+		}
+	}
+#endif
+
+	myip = d->myip = rbuf.rbootp.bp_yiaddr;
+	servip = rbuf.rbootp.bp_siaddr;
+	if(rootip.s_addr == INADDR_ANY) rootip = servip;
+	bcopy(rbuf.rbootp.bp_file, bootfile, sizeof(bootfile));
+	bootfile[sizeof(bootfile) - 1] = '\0';
+
+	if (IN_CLASSA(ntohl(myip.s_addr)))
+		nmask = htonl(IN_CLASSA_NET);
+	else if (IN_CLASSB(ntohl(myip.s_addr)))
+		nmask = htonl(IN_CLASSB_NET);
+	else
+		nmask = htonl(IN_CLASSC_NET);
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("'native netmask' is %s\n", intoa(nmask));
+#endif
+
+	/* Check subnet mask against net mask; toss if bogus */
+	if ((nmask & smask) != nmask) {
+#ifdef BOOTP_DEBUG
+		if (debug)
+			printf("subnet mask (%s) bad\n", intoa(smask));
+#endif
+		smask = 0;
+	}
+
+	/* Get subnet (or natural net) mask */
+	netmask = nmask;
+	if (smask)
+		netmask = smask;
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("mask: %s\n", intoa(netmask));
+#endif
+
+	/* We need a gateway if root is on a different net */
+	if (!SAMENET(myip, rootip, netmask)) {
+#ifdef BOOTP_DEBUG
+		if (debug)
+			printf("need gateway for root ip\n");
+#endif
+	}
+
+	/* Toss gateway if on a different net */
+	if (!SAMENET(myip, gateip, netmask)) {
+#ifdef BOOTP_DEBUG
+		if (debug)
+			printf("gateway ip (%s) bad\n", inet_ntoa(gateip));
+#endif
+		gateip.s_addr = 0;
+	}
+
+	/* Bump xid so next request will be unique. */
+	++d->xid;
+}
+
+/* Transmit a bootp request */
+static ssize_t
+bootpsend(d, pkt, len)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+{
+	struct bootp *bp;
+
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("bootpsend: d=%lx called.\n", (long)d);
+#endif
+
+	bp = pkt;
+	bp->bp_secs = htons((u_short)(getsecs() - bot));
+
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("bootpsend: calling sendudp\n");
+#endif
+
+	return (sendudp(d, pkt, len));
+}
+
+static ssize_t
+bootprecv(d, pkt, len, tleft)
+struct iodesc *d;
+void *pkt;
+size_t len;
+time_t tleft;
+{
+	ssize_t n;
+	struct bootp *bp;
+
+#ifdef BOOTP_DEBUGx
+	if (debug)
+		printf("bootp_recvoffer: called\n");
+#endif
+
+	n = readudp(d, pkt, len, tleft);
+	if (n == -1 || n < sizeof(struct bootp) - BOOTP_VENDSIZE)
+		goto bad;
+
+	bp = (struct bootp *)pkt;
+	
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("bootprecv: checked.  bp = 0x%lx, n = %d\n",
+		    (long)bp, (int)n);
+#endif
+	if (bp->bp_xid != htonl(d->xid)) {
+#ifdef BOOTP_DEBUG
+		if (debug) {
+			printf("bootprecv: expected xid 0x%lx, got 0x%x\n",
+			    d->xid, ntohl(bp->bp_xid));
+		}
+#endif
+		goto bad;
+	}
+
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("bootprecv: got one!\n");
+#endif
+
+	/* Suck out vendor info */
+	if (bcmp(vm_rfc1048, bp->bp_vend, sizeof(vm_rfc1048)) == 0) {
+		if(vend_rfc1048(bp->bp_vend, sizeof(bp->bp_vend)) != 0)
+		    goto bad;
+	}
+#ifdef BOOTP_VEND_CMU
+	else if (bcmp(vm_cmu, bp->bp_vend, sizeof(vm_cmu)) == 0)
+		vend_cmu(bp->bp_vend);
+#endif
+	else
+		printf("bootprecv: unknown vendor 0x%lx\n", (long)bp->bp_vend);
+
+	return(n);
+bad:
+	errno = 0;
+	return (-1);
+}
+
+static int
+vend_rfc1048(cp, len)
+	u_char *cp;
+	u_int len;
+{
+	u_char *ep;
+	int size;
+	u_char tag;
+
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("vend_rfc1048 bootp info. len=%d\n", len);
+#endif
+	ep = cp + len;
+
+	/* Step over magic cookie */
+	cp += sizeof(int);
+
+	while (cp < ep) {
+		tag = *cp++;
+		size = *cp++;
+		if (tag == TAG_END)
+			break;
+
+		if (tag == TAG_SUBNET_MASK) {
+			bcopy(cp, &smask, sizeof(smask));
+		}
+		if (tag == TAG_GATEWAY) {
+			bcopy(cp, &gateip.s_addr, sizeof(gateip.s_addr));
+		}
+		if (tag == TAG_SWAPSERVER) {
+			/* let it override bp_siaddr */
+			bcopy(cp, &rootip.s_addr, sizeof(swapip.s_addr));
+		}
+		if (tag == TAG_ROOTPATH) {
+			strncpy(rootpath, (char *)cp, sizeof(rootpath));
+			rootpath[size] = '\0';
+		}
+		if (tag == TAG_HOSTNAME) {
+			strncpy(hostname, (char *)cp, sizeof(hostname));
+			hostname[size] = '\0';
+		}
+#ifdef SUPPORT_DHCP
+		if (tag == TAG_DHCP_MSGTYPE) {
+			if(*cp != expected_dhcpmsgtype)
+			    return(-1);
+			dhcp_ok = 1;
+		}
+		if (tag == TAG_SERVERID) {
+			bcopy(cp, &dhcp_serverip.s_addr,
+			      sizeof(dhcp_serverip.s_addr));
+		}
+#endif
+		cp += size;
+	}
+	return(0);
+}
+
+#ifdef BOOTP_VEND_CMU
+static void
+vend_cmu(cp)
+	u_char *cp;
+{
+	struct cmu_vend *vp;
+
+#ifdef BOOTP_DEBUG
+	if (debug)
+		printf("vend_cmu bootp info.\n");
+#endif
+	vp = (struct cmu_vend *)cp;
+
+	if (vp->v_smask.s_addr != 0) {
+		smask = vp->v_smask.s_addr;
+	}
+	if (vp->v_dgate.s_addr != 0) {
+		gateip = vp->v_dgate;
+	}
+}
+#endif
diff -ruN sys/boot/i386/pxe_ng/libstand/bootp.h sys/boot/i386/pxe_ng/libstand/bootp.h
--- sys/boot/i386/pxe_ng/libstand/bootp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bootp.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,145 @@
+/*	$NetBSD: bootp.h,v 1.4 1997/09/06 13:55:57 drochner Exp $	*/
+
+/*
+ * Bootstrap Protocol (BOOTP).  RFC951 and RFC1048.
+ *
+ * This file specifies the "implementation-independent" BOOTP protocol
+ * information which is common to both client and server.
+ *
+ * Copyright 1988 by Carnegie Mellon.
+ *
+ * Permission to use, copy, modify, and distribute this program for any
+ * purpose and without fee is hereby granted, provided that this copyright
+ * and permission notice appear on all copies and supporting documentation,
+ * the name of Carnegie Mellon not be used in advertising or publicity
+ * pertaining to distribution of the program without specific prior
+ * permission, and notice be given in supporting documentation that copying
+ * and distribution is by permission of Carnegie Mellon and Stanford
+ * University.  Carnegie Mellon makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * $FreeBSD$
+ */
+
+
+struct bootp {
+	unsigned char	bp_op;		/* packet opcode type */
+	unsigned char	bp_htype;	/* hardware addr type */
+	unsigned char	bp_hlen;	/* hardware addr length */
+	unsigned char	bp_hops;	/* gateway hops */
+	unsigned int	bp_xid;		/* transaction ID */
+	unsigned short	bp_secs;	/* seconds since boot began */
+	unsigned short	bp_flags;
+	struct in_addr	bp_ciaddr;	/* client IP address */
+	struct in_addr	bp_yiaddr;	/* 'your' IP address */
+	struct in_addr	bp_siaddr;	/* server IP address */
+	struct in_addr	bp_giaddr;	/* gateway IP address */
+	unsigned char	bp_chaddr[16];	/* client hardware address */
+	unsigned char	bp_sname[64];	/* server host name */
+	unsigned char	bp_file[128];	/* boot file name */
+#ifdef SUPPORT_DHCP
+#define BOOTP_VENDSIZE 312
+#else
+#define BOOTP_VENDSIZE 64
+#endif
+	unsigned char	bp_vend[BOOTP_VENDSIZE];	/* vendor-specific area */
+};
+
+/*
+ * UDP port numbers, server and client.
+ */
+#define	IPPORT_BOOTPS		67
+#define	IPPORT_BOOTPC		68
+
+#define BOOTREPLY		2
+#define BOOTREQUEST		1
+
+
+/*
+ * Vendor magic cookie (v_magic) for CMU
+ */
+#define VM_CMU		"CMU"
+
+/*
+ * Vendor magic cookie (v_magic) for RFC1048
+ */
+#define VM_RFC1048	{ 99, 130, 83, 99 }
+
+
+
+/*
+ * RFC1048 tag values used to specify what information is being supplied in
+ * the vendor field of the packet.
+ */
+
+#define TAG_PAD			((unsigned char)   0)
+#define TAG_SUBNET_MASK		((unsigned char)   1)
+#define TAG_TIME_OFFSET		((unsigned char)   2)
+#define TAG_GATEWAY		((unsigned char)   3)
+#define TAG_TIME_SERVER		((unsigned char)   4)
+#define TAG_NAME_SERVER		((unsigned char)   5)
+#define TAG_DOMAIN_SERVER	((unsigned char)   6)
+#define TAG_LOG_SERVER		((unsigned char)   7)
+#define TAG_COOKIE_SERVER	((unsigned char)   8)
+#define TAG_LPR_SERVER		((unsigned char)   9)
+#define TAG_IMPRESS_SERVER	((unsigned char)  10)
+#define TAG_RLP_SERVER		((unsigned char)  11)
+#define TAG_HOSTNAME		((unsigned char)  12)
+#define TAG_BOOTSIZE		((unsigned char)  13)
+#define TAG_DUMPFILE		((unsigned char)  14)
+#define TAG_DOMAINNAME		((unsigned char)  15)
+#define TAG_SWAPSERVER		((unsigned char)  16)
+#define TAG_ROOTPATH		((unsigned char)  17)
+
+#ifdef SUPPORT_DHCP
+#define TAG_REQ_ADDR		((unsigned char)  50)
+#define TAG_LEASETIME		((unsigned char)  51)
+#define TAG_OVERLOAD		((unsigned char)  52)
+#define TAG_DHCP_MSGTYPE	((unsigned char)  53)
+#define TAG_SERVERID		((unsigned char)  54)
+#define TAG_PARAM_REQ		((unsigned char)  55)
+#define TAG_MSG			((unsigned char)  56)
+#define TAG_MAXSIZE		((unsigned char)  57)
+#define TAG_T1			((unsigned char)  58)
+#define TAG_T2			((unsigned char)  59)
+#define TAG_CLASSID		((unsigned char)  60)
+#define TAG_CLIENTID		((unsigned char)  61)
+#endif
+
+#define TAG_END			((unsigned char) 255)
+
+#ifdef SUPPORT_DHCP
+#define DHCPDISCOVER 1
+#define DHCPOFFER 2
+#define DHCPREQUEST 3
+#define DHCPDECLINE 4
+#define DHCPACK 5
+#define DHCPNAK 6
+#define DHCPRELEASE 7
+#endif
+
+/*
+ * bootp flags
+ */
+#define	BOOTP_NONE		0x0000		/* No flags */
+#define	BOOTP_PXE		0x0001		/* Booting from PXE. */
+
+/*
+ * "vendor" data permitted for CMU bootp clients.
+ */
+
+struct cmu_vend {
+	unsigned char	v_magic[4];	/* magic number */
+	unsigned int	v_flags;	/* flags/opcodes, etc. */
+	struct in_addr	v_smask;	/* Subnet mask */
+	struct in_addr	v_dgate;	/* Default gateway */
+	struct in_addr	v_dns1, v_dns2; /* Domain name servers */
+	struct in_addr	v_ins1, v_ins2; /* IEN-116 name servers */
+	struct in_addr	v_ts1, v_ts2;	/* Time servers */
+	unsigned char	v_unused[25];	/* currently unused */
+};
+
+
+/* v_flags values */
+#define VF_SMASK	1	/* Subnet mask field contains valid data */
diff -ruN sys/boot/i386/pxe_ng/libstand/bootparam.c sys/boot/i386/pxe_ng/libstand/bootparam.c
--- sys/boot/i386/pxe_ng/libstand/bootparam.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bootparam.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,452 @@
+/*	$NetBSD: bootparam.c,v 1.11 1997/06/26 19:11:32 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1995 Gordon W. Ross
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 4. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Gordon W. Ross
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * RPC/bootparams
+ */
+
+#include <sys/param.h>
+#include <sys/socket.h>
+
+#include <net/if.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include <string.h>
+
+#include "rpcv2.h"
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+#include "rpc.h"
+#include "bootparam.h"
+
+#ifdef DEBUG_RPC
+#define RPC_PRINTF(a)	printf a
+#else
+#define RPC_PRINTF(a)
+#endif
+
+struct in_addr	bp_server_addr;	/* net order */
+n_short		bp_server_port;	/* net order */
+
+/*
+ * RPC definitions for bootparamd
+ */
+#define	BOOTPARAM_PROG		100026
+#define	BOOTPARAM_VERS		1
+#define BOOTPARAM_WHOAMI	1
+#define BOOTPARAM_GETFILE	2
+
+/*
+ * Inet address in RPC messages
+ * (Note, really four ints, NOT chars.  Blech.)
+ */
+struct xdr_inaddr {
+	u_int32_t  atype;
+	int32_t	addr[4];
+};
+
+int xdr_inaddr_encode(char **p, struct in_addr ia);
+int xdr_inaddr_decode(char **p, struct in_addr *ia);
+
+int xdr_string_encode(char **p, char *str, int len);
+int xdr_string_decode(char **p, char *str, int *len_p);
+
+
+/*
+ * RPC: bootparam/whoami
+ * Given client IP address, get:
+ *	client name	(hostname)
+ *	domain name (domainname)
+ *	gateway address
+ *
+ * The hostname and domainname are set here for convenience.
+ *
+ * Note - bpsin is initialized to the broadcast address,
+ * and will be replaced with the bootparam server address
+ * after this call is complete.  Have to use PMAP_PROC_CALL
+ * to make sure we get responses only from a servers that
+ * know about us (don't want to broadcast a getport call).
+ */
+int
+bp_whoami(sockfd)
+	int sockfd;
+{
+	/* RPC structures for PMAPPROC_CALLIT */
+	struct args {
+		u_int32_t prog;
+		u_int32_t vers;
+		u_int32_t proc;
+		u_int32_t arglen;
+		struct xdr_inaddr xina;
+	} *args;
+	struct repl {
+		u_int16_t _pad;
+		u_int16_t port;
+		u_int32_t encap_len;
+		/* encapsulated data here */
+		n_long  capsule[64];
+	} *repl;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct args d;
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct repl d;
+	} rdata;
+	char *send_tail, *recv_head;
+	struct iodesc *d;
+	int len, x;
+
+	RPC_PRINTF(("bp_whoami: myip=%s\n", inet_ntoa(myip)));
+
+	if (!(d = socktodesc(sockfd))) {
+		RPC_PRINTF(("bp_whoami: bad socket. %d\n", sockfd));
+		return (-1);
+	}
+	args = &sdata.d;
+	repl = &rdata.d;
+
+	/*
+	 * Build request args for PMAPPROC_CALLIT.
+	 */
+	args->prog = htonl(BOOTPARAM_PROG);
+	args->vers = htonl(BOOTPARAM_VERS);
+	args->proc = htonl(BOOTPARAM_WHOAMI);
+	args->arglen = htonl(sizeof(struct xdr_inaddr));
+	send_tail = (char*) &args->xina;
+
+	/*
+	 * append encapsulated data (client IP address)
+	 */
+	if (xdr_inaddr_encode(&send_tail, myip))
+		return (-1);
+
+	/* RPC: portmap/callit */
+	d->myport = htons(--rpc_port);
+	d->destip.s_addr = INADDR_BROADCAST;	/* XXX: subnet bcast? */
+	/* rpc_call will set d->destport */
+
+	len = rpc_call(d, PMAPPROG, PMAPVERS, PMAPPROC_CALLIT,
+				  args, send_tail - (char*)args,
+				  repl, sizeof(*repl));
+	if (len < 8) {
+		printf("bootparamd: 'whoami' call failed\n");
+		return (-1);
+	}
+
+	/* Save bootparam server address (from IP header). */
+	rpc_fromaddr(repl, &bp_server_addr, &bp_server_port);
+
+	/*
+	 * Note that bp_server_port is now 111 due to the
+	 * indirect call (using PMAPPROC_CALLIT), so get the
+	 * actual port number from the reply data.
+	 */
+	bp_server_port = repl->port;
+
+	RPC_PRINTF(("bp_whoami: server at %s:%d\n",
+	    inet_ntoa(bp_server_addr), ntohs(bp_server_port)));
+
+	/* We have just done a portmap call, so cache the portnum. */
+	rpc_pmap_putcache(bp_server_addr,
+			  BOOTPARAM_PROG,
+			  BOOTPARAM_VERS,
+			  (int)ntohs(bp_server_port));
+
+	/*
+	 * Parse the encapsulated results from bootparam/whoami
+	 */
+	x = ntohl(repl->encap_len);
+	if (len < x) {
+		printf("bp_whoami: short reply, %d < %d\n", len, x);
+		return (-1);
+	}
+	recv_head = (char*) repl->capsule;
+
+	/* client name */
+	hostnamelen = MAXHOSTNAMELEN-1;
+	if (xdr_string_decode(&recv_head, hostname, &hostnamelen)) {
+		RPC_PRINTF(("bp_whoami: bad hostname\n"));
+		return (-1);
+	}
+
+	/* domain name */
+	domainnamelen = MAXHOSTNAMELEN-1;
+	if (xdr_string_decode(&recv_head, domainname, &domainnamelen)) {
+		RPC_PRINTF(("bp_whoami: bad domainname\n"));
+		return (-1);
+	}
+
+	/* gateway address */
+	if (xdr_inaddr_decode(&recv_head, &gateip)) {
+		RPC_PRINTF(("bp_whoami: bad gateway\n"));
+		return (-1);
+	}
+
+	/* success */
+	return(0);
+}
+
+
+/*
+ * RPC: bootparam/getfile
+ * Given client name and file "key", get:
+ *	server name
+ *	server IP address
+ *	server pathname
+ */
+int
+bp_getfile(sockfd, key, serv_addr, pathname)
+	int sockfd;
+	char *key;
+	char *pathname;
+	struct in_addr *serv_addr;
+{
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		n_long  d[64];
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		n_long  d[128];
+	} rdata;
+	char serv_name[FNAME_SIZE];
+	char *send_tail, *recv_head;
+	/* misc... */
+	struct iodesc *d;
+	int sn_len, path_len, rlen;
+
+	if (!(d = socktodesc(sockfd))) {
+		RPC_PRINTF(("bp_getfile: bad socket. %d\n", sockfd));
+		return (-1);
+	}
+
+	send_tail = (char*) sdata.d;
+	recv_head = (char*) rdata.d;
+
+	/*
+	 * Build request message.
+	 */
+
+	/* client name (hostname) */
+	if (xdr_string_encode(&send_tail, hostname, hostnamelen)) {
+		RPC_PRINTF(("bp_getfile: bad client\n"));
+		return (-1);
+	}
+
+	/* key name (root or swap) */
+	if (xdr_string_encode(&send_tail, key, strlen(key))) {
+		RPC_PRINTF(("bp_getfile: bad key\n"));
+		return (-1);
+	}
+
+	/* RPC: bootparam/getfile */
+	d->myport = htons(--rpc_port);
+	d->destip   = bp_server_addr;
+	/* rpc_call will set d->destport */
+
+	rlen = rpc_call(d,
+		BOOTPARAM_PROG, BOOTPARAM_VERS, BOOTPARAM_GETFILE,
+		sdata.d, send_tail - (char*)sdata.d,
+		rdata.d, sizeof(rdata.d));
+	if (rlen < 4) {
+		RPC_PRINTF(("bp_getfile: short reply\n"));
+		errno = EBADRPC;
+		return (-1);
+	}
+	recv_head = (char*) rdata.d;
+
+	/*
+	 * Parse result message.
+	 */
+
+	/* server name */
+	sn_len = FNAME_SIZE-1;
+	if (xdr_string_decode(&recv_head, serv_name, &sn_len)) {
+		RPC_PRINTF(("bp_getfile: bad server name\n"));
+		return (-1);
+	}
+
+	/* server IP address (mountd/NFS) */
+	if (xdr_inaddr_decode(&recv_head, serv_addr)) {
+		RPC_PRINTF(("bp_getfile: bad server addr\n"));
+		return (-1);
+	}
+
+	/* server pathname */
+	path_len = MAXPATHLEN-1;
+	if (xdr_string_decode(&recv_head, pathname, &path_len)) {
+		RPC_PRINTF(("bp_getfile: bad server path\n"));
+		return (-1);
+	}
+
+	/* success */
+	return(0);
+}
+
+
+/*
+ * eXternal Data Representation routines.
+ * (but with non-standard args...)
+ */
+
+
+int
+xdr_string_encode(pkt, str, len)
+	char **pkt;
+	char *str;
+	int len;
+{
+	u_int32_t *lenp;
+	char *datap;
+	int padlen = (len + 3) & ~3;	/* padded length */
+
+	/* The data will be int aligned. */
+	lenp = (u_int32_t*) *pkt;
+	*pkt += sizeof(*lenp);
+	*lenp = htonl(len);
+
+	datap = *pkt;
+	*pkt += padlen;
+	bcopy(str, datap, len);
+
+	return (0);
+}
+
+int
+xdr_string_decode(pkt, str, len_p)
+	char **pkt;
+	char *str;
+	int *len_p;		/* bufsize - 1 */
+{
+	u_int32_t *lenp;
+	char *datap;
+	int slen;	/* string length */
+	int plen;	/* padded length */
+
+	/* The data will be int aligned. */
+	lenp = (u_int32_t*) *pkt;
+	*pkt += sizeof(*lenp);
+	slen = ntohl(*lenp);
+	plen = (slen + 3) & ~3;
+
+	if (slen > *len_p)
+		slen = *len_p;
+	datap = *pkt;
+	*pkt += plen;
+	bcopy(datap, str, slen);
+
+	str[slen] = '\0';
+	*len_p = slen;
+
+	return (0);
+}
+
+
+int
+xdr_inaddr_encode(pkt, ia)
+	char **pkt;
+	struct in_addr ia;		/* network order */
+{
+	struct xdr_inaddr *xi;
+	u_char *cp;
+	int32_t *ip;
+	union {
+		n_long l;	/* network order */
+		u_char c[4];
+	} uia;
+
+	/* The data will be int aligned. */
+	xi = (struct xdr_inaddr *) *pkt;
+	*pkt += sizeof(*xi);
+	xi->atype = htonl(1);
+	uia.l = ia.s_addr;
+	cp = uia.c;
+	ip = xi->addr;
+	/*
+	 * Note: the htonl() calls below DO NOT
+	 * imply that uia.l is in host order.
+	 * In fact this needs it in net order.
+	 */
+	*ip++ = htonl((unsigned int)*cp++);
+	*ip++ = htonl((unsigned int)*cp++);
+	*ip++ = htonl((unsigned int)*cp++);
+	*ip++ = htonl((unsigned int)*cp++);
+
+	return (0);
+}
+
+int
+xdr_inaddr_decode(pkt, ia)
+	char **pkt;
+	struct in_addr *ia;		/* network order */
+{
+	struct xdr_inaddr *xi;
+	u_char *cp;
+	int32_t *ip;
+	union {
+		n_long l;	/* network order */
+		u_char c[4];
+	} uia;
+
+	/* The data will be int aligned. */
+	xi = (struct xdr_inaddr *) *pkt;
+	*pkt += sizeof(*xi);
+	if (xi->atype != htonl(1)) {
+		RPC_PRINTF(("xdr_inaddr_decode: bad addrtype=%d\n",
+		    ntohl(xi->atype)));
+		return(-1);
+	}
+
+	cp = uia.c;
+	ip = xi->addr;
+	/*
+	 * Note: the ntohl() calls below DO NOT
+	 * imply that uia.l is in host order.
+	 * In fact this needs it in net order.
+	 */
+	*cp++ = ntohl(*ip++);
+	*cp++ = ntohl(*ip++);
+	*cp++ = ntohl(*ip++);
+	*cp++ = ntohl(*ip++);
+	ia->s_addr = uia.l;
+
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/bootparam.h sys/boot/i386/pxe_ng/libstand/bootparam.h
--- sys/boot/i386/pxe_ng/libstand/bootparam.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bootparam.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,5 @@
+/*	$NetBSD: bootparam.h,v 1.3 1998/01/05 19:19:41 perry Exp $	*/
+
+int bp_whoami(int sock);
+int bp_getfile(int sock, char *key, struct in_addr *addrp, char *path);
+
diff -ruN sys/boot/i386/pxe_ng/libstand/bswap.c sys/boot/i386/pxe_ng/libstand/bswap.c
--- sys/boot/i386/pxe_ng/libstand/bswap.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bswap.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,40 @@
+/*
+ * Written by Manuel Bouyer <bouyer@netbsd.org>.
+ * Public domain.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char *rcsid = "$NetBSD: bswap32.c,v 1.1 1997/10/09 15:42:33 bouyer Exp $";
+static char *rcsid = "$NetBSD: bswap64.c,v 1.1 1997/10/09 15:42:33 bouyer Exp $";
+#endif
+
+#include <sys/types.h>
+
+#undef bswap32
+#undef bswap64
+
+u_int32_t
+bswap32(x)
+    u_int32_t x;
+{
+	return  ((x << 24) & 0xff000000 ) |
+			((x <<  8) & 0x00ff0000 ) |
+			((x >>  8) & 0x0000ff00 ) |
+			((x >> 24) & 0x000000ff );
+}
+
+u_int64_t
+bswap64(x)
+    u_int64_t x;
+{  
+	u_int32_t *p = (u_int32_t*)&x;
+	u_int32_t t;
+	t = bswap32(p[0]);
+	p[0] = bswap32(p[1]);
+	p[1] = t;
+	return x;
+}   
+
diff -ruN sys/boot/i386/pxe_ng/libstand/bzipfs.c sys/boot/i386/pxe_ng/libstand/bzipfs.c
--- sys/boot/i386/pxe_ng/libstand/bzipfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/bzipfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,303 @@
+/* 
+ * Copyright (c) 1998 Michael Smith.
+ * Copyright (c) 2000 Maxim Sobolev
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+#include <sys/stat.h>
+#include <string.h>
+#include <bzlib.h>
+
+#define BZ_BUFSIZE 2048	/* XXX larger? */
+
+struct bz_file
+{
+    int			bzf_rawfd;
+    bz_stream		bzf_bzstream;
+    char		bzf_buf[BZ_BUFSIZE];
+};
+
+static int	bzf_fill(struct bz_file *z);
+static int	bzf_open(const char *path, struct open_file *f);
+static int	bzf_close(struct open_file *f);
+static int	bzf_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	bzf_seek(struct open_file *f, off_t offset, int where);
+static int	bzf_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops bzipfs_fsops = {
+    "bzip",
+    bzf_open, 
+    bzf_close, 
+    bzf_read,
+    null_write,
+    bzf_seek,
+    bzf_stat,
+    null_readdir
+};
+
+#if 0
+void *
+calloc(int items, size_t size)
+{
+    return(malloc(items * size));
+}
+#endif
+
+static int
+bzf_fill(struct bz_file *bzf)
+{
+    int		result;
+    int		req;
+    
+    req = BZ_BUFSIZE - bzf->bzf_bzstream.avail_in;
+    result = 0;
+    
+    /* If we need more */
+    if (req > 0) {
+	/* move old data to bottom of buffer */
+	if (req < BZ_BUFSIZE)
+	    bcopy(bzf->bzf_buf + req, bzf->bzf_buf, BZ_BUFSIZE - req);
+	
+	/* read to fill buffer and update availibility data */
+	result = read(bzf->bzf_rawfd, bzf->bzf_buf + bzf->bzf_bzstream.avail_in, req);
+	bzf->bzf_bzstream.next_in = bzf->bzf_buf;
+	if (result >= 0)
+	    bzf->bzf_bzstream.avail_in += result;
+    }
+    return(result);
+}
+
+/*
+ * Adapted from get_byte/check_header in libz
+ *
+ * Returns 0 if the header is OK, nonzero if not.
+ */
+static int
+get_byte(struct bz_file *bzf)
+{
+    if ((bzf->bzf_bzstream.avail_in == 0) && (bzf_fill(bzf) == -1))
+	return(-1);
+    bzf->bzf_bzstream.avail_in--;
+    return(*(bzf->bzf_bzstream.next_in)++);
+}
+
+static int bz_magic[3] = {'B', 'Z', 'h'}; /* bzip2 magic header */
+
+static int
+check_header(struct bz_file *bzf)
+{
+    unsigned int len;
+    int		 c;
+
+    /* Check the bzip2 magic header */
+    for (len = 0; len < 3; len++) {
+	c = get_byte(bzf);
+	if (c != bz_magic[len]) {
+	    return(1);
+	}
+    }
+    /* Check that the block size is valid */
+    c = get_byte(bzf);
+    if (c < '1' || c > '9')
+	return(1);
+
+    /* Put back bytes that we've took from the input stream */
+    bzf->bzf_bzstream.next_in -= 4;
+    bzf->bzf_bzstream.avail_in += 4;
+
+    return(0);
+}
+	
+static int
+bzf_open(const char *fname, struct open_file *f)
+{
+    static char		*bzfname;
+    int			rawfd;
+    struct bz_file	*bzf;
+    char		*cp;
+    int			error;
+    struct stat		sb;
+
+    /* Have to be in "just read it" mode */
+    if (f->f_flags != F_READ)
+	return(EPERM);
+
+    /* If the name already ends in .gz or .bz2, ignore it */
+    if ((cp = strrchr(fname, '.')) && (!strcmp(cp, ".gz")
+	    || !strcmp(cp, ".bz2") || !strcmp(cp, ".split")))
+	return(ENOENT);
+
+    /* Construct new name */
+    bzfname = malloc(strlen(fname) + 5);
+    sprintf(bzfname, "%s.bz2", fname);
+
+    /* Try to open the compressed datafile */
+    rawfd = open(bzfname, O_RDONLY);
+    free(bzfname);
+    if (rawfd == -1)
+	return(ENOENT);
+
+    if (fstat(rawfd, &sb) < 0) {
+	printf("bzf_open: stat failed\n");
+	close(rawfd);
+	return(ENOENT);
+    }
+    if (!S_ISREG(sb.st_mode)) {
+	printf("bzf_open: not a file\n");
+	close(rawfd);
+	return(EISDIR);			/* best guess */
+    }
+
+    /* Allocate a bz_file structure, populate it */
+    bzf = malloc(sizeof(struct bz_file));
+    bzero(bzf, sizeof(struct bz_file));
+    bzf->bzf_rawfd = rawfd;
+
+    /* Verify that the file is bzipped (XXX why do this afterwards?) */
+    if (check_header(bzf)) {
+	close(bzf->bzf_rawfd);
+	BZ2_bzDecompressEnd(&(bzf->bzf_bzstream));
+	free(bzf);
+	return(EFTYPE);
+    }
+
+    /* Initialise the inflation engine */
+    if ((error = BZ2_bzDecompressInit(&(bzf->bzf_bzstream), 0, 1)) != BZ_OK) {
+	printf("bzf_open: BZ2_bzDecompressInit returned %d\n", error);
+	close(bzf->bzf_rawfd);
+	free(bzf);
+	return(EIO);
+    }
+
+    /* Looks OK, we'll take it */
+    f->f_fsdata = bzf;
+    return(0);
+}
+
+static int
+bzf_close(struct open_file *f)
+{
+    struct bz_file	*bzf = (struct bz_file *)f->f_fsdata;
+    
+    BZ2_bzDecompressEnd(&(bzf->bzf_bzstream));
+    close(bzf->bzf_rawfd);
+    free(bzf);
+    return(0);
+}
+ 
+static int 
+bzf_read(struct open_file *f, void *buf, size_t size, size_t *resid)
+{
+    struct bz_file	*bzf = (struct bz_file *)f->f_fsdata;
+    int			error;
+
+    bzf->bzf_bzstream.next_out = buf;			/* where and how much */
+    bzf->bzf_bzstream.avail_out = size;
+
+    while (bzf->bzf_bzstream.avail_out) {
+	if ((bzf->bzf_bzstream.avail_in == 0) && (bzf_fill(bzf) == -1)) {
+	    printf("bzf_read: fill error\n");
+	    return(EIO);
+	}
+	if (bzf->bzf_bzstream.avail_in == 0) {		/* oops, unexpected EOF */
+	    printf("bzf_read: unexpected EOF\n");
+	    if (bzf->bzf_bzstream.avail_out == size)
+		return (EIO);
+	    break;
+	}
+
+	error = BZ2_bzDecompress(&bzf->bzf_bzstream);	/* decompression pass */
+	if (error == BZ_STREAM_END) {			/* EOF, all done */
+	    break;
+	}
+	if (error != BZ_OK) {				/* argh, decompression error */
+	    printf("bzf_read: BZ2_bzDecompress returned %d\n", error);
+	    return(EIO);
+	}
+    }
+    if (resid != NULL)
+	*resid = bzf->bzf_bzstream.avail_out;
+    return(0);
+}
+
+static off_t
+bzf_seek(struct open_file *f, off_t offset, int where)
+{
+    struct bz_file	*bzf = (struct bz_file *)f->f_fsdata;
+    off_t		target;
+    char		discard[16];
+    
+    switch (where) {
+    case SEEK_SET:
+	target = offset;
+	break;
+    case SEEK_CUR:
+	target = offset + bzf->bzf_bzstream.total_out_lo32;
+	break;
+    case SEEK_END:
+	target = -1;
+    default:
+	errno = EINVAL;
+	return (-1);
+    }
+
+    /* Can we get there from here? */
+    if (target < bzf->bzf_bzstream.total_out_lo32) {
+	errno = EOFFSET;
+	return -1;
+    } 
+
+    /* skip forwards if required */
+    while (target > bzf->bzf_bzstream.total_out_lo32) {
+	errno = bzf_read(f, discard, min(sizeof(discard),
+	    target - bzf->bzf_bzstream.total_out_lo32), NULL);
+	if (errno)
+	    return(-1);
+    }
+    /* This is where we are (be honest if we overshot) */
+    return (bzf->bzf_bzstream.total_out_lo32);
+}
+
+static int
+bzf_stat(struct open_file *f, struct stat *sb)
+{
+    struct bz_file	*bzf = (struct bz_file *)f->f_fsdata;
+    int			result;
+
+    /* stat as normal, but indicate that size is unknown */
+    if ((result = fstat(bzf->bzf_rawfd, sb)) == 0)
+	sb->st_size = -1;
+    return(result);
+}
+
+void
+bz_internal_error(int errorcode)
+{
+    panic("bzipfs: critical error %d in bzip2 library occured\n", errorcode);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/cd9660.c sys/boot/i386/pxe_ng/libstand/cd9660.c
--- sys/boot/i386/pxe_ng/libstand/cd9660.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/cd9660.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,588 @@
+/*	$NetBSD: cd9660.c,v 1.5 1997/06/26 19:11:33 drochner Exp $	*/
+
+/*
+ * Copyright (C) 1996 Wolfgang Solfrank.
+ * Copyright (C) 1996 TooLs GmbH.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by TooLs GmbH.
+ * 4. The name of TooLs GmbH may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Stand-alone ISO9660 file reading package.
+ *
+ * Note: This doesn't support Rock Ridge extensions, extended attributes,
+ * blocksizes other than 2048 bytes, multi-extent files, etc.
+ */
+#include <sys/param.h>
+#include <string.h>
+#include <sys/dirent.h>
+#include <isofs/cd9660/iso.h>
+#include <isofs/cd9660/cd9660_rrip.h>
+
+#include "stand.h"
+
+#define	SUSP_CONTINUATION	"CE"
+#define	SUSP_PRESENT		"SP"
+#define	SUSP_STOP		"ST"
+#define	SUSP_EXTREF		"ER"
+#define	RRIP_NAME		"NM"
+
+typedef struct {
+	ISO_SUSP_HEADER		h;
+	u_char signature	[ISODCL (  5,    6)];
+	u_char len_skp		[ISODCL (  7,    7)]; /* 711 */
+} ISO_SUSP_PRESENT;
+	
+static int	buf_read_file(struct open_file *f, char **buf_p,
+		    size_t *size_p);
+static int	cd9660_open(const char *path, struct open_file *f);
+static int	cd9660_close(struct open_file *f);
+static int	cd9660_read(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static int	cd9660_write(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static off_t	cd9660_seek(struct open_file *f, off_t offset, int where);
+static int	cd9660_stat(struct open_file *f, struct stat *sb);
+static int	cd9660_readdir(struct open_file *f, struct dirent *d);
+static int	dirmatch(struct open_file *f, const char *path,
+		    struct iso_directory_record *dp, int use_rrip, int lenskip);
+static int	rrip_check(struct open_file *f, struct iso_directory_record *dp,
+		    int *lenskip);
+static char	*rrip_lookup_name(struct open_file *f,
+		    struct iso_directory_record *dp, int lenskip, size_t *len);
+static ISO_SUSP_HEADER *susp_lookup_record(struct open_file *f,
+		    const char *identifier, struct iso_directory_record *dp,
+		    int lenskip);
+
+struct fs_ops cd9660_fsops = {
+	"cd9660",
+	cd9660_open,
+	cd9660_close,
+	cd9660_read,
+	cd9660_write,
+	cd9660_seek,
+	cd9660_stat,
+	cd9660_readdir
+};
+
+#define	F_ISDIR		0x0001		/* Directory */
+#define	F_ROOTDIR	0x0002		/* Root directory */
+#define	F_RR		0x0004		/* Rock Ridge on this volume */
+
+struct file {
+	int 		f_flags;	/* file flags */
+	off_t 		f_off;		/* Current offset within file */
+	daddr_t 	f_bno;		/* Starting block number */
+	off_t 		f_size;		/* Size of file */
+	daddr_t		f_buf_blkno;	/* block number of data block */	
+	char		*f_buf;		/* buffer for data block */
+	int		f_susp_skip;	/* len_skip for SUSP records */
+};
+
+struct ptable_ent {
+	char namlen	[ISODCL( 1, 1)];	/* 711 */
+	char extlen	[ISODCL( 2, 2)];	/* 711 */
+	char block	[ISODCL( 3, 6)];	/* 732 */
+	char parent	[ISODCL( 7, 8)];	/* 722 */
+	char name	[1];
+};
+#define	PTFIXSZ		8
+#define	PTSIZE(pp)	roundup(PTFIXSZ + isonum_711((pp)->namlen), 2)
+
+#define	cdb2devb(bno)	((bno) * ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE)
+
+static ISO_SUSP_HEADER *
+susp_lookup_record(struct open_file *f, const char *identifier,
+    struct iso_directory_record *dp, int lenskip)
+{
+	static char susp_buffer[ISO_DEFAULT_BLOCK_SIZE];
+	ISO_SUSP_HEADER *sh;
+	ISO_RRIP_CONT *shc;
+	char *p, *end;
+	int error;
+	size_t read;
+
+	p = dp->name + isonum_711(dp->name_len) + lenskip;
+	/* Names of even length have a padding byte after the name. */
+	if ((isonum_711(dp->name_len) & 1) == 0)
+		p++;
+	end = (char *)dp + isonum_711(dp->length);
+	while (p + 3 < end) {
+		sh = (ISO_SUSP_HEADER *)p;
+		if (bcmp(sh->type, identifier, 2) == 0)
+			return (sh);
+		if (bcmp(sh->type, SUSP_STOP, 2) == 0)
+			return (NULL);
+		if (bcmp(sh->type, SUSP_CONTINUATION, 2) == 0) {
+			shc = (ISO_RRIP_CONT *)sh;
+			error = f->f_dev->dv_strategy(f->f_devdata, F_READ,
+			    cdb2devb(isonum_733(shc->location)),
+			    ISO_DEFAULT_BLOCK_SIZE, susp_buffer, &read);
+
+			/* Bail if it fails. */
+			if (error != 0 || read != ISO_DEFAULT_BLOCK_SIZE)
+				return (NULL);
+			p = susp_buffer + isonum_733(shc->offset);
+			end = p + isonum_733(shc->length);
+		} else
+			/* Ignore this record and skip to the next. */
+			p += isonum_711(sh->length);
+	}
+	return (NULL);
+}
+
+static char *
+rrip_lookup_name(struct open_file *f, struct iso_directory_record *dp,
+    int lenskip, size_t *len)
+{
+	ISO_RRIP_ALTNAME *p;
+
+	if (len == NULL)
+		return (NULL);
+
+	p = (ISO_RRIP_ALTNAME *)susp_lookup_record(f, RRIP_NAME, dp, lenskip);
+	if (p == NULL)
+		return (NULL);
+	switch (*p->flags) {
+	case ISO_SUSP_CFLAG_CURRENT:
+		*len = 1;
+		return (".");
+	case ISO_SUSP_CFLAG_PARENT:
+		*len = 2;
+		return ("..");
+	case 0:
+		*len = isonum_711(p->h.length) - 5;
+		return ((char *)p + 5);
+	default:
+		/*
+		 * We don't handle hostnames or continued names as they are
+		 * too hard, so just bail and use the default name.
+		 */
+		return (NULL);
+	}
+}
+
+static int
+rrip_check(struct open_file *f, struct iso_directory_record *dp, int *lenskip)
+{
+	ISO_SUSP_PRESENT *sp;
+	ISO_RRIP_EXTREF *er;
+	char *p;
+
+	/* First, see if we can find a SP field. */
+	p = dp->name + isonum_711(dp->name_len);
+	if (p > (char *)dp + isonum_711(dp->length))
+		return (0);
+	sp = (ISO_SUSP_PRESENT *)p;
+	if (bcmp(sp->h.type, SUSP_PRESENT, 2) != 0)
+		return (0);
+	if (isonum_711(sp->h.length) != sizeof(ISO_SUSP_PRESENT))
+		return (0);
+	if (sp->signature[0] != 0xbe || sp->signature[1] != 0xef)
+		return (0);
+	*lenskip = isonum_711(sp->len_skp);
+
+	/*
+	 * Now look for an ER field.  If RRIP is present, then there must
+	 * be at least one of these.  It would be more pedantic to walk
+	 * through the list of fields looking for a Rock Ridge ER field.
+	 */
+	er = (ISO_RRIP_EXTREF *)susp_lookup_record(f, SUSP_EXTREF, dp, 0);
+	if (er == NULL)
+		return (0);
+	return (1);
+}
+
+static int
+dirmatch(struct open_file *f, const char *path, struct iso_directory_record *dp,
+    int use_rrip, int lenskip)
+{
+	size_t len;
+	char *cp;
+	int i, icase;
+
+	if (use_rrip)
+		cp = rrip_lookup_name(f, dp, lenskip, &len);
+	else
+		cp = NULL;
+	if (cp == NULL) {
+		len = isonum_711(dp->name_len);
+		cp = dp->name;
+		icase = 1;
+	} else
+		icase = 0;
+	for (i = len; --i >= 0; path++, cp++) {
+		if (!*path || *path == '/')
+			break;
+		if (*path == *cp)
+			continue;
+		if (!icase && toupper(*path) == *cp)
+			continue;
+		return 0;
+	}
+	if (*path && *path != '/')
+		return 0;
+	/*
+	 * Allow stripping of trailing dots and the version number.
+	 * Note that this will find the first instead of the last version
+	 * of a file.
+	 */
+	if (i >= 0 && (*cp == ';' || *cp == '.')) {
+		/* This is to prevent matching of numeric extensions */
+		if (*cp == '.' && cp[1] != ';')
+			return 0;
+		while (--i >= 0)
+			if (*++cp != ';' && (*cp < '0' || *cp > '9'))
+				return 0;
+	}
+	return 1;
+}
+
+static int
+cd9660_open(const char *path, struct open_file *f)
+{
+	struct file *fp = 0;
+	void *buf;
+	struct iso_primary_descriptor *vd;
+	size_t buf_size, read, dsize, off;
+	daddr_t bno, boff;
+	struct iso_directory_record rec;
+	struct iso_directory_record *dp = 0;
+	int rc, first, use_rrip, lenskip;
+
+	/* First find the volume descriptor */
+	buf = malloc(buf_size = ISO_DEFAULT_BLOCK_SIZE);
+	vd = buf;
+	for (bno = 16;; bno++) {
+		twiddle();
+		rc = f->f_dev->dv_strategy(f->f_devdata, F_READ, cdb2devb(bno),
+					   ISO_DEFAULT_BLOCK_SIZE, buf, &read);
+		if (rc)
+			goto out;
+		if (read != ISO_DEFAULT_BLOCK_SIZE) {
+			rc = EIO;
+			goto out;
+		}
+		rc = EINVAL;
+		if (bcmp(vd->id, ISO_STANDARD_ID, sizeof vd->id) != 0)
+			goto out;
+		if (isonum_711(vd->type) == ISO_VD_END)
+			goto out;
+		if (isonum_711(vd->type) == ISO_VD_PRIMARY)
+			break;
+	}
+	if (isonum_723(vd->logical_block_size) != ISO_DEFAULT_BLOCK_SIZE)
+		goto out;
+
+	rec = *(struct iso_directory_record *) vd->root_directory_record;
+	if (*path == '/') path++; /* eat leading '/' */
+
+	first = 1;
+	use_rrip = 0;
+	while (*path) {
+		bno = isonum_733(rec.extent) + isonum_711(rec.ext_attr_length);
+		dsize = isonum_733(rec.size);
+		off = 0;
+		boff = 0;
+
+		while (off < dsize) {
+			if ((off % ISO_DEFAULT_BLOCK_SIZE) == 0) {
+				twiddle();
+				rc = f->f_dev->dv_strategy
+					(f->f_devdata, F_READ,
+					 cdb2devb(bno + boff),
+					 ISO_DEFAULT_BLOCK_SIZE,
+					 buf, &read);
+				if (rc)
+					goto out;
+				if (read != ISO_DEFAULT_BLOCK_SIZE) {
+					rc = EIO;
+					goto out;
+				}
+				boff++;
+				dp = (struct iso_directory_record *) buf;
+			}
+			if (isonum_711(dp->length) == 0) {
+			    /* skip to next block, if any */
+			    off = boff * ISO_DEFAULT_BLOCK_SIZE;
+			    continue;
+			}
+
+			/* See if RRIP is in use. */
+			if (first)
+				use_rrip = rrip_check(f, dp, &lenskip);
+
+			if (dirmatch(f, path, dp, use_rrip,
+				first ? 0 : lenskip)) {
+				first = 0;
+				break;
+			} else
+				first = 0;
+
+			dp = (struct iso_directory_record *)
+				((char *) dp + isonum_711(dp->length));
+			off += isonum_711(dp->length);
+		}
+		if (off >= dsize) {
+			rc = ENOENT;
+			goto out;
+		}
+
+		rec = *dp;
+		while (*path && *path != '/') /* look for next component */
+			path++;
+		if (*path) path++; /* skip '/' */
+	}
+
+	/* allocate file system specific data structure */
+	fp = malloc(sizeof(struct file));
+	bzero(fp, sizeof(struct file));
+	f->f_fsdata = (void *)fp;
+
+	if ((isonum_711(rec.flags) & 2) != 0) {
+		fp->f_flags = F_ISDIR;
+	}
+	if (first) {
+		fp->f_flags |= F_ROOTDIR;
+
+		/* Check for Rock Ridge since we didn't in the loop above. */
+		bno = isonum_733(rec.extent) + isonum_711(rec.ext_attr_length);
+		twiddle();
+		rc = f->f_dev->dv_strategy(f->f_devdata, F_READ, cdb2devb(bno),
+		    ISO_DEFAULT_BLOCK_SIZE, buf, &read);
+		if (rc)
+			goto out;
+		if (read != ISO_DEFAULT_BLOCK_SIZE) {
+			rc = EIO;
+			goto out;
+		}
+		dp = (struct iso_directory_record *)buf;
+		use_rrip = rrip_check(f, dp, &lenskip);
+	}
+	if (use_rrip) {
+		fp->f_flags |= F_RR;
+		fp->f_susp_skip = lenskip;
+	}
+	fp->f_off = 0;
+	fp->f_bno = isonum_733(rec.extent) + isonum_711(rec.ext_attr_length);
+	fp->f_size = isonum_733(rec.size);
+	free(buf);
+
+	return 0;
+
+out:
+	if (fp)
+		free(fp);
+	free(buf);
+
+	return rc;
+}
+
+static int
+cd9660_close(struct open_file *f)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	f->f_fsdata = 0;
+	free(fp);
+
+	return 0;
+}
+
+static int
+buf_read_file(struct open_file *f, char **buf_p, size_t *size_p)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	daddr_t blkno, blkoff;
+	int rc = 0;
+	size_t read;
+
+	blkno = fp->f_off / ISO_DEFAULT_BLOCK_SIZE + fp->f_bno;
+	blkoff = fp->f_off % ISO_DEFAULT_BLOCK_SIZE;
+
+	if (blkno != fp->f_buf_blkno) {
+		if (fp->f_buf == (char *)0)
+			fp->f_buf = malloc(ISO_DEFAULT_BLOCK_SIZE);
+
+		twiddle();
+		rc = f->f_dev->dv_strategy(f->f_devdata, F_READ,
+		    cdb2devb(blkno), ISO_DEFAULT_BLOCK_SIZE, fp->f_buf, &read);
+		if (rc)
+			return (rc);
+		if (read != ISO_DEFAULT_BLOCK_SIZE)
+			return (EIO);
+
+		fp->f_buf_blkno = blkno;
+	}
+
+	*buf_p = fp->f_buf + blkoff;
+	*size_p = ISO_DEFAULT_BLOCK_SIZE - blkoff;
+
+	if (*size_p > fp->f_size - fp->f_off)
+		*size_p = fp->f_size - fp->f_off;
+	return (rc);
+}
+
+static int
+cd9660_read(struct open_file *f, void *start, size_t size, size_t *resid)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	char *buf, *addr;
+	size_t buf_size, csize;
+	int rc = 0;
+
+	addr = start;
+	while (size) {
+		if (fp->f_off < 0 || fp->f_off >= fp->f_size)
+			break;
+
+		rc = buf_read_file(f, &buf, &buf_size);
+		if (rc)
+			break;
+
+		csize = size > buf_size ? buf_size : size;
+		bcopy(buf, addr, csize);
+
+		fp->f_off += csize;
+		addr += csize;
+		size -= csize;
+	}
+	if (resid)
+		*resid = size;
+	return (rc);
+}
+
+static int
+cd9660_readdir(struct open_file *f, struct dirent *d)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct iso_directory_record *ep;
+	size_t buf_size, reclen, namelen;
+	int error = 0;
+	int lenskip;
+	char *buf, *name;
+
+again:
+	if (fp->f_off >= fp->f_size)
+		return (ENOENT);
+	error = buf_read_file(f, &buf, &buf_size);
+	if (error)
+		return (error);
+	ep = (struct iso_directory_record *)buf;
+
+	if (isonum_711(ep->length) == 0) {
+		daddr_t blkno;
+		
+		/* skip to next block, if any */
+		blkno = fp->f_off / ISO_DEFAULT_BLOCK_SIZE;
+		fp->f_off = (blkno + 1) * ISO_DEFAULT_BLOCK_SIZE;
+		goto again;
+	}
+
+	if (fp->f_flags & F_RR) {
+		if (fp->f_flags & F_ROOTDIR && fp->f_off == 0)
+			lenskip = 0;
+		else
+			lenskip = fp->f_susp_skip;
+		name = rrip_lookup_name(f, ep, lenskip, &namelen);
+	} else
+		name = NULL;
+	if (name == NULL) {
+		namelen = isonum_711(ep->name_len);
+		name = ep->name;
+		if (namelen == 1) {
+			if (ep->name[0] == 0)
+				name = ".";
+			else if (ep->name[0] == 1) {
+				namelen = 2;
+				name = "..";
+			}
+		}
+	}
+	reclen = sizeof(struct dirent) - (MAXNAMLEN+1) + namelen + 1;
+	reclen = (reclen + 3) & ~3;
+
+	d->d_fileno = isonum_733(ep->extent);
+	d->d_reclen = reclen;
+	if (isonum_711(ep->flags) & 2)
+		d->d_type = DT_DIR;
+	else
+		d->d_type = DT_REG;
+	d->d_namlen = namelen;
+
+	bcopy(name, d->d_name, d->d_namlen);
+	d->d_name[d->d_namlen] = 0;
+
+	fp->f_off += isonum_711(ep->length);
+	return (0);
+}
+
+static int
+cd9660_write(struct open_file *f, void *start, size_t size, size_t *resid)
+{
+	return EROFS;
+}
+
+static off_t
+cd9660_seek(struct open_file *f, off_t offset, int where)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	switch (where) {
+	case SEEK_SET:
+		fp->f_off = offset;
+		break;
+	case SEEK_CUR:
+		fp->f_off += offset;
+		break;
+	case SEEK_END:
+		fp->f_off = fp->f_size - offset;
+		break;
+	default:
+		return -1;
+	}
+	return fp->f_off;
+}
+
+static int
+cd9660_stat(struct open_file *f, struct stat *sb)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	/* only important stuff */
+	sb->st_mode = S_IRUSR | S_IRGRP | S_IROTH;
+	if (fp->f_flags & F_ISDIR)
+		sb->st_mode |= S_IFDIR;
+	else
+		sb->st_mode |= S_IFREG;
+	sb->st_uid = sb->st_gid = 0;
+	sb->st_size = fp->f_size;
+	return 0;
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/close.c sys/boot/i386/pxe_ng/libstand/close.c
--- sys/boot/i386/pxe_ng/libstand/close.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/close.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,96 @@
+/*	$NetBSD: close.c,v 1.7 1997/01/22 00:38:09 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)close.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+int
+close(int fd)
+{
+    struct open_file	*f = &files[fd];
+    int			err1 = 0, err2 = 0;
+
+    if ((unsigned)fd >= SOPEN_MAX || f->f_flags == 0) {
+	errno = EBADF;
+	return (-1);
+    }
+    if (f->f_rabuf != NULL)
+	free(f->f_rabuf);
+    if (!(f->f_flags & F_RAW) && f->f_ops)
+	err1 = (f->f_ops->fo_close)(f);
+    if (!(f->f_flags & F_NODEV) && f->f_dev)
+	err2 = (f->f_dev->dv_close)(f);
+    if (f->f_devdata != NULL)
+	devclose(f);
+    f->f_flags = 0;
+    if (err1) {
+	errno = err1;
+	return (-1);
+    }
+    if (err2) {
+	errno = err2;
+	return (-1);
+    }
+    return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/closeall.c sys/boot/i386/pxe_ng/libstand/closeall.c
--- sys/boot/i386/pxe_ng/libstand/closeall.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/closeall.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,76 @@
+/*	$NetBSD: closeall.c,v 1.1 1996/01/13 22:25:36 leo Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)close.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+void
+closeall()
+{
+	int i;
+
+        for (i = 0; i < SOPEN_MAX; i++)
+            if (files[i].f_flags != 0)
+                (void)close(i);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/dev.c sys/boot/i386/pxe_ng/libstand/dev.c
--- sys/boot/i386/pxe_ng/libstand/dev.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/dev.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,61 @@
+/*	$NetBSD: dev.c,v 1.4 1994/10/30 21:48:23 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)dev.c	8.1 (Berkeley) 6/11/93
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/reboot.h>
+
+#include "stand.h"
+
+int
+nodev()
+{
+	return (ENXIO);
+}
+
+void
+nullsys()
+{
+}
+
+/* ARGSUSED */
+int
+noioctl(f, cmd, data)
+	struct open_file *f;
+	u_long cmd;
+	void *data;
+{
+	return (EINVAL);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/dosfs.c sys/boot/i386/pxe_ng/libstand/dosfs.c
--- sys/boot/i386/pxe_ng/libstand/dosfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/dosfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,708 @@
+/*
+ * Copyright (c) 1996, 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Readonly filesystem for Microsoft FAT12/FAT16/FAT32 filesystems,
+ * also supports VFAT.
+ */
+
+#include <sys/types.h>
+#include <string.h>
+#include <stddef.h>
+
+#include "stand.h"
+
+#include "dosfs.h"
+
+
+static int	dos_open(const char *path, struct open_file *fd);
+static int	dos_close(struct open_file *fd);
+static int	dos_read(struct open_file *fd, void *buf, size_t size, size_t *resid);
+static off_t	dos_seek(struct open_file *fd, off_t offset, int whence);
+static int	dos_stat(struct open_file *fd, struct stat *sb);
+
+struct fs_ops dosfs_fsops = {
+	"dosfs",
+	dos_open,
+	dos_close,
+	dos_read,
+	null_write,
+	dos_seek,
+	dos_stat,
+	null_readdir
+};
+
+#define SECSIZ  512             /* sector size */
+#define SSHIFT    9             /* SECSIZ shift */
+#define DEPSEC   16             /* directory entries per sector */
+#define DSHIFT    4             /* DEPSEC shift */
+#define LOCLUS    2             /* lowest cluster number */
+
+/* DOS "BIOS Parameter Block" */
+typedef struct {
+    u_char secsiz[2];           /* sector size */
+    u_char spc;                 /* sectors per cluster */
+    u_char ressec[2];           /* reserved sectors */
+    u_char fats;                /* FATs */
+    u_char dirents[2];          /* root directory entries */
+    u_char secs[2];             /* total sectors */
+    u_char media;               /* media descriptor */
+    u_char spf[2];              /* sectors per FAT */
+    u_char spt[2];              /* sectors per track */
+    u_char heads[2];            /* drive heads */
+    u_char hidsec[4];           /* hidden sectors */
+    u_char lsecs[4];            /* huge sectors */
+    u_char lspf[4];             /* huge sectors per FAT */
+    u_char xflg[2];             /* flags */
+    u_char vers[2];             /* filesystem version */
+    u_char rdcl[4];             /* root directory start cluster */
+    u_char infs[2];             /* filesystem info sector */
+    u_char bkbs[2];             /* backup boot sector */
+} DOS_BPB;
+
+/* Initial portion of DOS boot sector */
+typedef struct {
+    u_char jmp[3];              /* usually 80x86 'jmp' opcode */
+    u_char oem[8];              /* OEM name and version */
+    DOS_BPB bpb;                /* BPB */
+} DOS_BS;
+
+/* Supply missing "." and ".." root directory entries */
+static const char *const dotstr[2] = {".", ".."};
+static DOS_DE dot[2] = {
+    {".       ", "   ", FA_DIR, {0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
+     {0, 0}, {0x21, 0}, {0, 0}, {0, 0, 0, 0}},
+    {"..      ", "   ", FA_DIR, {0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}},
+     {0, 0}, {0x21, 0}, {0, 0}, {0, 0, 0, 0}}
+};
+
+/* The usual conversion macros to avoid multiplication and division */
+#define bytsec(n)      ((n) >> SSHIFT)
+#define secbyt(s)      ((s) << SSHIFT)
+#define entsec(e)      ((e) >> DSHIFT)
+#define bytblk(fs, n)  ((n) >> (fs)->bshift)
+#define blkbyt(fs, b)  ((b) << (fs)->bshift)
+#define secblk(fs, s)  ((s) >> ((fs)->bshift - SSHIFT))
+#define blksec(fs, b)  ((b) << ((fs)->bshift - SSHIFT))
+
+/* Convert cluster number to offset within filesystem */
+#define blkoff(fs, b) (secbyt((fs)->lsndta) + blkbyt(fs, (b) - LOCLUS))
+
+/* Convert cluster number to logical sector number */
+#define blklsn(fs, b)  ((fs)->lsndta + blksec(fs, (b) - LOCLUS))
+
+/* Convert cluster number to offset within FAT */
+#define fatoff(sz, c)  ((sz) == 12 ? (c) + ((c) >> 1) :  \
+                        (sz) == 16 ? (c) << 1 :          \
+			(c) << 2)
+
+/* Does cluster number reference a valid data cluster? */
+#define okclus(fs, c)  ((c) >= LOCLUS && (c) <= (fs)->xclus)
+
+/* Get start cluster from directory entry */
+#define stclus(sz, de)  ((sz) != 32 ? cv2((de)->clus) :          \
+                         ((u_int)cv2((de)->dex.h_clus) << 16) |  \
+			 cv2((de)->clus))
+    
+static int dosunmount(DOS_FS *);
+static int parsebs(DOS_FS *, DOS_BS *);
+static int namede(DOS_FS *, const char *, DOS_DE **);
+static int lookup(DOS_FS *, u_int, const char *, DOS_DE **);
+static void cp_xdnm(u_char *, DOS_XDE *);
+static void cp_sfn(u_char *, DOS_DE *);
+static off_t fsize(DOS_FS *, DOS_DE *);
+static int fatcnt(DOS_FS *, u_int);
+static int fatget(DOS_FS *, u_int *);
+static int fatend(u_int, u_int);
+static int ioread(DOS_FS *, u_int, void *, u_int);
+static int iobuf(DOS_FS *, u_int);
+static int ioget(struct open_file *, u_int, void *, u_int);
+
+/*
+ * Mount DOS filesystem
+ */
+static int
+dos_mount(DOS_FS *fs, struct open_file *fd)
+{
+    int err;
+
+    bzero(fs, sizeof(DOS_FS));
+    fs->fd = fd;
+    if ((err = !(fs->buf = malloc(SECSIZ)) ? errno : 0) ||
+        (err = ioget(fs->fd, 0, fs->buf, 1)) ||
+        (err = parsebs(fs, (DOS_BS *)fs->buf))) {
+        (void)dosunmount(fs);
+        return(err);
+    }
+    return 0;
+}
+
+/*
+ * Unmount mounted filesystem
+ */
+static int
+dos_unmount(DOS_FS *fs)
+{
+    int err;
+
+    if (fs->links)
+        return(EBUSY);
+    if ((err = dosunmount(fs)))
+        return(err);
+    return 0;
+}
+
+/*
+ * Common code shared by dos_mount() and dos_unmount()
+ */
+static int
+dosunmount(DOS_FS *fs)
+{
+    if (fs->buf)
+        free(fs->buf);
+    free(fs);
+    return(0);
+}
+
+/*
+ * Open DOS file
+ */
+static int
+dos_open(const char *path, struct open_file *fd)
+{
+    DOS_DE *de;
+    DOS_FILE *f;
+    DOS_FS *fs;
+    u_int size, clus;
+    int err = 0;
+
+    /* Allocate mount structure, associate with open */
+    fs = malloc(sizeof(DOS_FS));
+    
+    if ((err = dos_mount(fs, fd)))
+	goto out;
+
+    if ((err = namede(fs, path, &de)))
+	goto out;
+
+    clus = stclus(fs->fatsz, de);
+    size = cv4(de->size);
+
+    if ((!(de->attr & FA_DIR) && (!clus != !size)) ||
+	((de->attr & FA_DIR) && size) ||
+	(clus && !okclus(fs, clus))) {
+        err = EINVAL;
+	goto out;
+    }
+    f = malloc(sizeof(DOS_FILE));
+    bzero(f, sizeof(DOS_FILE));
+    f->fs = fs;
+    fs->links++;
+    f->de = *de;
+    fd->f_fsdata = (void *)f;
+
+ out:
+    return(err);
+}
+
+/*
+ * Read from file
+ */
+static int
+dos_read(struct open_file *fd, void *buf, size_t nbyte, size_t *resid)
+{
+    off_t size;
+    u_int nb, off, clus, c, cnt, n;
+    DOS_FILE *f = (DOS_FILE *)fd->f_fsdata;
+    int err = 0;
+
+    nb = (u_int)nbyte;
+    if ((size = fsize(f->fs, &f->de)) == -1)
+	return EINVAL;
+    if (nb > (n = size - f->offset))
+        nb = n;
+    off = f->offset;
+    if ((clus = stclus(f->fs->fatsz, &f->de)))
+        off &= f->fs->bsize - 1;
+    c = f->c;
+    cnt = nb;
+    while (cnt) {
+        n = 0;
+        if (!c) {
+            if ((c = clus))
+                n = bytblk(f->fs, f->offset);
+        } else if (!off)
+            n++;
+        while (n--) {
+            if ((err = fatget(f->fs, &c)))
+		goto out;
+            if (!okclus(f->fs, c)) {
+		err = EINVAL;
+		goto out;
+	    }
+        }
+        if (!clus || (n = f->fs->bsize - off) > cnt)
+            n = cnt;
+        if ((err = ioread(f->fs, (c ? blkoff(f->fs, c) :
+				      secbyt(f->fs->lsndir)) + off,
+			  buf, n)))
+	    goto out;
+        f->offset += n;
+        f->c = c;
+        off = 0;
+        buf = (char *)buf + n;
+        cnt -= n;
+    }
+ out:
+    if (resid)
+	*resid = nbyte - nb + cnt;
+    return(err);
+}
+
+/*
+ * Reposition within file
+ */
+static off_t
+dos_seek(struct open_file *fd, off_t offset, int whence)
+{
+    off_t off;
+    u_int size;
+    DOS_FILE *f = (DOS_FILE *)fd->f_fsdata;
+
+    size = cv4(f->de.size);
+    switch (whence) {
+    case SEEK_SET:
+        off = 0;
+        break;
+    case SEEK_CUR:
+        off = f->offset;
+        break;
+    case SEEK_END:
+        off = size;
+        break;
+    default:
+	errno = EINVAL;
+	return(-1);
+    }
+    off += offset;
+    if (off < 0 || off > size) {
+	errno = EINVAL;
+        return(-1);
+    }
+    f->offset = (u_int)off;
+    f->c = 0;
+    return(off);
+}
+
+/*
+ * Close open file
+ */
+static int
+dos_close(struct open_file *fd)
+{
+    DOS_FILE *f = (DOS_FILE *)fd->f_fsdata;
+    DOS_FS *fs = f->fs;
+
+    f->fs->links--;
+    free(f);
+    dos_unmount(fs);
+    return 0;
+}
+
+/*
+ * Return some stat information on a file.
+ */
+static int
+dos_stat(struct open_file *fd, struct stat *sb)
+{
+    DOS_FILE *f = (DOS_FILE *)fd->f_fsdata;
+
+    /* only important stuff */
+    sb->st_mode = f->de.attr & FA_DIR ? S_IFDIR | 0555 : S_IFREG | 0444;
+    sb->st_nlink = 1;
+    sb->st_uid = 0;
+    sb->st_gid = 0;
+    if ((sb->st_size = fsize(f->fs, &f->de)) == -1)
+	return EINVAL;
+    return (0);
+}
+
+/*
+ * Parse DOS boot sector
+ */
+static int
+parsebs(DOS_FS *fs, DOS_BS *bs)
+{
+    u_int sc;
+
+    if ((bs->jmp[0] != 0x69 &&
+         bs->jmp[0] != 0xe9 &&
+         (bs->jmp[0] != 0xeb || bs->jmp[2] != 0x90)) ||
+        bs->bpb.media < 0xf0)
+        return EINVAL;
+    if (cv2(bs->bpb.secsiz) != SECSIZ)
+        return EINVAL;
+    if (!(fs->spc = bs->bpb.spc) || fs->spc & (fs->spc - 1))
+        return EINVAL;
+    fs->bsize = secbyt(fs->spc);
+    fs->bshift = ffs(fs->bsize) - 1;
+    if ((fs->spf = cv2(bs->bpb.spf))) {
+        if (bs->bpb.fats != 2)
+            return EINVAL;
+        if (!(fs->dirents = cv2(bs->bpb.dirents)))
+            return EINVAL;
+    } else {
+        if (!(fs->spf = cv4(bs->bpb.lspf)))
+            return EINVAL;
+        if (!bs->bpb.fats || bs->bpb.fats > 16)
+            return EINVAL;
+        if ((fs->rdcl = cv4(bs->bpb.rdcl)) < LOCLUS)
+            return EINVAL;
+    }
+    if (!(fs->lsnfat = cv2(bs->bpb.ressec)))
+        return EINVAL;
+    fs->lsndir = fs->lsnfat + fs->spf * bs->bpb.fats;
+    fs->lsndta = fs->lsndir + entsec(fs->dirents);
+    if (!(sc = cv2(bs->bpb.secs)) && !(sc = cv4(bs->bpb.lsecs)))
+        return EINVAL;
+    if (fs->lsndta > sc)
+        return EINVAL;
+    if ((fs->xclus = secblk(fs, sc - fs->lsndta) + 1) < LOCLUS)
+        return EINVAL;
+    fs->fatsz = fs->dirents ? fs->xclus < 0xff6 ? 12 : 16 : 32;
+    sc = (secbyt(fs->spf) << 1) / (fs->fatsz >> 2) - 1;
+    if (fs->xclus > sc)
+        fs->xclus = sc;
+    return 0;
+}
+
+/*
+ * Return directory entry from path
+ */
+static int
+namede(DOS_FS *fs, const char *path, DOS_DE **dep)
+{
+    char name[256];
+    DOS_DE *de;
+    char *s;
+    size_t n;
+    int err;
+
+    err = 0;
+    de = dot;
+    if (*path == '/')
+        path++;
+    while (*path) {
+        if (!(s = strchr(path, '/')))
+            s = strchr(path, 0);
+        if ((n = s - path) > 255)
+            return ENAMETOOLONG;
+        memcpy(name, path, n);
+        name[n] = 0;
+        path = s;
+        if (!(de->attr & FA_DIR))
+            return ENOTDIR;
+        if ((err = lookup(fs, stclus(fs->fatsz, de), name, &de)))
+            return err;
+        if (*path == '/')
+            path++;
+    }
+    *dep = de;
+    return 0;
+}
+
+/*
+ * Lookup path segment
+ */
+static int
+lookup(DOS_FS *fs, u_int clus, const char *name, DOS_DE **dep)
+{
+    static DOS_DIR dir[DEPSEC];
+    u_char lfn[261];
+    u_char sfn[13];
+    u_int nsec, lsec, xdn, chk, sec, ent, x;
+    int err, ok, i;
+
+    if (!clus)
+        for (ent = 0; ent < 2; ent++)
+            if (!strcasecmp(name, dotstr[ent])) {
+                *dep = dot + ent;
+                return 0;
+            }
+    if (!clus && fs->fatsz == 32)
+        clus = fs->rdcl;
+    nsec = !clus ? entsec(fs->dirents) : fs->spc;
+    lsec = 0;
+    xdn = chk = 0;
+    for (;;) {
+        if (!clus && !lsec)
+            lsec = fs->lsndir;
+        else if (okclus(fs, clus))
+            lsec = blklsn(fs, clus);
+        else
+            return EINVAL;
+        for (sec = 0; sec < nsec; sec++) {
+            if ((err = ioget(fs->fd, lsec + sec, dir, 1)))
+                return err;
+            for (ent = 0; ent < DEPSEC; ent++) {
+                if (!*dir[ent].de.name)
+                    return ENOENT;
+                if (*dir[ent].de.name != 0xe5) {
+                    if ((dir[ent].de.attr & FA_MASK) == FA_XDE) {
+                        x = dir[ent].xde.seq;
+                        if (x & 0x40 || (x + 1 == xdn &&
+                                         dir[ent].xde.chk == chk)) {
+                            if (x & 0x40) {
+                                chk = dir[ent].xde.chk;
+                                x &= ~0x40;
+                            }
+                            if (x >= 1 && x <= 20) {
+                                cp_xdnm(lfn, &dir[ent].xde);
+                                xdn = x;
+                                continue;
+                            }
+                        }
+                    } else if (!(dir[ent].de.attr & FA_LABEL)) {
+                        if ((ok = xdn == 1)) {
+                            for (x = 0, i = 0; i < 11; i++)
+                                x = ((((x & 1) << 7) | (x >> 1)) +
+                                     dir[ent].de.name[i]) & 0xff;
+                            ok = chk == x &&
+                                !strcasecmp(name, (const char *)lfn);
+                        }
+                        if (!ok) {
+                            cp_sfn(sfn, &dir[ent].de);
+                            ok = !strcasecmp(name, (const char *)sfn);
+                        }
+                        if (ok) {
+                            *dep = &dir[ent].de;
+                            return 0;
+                        }
+                    }
+		}
+                xdn = 0;
+            }
+        }
+        if (!clus)
+            break;
+        if ((err = fatget(fs, &clus)))
+            return err;
+        if (fatend(fs->fatsz, clus))
+            break;
+    }
+    return ENOENT;
+}
+
+/*
+ * Copy name from extended directory entry
+ */
+static void
+cp_xdnm(u_char *lfn, DOS_XDE *xde)
+{
+    static struct {
+        u_int off;
+        u_int dim;
+    } ix[3] = {
+        {offsetof(DOS_XDE, name1), sizeof(xde->name1) / 2},
+        {offsetof(DOS_XDE, name2), sizeof(xde->name2) / 2},
+        {offsetof(DOS_XDE, name3), sizeof(xde->name3) / 2}
+    };
+    u_char *p;
+    u_int n, x, c;
+
+    lfn += 13 * ((xde->seq & ~0x40) - 1);
+    for (n = 0; n < 3; n++)
+        for (p = (u_char *)xde + ix[n].off, x = ix[n].dim; x;
+	     p += 2, x--) {
+            if ((c = cv2(p)) && (c < 32 || c > 127))
+                c = '?';
+            if (!(*lfn++ = c))
+                return;
+        }
+    if (xde->seq & 0x40)
+        *lfn = 0;
+}
+
+/*
+ * Copy short filename
+ */
+static void
+cp_sfn(u_char *sfn, DOS_DE *de)
+{
+    u_char *p;
+    int j, i;
+
+    p = sfn;
+    if (*de->name != ' ') {
+        for (j = 7; de->name[j] == ' '; j--);
+        for (i = 0; i <= j; i++)
+            *p++ = de->name[i];
+        if (*de->ext != ' ') {
+            *p++ = '.';
+            for (j = 2; de->ext[j] == ' '; j--);
+            for (i = 0; i <= j; i++)
+                *p++ = de->ext[i];
+        }
+    }
+    *p = 0;
+    if (*sfn == 5)
+        *sfn = 0xe5;
+}
+
+/*
+ * Return size of file in bytes
+ */
+static off_t
+fsize(DOS_FS *fs, DOS_DE *de)
+{
+   u_long size;
+   u_int c;
+   int n;
+
+   if (!(size = cv4(de->size)) && de->attr & FA_DIR) {
+      if (!(c = cv2(de->clus)))
+         size = fs->dirents * sizeof(DOS_DE);
+      else {
+         if ((n = fatcnt(fs, c)) == -1)
+            return n;
+         size = blkbyt(fs, n);
+      }
+   }
+   return size;
+}
+
+/*
+ * Count number of clusters in chain
+ */
+static int
+fatcnt(DOS_FS *fs, u_int c)
+{
+   int n;
+
+   for (n = 0; okclus(fs, c); n++)
+      if (fatget(fs, &c))
+	  return -1;
+   return fatend(fs->fatsz, c) ? n : -1;
+}
+
+/*
+ * Get next cluster in cluster chain
+ */
+static int
+fatget(DOS_FS *fs, u_int *c)
+{
+    u_char buf[4];
+    u_int x;
+    int err;
+
+    err = ioread(fs, secbyt(fs->lsnfat) + fatoff(fs->fatsz, *c), buf,
+                 fs->fatsz != 32 ? 2 : 4);
+    if (err)
+        return err;
+    x = fs->fatsz != 32 ? cv2(buf) : cv4(buf);
+    *c = fs->fatsz == 12 ? *c & 1 ? x >> 4 : x & 0xfff : x;
+    return 0;
+}
+
+/*
+ * Is cluster an end-of-chain marker?
+ */
+static int
+fatend(u_int sz, u_int c)
+{
+    return c > (sz == 12 ? 0xff7U : sz == 16 ? 0xfff7U : 0xffffff7);
+}
+
+/*
+ * Offset-based I/O primitive
+ */
+static int
+ioread(DOS_FS *fs, u_int offset, void *buf, u_int nbyte)
+{
+    char *s;
+    u_int off, n;
+    int err;
+
+    s = buf;
+    if ((off = offset & (SECSIZ - 1))) {
+        offset -= off;
+        if ((err = iobuf(fs, bytsec(offset))))
+            return err;
+        offset += SECSIZ;
+        if ((n = SECSIZ - off) > nbyte)
+            n = nbyte;
+        memcpy(s, fs->buf + off, n);
+        s += n;
+        nbyte -= n;
+    }
+    n = nbyte & (SECSIZ - 1);
+    if (nbyte -= n) {
+        if ((err = ioget(fs->fd, bytsec(offset), s, bytsec(nbyte))))
+            return err;
+        offset += nbyte;
+        s += nbyte;
+    }
+    if (n) {
+        if ((err = iobuf(fs, bytsec(offset))))
+            return err;
+        memcpy(s, fs->buf, n);
+    }
+    return 0;
+}
+
+/*
+ * Buffered sector-based I/O primitive
+ */
+static int
+iobuf(DOS_FS *fs, u_int lsec)
+{
+    int err;
+
+    if (fs->bufsec != lsec) {
+        if ((err = ioget(fs->fd, lsec, fs->buf, 1)))
+            return err;
+        fs->bufsec = lsec;
+    }
+    return 0;
+}
+
+/*
+ * Sector-based I/O primitive
+ */
+static int
+ioget(struct open_file *fd, u_int lsec, void *buf, u_int nsec)
+{
+    int	err;
+    
+    if ((err = (fd->f_dev->dv_strategy)(fd->f_devdata, F_READ, lsec, 
+					secbyt(nsec), buf, NULL)))
+	return(err);
+    return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/dosfs.h sys/boot/i386/pxe_ng/libstand/dosfs.h
--- sys/boot/i386/pxe_ng/libstand/dosfs.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/dosfs.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 1996, 1998 Robert Nordier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DOSIO_H
+#define DOSIO_H
+
+/*
+ * DOS file attributes
+ */
+
+#define FA_RDONLY  001          /* read-only */
+#define FA_HIDDEN  002          /* hidden file */
+#define FA_SYSTEM  004          /* system file */
+#define FA_LABEL   010          /* volume label */
+#define FA_DIR     020          /* directory */
+#define FA_ARCH    040          /* archive (file modified) */
+#define FA_XDE     017          /* extended directory entry */
+#define FA_MASK    077          /* all attributes */
+
+/*
+ * Macros to convert DOS-format 16-bit and 32-bit quantities
+ */
+
+#define cv2(p)  ((u_int16_t)(p)[0] |         \
+                ((u_int16_t)(p)[1] << 010))
+#define cv4(p)  ((u_int32_t)(p)[0] |          \
+                ((u_int32_t)(p)[1] << 010) |  \
+                ((u_int32_t)(p)[2] << 020) |  \
+                ((u_int32_t)(p)[3] << 030))
+
+/*
+ * Directory, filesystem, and file structures.
+ */
+
+typedef struct {
+    u_char x_case;              /* case */
+    u_char c_hsec;              /* created: secs/100 */
+    u_char c_time[2];           /* created: time */
+    u_char c_date[2];           /* created: date */
+    u_char a_date[2];           /* accessed: date */
+    u_char h_clus[2];           /* clus[hi] */
+} DOS_DEX;
+
+typedef struct {
+    u_char name[8];             /* name */
+    u_char ext[3];              /* extension */
+    u_char attr;                /* attributes */
+    DOS_DEX dex;                /* VFAT/FAT32 only */
+    u_char time[2];             /* modified: time */
+    u_char date[2];             /* modified: date */
+    u_char clus[2];             /* starting cluster */
+    u_char size[4];             /* size */
+} DOS_DE;
+
+typedef struct {
+    u_char seq;                 /* flags */
+    u_char name1[5][2];         /* 1st name area */
+    u_char attr;                /* (see fat_de) */
+    u_char res;                 /* reserved */
+    u_char chk;                 /* checksum */
+    u_char name2[6][2];         /* 2nd name area */
+    u_char clus[2];             /* (see fat_de) */
+    u_char name3[2][2];         /* 3rd name area */
+} DOS_XDE;
+
+typedef union {
+    DOS_DE de;                  /* standard directory entry */
+    DOS_XDE xde;                /* extended directory entry */
+} DOS_DIR;
+
+typedef struct {
+    struct open_file *fd;       /* file descriptor */
+    u_char *buf;                /* buffer */
+    u_int bufsec;               /* buffered sector */
+    u_int links;                /* active links to structure */
+    u_int spc;                  /* sectors per cluster */
+    u_int bsize;                /* cluster size in bytes */
+    u_int bshift;               /* cluster conversion shift */
+    u_int dirents;              /* root directory entries */
+    u_int spf;                  /* sectors per fat */
+    u_int rdcl;                 /* root directory start cluster */
+    u_int lsnfat;               /* start of fat */
+    u_int lsndir;               /* start of root dir */
+    u_int lsndta;               /* start of data area */
+    u_int fatsz;                /* FAT entry size */
+    u_int xclus;                /* maximum cluster number */
+} DOS_FS;
+
+typedef struct {
+    DOS_FS *fs;                 /* associated filesystem */
+    DOS_DE de;                  /* directory entry */
+    u_int offset;               /* current offset */
+    u_int c;                    /* last cluster read */
+} DOS_FILE;
+
+#endif  /* !DOSIO_H */
diff -ruN sys/boot/i386/pxe_ng/libstand/environment.c sys/boot/i386/pxe_ng/libstand/environment.c
--- sys/boot/i386/pxe_ng/libstand/environment.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/environment.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,219 @@
+/* 
+ * Copyright (c) 1998 Michael Smith.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Manage an environment-like space in which string variables may be stored.
+ * Provide support for some method-like operations for setting/retrieving
+ * variables in order to allow some type strength.
+ */
+
+#include "stand.h"
+
+#include <string.h>
+
+static void	env_discard(struct env_var *ev);
+
+struct env_var	*environ = NULL;
+
+/*
+ * Look up (name) and return it's env_var structure.
+ */
+struct env_var	*
+env_getenv(const char *name)
+{
+    struct env_var	*ev;
+    
+    for (ev = environ; ev != NULL; ev = ev->ev_next)
+	if (!strcmp(ev->ev_name, name))
+	    break;
+    return(ev);
+}
+
+/*
+ * Some notes:
+ *
+ * If the EV_VOLATILE flag is set, a copy of the variable is made.
+ * If EV_DYNAMIC is set, the the variable has been allocated with
+ * malloc and ownership transferred to the environment.
+ * If (value) is NULL, the variable is set but has no value.
+ */
+int
+env_setenv(const char *name, int flags, const void *value,
+	   ev_sethook_t sethook, ev_unsethook_t unsethook)
+{
+    struct env_var	*ev, *curr, *last;
+
+    if ((ev = env_getenv(name)) != NULL) {
+	/*
+	 * If there's a set hook, let it do the work (unless we are working
+	 * for one already.
+	 */
+	if ((ev->ev_sethook != NULL) && !(flags & EV_NOHOOK))
+	    return(ev->ev_sethook(ev, flags, value));
+    } else {
+
+	/*
+	 * New variable; create and sort into list
+	 */
+	ev = malloc(sizeof(struct env_var));
+	ev->ev_name = strdup(name);
+	ev->ev_value = NULL;
+	/* hooks can only be set when the variable is instantiated */
+	ev->ev_sethook = sethook;
+	ev->ev_unsethook = unsethook;
+
+	/* Sort into list */
+	ev->ev_prev = NULL;
+	ev->ev_next = NULL;
+	/* Search for the record to insert before */
+	for (last = NULL, curr = environ; 
+	     curr != NULL; 
+	     last = curr, curr = curr->ev_next) {
+
+	    if (strcmp(ev->ev_name, curr->ev_name) < 0) {
+		if (curr->ev_prev) {
+		    curr->ev_prev->ev_next = ev;
+		} else {
+		    environ = ev;
+		}
+		ev->ev_next = curr;
+		ev->ev_prev = curr->ev_prev;
+		curr->ev_prev = ev;
+		break;
+	    }
+	}
+	if (curr == NULL) {
+	    if (last == NULL) {
+		environ = ev;
+	    } else {
+		last->ev_next = ev;
+		ev->ev_prev = last;
+	    }
+	}
+    }
+    
+    /* If there is data in the variable, discard it */
+    if (ev->ev_value != NULL)
+	free(ev->ev_value);
+
+    /* If we have a new value, use it */
+    if (flags & EV_VOLATILE) {
+	ev->ev_value = strdup(value);
+    } else {
+	ev->ev_value = (char *)value;
+    }
+
+    /* Keep the flag components that are relevant */
+    ev->ev_flags = flags & (EV_DYNAMIC);
+
+    return(0);
+}
+
+char *
+getenv(const char *name)
+{
+    struct env_var	*ev;
+
+    /* Set but no value gives empty string */
+    if ((ev = env_getenv(name)) != NULL) {
+	if (ev->ev_value != NULL)
+	    return(ev->ev_value);
+	return("");
+    }
+    return(NULL);
+}
+
+int
+setenv(const char *name, const char *value, int overwrite)
+{
+    /* No guarantees about state, always assume volatile */
+    if (overwrite || (env_getenv(name) == NULL))
+	return(env_setenv(name, EV_VOLATILE, value, NULL, NULL));
+    return(0);
+}
+
+int
+putenv(const char *string)
+{
+    char	*value, *copy;
+    int		result;
+
+    copy = strdup(string);
+    if ((value = strchr(copy, '=')) != NULL)
+	*(value++) = 0;
+    result = setenv(copy, value, 1);
+    free(copy);
+    return(result);
+}
+
+int
+unsetenv(const char *name)
+{
+    struct env_var	*ev;
+    int			err;
+
+    err = 0;
+    if ((ev = env_getenv(name)) == NULL) {
+	err = ENOENT;
+    } else {
+	if (ev->ev_unsethook != NULL)
+	    err = ev->ev_unsethook(ev);
+	if (err == 0) {
+	    env_discard(ev);
+	}
+    }
+    return(err);
+}
+
+static void
+env_discard(struct env_var *ev)
+{
+    if (ev->ev_prev)
+	ev->ev_prev->ev_next = ev->ev_next;
+    if (ev->ev_next)
+	ev->ev_next->ev_prev = ev->ev_prev;
+    if (environ == ev)
+	environ = ev->ev_next;
+    free(ev->ev_name);
+    if (ev->ev_flags & EV_DYNAMIC)
+	free(ev->ev_value);
+    free(ev);
+}
+
+int
+env_noset(struct env_var *ev, int flags, const void *value)
+{
+    return(EPERM);
+}
+
+int
+env_nounset(struct env_var *ev)
+{
+    return(EPERM);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/ether.c sys/boot/i386/pxe_ng/libstand/ether.c
--- sys/boot/i386/pxe_ng/libstand/ether.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/ether.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,150 @@
+/*	$NetBSD: ether.c,v 1.11 1997/07/07 15:52:50 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: net.c,v 1.9 93/08/06 19:32:15 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <string.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+
+/* Caller must leave room for ethernet header in front!! */
+ssize_t
+sendether(d, pkt, len, dea, etype)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	u_char *dea;
+	int etype;
+{
+	ssize_t n;
+	struct ether_header *eh;
+
+#ifdef ETHER_DEBUG
+ 	if (debug)
+		printf("sendether: called\n");
+#endif
+
+	eh = (struct ether_header *)pkt - 1;
+	len += sizeof(*eh);
+
+	MACPY(d->myea, eh->ether_shost);		/* by byte */
+	MACPY(dea, eh->ether_dhost);			/* by byte */
+	eh->ether_type = htons(etype);
+
+	n = netif_put(d, eh, len);
+	if (n == -1 || n < sizeof(*eh))
+		return (-1);
+
+	n -= sizeof(*eh);
+	return (n);
+}
+
+/*
+ * Get a packet of any Ethernet type, with our address or
+ * the broadcast address.  Save the Ether type in arg 5.
+ * NOTE: Caller must leave room for the Ether header.
+ */
+ssize_t
+readether(d, pkt, len, tleft, etype)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	time_t tleft;
+	u_int16_t *etype;
+{
+	ssize_t n;
+	struct ether_header *eh;
+
+#ifdef ETHER_DEBUG
+ 	if (debug)
+		printf("readether: called\n");
+#endif
+
+	eh = (struct ether_header *)pkt - 1;
+	len += sizeof(*eh);
+
+	n = netif_get(d, eh, len, tleft);
+	if (n == -1 || n < sizeof(*eh))
+		return (-1);
+
+	/* Validate Ethernet address. */
+	if (bcmp(d->myea, eh->ether_dhost, 6) != 0 &&
+	    bcmp(bcea, eh->ether_dhost, 6) != 0) {
+#ifdef ETHER_DEBUG
+		if (debug)
+			printf("readether: not ours (ea=%s)\n",
+			    ether_sprintf(eh->ether_dhost));
+#endif
+		return (-1);
+	}
+	*etype = ntohs(eh->ether_type);
+
+	n -= sizeof(*eh);
+	return (n);
+}
+
+/*
+ * Convert Ethernet address to printable (loggable) representation.
+ */
+static char digits[] = "0123456789abcdef";
+char *
+ether_sprintf(ap)
+        u_char *ap;
+{
+	int i;
+	static char etherbuf[18];
+	char *cp = etherbuf;
+
+	for (i = 0; i < 6; i++) {
+		*cp++ = digits[*ap >> 4];
+		*cp++ = digits[*ap++ & 0xf];
+		*cp++ = ':';
+	}
+	*--cp = 0;
+	return (etherbuf);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/ext2fs.c sys/boot/i386/pxe_ng/libstand/ext2fs.c
--- sys/boot/i386/pxe_ng/libstand/ext2fs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/ext2fs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,906 @@
+/*-
+ * Copyright (c) 1999,2000 Jonathan Lemon <jlemon@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *  
+ *
+ * Copyright (c) 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: David Golub
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/param.h>
+#include <sys/time.h>
+#include "stand.h"
+#include "string.h"
+
+static int	ext2fs_open(const char *path, struct open_file *f);
+static int	ext2fs_close(struct open_file *f);
+static int	ext2fs_read(struct open_file *f, void *buf,
+			 size_t size, size_t *resid);
+static off_t	ext2fs_seek(struct open_file *f, off_t offset, int where);
+static int	ext2fs_stat(struct open_file *f, struct stat *sb);
+static int	ext2fs_readdir(struct open_file *f, struct dirent *d);
+
+static int dtmap[] = { DT_UNKNOWN, DT_REG, DT_DIR, DT_CHR,
+			 DT_BLK, DT_FIFO, DT_SOCK, DT_LNK };
+#define EXTFTODT(x)	(x) > sizeof(dtmap) / sizeof(dtmap[0]) ? \
+			DT_UNKNOWN : dtmap[x]
+
+struct fs_ops ext2fs_fsops = {
+	"ext2fs",
+	ext2fs_open,
+	ext2fs_close,
+	ext2fs_read,
+	null_write,
+	ext2fs_seek,
+	ext2fs_stat,
+	ext2fs_readdir
+};
+
+#define	EXT2_SBSIZE	1024
+#define	EXT2_SBLOCK	(1024 / DEV_BSIZE)	/* block offset of superblock */
+#define EXT2_MAGIC	0xef53
+#define EXT2_ROOTINO	2
+
+#define EXT2_REV0		0	/* original revision of ext2 */
+#define EXT2_R0_ISIZE		128	/* inode size */
+#define EXT2_R0_FIRSTINO	11	/* first inode */
+
+#define EXT2_MINBSHIFT		10	/* mininum block shift */
+#define EXT2_MINFSHIFT		10	/* mininum frag shift */
+
+#define NDADDR		12		/* # of direct blocks */
+#define NIADDR		3		/* # of indirect blocks */
+
+/*
+ * file system block to disk address
+ */
+#define fsb_to_db(fs, blk)	((blk) << (fs)->fs_fsbtodb)
+
+/*
+ * inode to block group offset
+ * inode to block group
+ * inode to disk address
+ * inode to block offset
+ */
+#define ino_to_bgo(fs, ino)	(((ino) - 1) % (fs)->fs_ipg)
+#define ino_to_bg(fs, ino)	(((ino) - 1) / (fs)->fs_ipg)
+#define ino_to_db(fs, bg, ino) \
+	fsb_to_db(fs, ((bg)[ino_to_bg(fs, ino)].bg_inotbl + \
+	    ino_to_bgo(fs, ino) / (fs)->fs_ipb))
+#define ino_to_bo(fs, ino)	(ino_to_bgo(fs, ino) % (fs)->fs_ipb)
+
+#define nindir(fs) \
+	((fs)->fs_bsize / sizeof(u_int32_t))
+#define lblkno(fs, loc)				/* loc / bsize */ \
+	((loc) >> (fs)->fs_bshift)
+#define smalllblktosize(fs, blk)		/* blk * bsize */ \
+	((blk) << (fs)->fs_bshift)
+#define blkoff(fs, loc)				/* loc % bsize */ \
+	((loc) & (fs)->fs_bmask)
+#define fragroundup(fs, size)			/* roundup(size, fsize) */ \
+	(((size) + (fs)->fs_fmask) & ~(fs)->fs_fmask)
+#define dblksize(fs, dip, lbn) \
+	(((lbn) >= NDADDR || (dip)->di_size >= smalllblktosize(fs, (lbn) + 1)) \
+	    ? (fs)->fs_bsize \
+	    : (fragroundup(fs, blkoff(fs, (dip)->di_size))))
+
+/*
+ * superblock describing ext2fs
+ */
+struct ext2fs_disk {
+	u_int32_t	fd_inodes;	/* # of inodes */
+	u_int32_t	fd_blocks;	/* # of blocks */
+	u_int32_t	fd_resblk;	/* # of reserved blocks */
+	u_int32_t	fd_freeblk;	/* # of free blocks */
+	u_int32_t	fd_freeino;	/* # of free inodes */
+	u_int32_t	fd_firstblk;	/* first data block */
+	u_int32_t	fd_bsize;	/* block size */
+	u_int32_t	fd_fsize;	/* frag size */
+	u_int32_t	fd_bpg;		/* blocks per group */
+	u_int32_t	fd_fpg;		/* frags per group */
+	u_int32_t	fd_ipg;		/* inodes per group */
+	u_int32_t	fd_mtime;	/* mount time */
+	u_int32_t	fd_wtime;	/* write time */
+	u_int16_t	fd_mount;	/* # of mounts */
+	int16_t		fd_maxmount;	/* max # of mounts */
+	u_int16_t	fd_magic;	/* magic number */
+	u_int16_t	fd_state;	/* state */
+	u_int16_t	fd_eflag;	/* error flags */
+	u_int16_t	fd_mnrrev;	/* minor revision */
+	u_int32_t	fd_lastchk;	/* last check */
+	u_int32_t	fd_chkintvl;	/* maximum check interval */
+	u_int32_t	fd_os;		/* os */
+	u_int32_t	fd_revision;	/* revision */
+	u_int16_t	fd_uid;		/* uid for reserved blocks */
+	u_int16_t	fd_gid;		/* gid for reserved blocks */
+
+	u_int32_t	fd_firstino;	/* first non-reserved inode */
+	u_int16_t	fd_isize;	/* inode size */
+	u_int16_t	fd_nblkgrp;	/* block group # of superblock */
+	u_int32_t	fd_fcompat;	/* compatible features */
+	u_int32_t	fd_fincompat;	/* incompatible features */
+	u_int32_t	fd_frocompat;	/* read-only compatibilties */
+	u_int8_t	fd_uuid[16];	/* volume uuid */
+	char 		fd_volname[16];	/* volume name */
+	char 		fd_fsmnt[64];	/* name last mounted on */
+	u_int32_t	fd_bitmap;	/* compression bitmap */
+
+	u_int8_t	fd_nblkpa;	/* # of blocks to preallocate */	
+	u_int8_t	fd_ndblkpa;	/* # of dir blocks to preallocate */
+};
+
+struct ext2fs_core {
+	int		fc_bsize;	/* block size */
+	int		fc_bshift;	/* block shift amount */
+	int		fc_bmask;	/* block mask */
+	int		fc_fsize;	/* frag size */
+	int		fc_fshift;	/* frag shift amount */
+	int		fc_fmask;	/* frag mask */
+	int		fc_isize;	/* inode size */
+	int		fc_imask;	/* inode mask */
+	int		fc_firstino;	/* first non-reserved inode */
+	int		fc_ipb;		/* inodes per block */
+	int		fc_fsbtodb;	/* fsb to ds shift */
+};
+
+struct ext2fs {
+	struct		ext2fs_disk fs_fd;
+	char		fs_pad[EXT2_SBSIZE - sizeof(struct ext2fs_disk)];
+	struct		ext2fs_core fs_fc;
+
+#define fs_magic	fs_fd.fd_magic
+#define fs_revision	fs_fd.fd_revision
+#define fs_blocks	fs_fd.fd_blocks
+#define fs_firstblk	fs_fd.fd_firstblk
+#define fs_bpg		fs_fd.fd_bpg
+#define fs_ipg		fs_fd.fd_ipg
+	    
+#define fs_bsize	fs_fc.fc_bsize
+#define fs_bshift	fs_fc.fc_bshift
+#define fs_bmask	fs_fc.fc_bmask
+#define fs_fsize	fs_fc.fc_fsize
+#define fs_fshift	fs_fc.fc_fshift
+#define fs_fmask	fs_fc.fc_fmask
+#define fs_isize	fs_fc.fc_isize
+#define fs_imask	fs_fc.fc_imask
+#define fs_firstino	fs_fc.fc_firstino
+#define fs_ipb		fs_fc.fc_ipb
+#define fs_fsbtodb	fs_fc.fc_fsbtodb
+};
+
+struct ext2blkgrp {
+	u_int32_t	bg_blkmap;	/* block bitmap */
+	u_int32_t	bg_inomap;	/* inode bitmap */
+	u_int32_t	bg_inotbl;	/* inode table */
+	u_int16_t	bg_nfblk;	/* # of free blocks */
+	u_int16_t	bg_nfino;	/* # of free inodes */
+	u_int16_t	bg_ndirs;	/* # of dirs */
+	char		bg_pad[14];
+};
+
+struct ext2dinode {
+	u_int16_t	di_mode;	/* mode */
+	u_int16_t	di_uid;		/* uid */
+	u_int32_t	di_size;	/* byte size */
+	u_int32_t	di_atime;	/* access time */
+	u_int32_t	di_ctime;	/* creation time */
+	u_int32_t	di_mtime;	/* modification time */
+	u_int32_t	di_dtime;	/* deletion time */
+	u_int16_t	di_gid;		/* gid */
+	u_int16_t	di_nlink;	/* link count */
+	u_int32_t	di_nblk;	/* block count */
+	u_int32_t	di_flags;	/* file flags */
+
+	u_int32_t	di_osdep1;	/* os dependent stuff */
+
+	u_int32_t	di_db[NDADDR];	/* direct blocks */
+	u_int32_t	di_ib[NIADDR];	/* indirect blocks */
+	u_int32_t	di_version;	/* version */
+	u_int32_t	di_facl;	/* file acl */
+	u_int32_t	di_dacl;	/* dir acl */
+	u_int32_t	di_faddr;	/* fragment addr */
+
+	u_int8_t	di_frag;	/* fragment number */
+	u_int8_t	di_fsize;	/* fragment size */
+
+	char		di_pad[10];
+
+#define di_shortlink	di_db
+};
+
+#define EXT2_MAXNAMLEN       255
+
+struct ext2dirent {
+	u_int32_t	d_ino;		/* inode */
+	u_int16_t	d_reclen;	/* directory entry length */
+	u_int8_t	d_namlen;	/* name length */
+	u_int8_t	d_type;		/* file type */
+	char		d_name[EXT2_MAXNAMLEN];
+};
+
+struct file {
+	off_t		f_seekp;		/* seek pointer */
+	struct 		ext2fs *f_fs;		/* pointer to super-block */
+	struct 		ext2blkgrp *f_bg;	/* pointer to blkgrp map */
+	struct 		ext2dinode f_di;	/* copy of on-disk inode */
+	int		f_nindir[NIADDR];	/* number of blocks mapped by
+						   indirect block at level i */
+	char		*f_blk[NIADDR];		/* buffer for indirect block
+						   at level i */
+	size_t		f_blksize[NIADDR];	/* size of buffer */
+	daddr_t		f_blkno[NIADDR];	/* disk address of block in
+						   buffer */
+	char		*f_buf;			/* buffer for data block */
+	size_t		f_buf_size;		/* size of data block */
+	daddr_t		f_buf_blkno;		/* block number of data block */
+};
+
+/* forward decls */
+static int 	read_inode(ino_t inumber, struct open_file *f);
+static int	block_map(struct open_file *f, daddr_t file_block,
+		    daddr_t *disk_block_p);
+static int	buf_read_file(struct open_file *f, char **buf_p,
+		    size_t *size_p);
+static int	search_directory(char *name, struct open_file *f,
+		    ino_t *inumber_p);
+
+/*
+ * Open a file.
+ */
+static int
+ext2fs_open(const char *upath, struct open_file *f)
+{
+	struct file *fp;
+	struct ext2fs *fs;
+	size_t buf_size;
+	ino_t inumber, parent_inumber;
+	int i, len, groups, bg_per_blk, blkgrps, mult;
+	int nlinks = 0;
+	int error = 0;
+	char *cp, *ncp, *path = NULL, *buf = NULL;
+	char namebuf[MAXPATHLEN+1];
+	char c;
+
+	/* allocate file system specific data structure */
+	fp = malloc(sizeof(struct file));
+	if (fp == NULL)
+		return (ENOMEM);
+	bzero(fp, sizeof(struct file));
+	f->f_fsdata = (void *)fp;
+
+	/* allocate space and read super block */
+	fs = (struct ext2fs *)malloc(sizeof(*fs));
+	fp->f_fs = fs;
+	twiddle();
+	error = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+	    EXT2_SBLOCK, EXT2_SBSIZE, (char *)fs, &buf_size);
+	if (error)
+		goto out;
+
+	if (buf_size != EXT2_SBSIZE || fs->fs_magic != EXT2_MAGIC) {
+		error = EINVAL;
+		goto out;
+	}
+
+	/*
+	 * compute in-core values for the superblock
+	 */
+	fs->fs_bshift = EXT2_MINBSHIFT + fs->fs_fd.fd_bsize;
+	fs->fs_bsize = 1 << fs->fs_bshift;
+	fs->fs_bmask = fs->fs_bsize - 1;
+
+	fs->fs_fshift = EXT2_MINFSHIFT + fs->fs_fd.fd_fsize;
+	fs->fs_fsize = 1 << fs->fs_fshift;
+	fs->fs_fmask = fs->fs_fsize - 1;
+
+	if (fs->fs_revision == EXT2_REV0) {
+		fs->fs_isize = EXT2_R0_ISIZE;
+		fs->fs_firstino = EXT2_R0_FIRSTINO;
+	} else {
+		fs->fs_isize = fs->fs_fd.fd_isize;
+		fs->fs_firstino = fs->fs_fd.fd_firstino;
+	}
+	fs->fs_imask = fs->fs_isize - 1;
+	fs->fs_ipb = fs->fs_bsize / fs->fs_isize;
+	fs->fs_fsbtodb = (fs->fs_bsize / DEV_BSIZE) - 1;
+
+	/*
+	 * we have to load in the "group descriptors" here
+	 */
+	groups = howmany(fs->fs_blocks - fs->fs_firstblk, fs->fs_bpg);
+	bg_per_blk = fs->fs_bsize / sizeof(struct ext2blkgrp);
+	blkgrps = howmany(groups, bg_per_blk);
+	len = blkgrps * fs->fs_bsize;
+
+	fp->f_bg = malloc(len);
+	twiddle();
+	error = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+	    EXT2_SBLOCK + EXT2_SBSIZE / DEV_BSIZE, len,
+	    (char *)fp->f_bg, &buf_size);
+	if (error)
+		goto out;
+
+	/*
+	 * XXX
+	 * validation of values?  (blocksize, descriptors, etc?)
+	 */
+
+	/*
+	 * Calculate indirect block levels.
+	 */
+	mult = 1;
+	for (i = 0; i < NIADDR; i++) {
+		mult *= nindir(fs);
+		fp->f_nindir[i] = mult;
+	}
+
+	inumber = EXT2_ROOTINO;
+	if ((error = read_inode(inumber, f)) != 0)
+		goto out;
+
+	path = strdup(upath);
+	if (path == NULL) {
+		error = ENOMEM;
+		goto out;
+	}
+	cp = path;
+	while (*cp) {
+		/*
+		 * Remove extra separators
+		 */
+		while (*cp == '/')
+			cp++;
+		if (*cp == '\0')
+			break;
+
+		/*
+		 * Check that current node is a directory.
+		 */
+		if (! S_ISDIR(fp->f_di.di_mode)) {
+			error = ENOTDIR;
+			goto out;
+		}
+
+		/*
+		 * Get next component of path name.
+		 */
+		len = 0;
+
+		ncp = cp;
+		while ((c = *cp) != '\0' && c != '/') {
+			if (++len > EXT2_MAXNAMLEN) {
+				error = ENOENT;
+				goto out;
+			}
+			cp++;
+		}
+		*cp = '\0';
+
+		/*
+		 * Look up component in current directory.
+		 * Save directory inumber in case we find a
+		 * symbolic link.
+		 */
+		parent_inumber = inumber;
+		error = search_directory(ncp, f, &inumber);
+		*cp = c;
+		if (error)
+			goto out;
+
+		/*
+		 * Open next component.
+		 */
+		if ((error = read_inode(inumber, f)) != 0)
+			goto out;
+
+		/*
+		 * Check for symbolic link.
+		 */
+		if (S_ISLNK(fp->f_di.di_mode)) {
+			int link_len = fp->f_di.di_size;
+			int len;
+
+			len = strlen(cp);
+			if (link_len + len > MAXPATHLEN ||
+			    ++nlinks > MAXSYMLINKS) {
+				error = ENOENT;
+				goto out;
+			}
+
+			bcopy(cp, &namebuf[link_len], len + 1);
+			if (fp->f_di.di_nblk == 0) {
+				bcopy(fp->f_di.di_shortlink,
+				    namebuf, link_len);
+			} else {
+				/*
+				 * Read file for symbolic link
+				 */
+				struct ext2fs *fs = fp->f_fs;
+				daddr_t	disk_block;
+				size_t buf_size;
+
+				if (! buf)
+					buf = malloc(fs->fs_bsize);
+				error = block_map(f, (daddr_t)0, &disk_block);
+				if (error)
+					goto out;
+				
+				twiddle();
+				error = (f->f_dev->dv_strategy)(f->f_devdata,
+				    F_READ, fsb_to_db(fs, disk_block),
+				    fs->fs_bsize, buf, &buf_size);
+				if (error)
+					goto out;
+
+				bcopy((char *)buf, namebuf, link_len);
+			}
+
+			/*
+			 * If relative pathname, restart at parent directory.
+			 * If absolute pathname, restart at root.
+			 */
+			cp = namebuf;
+			if (*cp != '/')
+				inumber = parent_inumber;
+			else
+				inumber = (ino_t)EXT2_ROOTINO;
+
+			if ((error = read_inode(inumber, f)) != 0)
+				goto out;
+		}
+	}
+
+	/*
+	 * Found terminal component.
+	 */
+	error = 0;
+out:
+	if (buf)
+		free(buf);
+	if (path)
+		free(path);
+	if (error) {
+		if (fp->f_buf)
+			free(fp->f_buf);
+		free(fp->f_fs);
+		free(fp);
+	}
+	return (error);
+}
+
+/*
+ * Read a new inode into a file structure.
+ */
+static int
+read_inode(ino_t inumber, struct open_file *f)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct ext2fs *fs = fp->f_fs;
+	struct ext2dinode *dp;
+	char *buf;
+	size_t rsize;
+	int level, error = 0;
+
+	/*
+	 * Read inode and save it.
+	 */
+	buf = malloc(fs->fs_bsize);
+	twiddle();
+	error = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+	    ino_to_db(fs, fp->f_bg, inumber), fs->fs_bsize, buf, &rsize);
+	if (error)
+		goto out;
+	if (rsize != fs->fs_bsize) {
+		error = EIO;
+		goto out;
+	}
+
+	dp = (struct ext2dinode *)buf;
+	fp->f_di = dp[ino_to_bo(fs, inumber)];
+
+	/* clear out old buffers */
+	for (level = 0; level < NIADDR; level++)
+		fp->f_blkno[level] = -1;
+	fp->f_buf_blkno = -1;
+
+out:
+	free(buf);
+	return (error);	 
+}
+
+/*
+ * Given an offset in a file, find the disk block number that
+ * contains that block.
+ */
+static int
+block_map(struct open_file *f, daddr_t file_block, daddr_t *disk_block_p)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct ext2fs *fs = fp->f_fs;
+	daddr_t ind_block_num;
+	int32_t *ind_p;
+	int idx, level;
+	int error;
+
+	/*
+	 * Index structure of an inode:
+	 *
+	 * di_db[0..NDADDR-1]	hold block numbers for blocks
+	 *			0..NDADDR-1
+	 *
+	 * di_ib[0]		index block 0 is the single indirect block
+	 *			holds block numbers for blocks
+	 *			NDADDR .. NDADDR + NINDIR(fs)-1
+	 *
+	 * di_ib[1]		index block 1 is the double indirect block
+	 *			holds block numbers for INDEX blocks for blocks
+	 *			NDADDR + NINDIR(fs) ..
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 - 1
+	 *
+	 * di_ib[2]		index block 2 is the triple indirect block
+	 *			holds block numbers for double-indirect
+	 *			blocks for blocks
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 ..
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2
+	 *				+ NINDIR(fs)**3 - 1
+	 */
+
+	if (file_block < NDADDR) {
+		/* Direct block. */
+		*disk_block_p = fp->f_di.di_db[file_block];
+		return (0);
+	}
+
+	file_block -= NDADDR;
+
+	/*
+	 * nindir[0] = NINDIR
+	 * nindir[1] = NINDIR**2
+	 * nindir[2] = NINDIR**3
+	 *	etc
+	 */
+	for (level = 0; level < NIADDR; level++) {
+		if (file_block < fp->f_nindir[level])
+			break;
+		file_block -= fp->f_nindir[level];
+	}
+	if (level == NIADDR) {
+		/* Block number too high */
+		return (EFBIG);
+	}
+
+	ind_block_num = fp->f_di.di_ib[level];
+
+	for (; level >= 0; level--) {
+		if (ind_block_num == 0) {
+			*disk_block_p = 0;	/* missing */
+			return (0);
+		}
+
+		if (fp->f_blkno[level] != ind_block_num) {
+			if (fp->f_blk[level] == (char *)0)
+				fp->f_blk[level] =
+					malloc(fs->fs_bsize);
+			twiddle();
+			error = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+			    fsb_to_db(fp->f_fs, ind_block_num), fs->fs_bsize,
+			    fp->f_blk[level], &fp->f_blksize[level]);
+			if (error)
+				return (error);
+			if (fp->f_blksize[level] != fs->fs_bsize)
+				return (EIO);
+			fp->f_blkno[level] = ind_block_num;
+		}
+
+		ind_p = (int32_t *)fp->f_blk[level];
+
+		if (level > 0) {
+			idx = file_block / fp->f_nindir[level - 1];
+			file_block %= fp->f_nindir[level - 1];
+		} else {
+			idx = file_block;
+		}
+		ind_block_num = ind_p[idx];
+	}
+
+	*disk_block_p = ind_block_num;
+
+	return (0);
+}
+
+/*
+ * Read a portion of a file into an internal buffer.  Return
+ * the location in the buffer and the amount in the buffer.
+ */
+static int
+buf_read_file(struct open_file *f, char **buf_p, size_t *size_p)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct ext2fs *fs = fp->f_fs;
+	long off;
+	daddr_t file_block;
+	daddr_t	disk_block;
+	size_t block_size;
+	int error = 0;
+
+	off = blkoff(fs, fp->f_seekp);
+	file_block = lblkno(fs, fp->f_seekp);
+	block_size = dblksize(fs, &fp->f_di, file_block);
+
+	if (file_block != fp->f_buf_blkno) {
+		error = block_map(f, file_block, &disk_block);
+		if (error)
+			goto done;
+
+		if (fp->f_buf == (char *)0)
+			fp->f_buf = malloc(fs->fs_bsize);
+
+		if (disk_block == 0) {
+			bzero(fp->f_buf, block_size);
+			fp->f_buf_size = block_size;
+		} else {
+			twiddle();
+			error = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+			    fsb_to_db(fs, disk_block), block_size,
+			    fp->f_buf, &fp->f_buf_size);
+			if (error)
+				goto done;
+		}
+		fp->f_buf_blkno = file_block;
+	}
+
+	/*
+	 * Return address of byte in buffer corresponding to
+	 * offset, and size of remainder of buffer after that
+	 * byte.
+	 */
+	*buf_p = fp->f_buf + off;
+	*size_p = block_size - off;
+
+	/*
+	 * But truncate buffer at end of file.
+	 */
+	if (*size_p > fp->f_di.di_size - fp->f_seekp)
+		*size_p = fp->f_di.di_size - fp->f_seekp;
+done:
+	return (error);
+}
+
+/*
+ * Search a directory for a name and return its
+ * i_number.
+ */
+static int
+search_directory(char *name, struct open_file *f, ino_t *inumber_p)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct ext2dirent *dp, *edp;
+	char *buf;
+	size_t buf_size;
+	int namlen, length;
+	int error;
+
+	length = strlen(name);
+	fp->f_seekp = 0;
+	while (fp->f_seekp < fp->f_di.di_size) {
+		error = buf_read_file(f, &buf, &buf_size);
+		if (error)
+			return (error);
+		dp = (struct ext2dirent *)buf;
+		edp = (struct ext2dirent *)(buf + buf_size);
+		while (dp < edp) {
+			if (dp->d_ino == (ino_t)0)
+				goto next;
+			namlen = dp->d_namlen;
+			if (namlen == length &&
+			    strncmp(name, dp->d_name, length) == 0) {
+				/* found entry */
+				*inumber_p = dp->d_ino;
+				return (0);
+			}
+		next:
+			dp = (struct ext2dirent *)((char *)dp + dp->d_reclen);
+		}
+		fp->f_seekp += buf_size;
+	}
+	return (ENOENT);
+}
+
+static int
+ext2fs_close(struct open_file *f)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	int level;
+
+	f->f_fsdata = (void *)0;
+	if (fp == (struct file *)0)
+		return (0);
+
+	for (level = 0; level < NIADDR; level++) {
+		if (fp->f_blk[level])
+			free(fp->f_blk[level]);
+	}
+	if (fp->f_buf)
+		free(fp->f_buf);
+	if (fp->f_bg)
+		free(fp->f_bg);
+	free(fp->f_fs);
+	free(fp);
+	return (0);
+}
+
+static int
+ext2fs_read(struct open_file *f, void *addr, size_t size, size_t *resid)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	size_t csize, buf_size;
+	char *buf;
+	int error = 0;
+
+	while (size != 0) {
+		if (fp->f_seekp >= fp->f_di.di_size)
+			break;
+
+		error = buf_read_file(f, &buf, &buf_size);
+		if (error)
+			break;
+
+		csize = size;
+		if (csize > buf_size)
+			csize = buf_size;
+
+		bcopy(buf, addr, csize);
+
+		fp->f_seekp += csize;
+		addr = (char *)addr + csize;
+		size -= csize;
+	}
+	if (resid)
+		*resid = size;
+	return (error);
+}
+
+static off_t
+ext2fs_seek(struct open_file *f, off_t offset, int where)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	switch (where) {
+	case SEEK_SET:
+		fp->f_seekp = offset;
+		break;
+	case SEEK_CUR:
+		fp->f_seekp += offset;
+		break;
+	case SEEK_END:
+		fp->f_seekp = fp->f_di.di_size - offset;
+		break;
+	default:
+		errno = EINVAL;
+		return (-1);
+	}
+	return (fp->f_seekp);
+}
+
+static int
+ext2fs_stat(struct open_file *f, struct stat *sb)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	/* only important stuff */
+	sb->st_mode = fp->f_di.di_mode;
+	sb->st_uid = fp->f_di.di_uid;
+	sb->st_gid = fp->f_di.di_gid;
+	sb->st_size = fp->f_di.di_size;
+	return (0);
+}
+
+static int
+ext2fs_readdir(struct open_file *f, struct dirent *d)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct ext2dirent *ed;
+	char *buf;
+	size_t buf_size;
+	int error;
+
+	/*
+	 * assume that a directory entry will not be split across blocks
+	 */
+again:
+	if (fp->f_seekp >= fp->f_di.di_size)
+		return (ENOENT);
+	error = buf_read_file(f, &buf, &buf_size);
+	if (error)
+		return (error);
+	ed = (struct ext2dirent *)buf;
+	fp->f_seekp += ed->d_reclen;
+	if (ed->d_ino == (ino_t)0)
+		goto again;
+	d->d_type = EXTFTODT(ed->d_type);
+	strncpy(d->d_name, ed->d_name, ed->d_namlen);
+	d->d_name[ed->d_namlen] = '\0';
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/fstat.c sys/boot/i386/pxe_ng/libstand/fstat.c
--- sys/boot/i386/pxe_ng/libstand/fstat.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/fstat.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,61 @@
+/*	$NetBSD: fstat.c,v 1.1 1996/01/13 22:25:38 leo Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)stat.c	8.1 (Berkeley) 6/11/93
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+int
+fstat(fd, sb)
+	int fd;
+	struct stat *sb;
+{
+	struct open_file *f = &files[fd];
+
+	if ((unsigned)fd >= SOPEN_MAX || f->f_flags == 0) {
+		errno = EBADF;
+		return (-1);
+	}
+
+	/* operation not defined on raw devices */
+	if (f->f_flags & F_RAW) {
+		errno = EOPNOTSUPP;
+		return (-1);
+	}
+
+	errno = (f->f_ops->fo_stat)(f, sb);
+	if (errno)
+		return (-1);
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/getopt.c sys/boot/i386/pxe_ng/libstand/getopt.c
--- sys/boot/i386/pxe_ng/libstand/getopt.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/getopt.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 1987, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
+#endif /* LIBC_SCCS and not lint */
+
+#include "stand.h"
+#include <string.h>
+
+int	opterr = 1,		/* if error message should be printed */
+	optind = 1,		/* index into parent argv vector */
+	optopt,			/* character checked for validity */
+	optreset;		/* reset getopt */
+char	*optarg;		/* argument associated with option */
+
+#define	BADCH	(int)'?'
+#define	BADARG	(int)':'
+#define	EMSG	""
+
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt(nargc, nargv, ostr)
+	int nargc;
+	char * const *nargv;
+	const char *ostr;
+{
+	static char *place = EMSG;		/* option letter processing */
+	char *oli;				/* option letter list index */
+
+	if (optreset || !*place) {		/* update scanning pointer */
+		optreset = 0;
+		if (optind >= nargc || *(place = nargv[optind]) != '-') {
+			place = EMSG;
+			return (-1);
+		}
+		if (place[1] && *++place == '-') {	/* found "--" */
+			++optind;
+			place = EMSG;
+			return (-1);
+		}
+	}					/* option letter okay? */
+	if ((optopt = (int)*place++) == (int)':' ||
+	    !(oli = strchr(ostr, optopt))) {
+		/*
+		 * if the user didn't specify '-' as an option,
+		 * assume it means -1.
+		 */
+		if (optopt == (int)'-')
+			return (-1);
+		if (!*place)
+			++optind;
+		if (opterr && *ostr != ':')
+			(void)printf("illegal option -- %c\n", optopt);
+		return (BADCH);
+	}
+	if (*++oli != ':') {			/* don't need argument */
+		optarg = NULL;
+		if (!*place)
+			++optind;
+	}
+	else {					/* need an argument */
+		if (*place)			/* no white space */
+			optarg = place;
+		else if (nargc <= ++optind) {	/* no arg */
+			place = EMSG;
+			if (*ostr == ':')
+				return (BADARG);
+			if (opterr)
+				(void)printf("option requires an argument -- %c\n", optopt);
+			return (BADCH);
+		}
+	 	else				/* white space */
+			optarg = nargv[optind];
+		place = EMSG;
+		++optind;
+	}
+	return (optopt);			/* dump back option letter */
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/gets.c sys/boot/i386/pxe_ng/libstand/gets.c
--- sys/boot/i386/pxe_ng/libstand/gets.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/gets.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,112 @@
+/*	$NetBSD: gets.c,v 1.6 1995/10/11 21:16:57 pk Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)gets.c	8.1 (Berkeley) 6/11/93
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+/* gets() with constrained input length */
+
+void
+ngets(char *buf, int n)
+{
+    int c;
+    char *lp;
+
+    for (lp = buf;;)
+	switch (c = getchar() & 0177) {
+	case '\n':
+	case '\r':
+	    *lp = '\0';
+	    putchar('\n');
+	    return;
+	case '\b':
+	case '\177':
+	    if (lp > buf) {
+		lp--;
+		putchar('\b');
+		putchar(' ');
+		putchar('\b');
+	    }
+	    break;
+	case 'r'&037: {
+	    char *p;
+
+	    putchar('\n');
+	    for (p = buf; p < lp; ++p)
+		putchar(*p);
+	    break;
+	}
+	case 'u'&037:
+	case 'w'&037:
+	    lp = buf;
+	    putchar('\n');
+	    break;
+	default:
+	    if ((n < 1) || ((lp - buf) < n)) {
+		*lp++ = c;
+		putchar(c);
+	    }
+	}
+    /*NOTREACHED*/
+}
+
+int
+fgetstr(char *buf, int size, int fd)
+{
+    char	c;
+    int		err, len;
+    
+    size--;	/* leave space for terminator */
+    len = 0;
+    while (size != 0) {
+	err = read(fd, &c, sizeof(c));
+	if (err < 0)		/* read error */
+	    return(-1);
+	if (err == 0) {		/* EOF */
+	    if (len == 0)
+		return(-1);	/* nothing to read */
+	    break;
+	}
+	if ((c == '\r') ||	/* line terminators */
+	    (c == '\n'))
+	    break;
+	*buf++ = c;		/* keep char */
+	size--;
+	len++;
+    }
+    *buf = 0;
+    return(len);
+}
+
diff -ruN sys/boot/i386/pxe_ng/libstand/globals.c sys/boot/i386/pxe_ng/libstand/globals.c
--- sys/boot/i386/pxe_ng/libstand/globals.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/globals.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,36 @@
+/*	$NetBSD: globals.c,v 1.3 1995/09/18 21:19:27 pk Exp $	*/
+
+/*
+ *	globals.c:
+ *
+ *	global variables should be separate, so nothing else
+ *	must be included extraneously.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include "stand.h"
+#include "net.h"
+
+u_char	bcea[6] = BA;			/* broadcast ethernet address */
+
+char	rootpath[FNAME_SIZE] = "/";	/* root mount path */
+char	bootfile[FNAME_SIZE];		/* bootp says to boot this */
+char	hostname[FNAME_SIZE];		/* our hostname */
+int	hostnamelen;
+char	domainname[FNAME_SIZE];		/* our DNS domain */
+int	domainnamelen;
+char	ifname[IFNAME_SIZE];		/* name of interface (e.g. "le0") */
+struct	in_addr myip;			/* my ip address */
+struct	in_addr nameip;			/* DNS server ip address */
+struct	in_addr rootip;			/* root ip address */
+struct	in_addr swapip;			/* swap ip address */
+struct	in_addr gateip;			/* swap ip address */
+n_long	netmask = 0xffffff00;		/* subnet or net mask */
+int	errno;				/* our old friend */
+
diff -ruN sys/boot/i386/pxe_ng/libstand/gzipfs.c sys/boot/i386/pxe_ng/libstand/gzipfs.c
--- sys/boot/i386/pxe_ng/libstand/gzipfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/gzipfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,345 @@
+/* 
+ * Copyright (c) 1998 Michael Smith.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+#include <sys/stat.h>
+#include <string.h>
+#include <zlib.h>
+
+#define Z_BUFSIZE 2048	/* XXX larger? */
+
+struct z_file
+{
+    int			zf_rawfd;
+    off_t		zf_dataoffset;
+    z_stream		zf_zstream;
+    char		zf_buf[Z_BUFSIZE];
+};
+
+static int	zf_fill(struct z_file *z);
+static int	zf_open(const char *path, struct open_file *f);
+static int	zf_close(struct open_file *f);
+static int	zf_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	zf_seek(struct open_file *f, off_t offset, int where);
+static int	zf_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops gzipfs_fsops = {
+    "zip",
+    zf_open, 
+    zf_close, 
+    zf_read,
+    null_write,
+    zf_seek,
+    zf_stat,
+    null_readdir
+};
+
+#if 0
+void *
+calloc(int items, size_t size)
+{
+    return(malloc(items * size));
+}
+#endif
+
+static int
+zf_fill(struct z_file *zf)
+{
+    int		result;
+    int		req;
+    
+    req = Z_BUFSIZE - zf->zf_zstream.avail_in;
+    result = 0;
+    
+    /* If we need more */
+    if (req > 0) {
+	/* move old data to bottom of buffer */
+	if (req < Z_BUFSIZE)
+	    bcopy(zf->zf_buf + req, zf->zf_buf, Z_BUFSIZE - req);
+	
+	/* read to fill buffer and update availibility data */
+	result = read(zf->zf_rawfd, zf->zf_buf + zf->zf_zstream.avail_in, req);
+	zf->zf_zstream.next_in = zf->zf_buf;
+	if (result >= 0)
+	    zf->zf_zstream.avail_in += result;
+    }
+    return(result);
+}
+
+/*
+ * Adapted from get_byte/check_header in libz
+ *
+ * Returns 0 if the header is OK, nonzero if not.
+ */
+static int
+get_byte(struct z_file *zf, off_t *curoffp)
+{
+    if ((zf->zf_zstream.avail_in == 0) && (zf_fill(zf) == -1))
+	return(-1);
+    zf->zf_zstream.avail_in--;
+    ++*curoffp;
+    return(*(zf->zf_zstream.next_in)++);
+}
+
+static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
+
+/* gzip flag byte */
+#define ASCII_FLAG	0x01 /* bit 0 set: file probably ascii text */
+#define HEAD_CRC	0x02 /* bit 1 set: header CRC present */
+#define EXTRA_FIELD	0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME	0x08 /* bit 3 set: original file name present */
+#define COMMENT		0x10 /* bit 4 set: file comment present */
+#define RESERVED	0xE0 /* bits 5..7: reserved */
+
+static int
+check_header(struct z_file *zf)
+{
+    int		method; /* method byte */
+    int		flags;  /* flags byte */
+    uInt	len;
+    int		c;
+
+    zf->zf_dataoffset = 0;
+    /* Check the gzip magic header */
+    for (len = 0; len < 2; len++) {
+	c = get_byte(zf, &zf->zf_dataoffset);
+	if (c != gz_magic[len]) {
+	    return(1);
+	}
+    }
+    method = get_byte(zf, &zf->zf_dataoffset);
+    flags = get_byte(zf, &zf->zf_dataoffset);
+    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
+	return(1);
+    }
+    
+    /* Discard time, xflags and OS code: */
+    for (len = 0; len < 6; len++) (void)get_byte(zf, &zf->zf_dataoffset);
+
+    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
+	len  =  (uInt)get_byte(zf, &zf->zf_dataoffset);
+	len += ((uInt)get_byte(zf, &zf->zf_dataoffset))<<8;
+	/* len is garbage if EOF but the loop below will quit anyway */
+	while (len-- != 0 && get_byte(zf, &zf->zf_dataoffset) != -1) ;
+    }
+    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
+	while ((c = get_byte(zf, &zf->zf_dataoffset)) != 0 && c != -1) ;
+    }
+    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
+	while ((c = get_byte(zf, &zf->zf_dataoffset)) != 0 && c != -1) ;
+    }
+    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
+	for (len = 0; len < 2; len++) c = get_byte(zf, &zf->zf_dataoffset);
+    }
+    /* if there's data left, we're in business */
+    return((c == -1) ? 1 : 0);
+}
+	
+static int
+zf_open(const char *fname, struct open_file *f)
+{
+    static char		*zfname;
+    int			rawfd;
+    struct z_file	*zf;
+    char		*cp;
+    int			error;
+    struct stat		sb;
+
+    /* Have to be in "just read it" mode */
+    if (f->f_flags != F_READ)
+	return(EPERM);
+
+    /* If the name already ends in .gz or .bz2, ignore it */
+    if ((cp = strrchr(fname, '.')) && (!strcmp(cp, ".gz")
+	    || !strcmp(cp, ".bz2") || !strcmp(cp, ".split")))
+	return(ENOENT);
+
+    /* Construct new name */
+    zfname = malloc(strlen(fname) + 4);
+    if (zfname == NULL)
+        return(ENOMEM);
+    sprintf(zfname, "%s.gz", fname);
+
+    /* Try to open the compressed datafile */
+    rawfd = open(zfname, O_RDONLY);
+    free(zfname);
+    if (rawfd == -1)
+	return(ENOENT);
+
+    if (fstat(rawfd, &sb) < 0) {
+	printf("zf_open: stat failed\n");
+	close(rawfd);
+	return(ENOENT);
+    }
+    if (!S_ISREG(sb.st_mode)) {
+	printf("zf_open: not a file\n");
+	close(rawfd);
+	return(EISDIR);			/* best guess */
+    }
+
+    /* Allocate a z_file structure, populate it */
+    zf = malloc(sizeof(struct z_file));
+    if (zf == NULL)
+        return(ENOMEM);
+    bzero(zf, sizeof(struct z_file));
+    zf->zf_rawfd = rawfd;
+
+    /* Verify that the file is gzipped (XXX why do this afterwards?) */
+    if (check_header(zf)) {
+	close(zf->zf_rawfd);
+	inflateEnd(&(zf->zf_zstream));
+	free(zf);
+	return(EFTYPE);
+    }
+
+    /* Initialise the inflation engine */
+    if ((error = inflateInit2(&(zf->zf_zstream), -15)) != Z_OK) {
+	printf("zf_open: inflateInit returned %d : %s\n", error, zf->zf_zstream.msg);
+	close(zf->zf_rawfd);
+	free(zf);
+	return(EIO);
+    }
+
+    /* Looks OK, we'll take it */
+    f->f_fsdata = zf;
+    return(0);
+}
+
+static int
+zf_close(struct open_file *f)
+{
+    struct z_file	*zf = (struct z_file *)f->f_fsdata;
+    
+    inflateEnd(&(zf->zf_zstream));
+    close(zf->zf_rawfd);
+    free(zf);
+    return(0);
+}
+ 
+static int 
+zf_read(struct open_file *f, void *buf, size_t size, size_t *resid)
+{
+    struct z_file	*zf = (struct z_file *)f->f_fsdata;
+    int			error;
+
+    zf->zf_zstream.next_out = buf;			/* where and how much */
+    zf->zf_zstream.avail_out = size;
+
+    while (zf->zf_zstream.avail_out) {
+	if ((zf->zf_zstream.avail_in == 0) && (zf_fill(zf) == -1)) {
+	    printf("zf_read: fill error\n");
+	    return(EIO);
+	}
+	if (zf->zf_zstream.avail_in == 0) {		/* oops, unexpected EOF */
+	    printf("zf_read: unexpected EOF\n");
+	    if (zf->zf_zstream.avail_out == size)
+		return (EIO);
+	    break;
+	}
+
+	error = inflate(&zf->zf_zstream, Z_SYNC_FLUSH);	/* decompression pass */
+	if (error == Z_STREAM_END) {			/* EOF, all done */
+	    break;
+	}
+	if (error != Z_OK) {				/* argh, decompression error */
+	    printf("inflate: %s\n", zf->zf_zstream.msg);
+	    return(EIO);
+	}
+    }
+    if (resid != NULL)
+	*resid = zf->zf_zstream.avail_out;
+    return(0);
+}
+
+static int
+zf_rewind(struct open_file *f)
+{
+    struct z_file	*zf = (struct z_file *)f->f_fsdata;
+
+    if (lseek(zf->zf_rawfd, zf->zf_dataoffset, SEEK_SET) == -1)
+	return -1;
+    zf->zf_zstream.avail_in = 0;
+    zf->zf_zstream.next_in = NULL;
+    (void)inflateReset(&zf->zf_zstream);
+
+    return 0;
+}
+
+static off_t
+zf_seek(struct open_file *f, off_t offset, int where)
+{
+    struct z_file	*zf = (struct z_file *)f->f_fsdata;
+    off_t		target;
+    char		discard[16];
+    
+    switch (where) {
+    case SEEK_SET:
+	target = offset;
+	break;
+    case SEEK_CUR:
+	target = offset + zf->zf_zstream.total_out;
+	break;
+    case SEEK_END:
+	target = -1;
+    default:
+	errno = EINVAL;
+	return (-1);
+    }
+
+    /* rewind if required */
+    if (target < zf->zf_zstream.total_out && zf_rewind(f) != 0)
+	return -1;
+
+    /* skip forwards if required */
+    while (target > zf->zf_zstream.total_out) {
+	errno = zf_read(f, discard, min(sizeof(discard),
+	    target - zf->zf_zstream.total_out), NULL);
+	if (errno)
+	    return(-1);
+    }
+    /* This is where we are (be honest if we overshot) */
+    return (zf->zf_zstream.total_out);
+}
+
+
+static int
+zf_stat(struct open_file *f, struct stat *sb)
+{
+    struct z_file	*zf = (struct z_file *)f->f_fsdata;
+    int			result;
+
+    /* stat as normal, but indicate that size is unknown */
+    if ((result = fstat(zf->zf_rawfd, sb)) == 0)
+	sb->st_size = -1;
+    return(result);
+}
+
+
+
diff -ruN sys/boot/i386/pxe_ng/libstand/i386/_setjmp.S sys/boot/i386/pxe_ng/libstand/i386/_setjmp.S
--- sys/boot/i386/pxe_ng/libstand/i386/_setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/i386/_setjmp.S	2009-02-20 12:30:54.000000000 -0500
@@ -0,0 +1,75 @@
+/*-
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * William Jolitz.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_RCS) && !defined(lint)
+	.text
+	.asciz "$FreeBSD$"
+#endif /* LIBC_RCS and not lint */
+
+/*
+ * C library -- _setjmp, _longjmp
+ *
+ *	_longjmp(a,v)
+ * will generate a "return(v)" from the last call to
+ *	_setjmp(a)
+ * by restoring registers from the environment 'a'.
+ * The previous signal state is NOT restored.
+ */
+
+#include <machine/asm.h>
+
+ENTRY(_setjmp)
+	movl	4(%esp),%eax
+	movl	0(%esp),%edx
+	movl	%edx, 0(%eax)		/* rta */
+	movl	%ebx, 4(%eax)
+	movl	%esp, 8(%eax)
+	movl	%ebp,12(%eax)
+	movl	%esi,16(%eax)
+	movl	%edi,20(%eax)
+	xorl	%eax,%eax
+	ret
+
+ENTRY(_longjmp)
+	movl	4(%esp),%edx
+	movl	8(%esp),%eax
+	movl	0(%edx),%ecx
+	movl	4(%edx),%ebx
+	movl	8(%edx),%esp
+	movl	12(%edx),%ebp
+	movl	16(%edx),%esi
+	movl	20(%edx),%edi
+	testl	%eax,%eax
+	jnz	1f
+	incl	%eax
+1:	movl	%ecx,0(%esp)
+	ret
diff -ruN sys/boot/i386/pxe_ng/libstand/if_ether.h sys/boot/i386/pxe_ng/libstand/if_ether.h
--- sys/boot/i386/pxe_ng/libstand/if_ether.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/if_ether.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,261 @@
+/*	$NetBSD: if_ether.h,v 1.25 1997/01/17 17:06:06 mikel Exp $	*/
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.1 (Berkeley) 6/10/93
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * Ethernet address - 6 octets
+ * this is only used by the ethers(3) functions.
+ */
+struct ether_addr {
+	u_int8_t ether_addr_octet[6];
+};
+
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+#define	ETHER_ADDR_LEN	6
+
+struct	ether_header {
+	u_int8_t  ether_dhost[ETHER_ADDR_LEN];
+	u_int8_t  ether_shost[ETHER_ADDR_LEN];
+	u_int16_t ether_type;
+};
+
+#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
+#define	ETHERTYPE_IP		0x0800	/* IP protocol */
+#define	ETHERTYPE_ARP		0x0806	/* address resolution protocol */
+#define	ETHERTYPE_REVARP	0x8035	/* reverse addr resolution protocol */
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHER_IS_MULTICAST(addr) (*(addr) & 0x01) /* is address mcast/bcast? */
+
+#define	ETHERMTU	1500
+#define	ETHERMIN	(60-14)
+
+#ifdef _KERNEL
+/*
+ * Macro to map an IP multicast address to an Ethernet multicast address.
+ * The high-order 25 bits of the Ethernet address are statically assigned,
+ * and the low-order 23 bits are taken from the low end of the IP address.
+ */
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr)				\
+	/* struct in_addr *ipaddr; */					\
+	/* u_int8_t enaddr[ETHER_ADDR_LEN]; */				\
+{									\
+	(enaddr)[0] = 0x01;						\
+	(enaddr)[1] = 0x00;						\
+	(enaddr)[2] = 0x5e;						\
+	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f;			\
+	(enaddr)[4] = ((u_int8_t *)ipaddr)[2];				\
+	(enaddr)[5] = ((u_int8_t *)ipaddr)[3];				\
+}
+#endif
+
+/*
+ * Ethernet Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  Structure below is adapted
+ * to resolving internet addresses.  Field names used correspond to 
+ * RFC 826.
+ */
+struct	ether_arp {
+	struct	 arphdr ea_hdr;			/* fixed-size header */
+	u_int8_t arp_sha[ETHER_ADDR_LEN];	/* sender hardware address */
+	u_int8_t arp_spa[4];			/* sender protocol address */
+	u_int8_t arp_tha[ETHER_ADDR_LEN];	/* target hardware address */
+	u_int8_t arp_tpa[4];			/* target protocol address */
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+/*
+ * Structure shared between the ethernet driver modules and
+ * the address resolution code.  For example, each ec_softc or il_softc
+ * begins with this structure.
+ */
+struct	arpcom {
+	struct	 ifnet ac_if;			/* network-visible interface */
+	u_int8_t ac_enaddr[ETHER_ADDR_LEN];	/* ethernet hardware address */
+	char	 ac__pad[2];			/* be nice to m68k ports */
+	LIST_HEAD(, ether_multi) ac_multiaddrs;	/* list of ether multicast addrs */
+	int	 ac_multicnt;			/* length of ac_multiaddrs list */
+};
+
+struct llinfo_arp {
+	LIST_ENTRY(llinfo_arp) la_list;
+	struct	rtentry *la_rt;
+	struct	mbuf *la_hold;		/* last packet until resolved/timeout */
+	long	la_asked;		/* last time we QUERIED for this addr */
+#define la_timer la_rt->rt_rmx.rmx_expire /* deletion time in seconds */
+};
+
+struct sockaddr_inarp {
+	u_int8_t  sin_len;
+	u_int8_t  sin_family;
+	u_int16_t sin_port;
+	struct	  in_addr sin_addr;
+	struct	  in_addr sin_srcaddr;
+	u_int16_t sin_tos;
+	u_int16_t sin_other;
+#define SIN_PROXY 1
+};
+
+/*
+ * IP and ethernet specific routing flags
+ */
+#define	RTF_USETRAILERS	RTF_PROTO1	/* use trailers */
+#define	RTF_ANNOUNCE	RTF_PROTO2	/* announce new arp entry */
+
+#ifdef	_KERNEL
+u_int8_t etherbroadcastaddr[ETHER_ADDR_LEN];
+u_int8_t ether_ipmulticast_min[ETHER_ADDR_LEN];
+u_int8_t ether_ipmulticast_max[ETHER_ADDR_LEN];
+struct	ifqueue arpintrq;
+
+void	arpwhohas(struct arpcom *, struct in_addr *);
+void	arpintr(void);
+int	arpresolve(struct arpcom *,
+	    struct rtentry *, struct mbuf *, struct sockaddr *, u_char *);
+void	arp_ifinit(struct arpcom *, struct ifaddr *);
+void	arp_rtrequest(int, struct rtentry *, struct sockaddr *);
+
+int	ether_addmulti(struct ifreq *, struct arpcom *);
+int	ether_delmulti(struct ifreq *, struct arpcom *);
+#endif /* _KERNEL */
+
+/*
+ * Ethernet multicast address structure.  There is one of these for each
+ * multicast address or range of multicast addresses that we are supposed
+ * to listen to on a particular interface.  They are kept in a linked list,
+ * rooted in the interface's arpcom structure.  (This really has nothing to
+ * do with ARP, or with the Internet address family, but this appears to be
+ * the minimally-disrupting place to put it.)
+ */
+struct ether_multi {
+	u_int8_t enm_addrlo[ETHER_ADDR_LEN]; /* low  or only address of range */
+	u_int8_t enm_addrhi[ETHER_ADDR_LEN]; /* high or only address of range */
+	struct	 arpcom *enm_ac;	/* back pointer to arpcom */
+	u_int	 enm_refcount;		/* no. claims to this addr/range */
+	LIST_ENTRY(ether_multi) enm_list;
+};
+
+/*
+ * Structure used by macros below to remember position when stepping through
+ * all of the ether_multi records.
+ */
+struct ether_multistep {
+	struct ether_multi  *e_enm;
+};
+
+/*
+ * Macro for looking up the ether_multi record for a given range of Ethernet
+ * multicast addresses connected to a given arpcom structure.  If no matching
+ * record is found, "enm" returns NULL.
+ */
+#define ETHER_LOOKUP_MULTI(addrlo, addrhi, ac, enm)			\
+	/* u_int8_t addrlo[ETHER_ADDR_LEN]; */				\
+	/* u_int8_t addrhi[ETHER_ADDR_LEN]; */				\
+	/* struct arpcom *ac; */					\
+	/* struct ether_multi *enm; */					\
+{									\
+	for ((enm) = (ac)->ac_multiaddrs.lh_first;			\
+	    (enm) != NULL &&						\
+	    (bcmp((enm)->enm_addrlo, (addrlo), ETHER_ADDR_LEN) != 0 ||	\
+	     bcmp((enm)->enm_addrhi, (addrhi), ETHER_ADDR_LEN) != 0);	\
+		(enm) = (enm)->enm_list.le_next);			\
+}
+
+/*
+ * Macro to step through all of the ether_multi records, one at a time.
+ * The current position is remembered in "step", which the caller must
+ * provide.  ETHER_FIRST_MULTI(), below, must be called to initialize "step"
+ * and get the first record.  Both macros return a NULL "enm" when there
+ * are no remaining records.
+ */
+#define ETHER_NEXT_MULTI(step, enm) \
+	/* struct ether_multistep step; */  \
+	/* struct ether_multi *enm; */  \
+{ \
+	if (((enm) = (step).e_enm) != NULL) \
+		(step).e_enm = (enm)->enm_list.le_next; \
+}
+
+#define ETHER_FIRST_MULTI(step, ac, enm) \
+	/* struct ether_multistep step; */ \
+	/* struct arpcom *ac; */ \
+	/* struct ether_multi *enm; */ \
+{ \
+	(step).e_enm = (ac)->ac_multiaddrs.lh_first; \
+	ETHER_NEXT_MULTI((step), (enm)); \
+}
+
+#ifdef _KERNEL
+void arp_rtrequest(int, struct rtentry *, struct sockaddr *);
+int arpresolve(struct arpcom *, struct rtentry *, struct mbuf *,
+		    struct sockaddr *, u_char *);
+void arpintr(void);
+int arpioctl(u_long, caddr_t);
+void arp_ifinit(struct arpcom *, struct ifaddr *);
+void revarpinput(struct mbuf *);
+void in_revarpinput(struct mbuf *);
+void revarprequest(struct ifnet *);
+int revarpwhoarewe(struct ifnet *, struct in_addr *, struct in_addr *);
+int revarpwhoami(struct in_addr *, struct ifnet *);
+int db_show_arptab(void);
+#endif
+
+/*
+ * Prototype ethers(3) functions.
+ */
+#ifndef _KERNEL
+#include <sys/cdefs.h>
+__BEGIN_DECLS
+char *	ether_ntoa(struct ether_addr *);
+struct ether_addr *
+	ether_aton(char *);
+int	ether_ntohost(char *, struct ether_addr *);
+int	ether_hostton(char *, struct ether_addr *);
+int	ether_line(char *, struct ether_addr *, char *);
+__END_DECLS
+#endif
diff -ruN sys/boot/i386/pxe_ng/libstand/in_cksum.c sys/boot/i386/pxe_ng/libstand/in_cksum.c
--- sys/boot/i386/pxe_ng/libstand/in_cksum.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/in_cksum.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,94 @@
+/*	$NetBSD: in_cksum.c,v 1.6 2000/03/31 19:55:09 castor Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: in_cksum.c,v 1.1 92/09/11 01:15:55 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <machine/endian.h>
+
+#include "stand.h"
+
+/*
+ * Checksum routine for Internet Protocol family headers.
+ * This routine is very heavily used in the network
+ * code and should be modified for each CPU to be as fast as possible.
+ * In particular, it should not be this one.
+ */
+int
+in_cksum(p, len)
+	void *p;
+	int len;
+{
+	int sum = 0, oddbyte = 0, v = 0;
+	u_char *cp = p;
+
+	/* we assume < 2^16 bytes being summed */
+	while (len > 0) {
+		if (oddbyte) {
+			sum += v + *cp++;
+			len--;
+		}
+		if (((long)cp & 1) == 0) {
+			while ((len -= 2) >= 0) {
+				sum += *(u_short *)cp;
+				cp += 2;
+			}
+		} else {
+			while ((len -= 2) >= 0) {
+#if BYTE_ORDER == BIG_ENDIAN
+				sum += *cp++ << 8;
+				sum += *cp++;
+#else
+				sum += *cp++;
+				sum += *cp++ << 8;
+#endif
+			}
+		}
+		if ((oddbyte = len & 1) != 0)
+#if BYTE_ORDER == BIG_ENDIAN
+			v = *cp << 8;
+#else
+			v = *cp;
+#endif
+	}
+	if (oddbyte)
+		sum += v;
+	sum = (sum >> 16) + (sum & 0xffff); /* add in accumulated carries */
+	sum += sum >> 16;		/* add potential last carry */
+	return (0xffff & ~sum);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/inet_ntoa.c sys/boot/i386/pxe_ng/libstand/inet_ntoa.c
--- sys/boot/i386/pxe_ng/libstand/inet_ntoa.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/inet_ntoa.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)inet_ntoa.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "stand.h"
+
+/*
+ * Convert network-format internet address
+ * to base 256 d.d.d.d representation.
+ */
+char *
+inet_ntoa(in)
+	struct in_addr in;
+{
+	static const char fmt[] = "%u.%u.%u.%u";
+	static char ret[sizeof "255.255.255.255"];
+	unsigned char *src = (unsigned char *) &in;
+
+	sprintf(ret, fmt, src[0], src[1], src[2], src[3]);
+	return (ret);
+}
+
+/*
+ * Weak aliases for applications that use certain private entry points,
+ * and fail to include <arpa/inet.h>.
+ */
+#undef inet_ntoa
+__weak_reference(__inet_ntoa, inet_ntoa);
diff -ruN sys/boot/i386/pxe_ng/libstand/ioctl.c sys/boot/i386/pxe_ng/libstand/ioctl.c
--- sys/boot/i386/pxe_ng/libstand/ioctl.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/ioctl.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,88 @@
+/*	$NetBSD: ioctl.c,v 1.4 1994/10/30 21:48:24 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioctl.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+int
+ioctl(fd, cmd, arg)
+	int fd;
+	u_long cmd;
+	char *arg;
+{
+	struct open_file *f = &files[fd];
+
+	if ((unsigned)fd >= SOPEN_MAX || f->f_flags == 0) {
+		errno = EBADF;
+		return (-1);
+	}
+	if (f->f_flags & F_RAW) {
+		errno = (f->f_dev->dv_ioctl)(f, cmd, arg);
+		if (errno)
+			return (-1);
+		return (0);
+	}
+	errno = EIO;
+	return (-1);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/iodesc.h sys/boot/i386/pxe_ng/libstand/iodesc.h
--- sys/boot/i386/pxe_ng/libstand/iodesc.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/iodesc.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,52 @@
+/*	$NetBSD: iodesc.h,v 1.4 1995/09/23 03:31:50 gwr Exp $	*/
+
+/*
+ * Copyright (c) 1993 Adam Glass 
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef __SYS_LIBNETBOOT_IODESC_H
+#define __SYS_LIBNETBOOT_IODESC_H
+
+struct iodesc {
+	struct	in_addr destip;		/* dest. ip addr, net order */
+	struct	in_addr myip;		/* local ip addr, net order */
+	u_short	destport;		/* dest. port, net order */
+	u_short	myport;			/* local port, net order */
+	u_long	xid;			/* transaction identification */
+	u_char	myea[6];		/* my ethernet address */
+	struct netif *io_netif;
+};
+
+#endif /* __SYS_LIBNETBOOT_IODESC_H */
diff -ruN sys/boot/i386/pxe_ng/libstand/libstand.3 sys/boot/i386/pxe_ng/libstand/libstand.3
--- sys/boot/i386/pxe_ng/libstand/libstand.3	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/libstand.3	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,680 @@
+.\" Copyright (c) Michael Smith
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd August 6, 2004
+.Dt LIBSTAND 3
+.Os
+.Sh NAME
+.Nm libstand
+.Nd support library for standalone executables
+.Sh SYNOPSIS
+.In stand.h
+.Sh DESCRIPTION
+The
+.Nm
+library provides a set of supporting functions for standalone
+applications, mimicking where possible the standard
+.Bx
+programming
+environment.
+The following sections group these functions by kind.
+Unless specifically described here, see the corresponding section 3
+manpages for the given functions.
+.Sh STRING FUNCTIONS
+String functions are available as documented in
+.Xr string 3
+and
+.Xr bstring 3 .
+.Sh MEMORY ALLOCATION
+.Bl -hang -width 10n
+.It Xo
+.Ft "void *"
+.Fn malloc "size_t size"
+.Xc
+.Pp
+Allocate
+.Fa size
+bytes of memory from the heap using a best-fit algorithm.
+.It Xo
+.Ft void
+.Fn free "void *ptr"
+.Xc
+.Pp
+Free the allocated object at
+.Fa ptr .
+.It Xo
+.Ft void
+.Fn setheap "void *start" "void *limit"
+.Xc
+.Pp
+Initialise the heap.
+This function must be called before calling
+.Fn alloc
+for the first time.
+The region between
+.Fa start
+and
+.Fa limit
+will be used for the heap; attempting to allocate beyond this will result
+in a panic.
+.It Xo
+.Ft "char *"
+.Fn sbrk "int junk"
+.Xc
+.Pp
+Provides the behaviour of
+.Fn sbrk 0 ,
+i.e., returns the highest point that the heap has reached.
+This value can
+be used during testing to determine the actual heap usage.
+The
+.Fa junk
+argument is ignored.
+.El
+.Sh ENVIRONMENT
+A set of functions are provided for manipulating a flat variable space similar
+to the traditional shell-supported environment.
+Major enhancements are support
+for set/unset hook functions.
+.Bl -hang -width 10n
+.It Xo
+.Ft "char *"
+.Fn getenv "const char *name"
+.Xc
+.It Xo
+.Ft int
+.Fn setenv "const char *name" "const char *value" "int overwrite"
+.Xc
+.It Xo
+.Ft int
+.Fn putenv "const char *string"
+.Xc
+.It Xo
+.Ft int
+.Fn unsetenv "const char *name"
+.Xc
+.Pp
+These functions behave similarly to their standard library counterparts.
+.It Xo
+.Ft "struct env_var *"
+.Fn env_getenv "const char *name"
+.Xc
+.Pp
+Looks up a variable in the environment and returns its entire
+data structure.
+.It Xo
+.Ft int
+.Fn env_setenv "const char *name" "int flags" "const void *value" "ev_sethook_t sethook" "ev_unsethook_t unsethook"
+.Xc
+.Pp
+Creates a new or sets an existing environment variable called
+.Fa name .
+If creating a new variable, the
+.Fa sethook
+and
+.Fa unsethook
+arguments may be specified.
+.Pp
+The set hook is invoked whenever an attempt
+is made to set the variable, unless the EV_NOHOOK flag is set.
+Typically
+a set hook will validate the
+.Fa value
+argument, and then call
+.Fn env_setenv
+again with EV_NOHOOK set to actually save the value.
+The predefined function
+.Fn env_noset
+may be specified to refuse all attempts to set a variable.
+.Pp
+The unset hook is invoked when an attempt is made to unset a variable.
+If it
+returns zero, the variable will be unset.
+The predefined function
+.Fa env_nounset
+may be used to prevent a variable being unset.
+.El
+.Sh STANDARD LIBRARY SUPPORT
+.Bl -hang -width 10n
+.It Xo
+.Ft int
+.Fn getopt "int argc" "char * const *argv" "const char *optstring"
+.Xc
+.It Xo
+.Ft long
+.Fn strtol "const char *nptr" "char **endptr" "int base"
+.Xc
+.It Xo
+.Ft void
+.Fn srandom "unsigned long seed"
+.Xc
+.It Xo
+.Ft "unsigned long"
+.Fn random void
+.Xc
+.It Xo
+.Ft "char *"
+.Fn strerror "int error"
+.Xc
+.Pp
+Returns error messages for the subset of errno values supported by
+.Nm .
+.It Fn assert expression
+.Pp
+Requires
+.In assert.h .
+.It Xo
+.Ft int
+.Fn setjmp "jmp_buf env"
+.Xc
+.It Xo
+.Ft void
+.Fn longjmp "jmp_buf env" "int val"
+.Xc
+.Pp
+Defined as
+.Fn _setjmp
+and
+.Fn _longjmp
+respectively as there is no signal state to manipulate.
+Requires
+.In setjmp.h .
+.El
+.Sh CHARACTER I/O
+.Bl -hang -width 10n
+.It Xo
+.Ft void
+.Fn gets "char *buf"
+.Xc
+.Pp
+Read characters from the console into
+.Fa buf .
+All of the standard cautions apply to this function.
+.It Xo
+.Ft void
+.Fn ngets "char *buf" "int size"
+.Xc
+.Pp
+Read at most
+.Fa size
+- 1 characters from the console into
+.Fa buf .
+If
+.Fa size
+is less than 1, the function's behaviour is as for
+.Fn gets .
+.It Xo
+.Ft int
+.Fn fgetstr "char *buf" "int size" "int fd"
+.Xc
+.Pp
+Read a line of at most
+.Fa size
+characters into
+.Fa buf .
+Line terminating characters are stripped, and the buffer is always
+.Dv NUL
+terminated.
+Returns the number of characters in
+.Fa buf
+if successful, or -1 if a read error occurs.
+.It Xo
+.Ft int
+.Fn printf "const char *fmt" "..."
+.Xc
+.It Xo
+.Ft void
+.Fn vprintf "const char *fmt" "va_list ap"
+.Xc
+.It Xo
+.Ft int
+.Fn sprintf "char *buf" "const char *fmt" "..."
+.Xc
+.It Xo
+.Ft void
+.Fn vsprintf "char *buf" "const char *fmt" "va_list ap"
+.Xc
+.Pp
+The *printf functions implement a subset of the standard
+.Fn printf
+family functionality and some extensions.
+The following standard conversions
+are supported: c,d,n,o,p,s,u,x.
+The following modifiers are supported:
++,-,#,*,0,field width,precision,l.
+.Pp
+The
+.Li b
+conversion is provided to decode error registers.
+Its usage is:
+.Pp
+.Bd -ragged -offset indent
+printf(
+.Qq reg=%b\en ,
+regval,
+.Qq <base><arg>*
+);
+.Ed
+.Pp
+where <base> is the output expressed as a control character, e.g.\& \e10 gives
+octal, \e20 gives hex.
+Each <arg> is a sequence of characters, the first of
+which gives the bit number to be inspected (origin 1) and the next characters
+(up to a character less than 32) give the text to be displayed if the bit is set.
+Thus
+.Pp
+.Bd -ragged -offset indent
+printf(
+.Qq reg=%b\en ,
+3,
+.Qq \e10\e2BITTWO\e1BITONE\en
+);
+.Ed
+.Pp
+would give the output
+.Pp
+.Bd -ragged -offset indent
+reg=3<BITTWO,BITONE>
+.Ed
+.Pp
+The
+.Li D
+conversion provides a hexdump facility, e.g.
+.Pp
+.Bd -ragged -offset indent
+printf(
+.Qq %6D ,
+ptr,
+.Qq \&:
+); gives
+.Qq XX:XX:XX:XX:XX:XX
+.Ed
+.Bd -ragged -offset indent
+printf(
+.Qq %*D ,
+len,
+ptr,
+.Qq "\ "
+); gives
+.Qq XX XX XX ...
+.Ed
+.El
+.Sh CHARACTER TESTS AND CONVERSIONS
+.Bl -hang -width 10n
+.It Xo
+.Ft int
+.Fn isupper "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn islower "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn isspace "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn isdigit "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn isxdigit "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn isascii "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn isalpha "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn toupper "int c"
+.Xc
+.It Xo
+.Ft int
+.Fn tolower "int c"
+.Xc
+.El
+.Sh FILE I/O
+.Bl -hang -width 10n
+.It Xo
+.Ft int
+.Fn open "const char *path" "int flags"
+.Xc
+.Pp
+Similar to the behaviour as specified in
+.Xr open 2 ,
+except that file creation is not supported, so the mode parameter is not
+required.
+The
+.Fa flags
+argument may be one of O_RDONLY, O_WRONLY and O_RDWR (although no file systems
+currently support writing).
+.It Xo
+.Ft int
+.Fn close "int fd"
+.Xc
+.It Xo
+.Ft void
+.Fn closeall void
+.Xc
+.Pp
+Close all open files.
+.It Xo
+.Ft ssize_t
+.Fn read "int fd" "void *buf" "size_t len"
+.Xc
+.It Xo
+.Ft ssize_t
+.Fn write "int fd" "void *buf" "size_t len"
+.Xc
+.Pp
+(No file systems currently support writing.)
+.It Xo
+.Ft off_t
+.Fn lseek "int fd" "off_t offset" "int whence"
+.Xc
+.Pp
+Files being automatically uncompressed during reading cannot seek backwards
+from the current point.
+.It Xo
+.Ft int
+.Fn stat "const char *path" "struct stat *sb"
+.Xc
+.It Xo
+.Ft int
+.Fn fstat "int fd" "struct stat *sb"
+.Xc
+.Pp
+The
+.Fn stat
+and
+.Fn fstat
+functions only fill out the following fields in the
+.Fa sb
+structure: st_mode,st_nlink,st_uid,st_gid,st_size.
+The
+.Nm tftp
+file system cannot provide meaningful values for this call, and the
+.Nm cd9660
+file system always reports files having uid/gid of zero.
+.El
+.Sh PAGER
+The
+.Nm
+library supplies a simple internal pager to ease reading the output of large
+commands.
+.Bl -hang -width 10n
+.It Xo
+.Ft void
+.Fn pager_open
+.Xc
+.Pp
+Initialises the pager and tells it that the next line output will be the top of the
+display.
+The environment variable LINES is consulted to determine the number of
+lines to be displayed before pausing.
+.It Xo
+.Ft void
+.Fn pager_close void
+.Xc
+.Pp
+Closes the pager.
+.It Xo
+.Ft int
+.Fn pager_output "const char *lines"
+.Xc
+.Pp
+Sends the lines in the
+.Dv NUL Ns
+-terminated buffer at
+.Fa lines
+to the pager.
+Newline characters are counted in order to determine the number
+of lines being output (wrapped lines are not accounted for).
+The
+.Fn pager_output
+function will return zero when all of the lines have been output, or nonzero
+if the display was paused and the user elected to quit.
+.It Xo
+.Ft int
+.Fn pager_file "const char *fname"
+.Xc
+.Pp
+Attempts to open and display the file
+.Fa fname .
+Returns -1 on error, 0 at EOF, or 1 if the user elects to quit while reading.
+.El
+.Sh MISC
+.Bl -hang -width 10n
+.It Xo
+.Ft void
+.Fn twiddle void
+.Xc
+.Pp
+Successive calls emit the characters in the sequence |,/,-,\\ followed by a
+backspace in order to provide reassurance to the user.
+.El
+.Sh REQUIRED LOW-LEVEL SUPPORT
+The following resources are consumed by
+.Nm
+- stack, heap, console and devices.
+.Pp
+The stack must be established before
+.Nm
+functions can be invoked.
+Stack requirements vary depending on the functions
+and file systems used by the consumer and the support layer functions detailed
+below.
+.Pp
+The heap must be established before calling
+.Fn alloc
+or
+.Fn open
+by calling
+.Fn setheap .
+Heap usage will vary depending on the number of simultaneously open files,
+as well as client behaviour.
+Automatic decompression will allocate more
+than 64K of data per open file.
+.Pp
+Console access is performed via the
+.Fn getchar ,
+.Fn putchar
+and
+.Fn ischar
+functions detailed below.
+.Pp
+Device access is initiated via
+.Fn devopen
+and is performed through the
+.Fn dv_strategy ,
+.Fn dv_ioctl
+and
+.Fn dv_close
+functions in the device switch structure that
+.Fn devopen
+returns.
+.Pp
+The consumer must provide the following support functions:
+.Bl -hang -width 10n
+.It Xo
+.Ft int
+.Fn getchar void
+.Xc
+.Pp
+Return a character from the console, used by
+.Fn gets ,
+.Fn ngets
+and pager functions.
+.It Xo
+.Ft int
+.Fn ischar void
+.Xc
+.Pp
+Returns nonzero if a character is waiting from the console.
+.It Xo
+.Ft void
+.Fn putchar int
+.Xc
+.Pp
+Write a character to the console, used by
+.Fn gets ,
+.Fn ngets ,
+.Fn *printf ,
+.Fn panic
+and
+.Fn twiddle
+and thus by many other functions for debugging and informational output.
+.It Xo
+.Ft int
+.Fn devopen "struct open_file *of" "const char *name" "const char **file"
+.Xc
+.Pp
+Open the appropriate device for the file named in
+.Fa name ,
+returning in
+.Fa file
+a pointer to the remaining body of
+.Fa name
+which does not refer to the device.
+The
+.Va f_dev
+field in
+.Fa of
+will be set to point to the
+.Vt devsw
+structure for the opened device if successful.
+Device identifiers must
+always precede the path component, but may otherwise be arbitrarily formatted.
+Used by
+.Fn open
+and thus for all device-related I/O.
+.It Xo
+.Ft int
+.Fn devclose "struct open_file *of"
+.Xc
+.Pp
+Close the device allocated for
+.Fa of .
+The device driver itself will already have been called for the close; this call
+should clean up any allocation made by devopen only.
+.It Xo
+.Ft void
+.Fn panic "const char *msg" "..."
+.Xc
+.Pp
+Signal a fatal and unrecoverable error condition.
+The
+.Fa msg ...
+arguments are as for
+.Fn printf .
+.El
+.Sh INTERNAL FILE SYSTEMS
+Internal file systems are enabled by the consumer exporting the array
+.Vt struct fs_ops *file_system[] ,
+which should be initialised with pointers
+to
+.Vt struct fs_ops
+structures.
+The following file system handlers are supplied by
+.Nm ,
+the consumer may supply other file systems of their own:
+.Bl -hang -width ".Va cd9660_fsops"
+.It Va ufs_fsops
+The
+.Bx
+UFS.
+.It Va ext2fs_fsops
+Linux ext2fs file system.
+.It Va tftp_fsops
+File access via TFTP.
+.It Va nfs_fsops
+File access via NFS.
+.It Va cd9660_fsops
+ISO 9660 (CD-ROM) file system.
+.It Va gzipfs_fsops
+Stacked file system supporting gzipped files.
+When trying the gzipfs file system,
+.Nm
+appends
+.Li .gz
+to the end of the filename, and then tries to locate the file using the other
+file systems.
+Placement of this file system in the
+.Va file_system[]
+array determines whether gzipped files will be opened in preference to non-gzipped
+files.
+It is only possible to seek a gzipped file forwards, and
+.Fn stat
+and
+.Fn fstat
+on gzipped files will report an invalid length.
+.It Va bzipfs_fsops
+The same as
+.Va gzipfs_fsops ,
+but for
+.Xr bzip2 1 Ns -compressed
+files.
+.El
+.Pp
+The array of
+.Vt struct fs_ops
+pointers should be terminated with a NULL.
+.Sh DEVICES
+Devices are exported by the supporting code via the array
+.Vt struct devsw *devsw[]
+which is a NULL terminated array of pointers to device switch structures.
+.Sh HISTORY
+The
+.Nm
+library contains contributions from many sources, including:
+.Bl -bullet -compact
+.It
+.Nm libsa
+from
+.Nx
+.It
+.Nm libc
+and
+.Nm libkern
+from
+.Fx 3.0 .
+.It
+.Nm zalloc
+from
+.An Matthew Dillon Aq dillon@backplane.com
+.El
+.Pp
+The reorganisation and port to
+.Fx 3.0 ,
+the environment functions and this manpage were written by
+.An Mike Smith Aq msmith@FreeBSD.org .
+.Sh BUGS
+The lack of detailed memory usage data is unhelpful.
diff -ruN sys/boot/i386/pxe_ng/libstand/lseek.c sys/boot/i386/pxe_ng/libstand/lseek.c
--- sys/boot/i386/pxe_ng/libstand/lseek.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/lseek.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,142 @@
+/*	$NetBSD: lseek.c,v 1.4 1997/01/22 00:38:10 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)lseek.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+off_t
+lseek(int fd, off_t offset, int where)
+{
+    off_t bufpos, filepos, target;
+    struct open_file *f = &files[fd];
+
+    if ((unsigned)fd >= SOPEN_MAX || f->f_flags == 0) {
+	errno = EBADF;
+	return (-1);
+    }
+
+    if (f->f_flags & F_RAW) {
+	/*
+	 * On RAW devices, update internal offset.
+	 */
+	switch (where) {
+	case SEEK_SET:
+	    f->f_offset = offset;
+	    break;
+	case SEEK_CUR:
+	    f->f_offset += offset;
+	    break;
+	case SEEK_END:
+	default:
+	    errno = EOFFSET;
+	    return (-1);
+	}
+	return (f->f_offset);
+    }
+
+    /*
+     * If there is some unconsumed data in the readahead buffer and it
+     * contains the desired offset, simply adjust the buffer offset and
+     * length.  We don't bother with SEEK_END here, since the code to
+     * handle it would fail in the same cases where the non-readahead
+     * code fails (namely, for streams which cannot seek backward and whose
+     * size isn't known in advance).
+     */
+    if (f->f_ralen != 0 && where != SEEK_END) {
+	if ((filepos = (f->f_ops->fo_seek)(f, (off_t)0, SEEK_CUR)) == -1)
+	    return (-1);
+	bufpos = filepos - f->f_ralen;
+	switch (where) {
+	case SEEK_SET:
+	    target = offset;
+	    break;
+	case SEEK_CUR:
+	    target = bufpos + offset;
+	    break;
+	default:
+	    errno = EINVAL;
+	    return (-1);
+	}
+	if (bufpos <= target && target < filepos) {
+	    f->f_raoffset += target - bufpos;
+	    f->f_ralen -= target - bufpos;
+	    return (target);
+	}
+    }
+
+    /*
+     * If this is a relative seek, we need to correct the offset for
+     * bytes that we have already read but the caller doesn't know
+     * about.
+     */
+    if (where == SEEK_CUR)
+	offset -= f->f_ralen;
+
+    /* 
+     * Invalidate the readahead buffer.
+     */
+    f->f_ralen = 0;
+
+    return (f->f_ops->fo_seek)(f, offset, where);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/net.c sys/boot/i386/pxe_ng/libstand/net.c
--- sys/boot/i386/pxe_ng/libstand/net.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/net.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,289 @@
+/*	$NetBSD: net.c,v 1.20 1997/12/26 22:41:30 scottr Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: net.c,v 1.9 93/08/06 19:32:15 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/socket.h>
+
+#include <string.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+#include <netinet/in_systm.h>
+
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+
+#include "stand.h"
+#include "net.h"
+
+/*
+ * Send a packet and wait for a reply, with exponential backoff.
+ *
+ * The send routine must return the actual number of bytes written,
+ * or -1 on error.
+ *
+ * The receive routine can indicate success by returning the number of
+ * bytes read; it can return 0 to indicate EOF; it can return -1 with a
+ * non-zero errno to indicate failure; finally, it can return -1 with a
+ * zero errno to indicate it isn't done yet.
+ */
+ssize_t
+sendrecv(d, sproc, sbuf, ssize, rproc, rbuf, rsize)
+	struct iodesc *d;
+	ssize_t (*sproc)(struct iodesc *, void *, size_t);
+	void *sbuf;
+	size_t ssize;
+	ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t);
+	void *rbuf;
+	size_t rsize;
+{
+	ssize_t cc;
+	time_t t, tmo, tlast;
+	long tleft;
+
+#ifdef NET_DEBUG
+	if (debug)
+		printf("sendrecv: called\n");
+#endif
+
+	tmo = MINTMO;
+	tlast = tleft = 0;
+	t = getsecs();
+	for (;;) {
+		if (tleft <= 0) {
+			if (tmo >= MAXTMO) {
+				errno = ETIMEDOUT;
+				return -1;
+			}
+			cc = (*sproc)(d, sbuf, ssize);
+			if (cc != -1 && cc < ssize)
+				panic("sendrecv: short write! (%zd < %zd)",
+				    cc, ssize);
+
+			tleft = tmo;
+			tmo <<= 1;
+			if (tmo > MAXTMO)
+				tmo = MAXTMO;
+
+			if (cc == -1) {
+				/* Error on transmit; wait before retrying */
+				while ((getsecs() - t) < tmo);
+				tleft = 0;
+				continue;
+			}
+
+			tlast = t;
+		}
+
+		/* Try to get a packet and process it. */
+		cc = (*rproc)(d, rbuf, rsize, tleft);
+		/* Return on data, EOF or real error. */
+		if (cc != -1 || errno != 0)
+			return (cc);
+
+		/* Timed out or didn't get the packet we're waiting for */
+		t = getsecs();
+		tleft -= t - tlast;
+		tlast = t;
+	}
+}
+
+/*
+ * Like inet_addr() in the C library, but we only accept base-10.
+ * Return values are in network order.
+ */
+n_long
+inet_addr(cp)
+	char *cp;
+{
+	u_long val;
+	int n;
+	char c;
+	u_int parts[4];
+	u_int *pp = parts;
+
+	for (;;) {
+		/*
+		 * Collect number up to ``.''.
+		 * Values are specified as for C:
+		 * 0x=hex, 0=octal, other=decimal.
+		 */
+		val = 0;
+		while ((c = *cp) != '\0') {
+			if (c >= '0' && c <= '9') {
+				val = (val * 10) + (c - '0');
+				cp++;
+				continue;
+			}
+			break;
+		}
+		if (*cp == '.') {
+			/*
+			 * Internet format:
+			 *	a.b.c.d
+			 *	a.b.c	(with c treated as 16-bits)
+			 *	a.b	(with b treated as 24 bits)
+			 */
+			if (pp >= parts + 3 || val > 0xff)
+				goto bad;
+			*pp++ = val, cp++;
+		} else
+			break;
+	}
+	/*
+	 * Check for trailing characters.
+	 */
+	if (*cp != '\0')
+		goto bad;
+
+	/*
+	 * Concoct the address according to
+	 * the number of parts specified.
+	 */
+	n = pp - parts + 1;
+	switch (n) {
+
+	case 1:				/* a -- 32 bits */
+		break;
+
+	case 2:				/* a.b -- 8.24 bits */
+		if (val > 0xffffff)
+			goto bad;
+		val |= parts[0] << 24;
+		break;
+
+	case 3:				/* a.b.c -- 8.8.16 bits */
+		if (val > 0xffff)
+			goto bad;
+		val |= (parts[0] << 24) | (parts[1] << 16);
+		break;
+
+	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
+		if (val > 0xff)
+			goto bad;
+		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
+		break;
+	}
+
+	return (htonl(val));
+ bad:
+	return (htonl(INADDR_NONE));
+}
+
+char *
+inet_ntoa(ia)
+	struct in_addr ia;
+{
+	return (intoa(ia.s_addr));
+}
+
+/* Similar to inet_ntoa() */
+char *
+intoa(addr)
+	n_long addr;
+{
+	char *cp;
+	u_int byte;
+	int n;
+	static char buf[17];	/* strlen(".255.255.255.255") + 1 */
+
+	addr = ntohl(addr);
+	cp = &buf[sizeof buf];
+	*--cp = '\0';
+
+	n = 4;
+	do {
+		byte = addr & 0xff;
+		*--cp = byte % 10 + '0';
+		byte /= 10;
+		if (byte > 0) {
+			*--cp = byte % 10 + '0';
+			byte /= 10;
+			if (byte > 0)
+				*--cp = byte + '0';
+		}
+		*--cp = '.';
+		addr >>= 8;
+	} while (--n > 0);
+
+	return (cp+1);
+}
+
+static char *
+number(s, n)
+	char *s;
+	int *n;
+{
+	for (*n = 0; isdigit(*s); s++)
+		*n = (*n * 10) + *s - '0';
+	return s;
+}
+
+n_long
+ip_convertaddr(p)
+	char *p;
+{
+#define IP_ANYADDR	0
+	n_long addr = 0, n;
+
+	if (p == (char *)0 || *p == '\0')
+		return IP_ANYADDR;
+	p = number(p, &n);
+	addr |= (n << 24) & 0xff000000;
+	if (*p == '\0' || *p++ != '.')
+		return IP_ANYADDR;
+	p = number(p, &n);
+	addr |= (n << 16) & 0xff0000;
+	if (*p == '\0' || *p++ != '.')
+		return IP_ANYADDR;
+	p = number(p, &n);
+	addr |= (n << 8) & 0xff00;
+	if (*p == '\0' || *p++ != '.')
+		return IP_ANYADDR;
+	p = number(p, &n);
+	addr |= n & 0xff;
+	if (*p != '\0')
+		return IP_ANYADDR;
+
+	return htonl(addr);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/net.h sys/boot/i386/pxe_ng/libstand/net.h
--- sys/boot/i386/pxe_ng/libstand/net.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/net.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,121 @@
+/*	$NetBSD: net.h,v 1.10 1995/10/20 00:46:30 cgd Exp $	*/
+
+/*
+ * Copyright (c) 1993 Adam Glass 
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _KERNEL	/* XXX - see <netinet/in.h> */
+#undef __IPADDR
+#define __IPADDR(x)	htonl((u_int32_t)(x))
+#endif
+
+#include "iodesc.h"
+
+#define BA { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }
+
+/* Returns true if n_long's on the same net */
+#define	SAMENET(a1, a2, m) ((a1.s_addr & m) == (a2.s_addr & m))
+
+#define MACPY(s, d) bcopy((char *)s, (char *)d, 6)
+
+#define MAXTMO 20	/* seconds */
+#define MINTMO 2	/* seconds */
+
+#define FNAME_SIZE 128
+#define	IFNAME_SIZE 16
+#define RECV_SIZE 1536	/* XXX delete this */
+
+/*
+ * How much room to leave for headers:
+ *  14: struct ether_header
+ *  20: struct ip
+ *   8: struct udphdr
+ * That's 42 but let's pad it out to 48 bytes.
+ */
+#define ETHER_SIZE 14
+#define	HEADER_SIZE 48
+
+extern	u_char bcea[6];
+extern	char rootpath[FNAME_SIZE];
+extern	char bootfile[FNAME_SIZE];
+extern	char hostname[FNAME_SIZE];
+extern	int hostnamelen;
+extern	char domainname[FNAME_SIZE];
+extern	int domainnamelen;
+extern	char ifname[IFNAME_SIZE];
+
+/* All of these are in network order. */
+extern	struct in_addr myip;
+extern	struct in_addr rootip;
+extern	struct in_addr swapip;
+extern	struct in_addr gateip;
+extern	struct in_addr nameip;
+extern	n_long netmask;
+
+extern	int debug;			/* defined in the machdep sources */
+
+extern struct iodesc sockets[SOPEN_MAX];
+
+/* ARP/RevARP functions: */
+u_char	*arpwhohas(struct iodesc *, struct in_addr);
+void	arp_reply(struct iodesc *, void *);
+int	rarp_getipaddress(int);
+
+/* Link functions: */
+ssize_t sendether(struct iodesc *d, void *pkt, size_t len,
+			u_char *dea, int etype);
+ssize_t readether(struct iodesc *d, void *pkt, size_t len,
+			time_t tleft, u_int16_t *etype);
+
+ssize_t	sendudp(struct iodesc *, void *, size_t);
+ssize_t	readudp(struct iodesc *, void *, size_t, time_t);
+ssize_t	sendrecv(struct iodesc *,
+		      ssize_t (*)(struct iodesc *, void *, size_t),
+			void *, size_t,
+		        ssize_t (*)(struct iodesc *, void *, size_t, time_t),
+			void *, size_t);
+
+/* bootp/DHCP */
+void	bootp(int, int);
+
+/* Utilities: */
+char	*ether_sprintf(u_char *);
+int	in_cksum(void *, int);
+char	*inet_ntoa(struct in_addr);
+char	*intoa(n_long);		/* similar to inet_ntoa */
+n_long	inet_addr(char *);
+
+/* Machine-dependent functions: */
+time_t	getsecs(void);
diff -ruN sys/boot/i386/pxe_ng/libstand/netif.c sys/boot/i386/pxe_ng/libstand/netif.c
--- sys/boot/i386/pxe_ng/libstand/netif.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/netif.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,335 @@
+/*	$NetBSD: netif.c,v 1.10 1997/09/06 13:57:14 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1993 Adam Glass
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Adam Glass.
+ * 4. The name of the Author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Adam Glass ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/cdefs.h>
+#include <sys/mount.h>
+#include <string.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+
+struct iodesc sockets[SOPEN_MAX];
+#ifdef NETIF_DEBUG
+int netif_debug = 0;
+#endif
+
+/*
+ * netif_init:
+ *
+ * initialize the generic network interface layer
+ */
+
+void
+netif_init()
+{
+	struct netif_driver *drv;
+	int d, i;
+    
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("netif_init: called\n");
+#endif
+	for (d = 0; netif_drivers[d]; d++) {
+		drv = netif_drivers[d];
+		for (i = 0; i < drv->netif_nifs; i++)
+			drv->netif_ifs[i].dif_used = 0;
+	}
+}
+
+int
+netif_match(nif, machdep_hint)
+	struct netif *nif;
+	void *machdep_hint;
+{
+	struct netif_driver *drv = nif->nif_driver;
+
+#if 0
+	if (netif_debug)
+		printf("%s%d: netif_match (%d)\n", drv->netif_bname,
+		    nif->nif_unit, nif->nif_sel);
+#endif
+	return drv->netif_match(nif, machdep_hint);
+}
+
+struct netif *
+netif_select(machdep_hint)
+	void *machdep_hint;
+{
+	int d, u, unit_done, s;
+	struct netif_driver *drv;
+	struct netif cur_if;
+	static struct netif best_if;
+	int best_val;
+	int val;
+
+	best_val = 0;
+	best_if.nif_driver = NULL;
+
+	for (d = 0; netif_drivers[d] != NULL; d++) {
+		cur_if.nif_driver = netif_drivers[d];
+		drv = cur_if.nif_driver;
+
+		for (u = 0; u < drv->netif_nifs; u++) {
+			cur_if.nif_unit = u;
+			unit_done = 0;
+		
+#ifdef NETIF_DEBUG
+			if (netif_debug)
+				printf("\t%s%d:", drv->netif_bname,
+				    cur_if.nif_unit);
+#endif
+
+			for (s = 0; s < drv->netif_ifs[u].dif_nsel; s++) {
+				cur_if.nif_sel = s;
+
+				if (drv->netif_ifs[u].dif_used & (1 << s)) {
+#ifdef NETIF_DEBUG
+					if (netif_debug)
+						printf(" [%d used]", s);
+#endif
+					continue;
+				}
+
+				val = netif_match(&cur_if, machdep_hint);
+#ifdef NETIF_DEBUG
+				if (netif_debug)
+					printf(" [%d -> %d]", s, val);
+#endif
+				if (val > best_val) {
+					best_val = val;
+					best_if = cur_if;
+				}
+			}
+#ifdef NETIF_DEBUG
+			if (netif_debug)
+				printf("\n");
+#endif
+		}
+	}
+
+	if (best_if.nif_driver == NULL)
+		return NULL;
+
+	best_if.nif_driver->
+	    netif_ifs[best_if.nif_unit].dif_used |= (1 << best_if.nif_sel);
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("netif_select: %s%d(%d) wins\n",
+			best_if.nif_driver->netif_bname,
+			best_if.nif_unit, best_if.nif_sel);
+#endif
+	return &best_if;
+}
+
+int
+netif_probe(nif, machdep_hint)
+	struct netif *nif;
+	void *machdep_hint;
+{
+	struct netif_driver *drv = nif->nif_driver;
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_probe\n", drv->netif_bname, nif->nif_unit);
+#endif
+	return drv->netif_probe(nif, machdep_hint);
+}
+
+void
+netif_attach(nif, desc, machdep_hint)
+	struct netif *nif;
+	struct iodesc *desc;
+	void *machdep_hint;
+{
+	struct netif_driver *drv = nif->nif_driver;
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_attach\n", drv->netif_bname, nif->nif_unit);
+#endif
+	desc->io_netif = nif; 
+#ifdef PARANOID
+	if (drv->netif_init == NULL)
+		panic("%s%d: no netif_init support\n", drv->netif_bname,
+		    nif->nif_unit);
+#endif
+	drv->netif_init(desc, machdep_hint);
+	bzero(drv->netif_ifs[nif->nif_unit].dif_stats, 
+	    sizeof(struct netif_stats));
+}
+
+void
+netif_detach(nif)
+	struct netif *nif;
+{
+	struct netif_driver *drv = nif->nif_driver;
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_detach\n", drv->netif_bname, nif->nif_unit);
+#endif
+#ifdef PARANOID
+	if (drv->netif_end == NULL)
+		panic("%s%d: no netif_end support\n", drv->netif_bname,
+		    nif->nif_unit);
+#endif
+	drv->netif_end(nif);
+}
+
+ssize_t
+netif_get(desc, pkt, len, timo)
+	struct iodesc *desc;
+	void *pkt;
+	size_t len;
+	time_t timo;
+{
+#ifdef NETIF_DEBUG
+	struct netif *nif = desc->io_netif;
+#endif
+	struct netif_driver *drv = desc->io_netif->nif_driver;
+	ssize_t rv;
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_get\n", drv->netif_bname, nif->nif_unit);
+#endif
+#ifdef PARANOID
+	if (drv->netif_get == NULL)
+		panic("%s%d: no netif_get support\n", drv->netif_bname,
+		    nif->nif_unit);
+#endif
+	rv = drv->netif_get(desc, pkt, len, timo);
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_get returning %d\n", drv->netif_bname,
+		    nif->nif_unit, (int)rv);
+#endif
+	return rv;
+}
+
+ssize_t
+netif_put(desc, pkt, len)
+	struct iodesc *desc;
+	void *pkt;
+	size_t len;
+{
+#ifdef NETIF_DEBUG
+	struct netif *nif = desc->io_netif;
+#endif
+	struct netif_driver *drv = desc->io_netif->nif_driver;
+	ssize_t rv;
+
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_put\n", drv->netif_bname, nif->nif_unit);
+#endif
+#ifdef PARANOID
+	if (drv->netif_put == NULL)
+		panic("%s%d: no netif_put support\n", drv->netif_bname,
+		    nif->nif_unit);
+#endif
+	rv = drv->netif_put(desc, pkt, len);
+#ifdef NETIF_DEBUG
+	if (netif_debug)
+		printf("%s%d: netif_put returning %d\n", drv->netif_bname,
+		    nif->nif_unit, (int)rv);
+#endif
+	return rv;
+}
+
+struct iodesc *
+socktodesc(sock)
+	int sock;
+{
+	if (sock >= SOPEN_MAX) {
+		errno = EBADF;
+		return (NULL);
+	}
+	return (&sockets[sock]);
+}
+
+int
+netif_open(machdep_hint)
+	void *machdep_hint;
+{
+	int fd;
+	struct iodesc *s;
+	struct netif *nif;
+	
+	/* find a free socket */
+	for (fd = 0, s = sockets; fd < SOPEN_MAX; fd++, s++)
+		if (s->io_netif == (struct netif *)0)
+			goto fnd;
+	errno = EMFILE;
+	return (-1);
+
+fnd:
+	bzero(s, sizeof(*s));
+	netif_init();
+	nif = netif_select(machdep_hint);
+	if (!nif) 
+		panic("netboot: no interfaces left untried");
+	if (netif_probe(nif, machdep_hint)) {
+		printf("netboot: couldn't probe %s%d\n",
+		    nif->nif_driver->netif_bname, nif->nif_unit);
+		errno = EINVAL;
+		return(-1);
+	}
+	netif_attach(nif, s, machdep_hint);
+
+	return(fd);
+}
+
+int
+netif_close(sock)
+	int sock;
+{
+	if (sock >= SOPEN_MAX) {
+		errno = EBADF;
+		return(-1);
+	}
+	netif_detach(sockets[sock].io_netif);
+	sockets[sock].io_netif = (struct netif *)0;
+
+	return(0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/netif.h sys/boot/i386/pxe_ng/libstand/netif.h
--- sys/boot/i386/pxe_ng/libstand/netif.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/netif.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,67 @@
+/*	$NetBSD: netif.h,v 1.4 1995/09/14 23:45:30 pk Exp $	*/
+
+/* $FreeBSD$ */
+
+#ifndef __SYS_LIBNETBOOT_NETIF_H
+#define __SYS_LIBNETBOOT_NETIF_H
+#include "iodesc.h"
+
+#define NENTS(x)	sizeof(x)/sizeof(x[0])
+
+struct netif_driver {
+	const	char *netif_bname;
+	int	(*netif_match)(struct netif *, void *);
+	int	(*netif_probe)(struct netif *, void *);
+	void	(*netif_init)(struct iodesc *, void *);
+	int	(*netif_get)(struct iodesc *, void *, size_t, time_t);
+	int	(*netif_put)(struct iodesc *, void *, size_t);
+	void	(*netif_end)(struct netif *);
+	struct	netif_dif *netif_ifs;
+	int	netif_nifs;
+};
+
+struct netif_dif {
+	int		dif_unit;
+	int		dif_nsel;
+	struct netif_stats *dif_stats;
+	void		*dif_private;
+	/* the following fields are used internally by the netif layer */
+	u_long		dif_used;
+};
+
+struct netif_stats {
+	int	collisions;
+	int	collision_error;
+	int	missed;
+	int	sent;
+	int	received;
+	int	deferred;
+	int	overflow;
+};
+
+struct netif {
+	struct netif_driver	*nif_driver;
+	int			nif_unit;
+	int			nif_sel;
+	void			*nif_devdata;
+};
+
+extern struct netif_driver	*netif_drivers[];	/* machdep */
+extern int			n_netif_drivers;
+
+extern int			netif_debug;
+
+void		netif_init(void);
+struct netif	*netif_select(void *);
+int		netif_probe(struct netif *, void *);
+void		netif_attach(struct netif *, struct iodesc *, void *);
+void		netif_detach(struct netif *);
+ssize_t		netif_get(struct iodesc *, void *, size_t, time_t);
+ssize_t		netif_put(struct iodesc *, void *, size_t);
+
+int		netif_open(void *);
+int		netif_close(int);
+
+struct iodesc	*socktodesc(int);
+	
+#endif /* __SYS_LIBNETBOOT_NETIF_H */
diff -ruN sys/boot/i386/pxe_ng/libstand/nfs.c sys/boot/i386/pxe_ng/libstand/nfs.c
--- sys/boot/i386/pxe_ng/libstand/nfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/nfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,768 @@
+/*	$NetBSD: nfs.c,v 1.2 1998/01/24 12:43:09 drochner Exp $	*/
+
+/*-
+ *  Copyright (c) 1993 John Brezak
+ *  All rights reserved.
+ * 
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <string.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include "rpcv2.h"
+#include "nfsv2.h"
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+#include "rpc.h"
+
+#define NFS_DEBUGxx
+
+/* Define our own NFS attributes without NQNFS stuff. */
+struct nfsv2_fattrs {
+	n_long	fa_type;
+	n_long	fa_mode;
+	n_long	fa_nlink;
+	n_long	fa_uid;
+	n_long	fa_gid;
+	n_long	fa_size;
+	n_long	fa_blocksize;
+	n_long	fa_rdev;
+	n_long	fa_blocks;
+	n_long	fa_fsid;
+	n_long	fa_fileid;
+	struct nfsv2_time fa_atime;
+	struct nfsv2_time fa_mtime;
+	struct nfsv2_time fa_ctime;
+};
+
+
+struct nfs_read_args {
+	u_char	fh[NFS_FHSIZE];
+	n_long	off;
+	n_long	len;
+	n_long	xxx;			/* XXX what's this for? */
+};
+
+/* Data part of nfs rpc reply (also the largest thing we receive) */
+#define NFSREAD_SIZE 1024
+struct nfs_read_repl {
+	n_long	errno;
+	struct	nfsv2_fattrs fa;
+	n_long	count;
+	u_char	data[NFSREAD_SIZE];
+};
+
+#ifndef NFS_NOSYMLINK
+struct nfs_readlnk_repl {
+	n_long	errno;
+	n_long	len;
+	char	path[NFS_MAXPATHLEN];
+};
+#endif
+
+struct nfs_readdir_args {
+	u_char	fh[NFS_FHSIZE];
+	n_long	cookie;
+	n_long	count;
+};
+
+struct nfs_readdir_data {
+	n_long	fileid;
+	n_long	len;
+	char	name[0];
+};
+
+struct nfs_readdir_off {
+	n_long	cookie;
+	n_long	follows;
+};
+
+struct nfs_iodesc {
+	struct	iodesc	*iodesc;
+	off_t	off;
+	u_char	fh[NFS_FHSIZE];
+	struct nfsv2_fattrs fa;	/* all in network order */
+};
+
+/*
+ * XXX interactions with tftp? See nfswrapper.c for a confusing
+ *     issue.
+ */
+int		nfs_open(const char *path, struct open_file *f);
+static int	nfs_close(struct open_file *f);
+static int	nfs_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static int	nfs_write(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	nfs_seek(struct open_file *f, off_t offset, int where);
+static int	nfs_stat(struct open_file *f, struct stat *sb);
+static int	nfs_readdir(struct open_file *f, struct dirent *d);
+
+struct	nfs_iodesc nfs_root_node;
+
+struct fs_ops nfs_fsops = {
+	"nfs",
+	nfs_open,
+	nfs_close,
+	nfs_read,
+	nfs_write,
+	nfs_seek,
+	nfs_stat,
+	nfs_readdir
+};
+
+/*
+ * Fetch the root file handle (call mount daemon)
+ * Return zero or error number.
+ */
+int
+nfs_getrootfh(d, path, fhp)
+	struct iodesc *d;
+	char *path;
+	u_char *fhp;
+{
+	int len;
+	struct args {
+		n_long	len;
+		char	path[FNAME_SIZE];
+	} *args;
+	struct repl {
+		n_long	errno;
+		u_char	fh[NFS_FHSIZE];
+	} *repl;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct args d;
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct repl d;
+	} rdata;
+	size_t cc;
+	
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("nfs_getrootfh: %s\n", path);
+#endif
+
+	args = &sdata.d;
+	repl = &rdata.d;
+
+	bzero(args, sizeof(*args));
+	len = strlen(path);
+	if (len > sizeof(args->path))
+		len = sizeof(args->path);
+	args->len = htonl(len);
+	bcopy(path, args->path, len);
+	len = 4 + roundup(len, 4);
+
+	cc = rpc_call(d, RPCPROG_MNT, RPCMNT_VER1, RPCMNT_MOUNT,
+	    args, len, repl, sizeof(*repl));
+	if (cc == -1) {
+		/* errno was set by rpc_call */
+		return (errno);
+	}
+	if (cc < 4)
+		return (EBADRPC);
+	if (repl->errno)
+		return (ntohl(repl->errno));
+	bcopy(repl->fh, fhp, sizeof(repl->fh));
+	return (0);
+}
+
+/*
+ * Lookup a file.  Store handle and attributes.
+ * Return zero or error number.
+ */
+int
+nfs_lookupfh(d, name, newfd)
+	struct nfs_iodesc *d;
+	const char *name;
+	struct nfs_iodesc *newfd;
+{
+	int len, rlen;
+	struct args {
+		u_char	fh[NFS_FHSIZE];
+		n_long	len;
+		char	name[FNAME_SIZE];
+	} *args;
+	struct repl {
+		n_long	errno;
+		u_char	fh[NFS_FHSIZE];
+		struct	nfsv2_fattrs fa;
+	} *repl;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct args d;
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct repl d;
+	} rdata;
+	ssize_t cc;
+	
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("lookupfh: called\n");
+#endif
+
+	args = &sdata.d;
+	repl = &rdata.d;
+
+	bzero(args, sizeof(*args));
+	bcopy(d->fh, args->fh, sizeof(args->fh));
+	len = strlen(name);
+	if (len > sizeof(args->name))
+		len = sizeof(args->name);
+	bcopy(name, args->name, len);
+	args->len = htonl(len);
+	len = 4 + roundup(len, 4);
+	len += NFS_FHSIZE;
+
+	rlen = sizeof(*repl);
+
+	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_LOOKUP,
+	    args, len, repl, rlen);
+	if (cc == -1)
+		return (errno);		/* XXX - from rpc_call */
+	if (cc < 4)
+		return (EIO);
+	if (repl->errno) {
+		/* saerrno.h now matches NFS error numbers. */
+		return (ntohl(repl->errno));
+	}
+	bcopy( repl->fh, &newfd->fh, sizeof(newfd->fh));
+	bcopy(&repl->fa, &newfd->fa, sizeof(newfd->fa));
+	return (0);
+}
+
+#ifndef NFS_NOSYMLINK
+/*
+ * Get the destination of a symbolic link.
+ */
+int
+nfs_readlink(d, buf)
+	struct nfs_iodesc *d;
+	char *buf;
+{
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		u_char fh[NFS_FHSIZE];
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct nfs_readlnk_repl d;
+	} rdata;
+	ssize_t cc;
+
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("readlink: called\n");
+#endif
+
+	bcopy(d->fh, sdata.fh, NFS_FHSIZE);
+	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_READLINK,
+		      sdata.fh, NFS_FHSIZE,
+		      &rdata.d, sizeof(rdata.d));
+	if (cc == -1)
+		return (errno);
+
+	if (cc < 4)
+		return (EIO);
+	
+	if (rdata.d.errno)
+		return (ntohl(rdata.d.errno));
+
+	rdata.d.len = ntohl(rdata.d.len);
+	if (rdata.d.len > NFS_MAXPATHLEN)
+		return (ENAMETOOLONG);
+
+	bcopy(rdata.d.path, buf, rdata.d.len);
+	buf[rdata.d.len] = 0;
+	return (0);
+}
+#endif
+
+/*
+ * Read data from a file.
+ * Return transfer count or -1 (and set errno)
+ */
+ssize_t
+nfs_readdata(d, off, addr, len)
+	struct nfs_iodesc *d;
+	off_t off;
+	void *addr;
+	size_t len;
+{
+	struct nfs_read_args *args;
+	struct nfs_read_repl *repl;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct nfs_read_args d;
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct nfs_read_repl d;
+	} rdata;
+	size_t cc;
+	long x;
+	int hlen, rlen;
+
+	args = &sdata.d;
+	repl = &rdata.d;
+
+	bcopy(d->fh, args->fh, NFS_FHSIZE);
+	args->off = htonl((n_long)off);
+	if (len > NFSREAD_SIZE)
+		len = NFSREAD_SIZE;
+	args->len = htonl((n_long)len);
+	args->xxx = htonl((n_long)0);
+	hlen = sizeof(*repl) - NFSREAD_SIZE;
+
+	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_READ,
+	    args, sizeof(*args),
+	    repl, sizeof(*repl));
+	if (cc == -1) {
+		/* errno was already set by rpc_call */
+		return (-1);
+	}
+	if (cc < hlen) {
+		errno = EBADRPC;
+		return (-1);
+	}
+	if (repl->errno) {
+		errno = ntohl(repl->errno);
+		return (-1);
+	}
+	rlen = cc - hlen;
+	x = ntohl(repl->count);
+	if (rlen < x) {
+		printf("nfsread: short packet, %d < %ld\n", rlen, x);
+		errno = EBADRPC;
+		return(-1);
+	}
+	bcopy(repl->data, addr, x);
+	return (x);
+}
+
+/*
+ * Open a file.
+ * return zero or error number
+ */
+int
+nfs_open(upath, f)
+	const char *upath;
+	struct open_file *f;
+{
+	struct iodesc *desc;
+	struct nfs_iodesc *currfd;
+	char buf[2 * NFS_FHSIZE + 3];
+	u_char *fh;
+	char *cp;
+	int i;
+#ifndef NFS_NOSYMLINK
+	struct nfs_iodesc *newfd;
+	struct nfsv2_fattrs *fa;
+	char *ncp;
+	int c;
+	char namebuf[NFS_MAXPATHLEN + 1];
+	char linkbuf[NFS_MAXPATHLEN + 1];
+	int nlinks = 0;
+#endif
+	int error;
+	char *path;
+
+#ifdef NFS_DEBUG
+ 	if (debug)
+ 	    printf("nfs_open: %s (rootpath=%s)\n", path, rootpath);
+#endif
+	if (!rootpath[0]) {
+		printf("no rootpath, no nfs\n");
+		return (ENXIO);
+	}
+
+#ifndef __i386__
+	if (strcmp(f->f_dev->dv_name, "net") != 0)
+		return(EINVAL);
+#endif
+
+	if (!(desc = socktodesc(*(int *)(f->f_devdata))))
+		return(EINVAL);
+
+	/* Bind to a reserved port. */
+	desc->myport = htons(--rpc_port);
+	desc->destip = rootip;
+	if ((error = nfs_getrootfh(desc, rootpath, nfs_root_node.fh)))
+		return (error);
+	nfs_root_node.iodesc = desc;
+
+	fh = &nfs_root_node.fh[0];
+	buf[0] = 'X';
+	cp = &buf[1];
+	for (i = 0; i < NFS_FHSIZE; i++, cp += 2)
+		sprintf(cp, "%02x", fh[i]);
+	sprintf(cp, "X");
+	setenv("boot.nfsroot.server", inet_ntoa(rootip), 1);
+	setenv("boot.nfsroot.path", rootpath, 1);
+	setenv("boot.nfsroot.nfshandle", buf, 1);
+
+#ifndef NFS_NOSYMLINK
+	/* Fake up attributes for the root dir. */
+	fa = &nfs_root_node.fa;
+	fa->fa_type  = htonl(NFDIR);
+	fa->fa_mode  = htonl(0755);
+	fa->fa_nlink = htonl(2);
+
+	currfd = &nfs_root_node;
+	newfd = 0;
+
+	cp = path = strdup(upath);
+	if (path == NULL) {
+	    error = ENOMEM;
+	    goto out;
+	}
+	while (*cp) {
+		/*
+		 * Remove extra separators
+		 */
+		while (*cp == '/')
+			cp++;
+
+		if (*cp == '\0')
+			break;
+		/*
+		 * Check that current node is a directory.
+		 */
+		if (currfd->fa.fa_type != htonl(NFDIR)) {
+			error = ENOTDIR;
+			goto out;
+		}
+		
+		/* allocate file system specific data structure */
+		newfd = malloc(sizeof(*newfd));
+		newfd->iodesc = currfd->iodesc;
+		newfd->off = 0;
+	
+		/*
+		 * Get next component of path name.
+		 */
+		{
+			int len = 0;
+			
+			ncp = cp;
+			while ((c = *cp) != '\0' && c != '/') {
+				if (++len > NFS_MAXNAMLEN) {
+					error = ENOENT;
+					goto out;
+				}
+				cp++;
+			}
+			*cp = '\0';
+		}
+		
+		/* lookup a file handle */
+		error = nfs_lookupfh(currfd, ncp, newfd);
+		*cp = c;
+		if (error)
+			goto out;
+		
+		/*
+		 * Check for symbolic link
+		 */
+		if (newfd->fa.fa_type == htonl(NFLNK)) {
+			int link_len, len;
+			
+			error = nfs_readlink(newfd, linkbuf);
+			if (error)
+				goto out;
+
+			link_len = strlen(linkbuf);
+			len = strlen(cp);
+
+			if (link_len + len > MAXPATHLEN
+			    || ++nlinks > MAXSYMLINKS) {
+				error = ENOENT;
+				goto out;
+			}
+
+			bcopy(cp, &namebuf[link_len], len + 1);
+			bcopy(linkbuf, namebuf, link_len);
+			
+			/*
+			 * If absolute pathname, restart at root.
+			 * If relative pathname, restart at parent directory.
+			 */
+			cp = namebuf;
+			if (*cp == '/') {
+				if (currfd != &nfs_root_node)
+					free(currfd);
+				currfd = &nfs_root_node;
+			}
+
+			free(newfd);
+			newfd = 0;
+			
+			continue;
+		}
+		
+		if (currfd != &nfs_root_node)
+			free(currfd);
+		currfd = newfd;
+		newfd = 0;
+	}
+
+	error = 0;
+
+out:
+	if (newfd)
+		free(newfd);
+	if (path)
+		free(path);
+#else
+        /* allocate file system specific data structure */
+        currfd = malloc(sizeof(*currfd));
+        currfd->iodesc = desc;
+        currfd->off = 0;
+
+        error = nfs_lookupfh(&nfs_root_node, upath, currfd);
+#endif
+	if (!error) {
+		f->f_fsdata = (void *)currfd;
+		return (0);
+	}
+		
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("nfs_open: %s lookupfh failed: %s\n",
+		    path, strerror(error));
+#endif
+#ifndef NFS_NOSYMLINK
+	if (currfd != &nfs_root_node)
+#endif
+		free(currfd);
+
+	return (error);
+}
+
+int
+nfs_close(f)
+	struct open_file *f;
+{
+	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
+
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("nfs_close: fp=0x%lx\n", (u_long)fp);
+#endif
+
+	if (fp != &nfs_root_node && fp)
+		free(fp);
+	f->f_fsdata = (void *)0;
+	
+	return (0);
+}
+
+/*
+ * read a portion of a file
+ */
+int
+nfs_read(f, buf, size, resid)
+	struct open_file *f;
+	void *buf;
+	size_t size;
+	size_t *resid;	/* out */
+{
+	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
+	ssize_t cc;
+	char *addr = buf;
+	
+#ifdef NFS_DEBUG
+	if (debug)
+		printf("nfs_read: size=%lu off=%d\n", (u_long)size,
+		       (int)fp->off);
+#endif
+	while ((int)size > 0) {
+		twiddle();
+		cc = nfs_readdata(fp, fp->off, (void *)addr, size);
+		/* XXX maybe should retry on certain errors */
+		if (cc == -1) {
+#ifdef NFS_DEBUG
+			if (debug)
+				printf("nfs_read: read: %s", strerror(errno));
+#endif
+			return (errno);	/* XXX - from nfs_readdata */
+		}
+		if (cc == 0) {
+#ifdef NFS_DEBUG
+			if (debug)
+				printf("nfs_read: hit EOF unexpectantly");
+#endif
+			goto ret;
+		}
+		fp->off += cc;
+		addr += cc;
+		size -= cc;
+	}
+ret:
+	if (resid)
+		*resid = size;
+
+	return (0);
+}
+
+/*
+ * Not implemented.
+ */
+int
+nfs_write(f, buf, size, resid)
+	struct open_file *f;
+	void *buf;
+	size_t size;
+	size_t *resid;	/* out */
+{
+	return (EROFS);
+}
+
+off_t
+nfs_seek(f, offset, where)
+	struct open_file *f;
+	off_t offset;
+	int where;
+{
+	struct nfs_iodesc *d = (struct nfs_iodesc *)f->f_fsdata;
+	n_long size = ntohl(d->fa.fa_size);
+
+	switch (where) {
+	case SEEK_SET:
+		d->off = offset;
+		break;
+	case SEEK_CUR:
+		d->off += offset;
+		break;
+	case SEEK_END:
+		d->off = size - offset;
+		break;
+	default:
+		errno = EINVAL;
+		return (-1);
+	}
+
+	return (d->off);
+}
+
+/* NFNON=0, NFREG=1, NFDIR=2, NFBLK=3, NFCHR=4, NFLNK=5 */
+int nfs_stat_types[8] = {
+	0, S_IFREG, S_IFDIR, S_IFBLK, S_IFCHR, S_IFLNK, 0 };
+
+int
+nfs_stat(f, sb)
+	struct open_file *f;
+	struct stat *sb;
+{
+	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
+	n_long ftype, mode;
+
+	ftype = ntohl(fp->fa.fa_type);
+	mode  = ntohl(fp->fa.fa_mode);
+	mode |= nfs_stat_types[ftype & 7];
+
+	sb->st_mode  = mode;
+	sb->st_nlink = ntohl(fp->fa.fa_nlink);
+	sb->st_uid   = ntohl(fp->fa.fa_uid);
+	sb->st_gid   = ntohl(fp->fa.fa_gid);
+	sb->st_size  = ntohl(fp->fa.fa_size);
+
+	return (0);
+}
+
+static int
+nfs_readdir(struct open_file *f, struct dirent *d)
+{
+	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
+	struct nfs_readdir_args *args;
+	struct nfs_readdir_data *rd;
+	struct nfs_readdir_off  *roff = NULL;
+	static char *buf;
+	static n_long cookie = 0;
+	size_t cc;
+	n_long eof;
+	
+	struct {
+		n_long h[RPC_HEADER_WORDS];
+		struct nfs_readdir_args d;
+	} sdata;
+	static struct {
+		n_long h[RPC_HEADER_WORDS];
+		u_char d[NFS_READDIRSIZE];
+	} rdata;
+
+	if (cookie == 0) {
+	refill:
+		args = &sdata.d;
+		bzero(args, sizeof(*args));
+
+		bcopy(fp->fh, args->fh, NFS_FHSIZE);
+		args->cookie = htonl(cookie);
+		args->count  = htonl(NFS_READDIRSIZE);
+		
+		cc = rpc_call(fp->iodesc, NFS_PROG, NFS_VER2, NFSPROC_READDIR,
+			      args, sizeof(*args),
+			      rdata.d, sizeof(rdata.d));
+		buf  = rdata.d;
+		roff = (struct nfs_readdir_off *)buf;
+		if (ntohl(roff->cookie) != 0)
+			return EIO;
+	}
+	roff = (struct nfs_readdir_off *)buf;
+
+	if (ntohl(roff->follows) == 0) {
+		eof = ntohl((roff+1)->cookie);
+		if (eof) {
+			cookie = 0;
+			return ENOENT;
+		}
+		goto refill;
+	}
+
+	buf += sizeof(struct nfs_readdir_off);
+	rd = (struct nfs_readdir_data *)buf;
+	d->d_namlen = ntohl(rd->len);
+	bcopy(rd->name, d->d_name, d->d_namlen);
+	d->d_name[d->d_namlen] = '\0';
+
+	buf += (sizeof(struct nfs_readdir_data) + roundup(htonl(rd->len),4));
+	roff = (struct nfs_readdir_off *)buf;
+	cookie = ntohl(roff->cookie);
+	return 0;
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/nfsv2.h sys/boot/i386/pxe_ng/libstand/nfsv2.h
--- sys/boot/i386/pxe_ng/libstand/nfsv2.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/nfsv2.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,164 @@
+/* $FreeBSD$ */
+/*	$NetBSD: nfsv2.h,v 1.2 1996/02/26 23:05:23 gwr Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Rick Macklem at The University of Guelph.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)nfsv2.h	8.1 (Berkeley) 6/10/93
+ */
+
+/*
+ * nfs definitions as per the version 2 specs
+ */
+
+/*
+ * Constants as defined in the Sun NFS Version 2 spec.
+ * "NFS: Network File System Protocol Specification" RFC1094
+ */
+
+#define NFS_PORT	2049
+#define	NFS_PROG	100003
+#define NFS_VER2	2
+#define	NFS_MAXDGRAMDATA 8192
+#define	NFS_MAXDATA	32768
+#define	NFS_MAXPATHLEN	1024
+#define	NFS_MAXNAMLEN	255
+#define	NFS_FHSIZE	32
+#define	NFS_MAXPKTHDR	404
+#define NFS_MAXPACKET	(NFS_MAXPKTHDR+NFS_MAXDATA)
+#define	NFS_MINPACKET	20
+#define	NFS_FABLKSIZE	512	/* Size in bytes of a block wrt fa_blocks */
+#define	NFS_READDIRSIZE	1024
+
+/* Stat numbers for rpc returns */
+#define	NFS_OK		0
+#define	NFSERR_PERM	1
+#define	NFSERR_NOENT	2
+#define	NFSERR_IO	5
+#define	NFSERR_NXIO	6
+#define	NFSERR_ACCES	13
+#define	NFSERR_EXIST	17
+#define	NFSERR_NODEV	19
+#define	NFSERR_NOTDIR	20
+#define	NFSERR_ISDIR	21
+#define	NFSERR_FBIG	27
+#define	NFSERR_NOSPC	28
+#define	NFSERR_ROFS	30
+#define	NFSERR_NAMETOL	63
+#define	NFSERR_NOTEMPTY	66
+#define	NFSERR_DQUOT	69
+#define	NFSERR_STALE	70
+#define	NFSERR_WFLUSH	99
+
+/* Sizes in bytes of various nfs rpc components */
+#define	NFSX_FH		32
+#define	NFSX_UNSIGNED	4
+#define	NFSX_FATTR	68
+#define	NFSX_SATTR	32
+#define NFSX_STATFS	20
+#define	NFSX_COOKIE	4
+
+/* nfs rpc procedure numbers */
+#define	NFSPROC_NULL		0
+#define	NFSPROC_GETATTR		1
+#define	NFSPROC_SETATTR		2
+#define	NFSPROC_NOOP		3
+#define	NFSPROC_ROOT		NFSPROC_NOOP	/* Obsolete */
+#define	NFSPROC_LOOKUP		4
+#define	NFSPROC_READLINK	5
+#define	NFSPROC_READ		6
+#define	NFSPROC_WRITECACHE	NFSPROC_NOOP	/* Obsolete */
+#define	NFSPROC_WRITE		8
+#define	NFSPROC_CREATE		9
+#define	NFSPROC_REMOVE		10
+#define	NFSPROC_RENAME		11
+#define	NFSPROC_LINK		12
+#define	NFSPROC_SYMLINK		13
+#define	NFSPROC_MKDIR		14
+#define	NFSPROC_RMDIR		15
+#define	NFSPROC_READDIR		16
+#define	NFSPROC_STATFS		17
+
+#define	NFS_NPROCS		18
+
+
+/* File types */
+typedef enum {
+	NFNON=0,
+	NFREG=1,
+	NFDIR=2,
+	NFBLK=3,
+	NFCHR=4,
+	NFLNK=5
+} nfstype;
+
+/* Structs for common parts of the rpc's */
+struct nfsv2_time {
+	n_long	nfs_sec;
+	n_long	nfs_usec;
+};
+
+/*
+ * File attributes and setable attributes.
+ */
+struct nfsv2_fattr {
+	n_long	fa_type;
+	n_long	fa_mode;
+	n_long	fa_nlink;
+	n_long	fa_uid;
+	n_long	fa_gid;
+	n_long	fa_size;
+	n_long	fa_blocksize;
+	n_long	fa_rdev;
+	n_long	fa_blocks;
+	n_long	fa_fsid;
+	n_long	fa_fileid;
+	struct nfsv2_time fa_atime;
+	struct nfsv2_time fa_mtime;
+	struct nfsv2_time fa_ctime;
+};
+
+struct nfsv2_sattr {
+	n_long	sa_mode;
+	n_long	sa_uid;
+	n_long	sa_gid;
+	n_long	sa_size;
+	struct nfsv2_time sa_atime;
+	struct nfsv2_time sa_mtime;
+};
+
+struct nfsv2_statfs {
+	n_long	sf_tsize;
+	n_long	sf_bsize;
+	n_long	sf_blocks;
+	n_long	sf_bfree;
+	n_long	sf_bavail;
+};
diff -ruN sys/boot/i386/pxe_ng/libstand/nullfs.c sys/boot/i386/pxe_ng/libstand/nullfs.c
--- sys/boot/i386/pxe_ng/libstand/nullfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/nullfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,105 @@
+/*	$NetBSD: nullfs.c,v 1.1 1996/01/13 22:25:39 leo Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)open.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+/*
+ * Null filesystem
+ */
+int	null_open (const char *path, struct open_file *f)
+{
+	return EINVAL;
+}
+
+int	null_close(struct open_file *f)
+{
+	return 0;
+}
+
+int	null_read (struct open_file *f, void *buf, size_t size, size_t *resid)
+{
+	return EIO;
+}
+
+int	null_write (struct open_file *f, void *buf, size_t size, size_t *resid)
+{
+	return EIO;
+}
+
+off_t	null_seek (struct open_file *f, off_t offset, int where)
+{
+	errno = EIO;
+	return -1;
+}
+
+int	null_stat (struct open_file *f, struct stat *sb)
+{
+	return EIO;
+}
+
+int	null_readdir(struct open_file *f, struct dirent *d)
+{
+	return EIO;
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/open.c sys/boot/i386/pxe_ng/libstand/open.c
--- sys/boot/i386/pxe_ng/libstand/open.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/open.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,144 @@
+/*	$NetBSD: open.c,v 1.16 1997/01/28 09:41:03 pk Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)open.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+struct open_file files[SOPEN_MAX];
+
+static int
+o_gethandle(void) 
+{
+    int		fd;
+    
+    for (fd = 0; fd < SOPEN_MAX; fd++)
+	if (files[fd].f_flags == 0)
+	    return(fd);
+    return(-1);
+}
+
+static void
+o_rainit(struct open_file *f)
+{
+    f->f_rabuf = malloc(SOPEN_RASIZE);
+    f->f_ralen = 0;
+    f->f_raoffset = 0;
+}
+
+int
+open(const char *fname, int mode)
+{
+    struct open_file	*f;
+    int			fd, i, error, besterror;
+    const char		*file;
+
+    if ((fd = o_gethandle()) == -1) {
+	errno = EMFILE;
+	return(-1);
+    }
+
+    f = &files[fd];
+    f->f_flags = mode + 1;
+    f->f_dev = (struct devsw *)0;
+    f->f_ops = (struct fs_ops *)0;
+    f->f_offset = 0;
+    f->f_devdata = NULL;
+    file = (char *)0;
+    error = devopen(f, fname, &file);
+    if (error ||
+	(((f->f_flags & F_NODEV) == 0) && f->f_dev == (struct devsw *)0))
+	goto err;
+
+    /* see if we opened a raw device; otherwise, 'file' is the file name. */
+    if (file == (char *)0 || *file == '\0') {
+	f->f_flags |= F_RAW;
+	return (fd);
+    }
+
+    /* pass file name to the different filesystem open routines */
+    besterror = ENOENT;
+    for (i = 0; file_system[i] != NULL; i++) {
+
+	error = ((*file_system[i]).fo_open)(file, f);
+	if (error == 0) {
+	    
+	    f->f_ops = file_system[i];
+	    o_rainit(f);
+	    return (fd);
+	}
+	if (error != EINVAL)
+	    besterror = error;
+    }
+    error = besterror;
+
+    if ((f->f_flags & F_NODEV) == 0)
+	f->f_dev->dv_close(f);
+    if (error)
+	devclose(f);
+
+ err:
+    f->f_flags = 0;
+    errno = error;
+    return (-1);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/pager.c sys/boot/i386/pxe_ng/libstand/pager.c
--- sys/boot/i386/pxe_ng/libstand/pager.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/pager.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,161 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ * Simple paged-output and paged-viewing functions
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+#include <string.h>
+
+static int	p_maxlines = -1;
+static int	p_freelines;
+
+static char *pager_prompt1 = " --more--  <space> page down <enter> line down <q> quit ";
+static char *pager_blank   = "                                                        ";
+
+/*
+ * 'open' the pager
+ */
+void
+pager_open(void)
+{
+    int		nlines;
+    char	*cp, *lp;
+    
+    nlines = 24;		/* sensible default */
+    if ((cp = getenv("LINES")) != NULL) {
+	nlines = strtol(cp, &lp, 0);
+    }
+
+    p_maxlines = nlines - 1;
+    if (p_maxlines < 1)
+	p_maxlines = 1;
+    p_freelines = p_maxlines;
+}
+
+/*
+ * 'close' the pager
+ */
+void
+pager_close(void)
+{
+    p_maxlines = -1;
+}
+
+/*
+ * Emit lines to the pager; may not return until the user
+ * has responded to the prompt.
+ *
+ * Will return nonzero if the user enters 'q' or 'Q' at the prompt.
+ *
+ * XXX note that this watches outgoing newlines (and eats them), but
+ *     does not handle wrap detection (req. count of columns).
+ */
+
+int
+pager_output(const char *cp)
+{
+    int		action;
+
+    if (cp == NULL)
+	return(0);
+    
+    for (;;) {
+	if (*cp == 0)
+	    return(0);
+	
+	putchar(*cp);			/* always emit character */
+
+	if (*(cp++) == '\n') {		/* got a newline? */
+	    p_freelines--;
+	    if (p_freelines <= 0) {
+		printf("%s", pager_prompt1);
+		action = 0;
+		while (action == 0) {
+		    switch(getchar()) {
+		    case '\r':
+		    case '\n':
+			p_freelines = 1;
+			action = 1;
+			break;
+		    case ' ':
+			p_freelines = p_maxlines;
+			action = 1;
+			break;
+		    case 'q':
+		    case 'Q':
+			action = 2;
+			break;
+		    default:
+			break;
+		    }
+		}
+		printf("\r%s\r", pager_blank);
+		if (action == 2)
+		    return(1);
+	    }
+	}
+    }
+}
+
+/*
+ * Display from (fd).
+ */
+int
+pager_file(const char *fname)
+{
+    char	buf[80];
+    size_t	hmuch;
+    int		fd;
+    int		result;
+    
+    if ((fd = open(fname, O_RDONLY)) == -1) {
+	printf("can't open '%s': %s\n", fname, strerror(errno));
+	return(-1);
+    }
+
+    for (;;) {
+	hmuch = read(fd, buf, sizeof(buf) - 1);
+	if (hmuch == -1) {
+	    result = -1;
+	    break;
+	}
+	if (hmuch == 0) {
+	    result = 0;
+	    break;
+	}
+	buf[hmuch] = 0;
+	if (pager_output(buf)) {
+	    result = 1;
+	    break;
+	}
+    }
+    close(fd);
+    return(result);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/powerpc/_setjmp.S sys/boot/i386/pxe_ng/libstand/powerpc/_setjmp.S
--- sys/boot/i386/pxe_ng/libstand/powerpc/_setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/powerpc/_setjmp.S	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,36 @@
+/*	$NetBSD: _setjmp.S,v 1.1 1997/03/29 20:55:53 thorpej Exp $	*/
+
+#include <machine/asm.h>
+
+#if (defined(LIBC_SCCS) || defined(LIBC_RCS)) && !defined(lint)
+	.text
+	.asciz "$FreeBSD$"
+#endif
+
+/*
+ * C library -- _setjmp, _longjmp
+ *
+ *	_longjmp(a,v)
+ * will generate a "return(v?v:1)" from the last call to
+ *	_setjmp(a)
+ * by restoring registers from the stack.
+ * The previous signal state is NOT restored.
+ */
+
+ENTRY(_setjmp)
+	mflr	11
+	mfcr	12
+	mr	10,1
+	mr	9,2
+	stmw	9,8(3)
+	li	3,0
+	blr
+
+ENTRY(_longjmp)
+	lmw	9,8(3)
+	mtlr	11
+	mtcr	12
+	mr	2,9
+	mr	1,10
+	mr	3,4
+	blr
diff -ruN sys/boot/i386/pxe_ng/libstand/printf.c sys/boot/i386/pxe_ng/libstand/printf.c
--- sys/boot/i386/pxe_ng/libstand/printf.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/printf.c	2009-03-02 20:20:06.000000000 -0500
@@ -0,0 +1,458 @@
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/lib/libstand/printf.c,v 1.10 2007/01/09 01:02:04 imp Exp $");
+
+/*
+ * Standaloneified version of the FreeBSD kernel printf family.
+ */
+
+#include <sys/types.h>
+#include <sys/stddef.h>
+#include <sys/stdint.h>
+#include <limits.h>
+#include <string.h>
+#include "stand.h"
+
+/*
+ * Note that stdarg.h and the ANSI style va_start macro is used for both
+ * ANSI and traditional C compilers.
+ */
+#include <machine/stdarg.h>
+
+#define MAXNBUF (sizeof(intmax_t) * CHAR_BIT + 1)
+
+static char	*ksprintn (char *buf, uintmax_t num, int base, int *len, int upper);
+static int      kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, size_t size, va_list ap);
+
+int
+printf(const char *fmt, ...)
+{
+	va_list ap;
+	int retval;
+
+	va_start(ap, fmt);
+	retval = kvprintf(fmt, putchar, NULL, 10, 0, ap);
+	va_end(ap);
+	return retval;
+}
+
+void
+vprintf(const char *fmt, va_list ap)
+{
+
+	kvprintf(fmt, putchar, NULL, 10, 0, ap);
+}
+
+int
+sprintf(char *buf, const char *cfmt, ...)
+{
+	int retval;
+	va_list ap;
+
+	va_start(ap, cfmt);
+	retval = kvprintf(cfmt, NULL, (void *)buf, 10, 0, ap);
+	buf[retval] = '\0';
+	va_end(ap);
+	return retval;
+}
+
+int
+snprintf(char *buf, size_t size, const char *cfmt, ...)
+{
+        int retval;
+        va_list ap;
+        size_t  maxsize = (size > 1) ? size - 1 : 0;
+			
+        if (maxsize == 0) {
+                buf[0] = '\0';
+                return (0);
+        }
+
+        va_start(ap, cfmt);
+        retval = kvprintf(cfmt, NULL, (void *)buf, 10, maxsize, ap);
+
+        if (retval < maxsize)
+                buf[retval] = '\0';
+        else
+                buf[maxsize] = '\0';
+	
+	va_end(ap);
+	
+	return (retval);
+}
+
+void
+vsprintf(char *buf, const char *cfmt, va_list ap)
+{
+	int	retval;
+	
+	retval = kvprintf(cfmt, NULL, (void *)buf, 10, 0, ap);
+	buf[retval] = '\0';
+}
+
+/*
+ * Put a NUL-terminated ASCII number (base <= 36) in a buffer in reverse
+ * order; return an optional length and a pointer to the last character
+ * written in the buffer (i.e., the first character of the string).
+ * The buffer pointed to by `nbuf' must have length >= MAXNBUF.
+ */
+static char *
+ksprintn(char *nbuf, uintmax_t num, int base, int *lenp, int upper)
+{
+	char *p, c;
+
+	p = nbuf;
+	*p = '\0';
+	do {
+		c = hex2ascii(num % base);
+		*++p = upper ? toupper(c) : c;
+	} while (num /= base);
+	if (lenp)
+		*lenp = p - nbuf;
+	return (p);
+}
+
+/*
+ * Scaled down version of printf(3).
+ *
+ * Two additional formats:
+ *
+ * The format %b is supported to decode error registers.
+ * Its usage is:
+ *
+ *	printf("reg=%b\n", regval, "<base><arg>*");
+ *
+ * where <base> is the output base expressed as a control character, e.g.
+ * \10 gives octal; \20 gives hex.  Each arg is a sequence of characters,
+ * the first of which gives the bit number to be inspected (origin 1), and
+ * the next characters (up to a control character, i.e. a character <= 32),
+ * give the name of the register.  Thus:
+ *
+ *	kvprintf("reg=%b\n", 3, "\10\2BITTWO\1BITONE\n");
+ *
+ * would produce output:
+ *
+ *	reg=3<BITTWO,BITONE>
+ *
+ * XXX:  %D  -- Hexdump, takes pointer and separator string:
+ *		("%6D", ptr, ":")   -> XX:XX:XX:XX:XX:XX
+ *		("%*D", len, ptr, " " -> XX XX XX XX ...
+ */
+static int
+kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, size_t maxsize, va_list ap)
+{
+#define PCHAR(c) { int cc=(c); if (func) (*func)(cc); else *d++ = cc; retval++; \
+                   if (maxsize && (retval == maxsize)) return (retval);         \
+		 }
+	char nbuf[MAXNBUF];
+	char *d;
+	const char *p, *percent, *q;
+	u_char *up;
+	int ch, n;
+	uintmax_t num;
+	int base, lflag, qflag, tmp, width, ladjust, sharpflag, neg, sign, dot;
+	int jflag, tflag, zflag;
+	int dwidth, upper;
+	char padc;
+	int retval = 0;
+
+	num = 0;
+	if (!func)
+		d = (char *) arg;
+	else
+		d = NULL;
+
+	if (fmt == NULL)
+		fmt = "(fmt null)\n";
+
+	if (radix < 2 || radix > 36)
+		radix = 10;
+
+	for (;;) {
+		padc = ' ';
+		width = 0;
+		while ((ch = (u_char)*fmt++) != '%') {
+			if (ch == '\0')
+				return (retval);
+			PCHAR(ch);
+		}
+		percent = fmt - 1;
+		qflag = 0; lflag = 0; ladjust = 0; sharpflag = 0; neg = 0;
+		sign = 0; dot = 0; dwidth = 0; upper = 0;
+		jflag = 0; tflag = 0; zflag = 0;
+reswitch:	switch (ch = (u_char)*fmt++) {
+		case '.':
+			dot = 1;
+			goto reswitch;
+		case '#':
+			sharpflag = 1;
+			goto reswitch;
+		case '+':
+			sign = 1;
+			goto reswitch;
+		case '-':
+			ladjust = 1;
+			goto reswitch;
+		case '%':
+			PCHAR(ch);
+			break;
+		case '*':
+			if (!dot) {
+				width = va_arg(ap, int);
+				if (width < 0) {
+					ladjust = !ladjust;
+					width = -width;
+				}
+			} else {
+				dwidth = va_arg(ap, int);
+			}
+			goto reswitch;
+		case '0':
+			if (!dot) {
+				padc = '0';
+				goto reswitch;
+			}
+		case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+				for (n = 0;; ++fmt) {
+					n = n * 10 + ch - '0';
+					ch = *fmt;
+					if (ch < '0' || ch > '9')
+						break;
+				}
+			if (dot)
+				dwidth = n;
+			else
+				width = n;
+			goto reswitch;
+		case 'b':
+			num = va_arg(ap, int);
+			p = va_arg(ap, char *);
+			for (q = ksprintn(nbuf, num, *p++, NULL, 0); *q;)
+				PCHAR(*q--);
+
+			if (num == 0)
+				break;
+
+			for (tmp = 0; *p;) {
+				n = *p++;
+				if (num & (1 << (n - 1))) {
+					PCHAR(tmp ? ',' : '<');
+					for (; (n = *p) > ' '; ++p)
+						PCHAR(n);
+					tmp = 1;
+				} else
+					for (; *p > ' '; ++p)
+						continue;
+			}
+			if (tmp)
+				PCHAR('>');
+			break;
+		case 'c':
+			PCHAR(va_arg(ap, int));
+			break;
+		case 'D':
+			up = va_arg(ap, u_char *);
+			p = va_arg(ap, char *);
+			if (!width)
+				width = 16;
+			while(width--) {
+				PCHAR(hex2ascii(*up >> 4));
+				PCHAR(hex2ascii(*up & 0x0f));
+				up++;
+				if (width)
+					for (q=p;*q;q++)
+						PCHAR(*q);
+			}
+			break;
+		case 'd':
+		case 'i':
+			base = 10;
+			sign = 1;
+			goto handle_sign;
+		case 'j':
+			jflag = 1;
+			goto reswitch;
+		case 'l':
+			if (lflag) {
+				lflag = 0;
+				qflag = 1;
+			} else
+				lflag = 1;
+			goto reswitch;
+		case 'n':
+			if (jflag)
+				*(va_arg(ap, intmax_t *)) = retval;
+			else if (qflag)
+				*(va_arg(ap, quad_t *)) = retval;
+			else if (lflag)
+				*(va_arg(ap, long *)) = retval;
+			else if (zflag)
+				*(va_arg(ap, size_t *)) = retval;
+			else
+				*(va_arg(ap, int *)) = retval;
+			break;
+		case 'o':
+			base = 8;
+			goto handle_nosign;
+		case 'p':
+			base = 16;
+			sharpflag = (width == 0);
+			sign = 0;
+			num = (uintptr_t)va_arg(ap, void *);
+			goto number;
+		case 'q':
+			qflag = 1;
+			goto reswitch;
+		case 'r':
+			base = radix;
+			if (sign)
+				goto handle_sign;
+			goto handle_nosign;
+		case 's':
+			p = va_arg(ap, char *);
+			if (p == NULL)
+				p = "(null)";
+			if (!dot)
+				n = strlen (p);
+			else
+				for (n = 0; n < dwidth && p[n]; n++)
+					continue;
+
+			width -= n;
+
+			if (!ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			while (n--)
+				PCHAR(*p++);
+			if (ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			break;
+		case 't':
+			tflag = 1;
+			goto reswitch;
+		case 'u':
+			base = 10;
+			goto handle_nosign;
+		case 'X':
+			upper = 1;
+		case 'x':
+			base = 16;
+			goto handle_nosign;
+		case 'y':
+			base = 16;
+			sign = 1;
+			goto handle_sign;
+		case 'z':
+			zflag = 1;
+			goto reswitch;
+handle_nosign:
+			sign = 0;
+			if (jflag)
+				num = va_arg(ap, uintmax_t);
+			else if (qflag)
+				num = va_arg(ap, u_quad_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, u_long);
+			else if (zflag)
+				num = va_arg(ap, size_t);
+			else
+				num = va_arg(ap, u_int);
+			goto number;
+handle_sign:
+			if (jflag)
+				num = va_arg(ap, intmax_t);
+			else if (qflag)
+				num = va_arg(ap, quad_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, long);
+			else if (zflag)
+				num = va_arg(ap, size_t);
+			else
+				num = va_arg(ap, int);
+number:
+			if (sign && (intmax_t)num < 0) {
+				neg = 1;
+				num = -(intmax_t)num;
+			}
+			p = ksprintn(nbuf, num, base, &tmp, upper);
+			if (sharpflag && num != 0) {
+				if (base == 8)
+					tmp++;
+				else if (base == 16)
+					tmp += 2;
+			}
+			if (neg)
+				tmp++;
+
+			if (!ladjust && width && (width -= tmp) > 0)
+				while (width--)
+					PCHAR(padc);
+			if (neg)
+				PCHAR('-');
+			if (sharpflag && num != 0) {
+				if (base == 8) {
+					PCHAR('0');
+				} else if (base == 16) {
+					PCHAR('0');
+					PCHAR('x');
+				}
+			}
+
+			while (*p)
+				PCHAR(*p--);
+
+			if (ladjust && width && (width -= tmp) > 0)
+				while (width--)
+					PCHAR(padc);
+
+			break;
+		default:
+			while (percent < fmt)
+				PCHAR(*percent++);
+			break;
+		}
+	}
+#undef PCHAR
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/qdivrem.c sys/boot/i386/pxe_ng/libstand/qdivrem.c
--- sys/boot/i386/pxe_ng/libstand/qdivrem.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/qdivrem.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,349 @@
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * 	From: Id: qdivrem.c,v 1.7 1997/11/07 09:20:40 phk Exp
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Multiprecision divide.  This algorithm is from Knuth vol. 2 (2nd ed),
+ * section 4.3.1, pp. 257--259.
+ */
+
+#include "quad.h"
+
+#define	B	(1 << HALF_BITS)	/* digit base */
+
+/* Combine two `digits' to make a single two-digit number. */
+#define	COMBINE(a, b) (((u_long)(a) << HALF_BITS) | (b))
+
+/* select a type for digits in base B: use unsigned short if they fit */
+#if ULONG_MAX == 0xffffffff && USHRT_MAX >= 0xffff
+typedef unsigned short digit;
+#else
+typedef u_long digit;
+#endif
+
+/*
+ * Shift p[0]..p[len] left `sh' bits, ignoring any bits that
+ * `fall out' the left (there never will be any such anyway).
+ * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
+ */
+static void
+shl(digit *p, int len, int sh)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+		p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
+	p[i] = LHALF(p[i] << sh);
+}
+
+/*
+ * __qdivrem(u, v, rem) returns u/v and, optionally, sets *rem to u%v.
+ *
+ * We do this in base 2-sup-HALF_BITS, so that all intermediate products
+ * fit within u_long.  As a consequence, the maximum length dividend and
+ * divisor are 4 `digits' in this base (they are shorter if they have
+ * leading zeros).
+ */
+u_quad_t
+__qdivrem(uq, vq, arq)
+	u_quad_t uq, vq, *arq;
+{
+	union uu tmp;
+	digit *u, *v, *q;
+	digit v1, v2;
+	u_long qhat, rhat, t;
+	int m, n, d, j, i;
+	digit uspace[5], vspace[5], qspace[5];
+
+	/*
+	 * Take care of special cases: divide by zero, and u < v.
+	 */
+	if (vq == 0) {
+		/* divide by zero. */
+		static volatile const unsigned int zero = 0;
+
+		tmp.ul[H] = tmp.ul[L] = 1 / zero;
+		if (arq)
+			*arq = uq;
+		return (tmp.q);
+	}
+	if (uq < vq) {
+		if (arq)
+			*arq = uq;
+		return (0);
+	}
+	u = &uspace[0];
+	v = &vspace[0];
+	q = &qspace[0];
+
+	/*
+	 * Break dividend and divisor into digits in base B, then
+	 * count leading zeros to determine m and n.  When done, we
+	 * will have:
+	 *	u = (u[1]u[2]...u[m+n]) sub B
+	 *	v = (v[1]v[2]...v[n]) sub B
+	 *	v[1] != 0
+	 *	1 < n <= 4 (if n = 1, we use a different division algorithm)
+	 *	m >= 0 (otherwise u < v, which we already checked)
+	 *	m + n = 4
+	 * and thus
+	 *	m = 4 - n <= 2
+	 */
+	tmp.uq = uq;
+	u[0] = 0;
+	u[1] = HHALF(tmp.ul[H]);
+	u[2] = LHALF(tmp.ul[H]);
+	u[3] = HHALF(tmp.ul[L]);
+	u[4] = LHALF(tmp.ul[L]);
+	tmp.uq = vq;
+	v[1] = HHALF(tmp.ul[H]);
+	v[2] = LHALF(tmp.ul[H]);
+	v[3] = HHALF(tmp.ul[L]);
+	v[4] = LHALF(tmp.ul[L]);
+	for (n = 4; v[1] == 0; v++) {
+		if (--n == 1) {
+			u_long rbj;	/* r*B+u[j] (not root boy jim) */
+			digit q1, q2, q3, q4;
+
+			/*
+			 * Change of plan, per exercise 16.
+			 *	r = 0;
+			 *	for j = 1..4:
+			 *		q[j] = floor((r*B + u[j]) / v),
+			 *		r = (r*B + u[j]) % v;
+			 * We unroll this completely here.
+			 */
+			t = v[2];	/* nonzero, by definition */
+			q1 = u[1] / t;
+			rbj = COMBINE(u[1] % t, u[2]);
+			q2 = rbj / t;
+			rbj = COMBINE(rbj % t, u[3]);
+			q3 = rbj / t;
+			rbj = COMBINE(rbj % t, u[4]);
+			q4 = rbj / t;
+			if (arq)
+				*arq = rbj % t;
+			tmp.ul[H] = COMBINE(q1, q2);
+			tmp.ul[L] = COMBINE(q3, q4);
+			return (tmp.q);
+		}
+	}
+
+	/*
+	 * By adjusting q once we determine m, we can guarantee that
+	 * there is a complete four-digit quotient at &qspace[1] when
+	 * we finally stop.
+	 */
+	for (m = 4 - n; u[1] == 0; u++)
+		m--;
+	for (i = 4 - m; --i >= 0;)
+		q[i] = 0;
+	q += 4 - m;
+
+	/*
+	 * Here we run Program D, translated from MIX to C and acquiring
+	 * a few minor changes.
+	 *
+	 * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
+	 */
+	d = 0;
+	for (t = v[1]; t < B / 2; t <<= 1)
+		d++;
+	if (d > 0) {
+		shl(&u[0], m + n, d);		/* u <<= d */
+		shl(&v[1], n - 1, d);		/* v <<= d */
+	}
+	/*
+	 * D2: j = 0.
+	 */
+	j = 0;
+	v1 = v[1];	/* for D3 -- note that v[1..n] are constant */
+	v2 = v[2];	/* for D3 */
+	do {
+		digit uj0, uj1, uj2;
+
+		/*
+		 * D3: Calculate qhat (\^q, in TeX notation).
+		 * Let qhat = min((u[j]*B + u[j+1])/v[1], B-1), and
+		 * let rhat = (u[j]*B + u[j+1]) mod v[1].
+		 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
+		 * decrement qhat and increase rhat correspondingly.
+		 * Note that if rhat >= B, v[2]*qhat < rhat*B.
+		 */
+		uj0 = u[j + 0];	/* for D3 only -- note that u[j+...] change */
+		uj1 = u[j + 1];	/* for D3 only */
+		uj2 = u[j + 2];	/* for D3 only */
+		if (uj0 == v1) {
+			qhat = B;
+			rhat = uj1;
+			goto qhat_too_big;
+		} else {
+			u_long nn = COMBINE(uj0, uj1);
+			qhat = nn / v1;
+			rhat = nn % v1;
+		}
+		while (v2 * qhat > COMBINE(rhat, uj2)) {
+	qhat_too_big:
+			qhat--;
+			if ((rhat += v1) >= B)
+				break;
+		}
+		/*
+		 * D4: Multiply and subtract.
+		 * The variable `t' holds any borrows across the loop.
+		 * We split this up so that we do not require v[0] = 0,
+		 * and to eliminate a final special case.
+		 */
+		for (t = 0, i = n; i > 0; i--) {
+			t = u[i + j] - v[i] * qhat - t;
+			u[i + j] = LHALF(t);
+			t = (B - HHALF(t)) & (B - 1);
+		}
+		t = u[j] - t;
+		u[j] = LHALF(t);
+		/*
+		 * D5: test remainder.
+		 * There is a borrow if and only if HHALF(t) is nonzero;
+		 * in that (rare) case, qhat was too large (by exactly 1).
+		 * Fix it by adding v[1..n] to u[j..j+n].
+		 */
+		if (HHALF(t)) {
+			qhat--;
+			for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
+				t += u[i + j] + v[i];
+				u[i + j] = LHALF(t);
+				t = HHALF(t);
+			}
+			u[j] = LHALF(u[j] + t);
+		}
+		q[j] = qhat;
+	} while (++j <= m);		/* D7: loop on j. */
+
+	/*
+	 * If caller wants the remainder, we have to calculate it as
+	 * u[m..m+n] >> d (this is at most n digits and thus fits in
+	 * u[m+1..m+n], but we may need more source digits).
+	 */
+	if (arq) {
+		if (d) {
+			for (i = m + n; i > m; --i)
+				u[i] = (u[i] >> d) |
+				    LHALF(u[i - 1] << (HALF_BITS - d));
+			u[i] = 0;
+		}
+		tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
+		tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
+		*arq = tmp.q;
+	}
+
+	tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
+	tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
+	return (tmp.q);
+}
+
+/*
+ * Divide two unsigned quads.
+ */
+
+u_quad_t
+__udivdi3(a, b)
+	u_quad_t a, b;
+{
+
+	return (__qdivrem(a, b, (u_quad_t *)0));
+}
+
+/*
+ * Return remainder after dividing two unsigned quads.
+ */
+u_quad_t
+__umoddi3(a, b)
+	u_quad_t a, b;
+{
+	u_quad_t r;
+
+	(void)__qdivrem(a, b, &r);
+	return (r);
+}
+
+/*
+ * Divide two signed quads.
+ * ??? if -1/2 should produce -1 on this machine, this code is wrong
+ */
+quad_t
+__divdi3(a, b)
+        quad_t a, b;
+{
+	u_quad_t ua, ub, uq;
+	int neg;
+
+	if (a < 0)
+		ua = -(u_quad_t)a, neg = 1;
+	else
+		ua = a, neg = 0;
+	if (b < 0)
+		ub = -(u_quad_t)b, neg ^= 1;
+	else
+		ub = b;
+	uq = __qdivrem(ua, ub, (u_quad_t *)0);
+	return (neg ? -uq : uq);
+}
+
+/*
+ * Return remainder after dividing two signed quads.
+ *
+ * XXX
+ * If -1/2 should produce -1 on this machine, this code is wrong.
+ */
+quad_t
+__moddi3(a, b)
+        quad_t a, b;
+{
+	u_quad_t ua, ub, ur;
+	int neg;
+
+	if (a < 0)
+		ua = -(u_quad_t)a, neg = 1;
+	else
+		ua = a, neg = 0;
+	if (b < 0)
+		ub = -(u_quad_t)b;
+	else
+		ub = b;
+	(void)__qdivrem(ua, ub, &ur);
+	return (neg ? -ur : ur);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/quad.h sys/boot/i386/pxe_ng/libstand/quad.h
--- sys/boot/i386/pxe_ng/libstand/quad.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/quad.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,112 @@
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)quad.h	8.1 (Berkeley) 6/4/93
+ * $FreeBSD$
+ */
+
+/*
+ * Quad arithmetic.
+ *
+ * This library makes the following assumptions:
+ *
+ *  - The type long long (aka quad_t) exists.
+ *
+ *  - A quad variable is exactly twice as long as `long'.
+ *
+ *  - The machine's arithmetic is two's complement.
+ *
+ * This library can provide 128-bit arithmetic on a machine with 128-bit
+ * quads and 64-bit longs, for instance, or 96-bit arithmetic on machines
+ * with 48-bit longs.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <limits.h>
+
+/*
+ * Depending on the desired operation, we view a `long long' (aka quad_t) in
+ * one or more of the following formats.
+ */
+union uu {
+	quad_t	q;		/* as a (signed) quad */
+	quad_t	uq;		/* as an unsigned quad */
+	long	sl[2];		/* as two signed longs */
+	u_long	ul[2];		/* as two unsigned longs */
+};
+
+/*
+ * Define high and low longwords.
+ */
+#define	H		_QUAD_HIGHWORD
+#define	L		_QUAD_LOWWORD
+
+/*
+ * Total number of bits in a quad_t and in the pieces that make it up.
+ * These are used for shifting, and also below for halfword extraction
+ * and assembly.
+ */
+#define	QUAD_BITS	(sizeof(quad_t) * CHAR_BIT)
+#define	LONG_BITS	(sizeof(long) * CHAR_BIT)
+#define	HALF_BITS	(sizeof(long) * CHAR_BIT / 2)
+
+/*
+ * Extract high and low shortwords from longword, and move low shortword of
+ * longword to upper half of long, i.e., produce the upper longword of
+ * ((quad_t)(x) << (number_of_bits_in_long/2)).  (`x' must actually be u_long.)
+ *
+ * These are used in the multiply code, to split a longword into upper
+ * and lower halves, and to reassemble a product as a quad_t, shifted left
+ * (sizeof(long)*CHAR_BIT/2).
+ */
+#define	HHALF(x)	((x) >> HALF_BITS)
+#define	LHALF(x)	((x) & ((1 << HALF_BITS) - 1))
+#define	LHUP(x)		((x) << HALF_BITS)
+
+quad_t		__divdi3(quad_t a, quad_t b);
+quad_t		__moddi3(quad_t a, quad_t b);
+u_quad_t	__qdivrem(u_quad_t u, u_quad_t v, u_quad_t *rem);
+u_quad_t	__udivdi3(u_quad_t a, u_quad_t b);
+u_quad_t	__umoddi3(u_quad_t a, u_quad_t b);
+
+/*
+ * XXX
+ * Compensate for gcc 1 vs gcc 2.  Gcc 1 defines ?sh?di3's second argument
+ * as u_quad_t, while gcc 2 correctly uses int.  Unfortunately, we still use
+ * both compilers.
+ */
+#if __GNUC__ >= 2
+typedef unsigned int	qshift_t;
+#else
+typedef u_quad_t	qshift_t;
+#endif
diff -ruN sys/boot/i386/pxe_ng/libstand/random.c sys/boot/i386/pxe_ng/libstand/random.c
--- sys/boot/i386/pxe_ng/libstand/random.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/random.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,70 @@
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)random.c	8.1 (Berkeley) 6/10/93
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+
+static u_long randseed = 1;
+
+void
+srandom(seed)
+	u_long seed;
+{
+	randseed = seed;
+}
+
+/*
+ * Pseudo-random number generator for randomizing the profiling clock,
+ * and whatever else we might use it for.  The result is uniform on
+ * [0, 2^31 - 1].
+ */
+u_long
+random()
+{
+	long x, hi, lo, t;
+
+	/*
+	 * Compute x[n + 1] = (7^5 * x[n]) mod (2^31 - 1).
+	 * From "Random number generators: good ones are hard to find",
+	 * Park and Miller, Communications of the ACM, vol. 31, no. 10,
+	 * October 1988, p. 1195.
+	 */
+	x = randseed;
+	hi = x / 127773;
+	lo = x % 127773;
+	t = 16807 * lo - 2836 * hi;
+	if (t <= 0)
+		t += 0x7fffffff;
+	randseed = t;
+	return (t);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/rarp.c sys/boot/i386/pxe_ng/libstand/rarp.c
--- sys/boot/i386/pxe_ng/libstand/rarp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/rarp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,225 @@
+/*	$NetBSD: rarp.c,v 1.16 1997/07/07 15:52:52 drochner Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: arp.c,v 1.5 93/07/15 05:52:26 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include <netinet/in_systm.h>
+
+#include <string.h>
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+
+
+static ssize_t rarpsend(struct iodesc *, void *, size_t);
+static ssize_t rarprecv(struct iodesc *, void *, size_t, time_t);
+
+/*
+ * Ethernet (Reverse) Address Resolution Protocol (see RFC 903, and 826).
+ */
+int
+rarp_getipaddress(sock)
+	int sock;
+{
+	struct iodesc *d;
+	struct ether_arp *ap;
+	struct {
+		u_char header[ETHER_SIZE];
+		struct {
+			struct ether_arp arp;
+			u_char pad[18]; 	/* 60 - sizeof(arp) */
+		} data;
+	} wbuf;
+	struct {
+		u_char header[ETHER_SIZE];
+		struct {
+			struct ether_arp arp;
+			u_char pad[24]; 	/* extra space */
+		} data;
+	} rbuf;
+
+#ifdef RARP_DEBUG
+ 	if (debug)
+		printf("rarp: socket=%d\n", sock);
+#endif
+	if (!(d = socktodesc(sock))) {
+		printf("rarp: bad socket. %d\n", sock);
+		return (-1);
+	}
+#ifdef RARP_DEBUG
+ 	if (debug)
+		printf("rarp: d=%x\n", (u_int)d);
+#endif
+
+	bzero((char*)&wbuf.data, sizeof(wbuf.data));
+	ap = &wbuf.data.arp;
+	ap->arp_hrd = htons(ARPHRD_ETHER);
+	ap->arp_pro = htons(ETHERTYPE_IP);
+	ap->arp_hln = sizeof(ap->arp_sha); /* hardware address length */
+	ap->arp_pln = sizeof(ap->arp_spa); /* protocol address length */
+	ap->arp_op = htons(ARPOP_REVREQUEST);
+	bcopy(d->myea, ap->arp_sha, 6);
+	bcopy(d->myea, ap->arp_tha, 6);
+
+	if (sendrecv(d,
+	    rarpsend, &wbuf.data, sizeof(wbuf.data),
+	    rarprecv, &rbuf.data, sizeof(rbuf.data)) < 0)
+	{
+		printf("No response for RARP request\n");
+		return (-1);
+	}
+
+	ap = &rbuf.data.arp;
+	bcopy(ap->arp_tpa, (char *)&myip, sizeof(myip));
+#if 0
+	/* XXX - Can NOT assume this is our root server! */
+	bcopy(ap->arp_spa, (char *)&rootip, sizeof(rootip));
+#endif
+
+	/* Compute our "natural" netmask. */
+	if (IN_CLASSA(myip.s_addr))
+		netmask = IN_CLASSA_NET;
+	else if (IN_CLASSB(myip.s_addr))
+		netmask = IN_CLASSB_NET;
+	else
+		netmask = IN_CLASSC_NET;
+
+	d->myip = myip;
+	return (0);
+}
+
+/*
+ * Broadcast a RARP request (i.e. who knows who I am)
+ */
+static ssize_t
+rarpsend(d, pkt, len)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+{
+
+#ifdef RARP_DEBUG
+ 	if (debug)
+		printf("rarpsend: called\n");
+#endif
+
+	return (sendether(d, pkt, len, bcea, ETHERTYPE_REVARP));
+}
+
+/*
+ * Returns 0 if this is the packet we're waiting for
+ * else -1 (and errno == 0)
+ */
+static ssize_t
+rarprecv(d, pkt, len, tleft)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	time_t tleft;
+{
+	ssize_t n;
+	struct ether_arp *ap;
+	u_int16_t etype;	/* host order */
+
+#ifdef RARP_DEBUG
+ 	if (debug)
+		printf("rarprecv: ");
+#endif
+
+	n = readether(d, pkt, len, tleft, &etype);
+	errno = 0;	/* XXX */
+	if (n == -1 || n < sizeof(struct ether_arp)) {
+#ifdef RARP_DEBUG
+		if (debug)
+			printf("bad len=%d\n", n);
+#endif
+		return (-1);
+	}
+
+	if (etype != ETHERTYPE_REVARP) {
+#ifdef RARP_DEBUG
+		if (debug)
+			printf("bad type=0x%x\n", etype);
+#endif
+		return (-1);
+	}
+
+	ap = (struct ether_arp *)pkt;
+	if (ap->arp_hrd != htons(ARPHRD_ETHER) ||
+	    ap->arp_pro != htons(ETHERTYPE_IP) ||
+	    ap->arp_hln != sizeof(ap->arp_sha) ||
+	    ap->arp_pln != sizeof(ap->arp_spa) )
+	{
+#ifdef RARP_DEBUG
+		if (debug)
+			printf("bad hrd/pro/hln/pln\n");
+#endif
+		return (-1);
+	}
+
+	if (ap->arp_op != htons(ARPOP_REVREPLY)) {
+#ifdef RARP_DEBUG
+		if (debug)
+			printf("bad op=0x%x\n", ntohs(ap->arp_op));
+#endif
+		return (-1);
+	}
+
+	/* Is the reply for our Ethernet address? */
+	if (bcmp(ap->arp_tha, d->myea, 6)) {
+#ifdef RARP_DEBUG
+		if (debug)
+			printf("unwanted address\n");
+#endif
+		return (-1);
+	}
+
+	/* We have our answer. */
+#ifdef RARP_DEBUG
+ 	if (debug)
+		printf("got it\n");
+#endif
+	return (n);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/read.c sys/boot/i386/pxe_ng/libstand/read.c
--- sys/boot/i386/pxe_ng/libstand/read.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/read.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,127 @@
+/*	$NetBSD: read.c,v 1.8 1997/01/22 00:38:12 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)read.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include "stand.h"
+
+ssize_t
+read(int fd, void *dest, size_t bcount)
+{
+    struct open_file	*f = &files[fd];
+    size_t		resid;
+
+    if ((unsigned)fd >= SOPEN_MAX || !(f->f_flags & F_READ)) {
+	errno = EBADF;
+	return (-1);
+    }
+    if (f->f_flags & F_RAW) {
+	twiddle();
+	errno = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+					btodb(f->f_offset), bcount, dest, &resid);
+	if (errno)
+	    return (-1);
+	f->f_offset += resid;
+	return (resid);
+    } 
+
+    /*
+     * Optimise reads from regular files using a readahead buffer.
+     * If the request can't be satisfied from the current buffer contents,
+     * check to see if it should be bypassed, or refill the buffer and complete
+     * the request.
+     */
+    resid = bcount;
+    for (;;) {
+	size_t	ccount, cresid;
+	/* how much can we supply? */
+	ccount = imin(f->f_ralen, resid);
+	if (ccount > 0) {
+	    bcopy(f->f_rabuf + f->f_raoffset, dest, ccount);
+	    f->f_raoffset += ccount;
+	    f->f_ralen -= ccount;
+	    resid -= ccount;
+	    if (resid == 0)
+		return(bcount);
+	    dest = (char *)dest + ccount;
+	}
+
+	/* will filling the readahead buffer again not help? */
+	if (resid >= SOPEN_RASIZE) {
+	    /* bypass the rest of the request and leave the buffer empty */
+	    if ((errno = (f->f_ops->fo_read)(f, dest, resid, &cresid)))
+		    return (-1);
+	    return(bcount - cresid);
+	}
+
+	/* fetch more data */
+	if ((errno = (f->f_ops->fo_read)(f, f->f_rabuf, SOPEN_RASIZE, &cresid)))
+	    return (-1);
+	f->f_raoffset = 0;
+	f->f_ralen = SOPEN_RASIZE - cresid;
+	/* no more data, return what we had */
+	if (f->f_ralen == 0)
+	    return(bcount - resid);
+    }	
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/readdir.c sys/boot/i386/pxe_ng/libstand/readdir.c
--- sys/boot/i386/pxe_ng/libstand/readdir.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/readdir.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,51 @@
+/*-
+ * Copyright (c) 1999,2000 Jonathan Lemon <jlemon@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include "stand.h"
+
+struct dirent *
+readdirfd(int fd)
+{
+	static struct dirent dir;		/* XXX not thread safe */
+	struct open_file *f = &files[fd];
+
+	if ((unsigned)fd >= SOPEN_MAX || !(f->f_flags & F_READ)) {
+		errno = EBADF;
+		return (NULL);
+	}
+	if (f->f_flags & F_RAW) {
+		errno = EIO;
+		return (NULL);
+	}
+	errno = (f->f_ops->fo_readdir)(f, &dir);
+	if (errno)
+		return (NULL);
+	return (&dir);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/rpc.c sys/boot/i386/pxe_ng/libstand/rpc.c
--- sys/boot/i386/pxe_ng/libstand/rpc.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/rpc.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,439 @@
+/*	$NetBSD: rpc.c,v 1.18 1998/01/23 19:27:45 thorpej Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: rpc.c,v 1.12 93/09/28 08:31:56 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * RPC functions used by NFS and bootparams.
+ * Note that bootparams requires the ability to find out the
+ * address of the server from which its response has come.
+ * This is supported by keeping the IP/UDP headers in the
+ * buffer space provided by the caller.  (See rpc_fromaddr)
+ */
+
+#include <sys/param.h>
+#include <sys/socket.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+
+#include <string.h>
+
+#include "rpcv2.h"
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+#include "rpc.h"
+
+struct auth_info {
+	int32_t 	authtype;	/* auth type */
+	u_int32_t	authlen;	/* auth length */
+};
+
+struct auth_unix {
+	int32_t   ua_time;
+	int32_t   ua_hostname;	/* null */
+	int32_t   ua_uid;
+	int32_t   ua_gid;
+	int32_t   ua_gidlist;	/* null */
+};
+
+struct rpc_call {
+	u_int32_t	rp_xid;		/* request transaction id */
+	int32_t 	rp_direction;	/* call direction (0) */
+	u_int32_t	rp_rpcvers;	/* rpc version (2) */
+	u_int32_t	rp_prog;	/* program */
+	u_int32_t	rp_vers;	/* version */
+	u_int32_t	rp_proc;	/* procedure */
+};
+
+struct rpc_reply {
+	u_int32_t	rp_xid;		/* request transaction id */
+	int32_t 	rp_direction;	/* call direction (1) */
+	int32_t 	rp_astatus;	/* accept status (0: accepted) */
+	union {
+		u_int32_t	rpu_errno;
+		struct {
+			struct auth_info rok_auth;
+			u_int32_t	rok_status;
+		} rpu_rok;
+	} rp_u;
+};
+
+/* Local forwards */
+static	ssize_t recvrpc(struct iodesc *, void *, size_t, time_t);
+static	int rpc_getport(struct iodesc *, n_long, n_long);
+
+int rpc_xid;
+int rpc_port = 0x400;	/* predecrement */
+
+/*
+ * Make a rpc call; return length of answer
+ * Note: Caller must leave room for headers.
+ */
+ssize_t
+rpc_call(d, prog, vers, proc, sdata, slen, rdata, rlen)
+	struct iodesc *d;
+	n_long prog, vers, proc;
+	void *sdata;
+	size_t slen;
+	void *rdata;
+	size_t rlen;
+{
+	ssize_t cc;
+	struct auth_info *auth;
+	struct rpc_call *call;
+	struct rpc_reply *reply;
+	char *send_head, *send_tail;
+	char *recv_head, *recv_tail;
+	n_long x;
+	int port;	/* host order */
+
+#ifdef RPC_DEBUG
+	if (debug)
+		printf("rpc_call: prog=0x%x vers=%d proc=%d\n",
+		    prog, vers, proc);
+#endif
+
+	port = rpc_getport(d, prog, vers);
+	if (port == -1)
+		return (-1);
+
+	d->destport = htons(port);
+
+	/*
+	 * Prepend authorization stuff and headers.
+	 * Note, must prepend things in reverse order.
+	 */
+	send_head = sdata;
+	send_tail = (char *)sdata + slen;
+
+	/* Auth verifier is always auth_null */
+	send_head -= sizeof(*auth);
+	auth = (struct auth_info *)send_head;
+	auth->authtype = htonl(RPCAUTH_NULL);
+	auth->authlen = 0;
+
+#if 1
+	/* Auth credentials: always auth unix (as root) */
+	send_head -= sizeof(struct auth_unix);
+	bzero(send_head, sizeof(struct auth_unix));
+	send_head -= sizeof(*auth);
+	auth = (struct auth_info *)send_head;
+	auth->authtype = htonl(RPCAUTH_UNIX);
+	auth->authlen = htonl(sizeof(struct auth_unix));
+#else
+	/* Auth credentials: always auth_null (XXX OK?) */
+	send_head -= sizeof(*auth);
+	auth = send_head;
+	auth->authtype = htonl(RPCAUTH_NULL);
+	auth->authlen = 0;
+#endif
+
+	/* RPC call structure. */
+	send_head -= sizeof(*call);
+	call = (struct rpc_call *)send_head;
+	rpc_xid++;
+	call->rp_xid       = htonl(rpc_xid);
+	call->rp_direction = htonl(RPC_CALL);
+	call->rp_rpcvers   = htonl(RPC_VER2);
+	call->rp_prog = htonl(prog);
+	call->rp_vers = htonl(vers);
+	call->rp_proc = htonl(proc);
+
+	/* Make room for the rpc_reply header. */
+	recv_head = rdata;
+	recv_tail = (char *)rdata + rlen;
+	recv_head -= sizeof(*reply);
+
+	cc = sendrecv(d,
+	    sendudp, send_head, send_tail - send_head,
+	    recvrpc, recv_head, recv_tail - recv_head);
+
+#ifdef RPC_DEBUG
+	if (debug)
+		printf("callrpc: cc=%ld rlen=%lu\n", (long)cc, (u_long)rlen);
+#endif
+	if (cc == -1)
+		return (-1);
+
+	if (cc <= sizeof(*reply)) {
+		errno = EBADRPC;
+		return (-1);
+	}
+
+	recv_tail = recv_head + cc;
+
+	/*
+	 * Check the RPC reply status.
+	 * The xid, dir, astatus were already checked.
+	 */
+	reply = (struct rpc_reply *)recv_head;
+	auth = &reply->rp_u.rpu_rok.rok_auth;
+	x = ntohl(auth->authlen);
+	if (x != 0) {
+#ifdef RPC_DEBUG
+		if (debug)
+			printf("callrpc: reply auth != NULL\n");
+#endif
+		errno = EBADRPC;
+		return(-1);
+	}
+	x = ntohl(reply->rp_u.rpu_rok.rok_status);
+	if (x != 0) {
+		printf("callrpc: error = %ld\n", (long)x);
+		errno = EBADRPC;
+		return(-1);
+	}
+	recv_head += sizeof(*reply);
+
+	return (ssize_t)(recv_tail - recv_head);
+}
+
+/*
+ * Returns true if packet is the one we're waiting for.
+ * This just checks the XID, direction, acceptance.
+ * Remaining checks are done by callrpc
+ */
+static ssize_t
+recvrpc(d, pkt, len, tleft)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	time_t tleft;
+{
+	struct rpc_reply *reply;
+	ssize_t	n;
+	int	x;
+
+	errno = 0;
+#ifdef RPC_DEBUG
+	if (debug)
+		printf("recvrpc: called len=%lu\n", (u_long)len);
+#endif
+
+	n = readudp(d, pkt, len, tleft);
+	if (n <= (4 * 4))
+		return -1;
+
+	reply = (struct rpc_reply *)pkt;
+
+	x = ntohl(reply->rp_xid);
+	if (x != rpc_xid) {
+#ifdef RPC_DEBUG
+		if (debug)
+			printf("recvrpc: rp_xid %d != xid %d\n", x, rpc_xid);
+#endif
+		return -1;
+	}
+
+	x = ntohl(reply->rp_direction);
+	if (x != RPC_REPLY) {
+#ifdef RPC_DEBUG
+		if (debug)
+			printf("recvrpc: rp_direction %d != REPLY\n", x);
+#endif
+		return -1;
+	}
+
+	x = ntohl(reply->rp_astatus);
+	if (x != RPC_MSGACCEPTED) {
+		errno = ntohl(reply->rp_u.rpu_errno);
+		printf("recvrpc: reject, astat=%d, errno=%d\n", x, errno);
+		return -1;
+	}
+
+	/* Return data count (thus indicating success) */
+	return (n);
+}
+
+/*
+ * Given a pointer to a reply just received,
+ * dig out the IP address/port from the headers.
+ */
+void
+rpc_fromaddr(pkt, addr, port)
+	void		*pkt;
+	struct in_addr	*addr;
+	u_short		*port;
+{
+	struct hackhdr {
+		/* Tail of IP header: just IP addresses */
+		n_long ip_src;
+		n_long ip_dst;
+		/* UDP header: */
+		u_int16_t uh_sport;		/* source port */
+		u_int16_t uh_dport;		/* destination port */
+		int16_t	  uh_ulen;		/* udp length */
+		u_int16_t uh_sum;		/* udp checksum */
+		/* RPC reply header: */
+		struct rpc_reply rpc;
+	} *hhdr;
+
+	hhdr = ((struct hackhdr *)pkt) - 1;
+	addr->s_addr = hhdr->ip_src;
+	*port = hhdr->uh_sport;
+}
+
+/*
+ * RPC Portmapper cache
+ */
+#define PMAP_NUM 8			/* need at most 5 pmap entries */
+
+int rpc_pmap_num;
+struct pmap_list {
+	struct in_addr	addr;	/* server, net order */
+	u_int	prog;		/* host order */
+	u_int	vers;		/* host order */
+	int 	port;		/* host order */
+} rpc_pmap_list[PMAP_NUM];
+
+/* return port number in host order, or -1 */
+int
+rpc_pmap_getcache(addr, prog, vers)
+	struct in_addr	addr;	/* server, net order */
+	u_int		prog;	/* host order */
+	u_int		vers;	/* host order */
+{
+	struct pmap_list *pl;
+
+	for (pl = rpc_pmap_list; pl < &rpc_pmap_list[rpc_pmap_num]; pl++) {
+		if (pl->addr.s_addr == addr.s_addr &&
+			pl->prog == prog && pl->vers == vers )
+		{
+			return (pl->port);
+		}
+	}
+	return (-1);
+}
+
+void
+rpc_pmap_putcache(addr, prog, vers, port)
+	struct in_addr	addr;	/* server, net order */
+	u_int		prog;	/* host order */
+	u_int		vers;	/* host order */
+	int 		port;	/* host order */
+{
+	struct pmap_list *pl;
+
+	/* Don't overflow cache... */
+	if (rpc_pmap_num >= PMAP_NUM) {
+		/* ... just re-use the last entry. */
+		rpc_pmap_num = PMAP_NUM - 1;
+#ifdef	RPC_DEBUG
+		printf("rpc_pmap_putcache: cache overflow\n");
+#endif
+	}
+
+	pl = &rpc_pmap_list[rpc_pmap_num];
+	rpc_pmap_num++;
+
+	/* Cache answer */
+	pl->addr = addr;
+	pl->prog = prog;
+	pl->vers = vers;
+	pl->port = port;
+}
+
+
+/*
+ * Request a port number from the port mapper.
+ * Returns the port in host order.
+ */
+int
+rpc_getport(d, prog, vers)
+	struct iodesc *d;
+	n_long prog;	/* host order */
+	n_long vers;	/* host order */
+{
+	struct args {
+		n_long	prog;		/* call program */
+		n_long	vers;		/* call version */
+		n_long	proto;		/* call protocol */
+		n_long	port;		/* call port (unused) */
+	} *args;
+	struct res {
+		n_long port;
+	} *res;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct args d;
+	} sdata;
+	struct {
+		n_long	h[RPC_HEADER_WORDS];
+		struct res d;
+		n_long  pad;
+	} rdata;
+	ssize_t cc;
+	int port;
+
+#ifdef RPC_DEBUG
+	if (debug)
+		printf("getport: prog=0x%x vers=%d\n", prog, vers);
+#endif
+
+	/* This one is fixed forever. */
+	if (prog == PMAPPROG)
+		return (PMAPPORT);
+
+	/* Try for cached answer first */
+	port = rpc_pmap_getcache(d->destip, prog, vers);
+	if (port != -1)
+		return (port);
+
+	args = &sdata.d;
+	args->prog = htonl(prog);
+	args->vers = htonl(vers);
+	args->proto = htonl(IPPROTO_UDP);
+	args->port = 0;
+	res = &rdata.d;
+
+	cc = rpc_call(d, PMAPPROG, PMAPVERS, PMAPPROC_GETPORT,
+		args, sizeof(*args), res, sizeof(*res));
+	if (cc < sizeof(*res)) {
+		printf("getport: %s", strerror(errno));
+		errno = EBADRPC;
+		return (-1);
+	}
+	port = (int)ntohl(res->port);
+
+	rpc_pmap_putcache(d->destip, prog, vers, port);
+
+	return (port);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/rpc.h sys/boot/i386/pxe_ng/libstand/rpc.h
--- sys/boot/i386/pxe_ng/libstand/rpc.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/rpc.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,66 @@
+/*	$NetBSD: rpc.h,v 1.8 1996/09/26 23:22:03 cgd Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/* XXX defines we can't easily get from system includes */
+#define	PMAPPORT		111
+#define	PMAPPROG		100000
+#define	PMAPVERS		2
+#define	PMAPPROC_NULL		0
+#define	PMAPPROC_SET		1
+#define	PMAPPROC_UNSET		2
+#define	PMAPPROC_GETPORT	3
+#define	PMAPPROC_DUMP		4
+#define	PMAPPROC_CALLIT		5
+
+/* RPC functions: */
+ssize_t	rpc_call(struct iodesc *, n_long, n_long, n_long,
+		     void *, size_t, void *, size_t);
+void	rpc_fromaddr(void *, struct in_addr *, u_short *);
+int	rpc_pmap_getcache(struct in_addr, u_int, u_int);
+void	rpc_pmap_putcache(struct in_addr, u_int, u_int, int);
+
+extern int rpc_port;	/* decrement before bind */
+
+/*
+ * How much space to leave in front of RPC requests.
+ * In 32-bit words (alignment) we have:
+ * 12: Ether + IP + UDP + padding
+ *  6: RPC call header
+ *  7: Auth UNIX
+ *  2: Auth NULL
+ */
+#define	RPC_HEADER_WORDS 28
diff -ruN sys/boot/i386/pxe_ng/libstand/rpcv2.h sys/boot/i386/pxe_ng/libstand/rpcv2.h
--- sys/boot/i386/pxe_ng/libstand/rpcv2.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/rpcv2.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,87 @@
+/*	$NetBSD: rpcv2.h,v 1.1 1996/02/26 23:05:32 gwr Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Rick Macklem at The University of Guelph.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)rpcv2.h	8.1 (Berkeley) 6/10/93
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * Definitions for Sun RPC Version 2, from
+ * "RPC: Remote Procedure Call Protocol Specification" RFC1057
+ */
+
+/* Version # */
+#define	RPC_VER2	2
+
+/* Authentication */
+#define	RPCAUTH_NULL	0
+#define	RPCAUTH_UNIX	1
+#define	RPCAUTH_SHORT	2
+#define	RPCAUTH_MAXSIZ	400
+#define	RPCAUTH_UNIXGIDS 16
+
+/* Rpc Constants */
+#define	RPC_CALL	0
+#define	RPC_REPLY	1
+#define	RPC_MSGACCEPTED	0
+#define	RPC_MSGDENIED	1
+#define	RPC_PROGUNAVAIL	1
+#define	RPC_PROGMISMATCH	2
+#define	RPC_PROCUNAVAIL	3
+#define	RPC_GARBAGE	4		/* I like this one */
+#define	RPC_MISMATCH	0
+#define	RPC_AUTHERR	1
+
+/* Authentication failures */
+#define	AUTH_BADCRED	1
+#define	AUTH_REJECTCRED	2
+#define	AUTH_BADVERF	3
+#define	AUTH_REJECTVERF	4
+#define	AUTH_TOOWEAK	5		/* Give em wheaties */
+
+/* Sizes of rpc header parts */
+#define	RPC_SIZ		24
+#define	RPC_REPLYSIZ	28
+
+/* RPC Prog definitions */
+#define	RPCPROG_MNT	100005
+#define	RPCMNT_VER1	1
+#define	RPCMNT_MOUNT	1
+#define	RPCMNT_DUMP	2
+#define	RPCMNT_UMOUNT	3
+#define	RPCMNT_UMNTALL	4
+#define	RPCMNT_EXPORT	5
+#define	RPCMNT_NAMELEN	255
+#define	RPCMNT_PATHLEN	1024
+#define	RPCPROG_NFS	100003
diff -ruN sys/boot/i386/pxe_ng/libstand/saioctl.h sys/boot/i386/pxe_ng/libstand/saioctl.h
--- sys/boot/i386/pxe_ng/libstand/saioctl.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/saioctl.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,50 @@
+/*	$NetBSD: saioctl.h,v 1.2 1994/10/26 05:45:04 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)saioctl.h	8.1 (Berkeley) 6/11/93
+ *
+ * $FreeBSD$
+ */
+
+/* ioctl's -- for disks just now */
+#define	SAIOHDR		(('d'<<8)|1)	/* next i/o includes header */
+#define	SAIOCHECK	(('d'<<8)|2)	/* next i/o checks data */
+#define	SAIOHCHECK	(('d'<<8)|3)	/* next i/o checks header & data */
+#define	SAIONOBAD	(('d'<<8)|4)	/* inhibit bad sector forwarding */
+#define	SAIODOBAD	(('d'<<8)|5)	/* enable bad sector forwarding */
+#define	SAIOECCLIM	(('d'<<8)|6)	/* set limit to ecc correction, bits */
+#define	SAIOECCUNL	(('d'<<8)|7)	/* use standard ecc procedures */
+#define	SAIORETRIES	(('d'<<8)|8)	/* set retry count for unit */
+#define	SAIODEVDATA	(('d'<<8)|9)	/* get pointer to pack label */
+#define	SAIOSSI		(('d'<<8)|10)	/* set skip sector inhibit */
+#define	SAIONOSSI	(('d'<<8)|11)	/* inhibit skip sector handling */
+#define	SAIOSSDEV	(('d'<<8)|12)	/* is device skip sector type? */
+#define	SAIODEBUG	(('d'<<8)|13)	/* enable/disable debugging */
+#define	SAIOGBADINFO	(('d'<<8)|14)	/* get bad-sector table */
diff -ruN sys/boot/i386/pxe_ng/libstand/sbrk.c sys/boot/i386/pxe_ng/libstand/sbrk.c
--- sys/boot/i386/pxe_ng/libstand/sbrk.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/sbrk.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,62 @@
+/*-
+ * Copyright (c) 1998 Michael Smith
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Minimal sbrk() emulation required for malloc support.
+ */
+
+#include <string.h>
+#include "stand.h"
+
+static size_t	maxheap, heapsize = 0;
+static void	*heapbase;
+
+void
+setheap(void *base, void *top)
+{
+    /* Align start address to 16 bytes for the malloc code. Sigh. */
+    heapbase = (void *)(((uintptr_t)base + 15) & ~15);
+    maxheap = (char *)top - (char *)heapbase;
+}
+
+char *
+sbrk(int incr)
+{
+    char	*ret;
+    
+    if ((heapsize + incr) <= maxheap) {
+	ret = (char *)heapbase + heapsize;
+	bzero(ret, incr);
+	heapsize += incr;
+	return(ret);
+    }
+    errno = ENOMEM;
+    return((char *)-1);
+}
+
diff -ruN sys/boot/i386/pxe_ng/libstand/sparc64/_setjmp.S sys/boot/i386/pxe_ng/libstand/sparc64/_setjmp.S
--- sys/boot/i386/pxe_ng/libstand/sparc64/_setjmp.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/sparc64/_setjmp.S	2009-02-20 12:30:54.000000000 -0500
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	$Header: _setjmp.s,v 1.1 91/07/06 16:45:53 torek Exp
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+	.asciz "@(#)_setjmp.s	8.1 (Berkeley) 6/4/93"
+#else
+	RCSID("$NetBSD: _setjmp.S,v 1.4 1998/10/08 02:27:59 eeh Exp $")
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include <machine/asm.h>
+__FBSDID("$FreeBSD$");
+
+#define	_JB_FP		0x0
+#define	_JB_PC		0x8
+#define	_JB_SP		0x10
+
+	.register %g2,#ignore
+	.register %g3,#ignore
+
+/*
+ * C library -- setjmp, longjmp
+ *
+ *	longjmp(a,v)
+ * will generate a "return(v?v:1)" from
+ * the last call to
+ *	setjmp(a)
+ * by restoring the previous context.
+ */
+
+ENTRY(_setjmp)
+	stx	%sp, [%o0 + _JB_SP]
+	stx	%o7, [%o0 + _JB_PC]
+	stx	%fp, [%o0 + _JB_FP]
+	retl
+	 clr	%o0
+END(_setjmp)
+
+ENTRY(_longjmp)
+	mov	1, %g1
+	movrnz	%o1, %o1, %g1
+	mov	%o0, %g2
+	ldx	[%g2 + _JB_FP], %g3
+1:	cmp	%fp, %g3
+	bl,a	1b
+	 restore
+	be,a	2f
+	 ldx	[%g2 + _JB_SP], %o0
+
+.Lbotch:
+	illtrap
+
+2:	cmp	%o0, %sp
+	bge,a	3f
+	 mov	%o0, %sp
+	b,a	.Lbotch
+	 nop
+3:	ldx	[%g2 + _JB_PC], %o7
+	retl
+	 mov	%g1, %o0
+END(_longjmp)
diff -ruN sys/boot/i386/pxe_ng/libstand/splitfs.c sys/boot/i386/pxe_ng/libstand/splitfs.c
--- sys/boot/i386/pxe_ng/libstand/splitfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/splitfs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,313 @@
+/* 
+ * Copyright (c) 2002 Maxim Sobolev
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+#define NTRIES		(3)
+#define CONF_BUF	(512)
+#define SEEK_BUF	(512)
+
+struct split_file
+{
+    char  **filesv;	/* Filenames */
+    char  **descsv;	/* Descriptions */
+    int	  filesc;	/* Number of parts */
+    int	  curfile;	/* Current file number */
+    int	  curfd;	/* Current file descriptor */
+    off_t tot_pos;	/* Offset from the beginning of the sequence */
+    off_t file_pos;	/* Offset from the beginning of the slice */
+};
+
+static int	split_openfile(struct split_file *sf);
+static int	splitfs_open(const char *path, struct open_file *f);
+static int	splitfs_close(struct open_file *f);
+static int	splitfs_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	splitfs_seek(struct open_file *f, off_t offset, int where);
+static int	splitfs_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops splitfs_fsops = {
+    "split",
+    splitfs_open, 
+    splitfs_close, 
+    splitfs_read,
+    null_write,
+    splitfs_seek,
+    splitfs_stat,
+    null_readdir
+};
+
+static void
+split_file_destroy(struct split_file *sf)
+{
+    int i;
+
+    if (sf->filesc > 0) {
+	for (i = 0; i < sf->filesc; i++) {
+	    free(sf->filesv[i]);
+	    free(sf->descsv[i]);
+	}
+	free(sf->filesv);
+	free(sf->descsv);
+    }
+    free(sf);
+}
+
+static int
+split_openfile(struct split_file *sf)
+{
+    int i;
+
+    for (i = 0;; i++) {
+	sf->curfd = open(sf->filesv[sf->curfile], O_RDONLY);
+	if (sf->curfd >= 0)
+	    break;
+	if ((sf->curfd == -1) && (errno != ENOENT))
+	    return (errno);
+	if (i == NTRIES)
+	    return (EIO);
+	printf("\nInsert disk labelled %s and press any key...",
+	    sf->descsv[sf->curfile]);
+	getchar();
+	putchar('\n');
+    }
+    sf->file_pos = 0;
+    return (0);
+}
+
+static int
+splitfs_open(const char *fname, struct open_file *f)
+{
+    char *buf, *confname, *cp;
+    int	conffd;
+    struct split_file *sf;
+    struct stat sb;
+
+    /* Have to be in "just read it" mode */
+    if (f->f_flags != F_READ)
+	return(EPERM);
+
+    /* If the name already ends in `.split', ignore it */
+    if ((cp = strrchr(fname, '.')) && (!strcmp(cp, ".split")))
+	return(ENOENT);
+
+    /* Construct new name */
+    confname = malloc(strlen(fname) + 7);
+    sprintf(confname, "%s.split", fname);
+
+    /* Try to open the configuration file */
+    conffd = open(confname, O_RDONLY);
+    free(confname);
+    if (conffd == -1)
+	return(ENOENT);
+
+    if (fstat(conffd, &sb) < 0) {
+	printf("splitfs_open: stat failed\n");
+	close(conffd);
+	return(ENOENT);
+    }
+    if (!S_ISREG(sb.st_mode)) {
+	printf("splitfs_open: not a file\n");
+	close(conffd);
+	return(EISDIR);			/* best guess */
+    }
+
+    /* Allocate a split_file structure, populate it from the config file */
+    sf = malloc(sizeof(struct split_file));
+    bzero(sf, sizeof(struct split_file));
+    buf = malloc(CONF_BUF);
+    while (fgetstr(buf, CONF_BUF, conffd) > 0) {
+	cp = buf;
+	while ((*cp != '\0') && (isspace(*cp) == 0))
+	    cp++;
+	if (*cp != '\0') {
+	    *cp = '\0';
+	    cp++;
+	}
+	while ((*cp != '\0') && (isspace(*cp) != 0))
+	    cp++;
+	if (*cp == '\0')
+	    cp = buf;
+	sf->filesc++;
+	sf->filesv = realloc(sf->filesv, sizeof(*(sf->filesv)) * sf->filesc);
+	sf->descsv = realloc(sf->descsv, sizeof(*(sf->descsv)) * sf->filesc);
+	sf->filesv[sf->filesc - 1] = strdup(buf);
+	sf->descsv[sf->filesc - 1] = strdup(cp);
+    }
+    free(buf);
+    close(conffd);
+
+    if (sf->filesc == 0) {
+	split_file_destroy(sf);
+	return(ENOENT);
+    }
+    errno = split_openfile(sf);
+    if (errno != 0) {
+	split_file_destroy(sf);
+	return(ENOENT);
+    }
+
+    /* Looks OK, we'll take it */
+    f->f_fsdata = sf;
+    return (0);
+}
+
+static int
+splitfs_close(struct open_file *f)
+{
+    int fd;
+    struct split_file *sf;
+
+    sf = (struct split_file *)f->f_fsdata;
+    fd = sf->curfd;
+    split_file_destroy(sf);
+    return(close(fd));
+}
+ 
+static int 
+splitfs_read(struct open_file *f, void *buf, size_t size, size_t *resid)
+{
+    ssize_t nread;
+    size_t totread;
+    struct split_file *sf;
+
+    sf = (struct split_file *)f->f_fsdata;
+    totread = 0;
+    do {
+	nread = read(sf->curfd, buf, size - totread);
+
+	/* Error? */
+	if (nread == -1)
+	    return (errno);
+
+	sf->tot_pos += nread;
+	sf->file_pos += nread;
+	totread += nread;
+	buf = (char *)buf + nread;
+
+	if (totread < size) {				/* EOF */
+	    if (sf->curfile == (sf->filesc - 1))	/* Last slice */
+		break;
+
+	    /* Close previous slice */
+	    if (close(sf->curfd) != 0)
+		return (errno);
+
+	    sf->curfile++;
+	    errno = split_openfile(sf);
+	    if (errno)
+		    return (errno);
+	}
+    } while (totread < size);
+
+    if (resid != NULL)
+	*resid = size - totread;
+
+    return (0);
+}
+
+static off_t
+splitfs_seek(struct open_file *f, off_t offset, int where)
+{
+    int nread;
+    size_t resid;
+    off_t new_pos, seek_by;
+    struct split_file *sf;
+
+    sf = (struct split_file *)f->f_fsdata;
+
+    seek_by = offset;
+    switch (where) {
+    case SEEK_SET:
+	seek_by -= sf->tot_pos;
+	break;
+    case SEEK_CUR:
+	break;
+    case SEEK_END:
+	panic("splitfs_seek: SEEK_END not supported");
+	break;
+    default:
+	errno = EINVAL;
+	return (-1);
+    }
+
+    if (seek_by > 0) {
+	/*
+	 * Seek forward - implemented using splitfs_read(), because otherwise we'll be
+	 * unable to detect that we have crossed slice boundary and hence
+	 * unable to do a long seek crossing that boundary.
+	 */
+	void *tmp;
+
+	tmp = malloc(SEEK_BUF);
+	if (tmp == NULL) {
+	    errno = ENOMEM;
+	    return (-1);
+	}
+
+	nread = 0;
+	for (; seek_by > 0; seek_by -= nread) {
+	    resid = 0;
+	    errno = splitfs_read(f, tmp, min(seek_by, SEEK_BUF), &resid);
+	    nread = min(seek_by, SEEK_BUF) - resid;
+	    if ((errno != 0) || (nread == 0))
+		/* Error or EOF */
+		break;
+	}
+	free(tmp);
+	if (errno != 0)
+	    return (-1);
+    }
+
+    if (seek_by != 0) {
+	/* Seek backward or seek past the boundary of the last slice */
+	if (sf->file_pos + seek_by < 0)
+	    panic("splitfs_seek: can't seek past the beginning of the slice");
+	new_pos = lseek(sf->curfd, seek_by, SEEK_CUR);
+	if (new_pos < 0) {
+	    errno = EINVAL;
+	    return (-1);
+	}
+	sf->tot_pos += new_pos - sf->file_pos;
+	sf->file_pos = new_pos;
+    }
+
+    return (sf->tot_pos);
+}
+
+static int
+splitfs_stat(struct open_file *f, struct stat *sb)
+{
+    int	result;
+    struct split_file *sf = (struct split_file *)f->f_fsdata;
+
+    /* stat as normal, but indicate that size is unknown */
+    if ((result = fstat(sf->curfd, sb)) == 0)
+	sb->st_size = -1;
+    return (result);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/stand.h sys/boot/i386/pxe_ng/libstand/stand.h
--- sys/boot/i386/pxe_ng/libstand/stand.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/stand.h	2009-03-02 20:20:09.000000000 -0500
@@ -0,0 +1,412 @@
+/*
+ * Copyright (c) 1998 Michael Smith.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libstand/stand.h,v 1.42 2007/01/09 01:02:04 imp Exp $
+ * From	$NetBSD: stand.h,v 1.22 1997/06/26 19:17:40 drochner Exp $	
+ */
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)stand.h	8.1 (Berkeley) 6/11/93
+ */
+
+#ifndef	STAND_H
+#define	STAND_H
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+#include <sys/stat.h>
+#include <sys/dirent.h>
+#include <string.h>
+
+#define CHK(fmt, args...)	printf("%s(%d): " fmt "\n", __func__, __LINE__ , ##args)
+#define PCHK(fmt, args...)	{printf("%s(%d): " fmt "\n", __func__, __LINE__ , ##args); getchar();}
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+/* Avoid unwanted userlandish components */
+#define _KERNEL
+#include <sys/errno.h>
+#undef _KERNEL
+
+/* special stand error codes */
+#define	EADAPT	(ELAST+1)	/* bad adaptor */
+#define	ECTLR	(ELAST+2)	/* bad controller */
+#define	EUNIT	(ELAST+3)	/* bad unit */
+#define ESLICE	(ELAST+4)	/* bad slice */
+#define	EPART	(ELAST+5)	/* bad partition */
+#define	ERDLAB	(ELAST+6)	/* can't read disk label */
+#define	EUNLAB	(ELAST+7)	/* unlabeled disk */
+#define	EOFFSET	(ELAST+8)	/* relative seek not supported */
+#define	ESALAST	(ELAST+8)	/* */
+
+struct open_file;
+
+/*
+ * This structure is used to define file system operations in a file system
+ * independent way.
+ *
+ * XXX note that filesystem providers should export a pointer to their fs_ops
+ *     struct, so that consumers can reference this and thus include the
+ *     filesystems that they require.
+ */
+struct fs_ops {
+    const char	*fs_name;
+    int		(*fo_open)(const char *path, struct open_file *f);
+    int		(*fo_close)(struct open_file *f);
+    int		(*fo_read)(struct open_file *f, void *buf,
+			   size_t size, size_t *resid);
+    int		(*fo_write)(struct open_file *f, void *buf,
+			    size_t size, size_t *resid);
+    off_t	(*fo_seek)(struct open_file *f, off_t offset, int where);
+    int		(*fo_stat)(struct open_file *f, struct stat *sb);
+    int		(*fo_readdir)(struct open_file *f, struct dirent *d);
+};
+
+/*
+ * libstand-supplied filesystems
+ */
+extern struct fs_ops ufs_fsops;
+extern struct fs_ops tftp_fsops;
+extern struct fs_ops nfs_fsops;
+extern struct fs_ops cd9660_fsops;
+extern struct fs_ops gzipfs_fsops;
+extern struct fs_ops bzipfs_fsops;
+extern struct fs_ops dosfs_fsops;
+extern struct fs_ops ext2fs_fsops;
+extern struct fs_ops splitfs_fsops;
+
+/* where values for lseek(2) */
+#define	SEEK_SET	0	/* set file offset to offset */
+#define	SEEK_CUR	1	/* set file offset to current plus offset */
+#define	SEEK_END	2	/* set file offset to EOF plus offset */
+
+/* 
+ * Device switch
+ */
+struct devsw {
+    const char	dv_name[8];
+    int		dv_type;		/* opaque type constant, arch-dependant */
+    int		(*dv_init)(void);	/* early probe call */
+    int		(*dv_strategy)(void *devdata, int rw, daddr_t blk, size_t size,
+			       char *buf, size_t *rsize);
+    int		(*dv_open)(struct open_file *f, ...);
+    int		(*dv_close)(struct open_file *f);
+    int		(*dv_ioctl)(struct open_file *f, u_long cmd, void *data);
+    void	(*dv_print)(int verbose);	/* print device information */
+    void	(*dv_cleanup)(void);
+};
+
+/*
+ * libstand-supplied device switch
+ */
+extern struct devsw netdev;
+
+extern int errno;
+
+struct open_file {
+    int			f_flags;	/* see F_* below */
+    struct devsw	*f_dev;		/* pointer to device operations */
+    void		*f_devdata;	/* device specific data */
+    struct fs_ops	*f_ops;		/* pointer to file system operations */
+    void		*f_fsdata;	/* file system specific data */
+    off_t		f_offset;	/* current file offset */
+    char		*f_rabuf;	/* readahead buffer pointer */
+    size_t		f_ralen;	/* valid data in readahead buffer */
+    off_t		f_raoffset;	/* consumer offset in readahead buffer */
+#define SOPEN_RASIZE	512
+};
+
+#define	SOPEN_MAX	8
+extern struct open_file files[];
+
+/* f_flags values */
+#define	F_READ		0x0001	/* file opened for reading */
+#define	F_WRITE		0x0002	/* file opened for writing */
+#define	F_RAW		0x0004	/* raw device open - no file system */
+#define F_NODEV		0x0008	/* network open - no device */
+
+#define isascii(c)	(((c) & ~0x7F) == 0)
+
+static __inline int isupper(int c)
+{
+    return c >= 'A' && c <= 'Z';
+}
+
+static __inline int islower(int c)
+{
+    return c >= 'a' && c <= 'z';
+}
+
+static __inline int isspace(int c)
+{
+    return c == ' ' || (c >= 0x9 && c <= 0xd);
+}
+
+static __inline int isdigit(int c)
+{
+    return c >= '0' && c <= '9';
+}
+
+static __inline int isxdigit(int c)
+{
+    return isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
+}
+
+static __inline int isalpha(int c)
+{
+    return isupper(c) || islower(c);
+}
+
+static __inline int isalnum(int c)
+{
+    return isalpha(c) || isdigit(c);
+}
+
+static __inline int toupper(int c)
+{
+    return islower(c) ? c - 'a' + 'A' : c;
+}
+
+static __inline int tolower(int c)
+{
+    return isupper(c) ? c - 'A' + 'a' : c;
+}
+
+/* sbrk emulation */
+extern void	setheap(void *base, void *top);
+extern char	*sbrk(int incr);
+
+/* Matt Dillon's zalloc/zmalloc */
+extern void	*malloc(size_t bytes);
+extern void	free(void *ptr);
+/*#define free(p)	{CHK("free %p", p); free(p);} */ /* use for catching guard violations */
+extern void	*calloc(size_t n1, size_t n2);
+extern void	*realloc(void *ptr, size_t size);
+extern void	*reallocf(void *ptr, size_t size);
+extern void	mallocstats(void);
+#ifdef __alpha__
+extern void	free_region(void *start, void *end);
+#endif
+
+/* disklabel support (undocumented, may be junk) */
+struct		disklabel;
+extern char	*getdisklabel(const char *, struct disklabel *);
+
+extern int	printf(const char *fmt, ...) __printflike(1, 2);
+extern void	vprintf(const char *fmt, __va_list);
+extern int	sprintf(char *buf, const char *cfmt, ...) __printflike(2, 3);
+extern int      snprintf(char *buf, size_t size, const char *cfmt, ...) __printflike(3, 4);
+extern void	vsprintf(char *buf, const char *cfmt, __va_list);
+
+extern void	twiddle(void);
+
+extern void	ngets(char *, int);
+#define gets(x)	ngets((x), 0)
+extern int	fgetstr(char *buf, int size, int fd);
+
+extern int	open(const char *, int);
+#define	O_RDONLY	0x0
+#define O_WRONLY	0x1
+#define O_RDWR		0x2
+extern int	close(int);
+extern void	closeall(void);
+extern ssize_t	read(int, void *, size_t);
+extern ssize_t	write(int, void *, size_t);
+extern struct	dirent *readdirfd(int);
+
+extern void	srandom(u_long seed);
+extern u_long	random(void);
+    
+/* imports from stdlib, locally modified */
+extern long	strtol(const char *, char **, int);
+extern char	*optarg;			/* getopt(3) external variables */
+extern int	optind, opterr, optopt, optreset;
+extern int	getopt(int, char * const [], const char *);
+
+/* pager.c */
+extern void	pager_open(void);
+extern void	pager_close(void);
+extern int	pager_output(const char *lines);
+extern int	pager_file(const char *fname);
+
+/* No signal state to preserve */
+#define setjmp	_setjmp
+#define longjmp	_longjmp
+
+/* environment.c */
+#define EV_DYNAMIC	(1<<0)		/* value was dynamically allocated, free if changed/unset */
+#define EV_VOLATILE	(1<<1)		/* value is volatile, make a copy of it */
+#define EV_NOHOOK	(1<<2)		/* don't call hook when setting */
+
+struct env_var;
+typedef char	*(ev_format_t)(struct env_var *ev);
+typedef int	(ev_sethook_t)(struct env_var *ev, int flags,
+		    const void *value);
+typedef int	(ev_unsethook_t)(struct env_var *ev);
+
+struct env_var
+{
+    char		*ev_name;
+    int			ev_flags;
+    void		*ev_value;
+    ev_sethook_t	*ev_sethook;
+    ev_unsethook_t	*ev_unsethook;
+    struct env_var	*ev_next, *ev_prev;
+};
+extern struct env_var	*environ;
+
+extern struct env_var	*env_getenv(const char *name);
+extern int		env_setenv(const char *name, int flags,
+				   const void *value, ev_sethook_t sethook,
+				   ev_unsethook_t unsethook);
+extern char		*getenv(const char *name);
+extern int		setenv(const char *name, const char *value,
+			       int overwrite);
+extern int		putenv(const char *string);
+extern int		unsetenv(const char *name);
+
+extern ev_sethook_t	env_noset;		/* refuse set operation */
+extern ev_unsethook_t	env_nounset;		/* refuse unset operation */
+
+/* BCD conversions (undocumented) */
+extern u_char const	bcd2bin_data[];
+extern u_char const	bin2bcd_data[];
+extern char const	hex2ascii_data[];
+
+#define	bcd2bin(bcd)	(bcd2bin_data[bcd])
+#define	bin2bcd(bin)	(bin2bcd_data[bin])
+#define	hex2ascii(hex)	(hex2ascii_data[hex])
+
+/* min/max (undocumented) */
+static __inline int imax(int a, int b) { return (a > b ? a : b); }
+static __inline int imin(int a, int b) { return (a < b ? a : b); }
+static __inline long lmax(long a, long b) { return (a > b ? a : b); }
+static __inline long lmin(long a, long b) { return (a < b ? a : b); }
+static __inline u_int max(u_int a, u_int b) { return (a > b ? a : b); }
+static __inline u_int min(u_int a, u_int b) { return (a < b ? a : b); }
+static __inline quad_t qmax(quad_t a, quad_t b) { return (a > b ? a : b); }
+static __inline quad_t qmin(quad_t a, quad_t b) { return (a < b ? a : b); }
+static __inline u_long ulmax(u_long a, u_long b) { return (a > b ? a : b); }
+static __inline u_long ulmin(u_long a, u_long b) { return (a < b ? a : b); }
+
+/* swaps (undocumented, useful?) */
+#ifdef __i386__
+extern u_int32_t	bswap32(u_int32_t x);
+extern u_int64_t	bswap64(u_int64_t x);
+#endif
+
+/* null functions for device/filesystem switches (undocumented) */
+extern int	nodev(void);
+extern int	noioctl(struct open_file *, u_long, void *);
+extern void	nullsys(void);
+
+extern int	null_open(const char *path, struct open_file *f);
+extern int	null_close(struct open_file *f);
+extern int	null_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+extern int	null_write(struct open_file *f, void *buf, size_t size, size_t *resid);
+extern off_t	null_seek(struct open_file *f, off_t offset, int where);
+extern int	null_stat(struct open_file *f, struct stat *sb);
+extern int	null_readdir(struct open_file *f, struct dirent *d);
+
+
+/* 
+ * Machine dependent functions and data, must be provided or stubbed by 
+ * the consumer 
+ */
+extern int		getchar(void);
+extern int		ischar(void);
+extern void		putchar(int);
+extern int		devopen(struct open_file *, const char *, const char **);
+extern int		devclose(struct open_file *f);
+extern void		panic(const char *, ...) __dead2 __printflike(1, 2);
+extern struct fs_ops	*file_system[];
+extern struct devsw	*devsw[];
+
+/*
+ * Expose byteorder(3) functions.
+ */
+#ifndef _BYTEORDER_PROTOTYPED
+#define	_BYTEORDER_PROTOTYPED
+extern uint32_t		htonl(uint32_t);
+extern uint16_t		htons(uint16_t);
+extern uint32_t		ntohl(uint32_t);
+extern uint16_t		ntohs(uint16_t);
+#endif
+
+#ifndef _BYTEORDER_FUNC_DEFINED
+#define	_BYTEORDER_FUNC_DEFINED
+#define	htonl(x)	__htonl(x)
+#define	htons(x)	__htons(x)
+#define	ntohl(x)	__ntohl(x)
+#define	ntohs(x)	__ntohs(x)
+#endif
+
+void *Malloc(size_t, const char *, int);
+void *Calloc(size_t, size_t, const char *, int);
+void *Realloc(void *, size_t, const char *, int);
+void Free(void *, const char *, int);
+
+#if 1
+#define malloc(x)	Malloc(x, __FILE__, __LINE__)
+#define calloc(x, y)	Calloc(x, y, __FILE__, __LINE__)
+#define free(x)		Free(x, __FILE__, __LINE__)
+#define realloc(x, y)	Realloc(x, y, __FILE__, __LINE__)
+#else
+#define malloc(x)	Malloc(x, NULL, 0)
+#define calloc(x, y)	Calloc(x, y, NULL, 0)
+#define free(x)		Free(x, NULL, 0)
+#define realloc(x, y)	Realloc(x, y, NULL, 0)
+#endif
+
+#endif	/* STAND_H */
diff -ruN sys/boot/i386/pxe_ng/libstand/stat.c sys/boot/i386/pxe_ng/libstand/stat.c
--- sys/boot/i386/pxe_ng/libstand/stat.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/stat.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,52 @@
+/*	$NetBSD: stat.c,v 1.4 1996/01/13 22:25:43 leo Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)stat.c	8.1 (Berkeley) 6/11/93
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+int
+stat(str, sb)
+	const char *str;
+	struct stat *sb;
+{
+	int fd, rv;
+
+	fd = open(str, O_RDONLY);
+	if (fd < 0)
+		return (-1);
+	rv = fstat(fd, sb);
+	(void)close(fd);
+	return (rv);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/strcasecmp.c sys/boot/i386/pxe_ng/libstand/strcasecmp.c
--- sys/boot/i386/pxe_ng/libstand/strcasecmp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/strcasecmp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 1987, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/cdefs.h>
+#include <string.h>
+#include "stand.h"
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)strcasecmp.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+
+int
+strcasecmp(s1, s2)
+	const char *s1, *s2;
+{
+	const u_char
+			*us1 = (const u_char *)s1,
+			*us2 = (const u_char *)s2;
+
+	while (tolower(*us1) == tolower(*us2++))
+		if (*us1++ == '\0')
+			return (0);
+	return (tolower(*us1) - tolower(*--us2));
+}
+
+int
+strncasecmp(s1, s2, n)
+	const char *s1, *s2;
+	size_t n;
+{
+	if (n != 0) {
+		const u_char
+				*us1 = (const u_char *)s1,
+				*us2 = (const u_char *)s2;
+
+		do {
+			if (tolower(*us1) != tolower(*us2++))
+				return (tolower(*us1) - tolower(*--us2));
+			if (*us1++ == '\0')
+				break;
+		} while (--n != 0);
+	}
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/strdup.c sys/boot/i386/pxe_ng/libstand/strdup.c
--- sys/boot/i386/pxe_ng/libstand/strdup.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/strdup.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)strdup.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+
+#include "stand.h"
+#include <stddef.h>
+#include <string.h>
+
+char *
+strdup(str)
+	const char *str;
+{
+	size_t len;
+	char *copy = NULL;
+
+	if (str != NULL) {
+	    len = strlen(str) + 1;
+	    if ((copy = malloc(len)) == NULL)
+		return (NULL);
+	    memcpy(copy, str, len);
+	}
+	return (copy);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/strerror.c sys/boot/i386/pxe_ng/libstand/strerror.c
--- sys/boot/i386/pxe_ng/libstand/strerror.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/strerror.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,87 @@
+/*	$NetBSD: strerror.c,v 1.12 1997/01/25 00:37:50 cgd Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "stand.h"
+
+static struct 
+{
+    int		err;
+    char	*msg;
+} errtab[] = {
+    {0,		"no error"},
+    /* standard errors */
+    {EPERM,		"operation not permitted"},
+    {ENOENT,		"no such file or directory"},
+    {EIO,		"input/output error"},
+    {ENXIO,		"device not configured"},
+    {ENOEXEC,		"exec format error"},
+    {EBADF,		"bad file descriptor"},
+    {ENOMEM,		"cannot allocate memory"},
+    {ENODEV,		"operation not supported by device"},
+    {ENOTDIR,		"not a directory"},
+    {EISDIR,		"is a directory"},
+    {EINVAL,		"invalid argument"},
+    {EMFILE,		"too many open files"},
+    {EFBIG,		"file too large"},
+    {EROFS,		"read-only filesystem"},
+    {EOPNOTSUPP,	"operation not supported"},
+    {ETIMEDOUT,		"operation timed out"},
+    {ESTALE,		"stale NFS file handle"},
+    {EBADRPC,		"RPC struct is bad"},
+    {EFTYPE,		"inappropriate file type or format"},
+
+    {EADAPT,		"bad adaptor number"},
+    {ECTLR,		"bad controller number"},
+    {EUNIT,		"bad unit number"},
+    {ESLICE,		"bad slice number"},
+    {EPART,		"bad partition"},
+    {ERDLAB,		"can't read disk label"},
+    {EUNLAB,		"disk unlabelled"},
+    {EOFFSET,		"illegal seek"},
+    {0,		NULL}
+};
+
+
+char *
+strerror(int err)
+{
+    static char	msg[32];
+    int		i;
+
+    for (i = 0; errtab[i].msg != NULL; i++)
+	if (errtab[i].err == err)
+	    return(errtab[i].msg);
+    sprintf(msg, "unknown error (%d)", err);
+    return(msg);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/strtol.c sys/boot/i386/pxe_ng/libstand/strtol.c
--- sys/boot/i386/pxe_ng/libstand/strtol.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/strtol.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,132 @@
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)strtol.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+
+#include "stand.h"
+#include <limits.h>
+
+/*
+ * Convert a string to a long integer.
+ *
+ * Ignores `locale' stuff.  Assumes that the upper and lower case
+ * alphabets and digits are each contiguous.
+ */
+long
+strtol(nptr, endptr, base)
+	const char *nptr;
+	char **endptr;
+	int base;
+{
+	const char *s;
+	unsigned long acc;
+	unsigned char c;
+	unsigned long cutoff;
+	int neg = 0, any, cutlim;
+
+	/* Be sensible about NULL strings */
+	if (nptr == NULL)
+	    nptr = "";
+	s = nptr;
+	
+	/*
+	 * Skip white space and pick up leading +/- sign if any.
+	 * If base is 0, allow 0x for hex and 0 for octal, else
+	 * assume decimal; if base is already 16, allow 0x.
+	 */
+	do {
+		c = *s++;
+	} while (isspace(c));
+	if (c == '-') {
+		neg = 1;
+		c = *s++;
+	} else if (c == '+')
+		c = *s++;
+	if ((base == 0 || base == 16) &&
+	    c == '0' && (*s == 'x' || *s == 'X')) {
+		c = s[1];
+		s += 2;
+		base = 16;
+	}
+	if (base == 0)
+		base = c == '0' ? 8 : 10;
+
+	/*
+	 * Compute the cutoff value between legal numbers and illegal
+	 * numbers.  That is the largest legal value, divided by the
+	 * base.  An input number that is greater than this value, if
+	 * followed by a legal input character, is too big.  One that
+	 * is equal to this value may be valid or not; the limit
+	 * between valid and invalid numbers is then based on the last
+	 * digit.  For instance, if the range for longs is
+	 * [-2147483648..2147483647] and the input base is 10,
+	 * cutoff will be set to 214748364 and cutlim to either
+	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
+	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
+	 * the number is too big, and we will return a range error.
+	 *
+	 * Set any if any `digits' consumed; make it negative to indicate
+	 * overflow.
+	 */
+	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
+	cutlim = cutoff % (unsigned long)base;
+	cutoff /= (unsigned long)base;
+	for (acc = 0, any = 0;; c = *s++) {
+		if (!isascii(c))
+			break;
+		if (isdigit(c))
+			c -= '0';
+		else if (isalpha(c))
+			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
+		else
+			break;
+		if (c >= base)
+			break;
+		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
+			any = -1;
+		else {
+			any = 1;
+			acc *= base;
+			acc += c;
+		}
+	}
+	if (any < 0) {
+		acc = neg ? LONG_MIN : LONG_MAX;
+		errno = ERANGE;
+	} else if (neg)
+		acc = -acc;
+	if (endptr != 0)
+		*endptr = (char *)(any ? s - 1 : nptr);
+	return (acc);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/tftp.c sys/boot/i386/pxe_ng/libstand/tftp.c
--- sys/boot/i386/pxe_ng/libstand/tftp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/tftp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,426 @@
+/*	$NetBSD: tftp.c,v 1.4 1997/09/17 16:57:07 drochner Exp $	 */
+
+/*
+ * Copyright (c) 1996
+ *	Matthias Drochner.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project
+ *	by Matthias Drochner.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Simple TFTP implementation for libsa.
+ * Assumes:
+ *  - socket descriptor (int) at open_file->f_devdata
+ *  - server host IP in global servip
+ * Restrictions:
+ *  - read only
+ *  - lseek only with SEEK_SET or SEEK_CUR
+ *  - no big time differences between transfers (<tftp timeout)
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+#include <netinet/in_systm.h>
+#include <arpa/tftp.h>
+
+#include <string.h>
+
+#include "stand.h"
+#include "net.h"
+#include "netif.h"
+
+#include "tftp.h"
+
+static int	tftp_open(const char *path, struct open_file *f);
+static int	tftp_close(struct open_file *f);
+static int	tftp_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static int	tftp_write(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	tftp_seek(struct open_file *f, off_t offset, int where);
+static int	tftp_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops tftp_fsops = {
+	"tftp",
+	tftp_open,
+	tftp_close,
+	tftp_read,
+	tftp_write,
+	tftp_seek,
+	tftp_stat,
+	null_readdir
+};
+
+extern struct in_addr servip;
+
+static int      tftpport = 2000;
+
+#define RSPACE 520		/* max data packet, rounded up */
+
+struct tftp_handle {
+	struct iodesc  *iodesc;
+	int             currblock;	/* contents of lastdata */
+	int             islastblock;	/* flag */
+	int             validsize;
+	int             off;
+	char           *path;	/* saved for re-requests */
+	struct {
+		u_char header[HEADER_SIZE];
+		struct tftphdr t;
+		u_char space[RSPACE];
+	} __packed __aligned(4) lastdata;
+};
+
+static const int tftperrors[8] = {
+	0,			/* ??? */
+	ENOENT,
+	EPERM,
+	ENOSPC,
+	EINVAL,			/* ??? */
+	EINVAL,			/* ??? */
+	EEXIST,
+	EINVAL			/* ??? */
+};
+
+static ssize_t 
+recvtftp(d, pkt, len, tleft)
+	struct iodesc *d;
+	void  *pkt;
+	ssize_t len;
+	time_t          tleft;
+{
+	struct tftphdr *t;
+
+	errno = 0;
+
+	len = readudp(d, pkt, len, tleft);
+
+	if (len < 4)
+		return (-1);
+
+	t = (struct tftphdr *) pkt;
+	switch (ntohs(t->th_opcode)) {
+	case DATA: {
+		int got;
+
+		if (htons(t->th_block) != d->xid) {
+			/*
+			 * Expected block?
+			 */
+			return (-1);
+		}
+		if (d->xid == 1) {
+			/*
+			 * First data packet from new port.
+			 */
+			struct udphdr *uh;
+			uh = (struct udphdr *) pkt - 1;
+			d->destport = uh->uh_sport;
+		} /* else check uh_sport has not changed??? */
+		got = len - (t->th_data - (char *) t);
+		return got;
+	}
+	case ERROR:
+		if ((unsigned) ntohs(t->th_code) >= 8) {
+			printf("illegal tftp error %d\n", ntohs(t->th_code));
+			errno = EIO;
+		} else {
+#ifdef DEBUG
+			printf("tftp-error %d\n", ntohs(t->th_code));
+#endif
+			errno = tftperrors[ntohs(t->th_code)];
+		}
+		return (-1);
+	default:
+#ifdef DEBUG
+		printf("tftp type %d not handled\n", ntohs(t->th_opcode));
+#endif
+		return (-1);
+	}
+}
+
+/* send request, expect first block (or error) */
+static int 
+tftp_makereq(h)
+	struct tftp_handle *h;
+{
+	struct {
+		u_char header[HEADER_SIZE];
+		struct tftphdr  t;
+		u_char space[FNAME_SIZE + 6];
+	} __packed __aligned(4) wbuf;
+	char           *wtail;
+	int             l;
+	ssize_t         res;
+	struct tftphdr *t;
+
+	wbuf.t.th_opcode = htons((u_short) RRQ);
+	wtail = wbuf.t.th_stuff;
+	l = strlen(h->path);
+	bcopy(h->path, wtail, l + 1);
+	wtail += l + 1;
+	bcopy("octet", wtail, 6);
+	wtail += 6;
+
+	t = &h->lastdata.t;
+
+	/* h->iodesc->myport = htons(--tftpport); */
+	h->iodesc->myport = htons(tftpport + (getsecs() & 0x3ff));
+	h->iodesc->destport = htons(IPPORT_TFTP);
+	h->iodesc->xid = 1;	/* expected block */
+
+	res = sendrecv(h->iodesc, sendudp, &wbuf.t, wtail - (char *) &wbuf.t,
+		       recvtftp, t, sizeof(*t) + RSPACE);
+
+	if (res == -1)
+		return (errno);
+
+	h->currblock = 1;
+	h->validsize = res;
+	h->islastblock = 0;
+	if (res < SEGSIZE)
+		h->islastblock = 1;	/* very short file */
+	return (0);
+}
+
+/* ack block, expect next */
+static int 
+tftp_getnextblock(h)
+	struct tftp_handle *h;
+{
+	struct {
+		u_char header[HEADER_SIZE];
+		struct tftphdr t;
+	} __packed __aligned(4) wbuf;
+	char           *wtail;
+	int             res;
+	struct tftphdr *t;
+
+	wbuf.t.th_opcode = htons((u_short) ACK);
+	wtail = (char *) &wbuf.t.th_block;
+	wbuf.t.th_block = htons((u_short) h->currblock);
+	wtail += 2;
+
+	t = &h->lastdata.t;
+
+	h->iodesc->xid = h->currblock + 1;	/* expected block */
+
+	res = sendrecv(h->iodesc, sendudp, &wbuf.t, wtail - (char *) &wbuf.t,
+		       recvtftp, t, sizeof(*t) + RSPACE);
+
+	if (res == -1)		/* 0 is OK! */
+		return (errno);
+
+	h->currblock++;
+	h->validsize = res;
+	if (res < SEGSIZE)
+		h->islastblock = 1;	/* EOF */
+	return (0);
+}
+
+static int 
+tftp_open(path, f)
+	const char *path;
+	struct open_file *f;
+{
+	struct tftp_handle *tftpfile;
+	struct iodesc  *io;
+	int             res;
+
+#ifndef __i386__
+	if (strcmp(f->f_dev->dv_name, "net") != 0)
+		return (EINVAL);
+#endif
+
+	tftpfile = (struct tftp_handle *) malloc(sizeof(*tftpfile));
+	if (!tftpfile)
+		return (ENOMEM);
+
+	tftpfile->iodesc = io = socktodesc(*(int *) (f->f_devdata));
+	if (io == NULL)
+		return (EINVAL);
+
+	io->destip = servip;
+	tftpfile->off = 0;
+	tftpfile->path = strdup(path);
+	if (tftpfile->path == NULL) {
+	    free(tftpfile);
+	    return(ENOMEM);
+	}
+
+	res = tftp_makereq(tftpfile, path);
+
+	if (res) {
+		free(tftpfile->path);
+		free(tftpfile);
+		return (res);
+	}
+	f->f_fsdata = (void *) tftpfile;
+	return (0);
+}
+
+static int 
+tftp_read(f, addr, size, resid)
+	struct open_file *f;
+	void           *addr;
+	size_t          size;
+	size_t         *resid;	/* out */
+{
+	struct tftp_handle *tftpfile;
+	static int      tc = 0;
+	tftpfile = (struct tftp_handle *) f->f_fsdata;
+
+	while (size > 0) {
+		int needblock, count;
+
+		if (!(tc++ % 16))
+			twiddle();
+
+		needblock = tftpfile->off / SEGSIZE + 1;
+
+		if (tftpfile->currblock > needblock)	/* seek backwards */
+			tftp_makereq(tftpfile);	/* no error check, it worked
+						 * for open */
+
+		while (tftpfile->currblock < needblock) {
+			int res;
+
+			res = tftp_getnextblock(tftpfile);
+			if (res) {	/* no answer */
+#ifdef DEBUG
+				printf("tftp: read error\n");
+#endif
+				return (res);
+			}
+			if (tftpfile->islastblock)
+				break;
+		}
+
+		if (tftpfile->currblock == needblock) {
+			int offinblock, inbuffer;
+
+			offinblock = tftpfile->off % SEGSIZE;
+
+			inbuffer = tftpfile->validsize - offinblock;
+			if (inbuffer < 0) {
+#ifdef DEBUG
+				printf("tftp: invalid offset %d\n",
+				    tftpfile->off);
+#endif
+				return (EINVAL);
+			}
+			count = (size < inbuffer ? size : inbuffer);
+			bcopy(tftpfile->lastdata.t.th_data + offinblock,
+			    addr, count);
+
+			addr = (char *)addr + count;
+			tftpfile->off += count;
+			size -= count;
+
+			if ((tftpfile->islastblock) && (count == inbuffer))
+				break;	/* EOF */
+		} else {
+#ifdef DEBUG
+			printf("tftp: block %d not found\n", needblock);
+#endif
+			return (EINVAL);
+		}
+
+	}
+
+	if (resid)
+		*resid = size;
+	return (0);
+}
+
+static int 
+tftp_close(f)
+	struct open_file *f;
+{
+	struct tftp_handle *tftpfile;
+	tftpfile = (struct tftp_handle *) f->f_fsdata;
+
+	/* let it time out ... */
+
+	if (tftpfile) {
+		free(tftpfile->path);
+		free(tftpfile);
+	}
+	return (0);
+}
+
+static int 
+tftp_write(f, start, size, resid)
+	struct open_file *f;
+	void           *start;
+	size_t          size;
+	size_t         *resid;	/* out */
+{
+	return (EROFS);
+}
+
+static int 
+tftp_stat(f, sb)
+	struct open_file *f;
+	struct stat    *sb;
+{
+	struct tftp_handle *tftpfile;
+	tftpfile = (struct tftp_handle *) f->f_fsdata;
+
+	sb->st_mode = 0444 | S_IFREG;
+	sb->st_nlink = 1;
+	sb->st_uid = 0;
+	sb->st_gid = 0;
+	sb->st_size = -1;
+	return (0);
+}
+
+static off_t 
+tftp_seek(f, offset, where)
+	struct open_file *f;
+	off_t           offset;
+	int             where;
+{
+	struct tftp_handle *tftpfile;
+	tftpfile = (struct tftp_handle *) f->f_fsdata;
+
+	switch (where) {
+	case SEEK_SET:
+		tftpfile->off = offset;
+		break;
+	case SEEK_CUR:
+		tftpfile->off += offset;
+		break;
+	default:
+		errno = EOFFSET;
+		return (-1);
+	}
+	return (tftpfile->off);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/tftp.h sys/boot/i386/pxe_ng/libstand/tftp.h
--- sys/boot/i386/pxe_ng/libstand/tftp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/tftp.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,36 @@
+/*	$NetBSD: tftp.h,v 1.1.1.1 1997/03/14 02:40:31 perry Exp $	*/
+
+/*
+ * Copyright (c) 1996
+ *	Matthias Drochner.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed for the NetBSD Project
+ *	by Matthias Drochner.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#define IPPORT_TFTP 69
diff -ruN sys/boot/i386/pxe_ng/libstand/twiddle.c sys/boot/i386/pxe_ng/libstand/twiddle.c
--- sys/boot/i386/pxe_ng/libstand/twiddle.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/twiddle.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,52 @@
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include "stand.h"
+
+/* Extra functions from NetBSD standalone printf.c */
+
+void
+twiddle()
+{
+	static int pos;
+
+	putchar("|/-\\"[pos++ & 3]);
+	putchar('\b');
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/udp.c sys/boot/i386/pxe_ng/libstand/udp.c
--- sys/boot/i386/pxe_ng/libstand/udp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/udp.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,271 @@
+/* Taken from $NetBSD: net.c,v 1.20 1997/12/26 22:41:30 scottr Exp $	*/
+
+/*
+ * Copyright (c) 1992 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This software was developed by the Computer Systems Engineering group
+ * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
+ * contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) Header: net.c,v 1.9 93/08/06 19:32:15 leres Exp  (LBL)
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/socket.h>
+
+#include <string.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+#include <netinet/in_systm.h>
+
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/udp.h>
+#include <netinet/udp_var.h>
+
+#include "stand.h"
+#include "net.h"
+
+/* Caller must leave room for ethernet, ip and udp headers in front!! */
+ssize_t
+sendudp(d, pkt, len)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+{
+	ssize_t cc;
+	struct ip *ip;
+	struct udphdr *uh;
+	u_char *ea;
+
+#ifdef NET_DEBUG
+ 	if (debug) {
+		printf("sendudp: d=%lx called.\n", (long)d);
+		if (d) {
+			printf("saddr: %s:%d",
+			    inet_ntoa(d->myip), ntohs(d->myport));
+			printf(" daddr: %s:%d\n",
+			    inet_ntoa(d->destip), ntohs(d->destport));
+		}
+	}
+#endif
+
+	uh = (struct udphdr *)pkt - 1;
+	ip = (struct ip *)uh - 1;
+	len += sizeof(*ip) + sizeof(*uh);
+
+	bzero(ip, sizeof(*ip) + sizeof(*uh));
+
+	ip->ip_v = IPVERSION;			/* half-char */
+	ip->ip_hl = sizeof(*ip) >> 2;		/* half-char */
+	ip->ip_len = htons(len);
+	ip->ip_p = IPPROTO_UDP;			/* char */
+	ip->ip_ttl = IP_TTL;			/* char */
+	ip->ip_src = d->myip;
+	ip->ip_dst = d->destip;
+	ip->ip_sum = in_cksum(ip, sizeof(*ip));	 /* short, but special */
+
+	uh->uh_sport = d->myport;
+	uh->uh_dport = d->destport;
+	uh->uh_ulen = htons(len - sizeof(*ip));
+
+#ifndef UDP_NO_CKSUM
+	{
+		struct udpiphdr *ui;
+		struct ip tip;
+
+		/* Calculate checksum (must save and restore ip header) */
+		tip = *ip;
+		ui = (struct udpiphdr *)ip;
+		bzero(&ui->ui_x1, sizeof(ui->ui_x1));
+		ui->ui_len = uh->uh_ulen;
+		uh->uh_sum = in_cksum(ui, len);
+		*ip = tip;
+	}
+#endif
+
+	if (ip->ip_dst.s_addr == INADDR_BROADCAST || ip->ip_src.s_addr == 0 ||
+	    netmask == 0 || SAMENET(ip->ip_src, ip->ip_dst, netmask))
+		ea = arpwhohas(d, ip->ip_dst);
+	else
+		ea = arpwhohas(d, gateip);
+
+	cc = sendether(d, ip, len, ea, ETHERTYPE_IP);
+	if (cc == -1)
+		return (-1);
+	if (cc != len)
+		panic("sendudp: bad write (%zd != %zd)", cc, len);
+	return (cc - (sizeof(*ip) + sizeof(*uh)));
+}
+
+/*
+ * Receive a UDP packet and validate it is for us.
+ * Caller leaves room for the headers (Ether, IP, UDP)
+ */
+ssize_t
+readudp(d, pkt, len, tleft)
+	struct iodesc *d;
+	void *pkt;
+	size_t len;
+	time_t tleft;
+{
+	ssize_t n;
+	size_t hlen;
+	struct ip *ip;
+	struct udphdr *uh;
+	u_int16_t etype;	/* host order */
+
+#ifdef NET_DEBUG
+	if (debug)
+		printf("readudp: called\n");
+#endif
+
+	uh = (struct udphdr *)pkt - 1;
+	ip = (struct ip *)uh - 1;
+
+	n = readether(d, ip, len + sizeof(*ip) + sizeof(*uh), tleft, &etype);
+	if (n == -1 || n < sizeof(*ip) + sizeof(*uh))
+		return -1;
+
+	/* Ethernet address checks now in readether() */
+
+	/* Need to respond to ARP requests. */
+	if (etype == ETHERTYPE_ARP) {
+		struct arphdr *ah = (void *)ip;
+		if (ah->ar_op == htons(ARPOP_REQUEST)) {
+			/* Send ARP reply */
+			arp_reply(d, ah);
+		}
+		return -1;
+	}
+
+	if (etype != ETHERTYPE_IP) {
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: not IP. ether_type=%x\n", etype);
+#endif
+		return -1;
+	}
+
+	/* Check ip header */
+	if (ip->ip_v != IPVERSION ||
+	    ip->ip_p != IPPROTO_UDP) {	/* half char */
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: IP version or not UDP. ip_v=%d ip_p=%d\n", ip->ip_v, ip->ip_p);
+#endif
+		return -1;
+	}
+
+	hlen = ip->ip_hl << 2;
+	if (hlen < sizeof(*ip) ||
+	    in_cksum(ip, hlen) != 0) {
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: short hdr or bad cksum.\n");
+#endif
+		return -1;
+	}
+	if (n < ntohs(ip->ip_len)) {
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: bad length %d < %d.\n",
+			       (int)n, ntohs(ip->ip_len));
+#endif
+		return -1;
+	}
+	if (d->myip.s_addr && ip->ip_dst.s_addr != d->myip.s_addr) {
+#ifdef NET_DEBUG
+		if (debug) {
+			printf("readudp: bad saddr %s != ", inet_ntoa(d->myip));
+			printf("%s\n", inet_ntoa(ip->ip_dst));
+		}
+#endif
+		return -1;
+	}
+
+	/* If there were ip options, make them go away */
+	if (hlen != sizeof(*ip)) {
+		bcopy(((u_char *)ip) + hlen, uh, len - hlen);
+		ip->ip_len = htons(sizeof(*ip));
+		n -= hlen - sizeof(*ip);
+	}
+	if (uh->uh_dport != d->myport) {
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: bad dport %d != %d\n",
+				d->myport, ntohs(uh->uh_dport));
+#endif
+		return -1;
+	}
+
+#ifndef UDP_NO_CKSUM
+	if (uh->uh_sum) {
+		struct udpiphdr *ui;
+		struct ip tip;
+
+		n = ntohs(uh->uh_ulen) + sizeof(*ip);
+		if (n > RECV_SIZE - ETHER_SIZE) {
+			printf("readudp: huge packet, udp len %d\n", (int)n);
+			return -1;
+		}
+
+		/* Check checksum (must save and restore ip header) */
+		tip = *ip;
+		ui = (struct udpiphdr *)ip;
+		bzero(&ui->ui_x1, sizeof(ui->ui_x1));
+		ui->ui_len = uh->uh_ulen;
+		if (in_cksum(ui, n) != 0) {
+#ifdef NET_DEBUG
+			if (debug)
+				printf("readudp: bad cksum\n");
+#endif
+			*ip = tip;
+			return -1;
+		}
+		*ip = tip;
+	}
+#endif
+	if (ntohs(uh->uh_ulen) < sizeof(*uh)) {
+#ifdef NET_DEBUG
+		if (debug)
+			printf("readudp: bad udp len %d < %d\n",
+				ntohs(uh->uh_ulen), (int)sizeof(*uh));
+#endif
+		return -1;
+	}
+
+	n = (n > (ntohs(uh->uh_ulen) - sizeof(*uh))) ? 
+	    ntohs(uh->uh_ulen) - sizeof(*uh) : n;
+	return (n);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/ufs.c sys/boot/i386/pxe_ng/libstand/ufs.c
--- sys/boot/i386/pxe_ng/libstand/ufs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/ufs.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,865 @@
+/*	$NetBSD: ufs.c,v 1.20 1998/03/01 07:15:39 ross Exp $	*/
+
+/*-
+ * Copyright (c) 2002 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by Marshall
+ * Kirk McKusick and Network Associates Laboratories, the Security
+ * Research Division of Network Associates, Inc. under DARPA/SPAWAR
+ * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
+ * research program
+ *
+ * Copyright (c) 1982, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *  
+ *
+ * Copyright (c) 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: David Golub
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ *	Stand-alone file reading package.
+ */
+
+#include <sys/param.h>
+#include <sys/disklabel.h>
+#include <sys/time.h>
+#include <ufs/ufs/dinode.h>
+#include <ufs/ufs/dir.h>
+#include <ufs/ffs/fs.h>
+#include "stand.h"
+#include "string.h"
+
+#ifdef __alpha__
+#define COMPAT_UFS		/* DUX has old format file systems */
+#endif
+
+static int	ufs_open(const char *path, struct open_file *f);
+static int	ufs_write(struct open_file *f, void *buf, size_t size, size_t *resid);
+static int	ufs_close(struct open_file *f);
+static int	ufs_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+static off_t	ufs_seek(struct open_file *f, off_t offset, int where);
+static int	ufs_stat(struct open_file *f, struct stat *sb);
+static int	ufs_readdir(struct open_file *f, struct dirent *d);
+
+struct fs_ops ufs_fsops = {
+	"ufs",
+	ufs_open,
+	ufs_close,
+	ufs_read,
+	ufs_write,
+	ufs_seek,
+	ufs_stat,
+	ufs_readdir
+};
+
+/*
+ * In-core open file.
+ */
+struct file {
+	off_t		f_seekp;	/* seek pointer */
+	struct fs	*f_fs;		/* pointer to super-block */
+	union dinode {
+		struct ufs1_dinode di1;
+		struct ufs2_dinode di2;
+	}		f_di;		/* copy of on-disk inode */
+	int		f_nindir[NIADDR];
+					/* number of blocks mapped by
+					   indirect block at level i */
+	char		*f_blk[NIADDR];	/* buffer for indirect block at
+					   level i */
+	size_t		f_blksize[NIADDR];
+					/* size of buffer */
+	ufs2_daddr_t	f_blkno[NIADDR];/* disk address of block in buffer */
+	ufs2_daddr_t	f_buf_blkno;	/* block number of data block */
+	char		*f_buf;		/* buffer for data block */
+	size_t		f_buf_size;	/* size of data block */
+};
+#define DIP(fp, field) \
+	((fp)->f_fs->fs_magic == FS_UFS1_MAGIC ? \
+	(fp)->f_di.di1.field : (fp)->f_di.di2.field)
+
+static int	read_inode(ino_t, struct open_file *);
+static int	block_map(struct open_file *, ufs2_daddr_t, ufs2_daddr_t *);
+static int	buf_read_file(struct open_file *, char **, size_t *);
+static int	buf_write_file(struct open_file *, char *, size_t *);
+static int	search_directory(char *, struct open_file *, ino_t *);
+
+/*
+ * Read a new inode into a file structure.
+ */
+static int
+read_inode(inumber, f)
+	ino_t inumber;
+	struct open_file *f;
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct fs *fs = fp->f_fs;
+	char *buf;
+	size_t rsize;
+	int rc;
+
+	if (fs == NULL)
+	    panic("fs == NULL");
+
+	/*
+	 * Read inode and save it.
+	 */
+	buf = malloc(fs->fs_bsize);
+	twiddle();
+	rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+		fsbtodb(fs, ino_to_fsba(fs, inumber)), fs->fs_bsize,
+		buf, &rsize);
+	if (rc)
+		goto out;
+	if (rsize != fs->fs_bsize) {
+		rc = EIO;
+		goto out;
+	}
+
+	if (fp->f_fs->fs_magic == FS_UFS1_MAGIC)
+		fp->f_di.di1 = ((struct ufs1_dinode *)buf)
+		    [ino_to_fsbo(fs, inumber)];
+	else
+		fp->f_di.di2 = ((struct ufs2_dinode *)buf)
+		    [ino_to_fsbo(fs, inumber)];
+
+	/*
+	 * Clear out the old buffers
+	 */
+	{
+		int level;
+
+		for (level = 0; level < NIADDR; level++)
+			fp->f_blkno[level] = -1;
+		fp->f_buf_blkno = -1;
+	}
+	fp->f_seekp = 0;
+out:
+	free(buf);
+	return (rc);	 
+}
+
+/*
+ * Given an offset in a file, find the disk block number that
+ * contains that block.
+ */
+static int
+block_map(f, file_block, disk_block_p)
+	struct open_file *f;
+	ufs2_daddr_t file_block;
+	ufs2_daddr_t *disk_block_p;	/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct fs *fs = fp->f_fs;
+	int level;
+	int idx;
+	ufs2_daddr_t ind_block_num;
+	int rc;
+
+	/*
+	 * Index structure of an inode:
+	 *
+	 * di_db[0..NDADDR-1]	hold block numbers for blocks
+	 *			0..NDADDR-1
+	 *
+	 * di_ib[0]		index block 0 is the single indirect block
+	 *			holds block numbers for blocks
+	 *			NDADDR .. NDADDR + NINDIR(fs)-1
+	 *
+	 * di_ib[1]		index block 1 is the double indirect block
+	 *			holds block numbers for INDEX blocks for blocks
+	 *			NDADDR + NINDIR(fs) ..
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 - 1
+	 *
+	 * di_ib[2]		index block 2 is the triple indirect block
+	 *			holds block numbers for double-indirect
+	 *			blocks for blocks
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 ..
+	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2
+	 *				+ NINDIR(fs)**3 - 1
+	 */
+
+	if (file_block < NDADDR) {
+		/* Direct block. */
+		*disk_block_p = DIP(fp, di_db[file_block]);
+		return (0);
+	}
+
+	file_block -= NDADDR;
+
+	/*
+	 * nindir[0] = NINDIR
+	 * nindir[1] = NINDIR**2
+	 * nindir[2] = NINDIR**3
+	 *	etc
+	 */
+	for (level = 0; level < NIADDR; level++) {
+		if (file_block < fp->f_nindir[level])
+			break;
+		file_block -= fp->f_nindir[level];
+	}
+	if (level == NIADDR) {
+		/* Block number too high */
+		return (EFBIG);
+	}
+
+	ind_block_num = DIP(fp, di_ib[level]);
+
+	for (; level >= 0; level--) {
+		if (ind_block_num == 0) {
+			*disk_block_p = 0;	/* missing */
+			return (0);
+		}
+
+		if (fp->f_blkno[level] != ind_block_num) {
+			if (fp->f_blk[level] == (char *)0)
+				fp->f_blk[level] =
+					malloc(fs->fs_bsize);
+			twiddle();
+			rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+				fsbtodb(fp->f_fs, ind_block_num),
+				fs->fs_bsize,
+				fp->f_blk[level],
+				&fp->f_blksize[level]);
+			if (rc)
+				return (rc);
+			if (fp->f_blksize[level] != fs->fs_bsize)
+				return (EIO);
+			fp->f_blkno[level] = ind_block_num;
+		}
+
+		if (level > 0) {
+			idx = file_block / fp->f_nindir[level - 1];
+			file_block %= fp->f_nindir[level - 1];
+		} else
+			idx = file_block;
+
+		if (fp->f_fs->fs_magic == FS_UFS1_MAGIC)
+			ind_block_num = ((ufs1_daddr_t *)fp->f_blk[level])[idx];
+		else
+			ind_block_num = ((ufs2_daddr_t *)fp->f_blk[level])[idx];
+	}
+
+	*disk_block_p = ind_block_num;
+
+	return (0);
+}
+
+/*
+ * Write a portion of a file from an internal buffer.
+ */
+static int
+buf_write_file(f, buf_p, size_p)
+	struct open_file *f;
+	char *buf_p;
+	size_t *size_p;		/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct fs *fs = fp->f_fs;
+	long off;
+	ufs_lbn_t file_block;
+	ufs2_daddr_t disk_block;
+	size_t block_size;
+	int rc;
+
+	/*
+	 * Calculate the starting block address and offset.
+	 */
+	off = blkoff(fs, fp->f_seekp);
+	file_block = lblkno(fs, fp->f_seekp);
+	block_size = sblksize(fs, DIP(fp, di_size), file_block);
+
+	rc = block_map(f, file_block, &disk_block);
+	if (rc)
+		return (rc);
+
+ 	if (disk_block == 0)
+		/* Because we can't allocate space on the drive */
+		return (EFBIG);
+
+	/*
+	 * Truncate buffer at end of file, and at the end of
+	 * this block.
+	 */
+	if (*size_p > DIP(fp, di_size) - fp->f_seekp)
+		*size_p = DIP(fp, di_size) - fp->f_seekp;
+	if (*size_p > block_size - off) 
+		*size_p = block_size - off;
+
+	/*
+	 * If we don't entirely occlude the block and it's not
+	 * in memory already, read it in first.
+	 */
+	if (((off > 0) || (*size_p + off < block_size)) &&
+	    (file_block != fp->f_buf_blkno)) {
+
+		if (fp->f_buf == (char *)0)
+			fp->f_buf = malloc(fs->fs_bsize);
+
+		twiddle();
+		rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+			fsbtodb(fs, disk_block),
+			block_size, fp->f_buf, &fp->f_buf_size);
+		if (rc)
+			return (rc);
+
+		fp->f_buf_blkno = file_block;
+	}
+
+	/*
+	 *	Copy the user data into the cached block.
+	 */
+	bcopy(buf_p, fp->f_buf + off, *size_p);
+
+	/*
+	 *	Write the block out to storage.
+	 */
+
+	twiddle();
+	rc = (f->f_dev->dv_strategy)(f->f_devdata, F_WRITE,
+		fsbtodb(fs, disk_block),
+		block_size, fp->f_buf, &fp->f_buf_size);
+	return (rc);
+}
+
+/*
+ * Read a portion of a file into an internal buffer.  Return
+ * the location in the buffer and the amount in the buffer.
+ */
+static int
+buf_read_file(f, buf_p, size_p)
+	struct open_file *f;
+	char **buf_p;		/* out */
+	size_t *size_p;		/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct fs *fs = fp->f_fs;
+	long off;
+	ufs_lbn_t file_block;
+	ufs2_daddr_t disk_block;
+	size_t block_size;
+	int rc;
+
+	off = blkoff(fs, fp->f_seekp);
+	file_block = lblkno(fs, fp->f_seekp);
+	block_size = sblksize(fs, DIP(fp, di_size), file_block);
+
+	if (file_block != fp->f_buf_blkno) {
+		if (fp->f_buf == (char *)0)
+			fp->f_buf = malloc(fs->fs_bsize);
+
+		rc = block_map(f, file_block, &disk_block);
+		if (rc)
+			return (rc);
+
+		if (disk_block == 0) {
+			bzero(fp->f_buf, block_size);
+			fp->f_buf_size = block_size;
+		} else {
+			twiddle();
+			rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+				fsbtodb(fs, disk_block),
+				block_size, fp->f_buf, &fp->f_buf_size);
+			if (rc)
+				return (rc);
+		}
+
+		fp->f_buf_blkno = file_block;
+	}
+
+	/*
+	 * Return address of byte in buffer corresponding to
+	 * offset, and size of remainder of buffer after that
+	 * byte.
+	 */
+	*buf_p = fp->f_buf + off;
+	*size_p = block_size - off;
+
+	/*
+	 * But truncate buffer at end of file.
+	 */
+	if (*size_p > DIP(fp, di_size) - fp->f_seekp)
+		*size_p = DIP(fp, di_size) - fp->f_seekp;
+
+	return (0);
+}
+
+/*
+ * Search a directory for a name and return its
+ * i_number.
+ */
+static int
+search_directory(name, f, inumber_p)
+	char *name;
+	struct open_file *f;
+	ino_t *inumber_p;		/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct direct *dp;
+	struct direct *edp;
+	char *buf;
+	size_t buf_size;
+	int namlen, length;
+	int rc;
+
+	length = strlen(name);
+
+	fp->f_seekp = 0;
+	while (fp->f_seekp < DIP(fp, di_size)) {
+		rc = buf_read_file(f, &buf, &buf_size);
+		if (rc)
+			return (rc);
+
+		dp = (struct direct *)buf;
+		edp = (struct direct *)(buf + buf_size);
+		while (dp < edp) {
+			if (dp->d_ino == (ino_t)0)
+				goto next;
+#if BYTE_ORDER == LITTLE_ENDIAN
+			if (fp->f_fs->fs_maxsymlinklen <= 0)
+				namlen = dp->d_type;
+			else
+#endif
+				namlen = dp->d_namlen;
+			if (namlen == length &&
+			    !strcmp(name, dp->d_name)) {
+				/* found entry */
+				*inumber_p = dp->d_ino;
+				return (0);
+			}
+		next:
+			dp = (struct direct *)((char *)dp + dp->d_reclen);
+		}
+		fp->f_seekp += buf_size;
+	}
+	return (ENOENT);
+}
+
+static int sblock_try[] = SBLOCKSEARCH;
+
+/*
+ * Open a file.
+ */
+static int
+ufs_open(upath, f)
+	const char *upath;
+	struct open_file *f;
+{
+	char *cp, *ncp;
+	int c;
+	ino_t inumber, parent_inumber;
+	struct file *fp;
+	struct fs *fs;
+	int i, rc;
+	size_t buf_size;
+	int nlinks = 0;
+	char namebuf[MAXPATHLEN+1];
+	char *buf = NULL;
+	char *path = NULL;
+
+	/* allocate file system specific data structure */
+	fp = malloc(sizeof(struct file));
+	bzero(fp, sizeof(struct file));
+	f->f_fsdata = (void *)fp;
+
+	/* allocate space and read super block */
+	fs = malloc(SBLOCKSIZE);
+	fp->f_fs = fs;
+	twiddle();
+	/*
+	 * Try reading the superblock in each of its possible locations.
+	 */
+	for (i = 0; sblock_try[i] != -1; i++) {
+		rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
+		    sblock_try[i] / DEV_BSIZE, SBLOCKSIZE,
+		    (char *)fs, &buf_size);
+		if (rc)
+			goto out;
+		if ((fs->fs_magic == FS_UFS1_MAGIC ||
+		     (fs->fs_magic == FS_UFS2_MAGIC &&
+		      fs->fs_sblockloc == sblock_try[i])) &&
+		    buf_size == SBLOCKSIZE &&
+		    fs->fs_bsize <= MAXBSIZE &&
+		    fs->fs_bsize >= sizeof(struct fs))
+			break;
+	}
+	if (sblock_try[i] == -1) {
+		rc = EINVAL;
+		goto out;
+	}
+	/*
+	 * Calculate indirect block levels.
+	 */
+	{
+		ufs2_daddr_t mult;
+		int level;
+
+		mult = 1;
+		for (level = 0; level < NIADDR; level++) {
+			mult *= NINDIR(fs);
+			fp->f_nindir[level] = mult;
+		}
+	}
+
+	inumber = ROOTINO;
+	if ((rc = read_inode(inumber, f)) != 0)
+		goto out;
+
+	cp = path = strdup(upath);
+	if (path == NULL) {
+	    rc = ENOMEM;
+	    goto out;
+	}
+	while (*cp) {
+
+		/*
+		 * Remove extra separators
+		 */
+		while (*cp == '/')
+			cp++;
+		if (*cp == '\0')
+			break;
+
+		/*
+		 * Check that current node is a directory.
+		 */
+		if ((DIP(fp, di_mode) & IFMT) != IFDIR) {
+			rc = ENOTDIR;
+			goto out;
+		}
+
+		/*
+		 * Get next component of path name.
+		 */
+		{
+			int len = 0;
+
+			ncp = cp;
+			while ((c = *cp) != '\0' && c != '/') {
+				if (++len > MAXNAMLEN) {
+					rc = ENOENT;
+					goto out;
+				}
+				cp++;
+			}
+			*cp = '\0';
+		}
+
+		/*
+		 * Look up component in current directory.
+		 * Save directory inumber in case we find a
+		 * symbolic link.
+		 */
+		parent_inumber = inumber;
+		rc = search_directory(ncp, f, &inumber);
+		*cp = c;
+		if (rc)
+			goto out;
+
+		/*
+		 * Open next component.
+		 */
+		if ((rc = read_inode(inumber, f)) != 0)
+			goto out;
+
+		/*
+		 * Check for symbolic link.
+		 */
+		if ((DIP(fp, di_mode) & IFMT) == IFLNK) {
+			int link_len = DIP(fp, di_size);
+			int len;
+
+			len = strlen(cp);
+
+			if (link_len + len > MAXPATHLEN ||
+			    ++nlinks > MAXSYMLINKS) {
+				rc = ENOENT;
+				goto out;
+			}
+
+			bcopy(cp, &namebuf[link_len], len + 1);
+
+			if (link_len < fs->fs_maxsymlinklen) {
+				if (fp->f_fs->fs_magic == FS_UFS1_MAGIC)
+					cp = (caddr_t)(fp->f_di.di1.di_db);
+				else
+					cp = (caddr_t)(fp->f_di.di2.di_db);
+				bcopy(cp, namebuf, (unsigned) link_len);
+			} else {
+				/*
+				 * Read file for symbolic link
+				 */
+				size_t buf_size;
+				ufs2_daddr_t disk_block;
+				struct fs *fs = fp->f_fs;
+
+				if (!buf)
+					buf = malloc(fs->fs_bsize);
+				rc = block_map(f, (ufs2_daddr_t)0, &disk_block);
+				if (rc)
+					goto out;
+				
+				twiddle();
+				rc = (f->f_dev->dv_strategy)(f->f_devdata,
+					F_READ, fsbtodb(fs, disk_block),
+					fs->fs_bsize, buf, &buf_size);
+				if (rc)
+					goto out;
+
+				bcopy((char *)buf, namebuf, (unsigned)link_len);
+			}
+
+			/*
+			 * If relative pathname, restart at parent directory.
+			 * If absolute pathname, restart at root.
+			 */
+			cp = namebuf;
+			if (*cp != '/')
+				inumber = parent_inumber;
+			else
+				inumber = (ino_t)ROOTINO;
+
+			if ((rc = read_inode(inumber, f)) != 0)
+				goto out;
+		}
+	}
+
+	/*
+	 * Found terminal component.
+	 */
+	rc = 0;
+	fp->f_seekp = 0;
+out:
+	if (buf)
+		free(buf);
+	if (path)
+		free(path);
+	if (rc) {
+		if (fp->f_buf)
+			free(fp->f_buf);
+		free(fp->f_fs);
+		free(fp);
+	}
+	return (rc);
+}
+
+static int
+ufs_close(f)
+	struct open_file *f;
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	int level;
+
+	f->f_fsdata = (void *)0;
+	if (fp == (struct file *)0)
+		return (0);
+
+	for (level = 0; level < NIADDR; level++) {
+		if (fp->f_blk[level])
+			free(fp->f_blk[level]);
+	}
+	if (fp->f_buf)
+		free(fp->f_buf);
+	free(fp->f_fs);
+	free(fp);
+	return (0);
+}
+
+/*
+ * Copy a portion of a file into kernel memory.
+ * Cross block boundaries when necessary.
+ */
+static int
+ufs_read(f, start, size, resid)
+	struct open_file *f;
+	void *start;
+	size_t size;
+	size_t *resid;	/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	size_t csize;
+	char *buf;
+	size_t buf_size;
+	int rc = 0;
+	char *addr = start;
+
+	while (size != 0) {
+		if (fp->f_seekp >= DIP(fp, di_size))
+			break;
+
+		rc = buf_read_file(f, &buf, &buf_size);
+		if (rc)
+			break;
+
+		csize = size;
+		if (csize > buf_size)
+			csize = buf_size;
+
+		bcopy(buf, addr, csize);
+
+		fp->f_seekp += csize;
+		addr += csize;
+		size -= csize;
+	}
+	if (resid)
+		*resid = size;
+	return (rc);
+}
+
+/*
+ * Write to a portion of an already allocated file.
+ * Cross block boundaries when necessary. Can not
+ * extend the file.
+ */
+static int
+ufs_write(f, start, size, resid)
+	struct open_file *f;
+	void *start;
+	size_t size;
+	size_t *resid;	/* out */
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	size_t csize;
+	int rc = 0;
+	char *addr = start;
+
+	csize = size;
+	while ((size != 0) && (csize != 0)) {
+		if (fp->f_seekp >= DIP(fp, di_size))
+			break;
+
+		if (csize >= 512) csize = 512; /* XXX */
+
+		rc = buf_write_file(f, addr, &csize);
+		if (rc)
+			break;
+
+		fp->f_seekp += csize;
+		addr += csize;
+		size -= csize;
+	}
+	if (resid)
+		*resid = size;
+	return (rc);
+}
+
+static off_t
+ufs_seek(f, offset, where)
+	struct open_file *f;
+	off_t offset;
+	int where;
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	switch (where) {
+	case SEEK_SET:
+		fp->f_seekp = offset;
+		break;
+	case SEEK_CUR:
+		fp->f_seekp += offset;
+		break;
+	case SEEK_END:
+		fp->f_seekp = DIP(fp, di_size) - offset;
+		break;
+	default:
+		errno = EINVAL;
+		return (-1);
+	}
+	return (fp->f_seekp);
+}
+
+static int
+ufs_stat(f, sb)
+	struct open_file *f;
+	struct stat *sb;
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+
+	/* only important stuff */
+	sb->st_mode = DIP(fp, di_mode);
+	sb->st_uid = DIP(fp, di_uid);
+	sb->st_gid = DIP(fp, di_gid);
+	sb->st_size = DIP(fp, di_size);
+	return (0);
+}
+
+static int
+ufs_readdir(struct open_file *f, struct dirent *d)
+{
+	struct file *fp = (struct file *)f->f_fsdata;
+	struct direct *dp;
+	char *buf;
+	size_t buf_size;
+	int error;
+
+	/*
+	 * assume that a directory entry will not be split across blocks
+	 */
+again:
+	if (fp->f_seekp >= DIP(fp, di_size))
+		return (ENOENT);
+	error = buf_read_file(f, &buf, &buf_size);
+	if (error)
+		return (error);
+	dp = (struct direct *)buf;
+	fp->f_seekp += dp->d_reclen;
+	if (dp->d_ino == (ino_t)0)
+		goto again;
+	d->d_type = dp->d_type;
+	strcpy(d->d_name, dp->d_name);
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/write.c sys/boot/i386/pxe_ng/libstand/write.c
--- sys/boot/i386/pxe_ng/libstand/write.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/write.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,95 @@
+/*	$NetBSD: write.c,v 1.7 1996/06/21 20:29:30 pk Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * The Mach Operating System project at Carnegie-Mellon University.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)write.c	8.1 (Berkeley) 6/11/93
+ *  
+ *
+ * Copyright (c) 1989, 1990, 1991 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Author: Alessandro Forin
+ * 
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ * 
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ * 
+ * Carnegie Mellon requests users of this software to return to
+ * 
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ * 
+ * any improvements or extensions that they make and grant Carnegie the
+ * rights to redistribute these changes.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include "stand.h"
+
+ssize_t
+write(fd, dest, bcount)
+	int fd;
+	void *dest;
+	size_t bcount;
+{
+	struct open_file *f = &files[fd];
+	size_t resid;
+
+	if ((unsigned)fd >= SOPEN_MAX || !(f->f_flags & F_WRITE)) {
+		errno = EBADF;
+		return (-1);
+	}
+	if (f->f_flags & F_RAW) {
+		twiddle();
+		errno = (f->f_dev->dv_strategy)(f->f_devdata, F_WRITE,
+			btodb(f->f_offset), bcount, dest, &resid);
+		if (errno)
+			return (-1);
+		f->f_offset += resid;
+		return (resid);
+	}
+	resid = bcount;
+	if ((errno = (f->f_ops->fo_write)(f, dest, bcount, &resid)))
+		return (-1);
+	return (bcount - resid);
+}
diff -ruN sys/boot/i386/pxe_ng/libstand/zalloc.c sys/boot/i386/pxe_ng/libstand/zalloc.c
--- sys/boot/i386/pxe_ng/libstand/zalloc.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/zalloc.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,303 @@
+/*
+ * This module derived from code donated to the FreeBSD Project by 
+ * Matthew Dillon <dillon@backplane.com>
+ *
+ * Copyright (c) 1998 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * LIB/MEMORY/ZALLOC.C	- self contained low-overhead memory pool/allocation 
+ *			  subsystem
+ *
+ *	This subsystem implements memory pools and memory allocation 
+ *	routines.
+ *
+ *	Pools are managed via a linked list of 'free' areas.  Allocating
+ *	memory creates holes in the freelist, freeing memory fills them.
+ *	Since the freelist consists only of free memory areas, it is possible
+ *	to allocate the entire pool without incuring any structural overhead.
+ *
+ *	The system works best when allocating similarly-sized chunks of
+ *	memory.  Care must be taken to avoid fragmentation when 
+ *	allocating/deallocating dissimilar chunks.
+ *
+ *	When a memory pool is first allocated, the entire pool is marked as
+ *	allocated.  This is done mainly because we do not want to modify any
+ *	portion of a pool's data area until we are given permission.  The
+ *	caller must explicitly deallocate portions of the pool to make them
+ *	available.
+ *
+ *	z[n]xalloc() works like z[n]alloc() but the allocation is made from
+ *	within the specified address range.  If the segment could not be 
+ *	allocated, NULL is returned.  WARNING!  The address range will be
+ *	aligned to an 8 or 16 byte boundry depending on the cpu so if you
+ *	give an unaligned address range, unexpected results may occur.
+ *
+ *	If a standard allocation fails, the reclaim function will be called
+ *	to recover some space.  This usually causes other portions of the
+ *	same pool to be released.  Memory allocations at this low level
+ *	should not block but you can do that too in your reclaim function
+ *	if you want.  Reclaim does not function when z[n]xalloc() is used,
+ *	only for z[n]alloc().
+ *
+ *	Allocation and frees of 0 bytes are valid operations.
+ */
+
+#include "zalloc_defs.h"
+
+/*
+ * znalloc() -	allocate memory (without zeroing) from pool.  Call reclaim
+ *		and retry if appropriate, return NULL if unable to allocate
+ *		memory.
+ */
+
+void *
+znalloc(MemPool *mp, iaddr_t bytes)
+{
+    /*
+     * align according to pool object size (can be 0).  This is
+     * inclusive of the MEMNODE_SIZE_MASK minimum alignment.
+     *
+     */
+    bytes = (bytes + MEMNODE_SIZE_MASK) & ~MEMNODE_SIZE_MASK;
+
+    if (bytes == 0)
+	return((void *)-1);
+
+    /*
+     * locate freelist entry big enough to hold the object.  If all objects
+     * are the same size, this is a constant-time function.
+     */
+
+    if (bytes <= mp->mp_Size - mp->mp_Used) {
+	MemNode **pmn;
+	MemNode *mn;
+
+	for (pmn = &mp->mp_First; (mn=*pmn) != NULL; pmn = &mn->mr_Next) {
+	    if (bytes > mn->mr_Bytes)
+		continue;
+
+	    /*
+	     *  Cut a chunk of memory out of the beginning of this
+	     *  block and fixup the link appropriately.
+	     */
+
+	    {
+		char *ptr = (char *)mn;
+
+		if (mn->mr_Bytes == bytes) {
+		    *pmn = mn->mr_Next;
+		} else {
+		    mn = (MemNode *)((char *)mn + bytes);
+		    mn->mr_Next  = ((MemNode *)ptr)->mr_Next;
+		    mn->mr_Bytes = ((MemNode *)ptr)->mr_Bytes - bytes;
+		    *pmn = mn;
+		}
+		mp->mp_Used += bytes;
+		return(ptr);
+	    }
+	}
+    }
+
+    /*
+     * Memory pool is full, return NULL.
+     */
+
+    return(NULL);
+}
+
+/*
+ * zfree() - free previously allocated memory
+ */
+
+void
+zfree(MemPool *mp, void *ptr, iaddr_t bytes)
+{
+    /*
+     * align according to pool object size (can be 0).  This is
+     * inclusive of the MEMNODE_SIZE_MASK minimum alignment.
+     */
+    bytes = (bytes + MEMNODE_SIZE_MASK) & ~MEMNODE_SIZE_MASK;
+
+    if (bytes == 0)
+	return;
+
+    /*
+     * panic if illegal pointer
+     */
+
+    if ((char *)ptr < (char *)mp->mp_Base || 
+	(char *)ptr + bytes > (char *)mp->mp_End ||
+	((iaddr_t)ptr & MEMNODE_SIZE_MASK) != 0)
+	panic("zfree(%p,%d): wild pointer", ptr, bytes);
+
+    /*
+     * free the segment
+     */
+
+    {
+	MemNode **pmn;
+	MemNode *mn;
+
+	mp->mp_Used -= bytes;
+
+	for (pmn = &mp->mp_First; (mn = *pmn) != NULL; pmn = &mn->mr_Next) {
+	    /*
+	     * If area between last node and current node
+	     *  - check range
+	     *  - check merge with next area
+	     *  - check merge with previous area
+	     */
+	    if ((char *)ptr <= (char *)mn) {
+		/*
+		 * range check
+		 */
+		if ((char *)ptr + bytes > (char *)mn)
+		    panic("zfree(%p,%d): corrupt memlist1",ptr, bytes);
+
+		/*
+		 * merge against next area or create independant area
+		 */
+
+		if ((char *)ptr + bytes == (char *)mn) {
+		    ((MemNode *)ptr)->mr_Next = mn->mr_Next;
+		    ((MemNode *)ptr)->mr_Bytes= bytes + mn->mr_Bytes;
+		} else {
+		    ((MemNode *)ptr)->mr_Next = mn;
+		    ((MemNode *)ptr)->mr_Bytes= bytes;
+		}
+		*pmn = mn = (MemNode *)ptr;
+
+		/*
+		 * merge against previous area (if there is a previous
+		 * area).
+		 */
+
+		if (pmn != &mp->mp_First) {
+		    if ((char*)pmn + ((MemNode*)pmn)->mr_Bytes == (char*)ptr) {
+			((MemNode *)pmn)->mr_Next = mn->mr_Next;
+			((MemNode *)pmn)->mr_Bytes += mn->mr_Bytes;
+			mn = (MemNode *)pmn;
+		    }
+		}
+		return;
+		/* NOT REACHED */
+	    }
+	    if ((char *)ptr < (char *)mn + mn->mr_Bytes)
+		panic("zfree(%p,%d): corrupt memlist2", ptr, bytes);
+	}
+	/*
+	 * We are beyond the last MemNode, append new MemNode.  Merge against
+	 * previous area if possible.
+	 */
+	if (pmn == &mp->mp_First || 
+	    (char *)pmn + ((MemNode *)pmn)->mr_Bytes != (char *)ptr
+	) {
+	    ((MemNode *)ptr)->mr_Next = NULL;
+	    ((MemNode *)ptr)->mr_Bytes = bytes;
+	    *pmn = (MemNode *)ptr;
+	    mn = (MemNode *)ptr;
+	} else {
+	    ((MemNode *)pmn)->mr_Bytes += bytes;
+	    mn = (MemNode *)pmn;
+	}
+    }
+}
+
+/*
+ * zextendPool() - extend memory pool to cover additional space.
+ *
+ *		   Note: the added memory starts out as allocated, you
+ *		   must free it to make it available to the memory subsystem.
+ *
+ *		   Note: mp_Size may not reflect (mp_End - mp_Base) range
+ *		   due to other parts of the system doing their own sbrk()
+ *		   calls.
+ */
+
+void
+zextendPool(MemPool *mp, void *base, iaddr_t bytes)
+{
+    if (mp->mp_Size == 0) {
+	mp->mp_Base = base;
+	mp->mp_Used = bytes;
+	mp->mp_End = (char *)base + bytes;
+	mp->mp_Size = bytes;
+    } else {
+	void *pend = (char *)mp->mp_Base + mp->mp_Size;
+
+	if (base < mp->mp_Base) {
+	    mp->mp_Size += (char *)mp->mp_Base - (char *)base;
+	    mp->mp_Used += (char *)mp->mp_Base - (char *)base;
+	    mp->mp_Base = base;
+	}
+	base = (char *)base + bytes;
+	if (base > pend) {
+	    mp->mp_Size += (char *)base - (char *)pend;
+	    mp->mp_Used += (char *)base - (char *)pend;
+	    mp->mp_End = (char *)base;
+	}
+    }
+}
+
+#ifdef ZALLOCDEBUG
+
+void
+zallocstats(MemPool *mp)
+{
+    int abytes = 0;
+    int hbytes = 0;
+    int fcount = 0;
+    MemNode *mn;
+
+    printf("%d bytes reserved", (int) mp->mp_Size);
+
+    mn = mp->mp_First;
+
+    if ((void *)mn != (void *)mp->mp_Base) {
+	abytes += (char *)mn - (char *)mp->mp_Base;
+    }
+
+    while (mn) {
+	if ((char *)mn + mn->mr_Bytes != mp->mp_End) {
+	    hbytes += mn->mr_Bytes;
+	    ++fcount;
+	}
+	if (mn->mr_Next)
+	    abytes += (char *)mn->mr_Next - ((char *)mn + mn->mr_Bytes);
+	mn = mn->mr_Next;
+    }
+    printf(" %d bytes allocated\n%d fragments (%d bytes fragmented)\n",
+	abytes,
+	fcount,
+	hbytes
+    );
+}
+
+#endif
+
diff -ruN sys/boot/i386/pxe_ng/libstand/zalloc_defs.h sys/boot/i386/pxe_ng/libstand/zalloc_defs.h
--- sys/boot/i386/pxe_ng/libstand/zalloc_defs.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/zalloc_defs.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,81 @@
+/*
+ * This module derived from code donated to the FreeBSD Project by 
+ * Matthew Dillon <dillon@backplane.com>
+ *
+ * Copyright (c) 1998 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * DEFS.H
+ */
+
+#define USEGUARD		/* use stard/end guard bytes */
+#define USEENDGUARD
+#define DMALLOCDEBUG		/* add debugging code to gather stats */
+#define ZALLOCDEBUG
+
+#include <string.h>
+#include "stand.h"
+
+typedef uintptr_t iaddr_t;	/* unsigned int same size as pointer	*/
+typedef intptr_t saddr_t;	/* signed int same size as pointer	*/
+#include "zalloc_mem.h"
+
+#define Prototype extern
+#define Library extern
+
+#ifndef NULL
+#define NULL	((void *)0)
+#endif
+
+/*
+ * block extension for sbrk()
+ */
+
+#define BLKEXTEND	(4 * 1024)
+#define BLKEXTENDMASK	(BLKEXTEND - 1)
+
+/*
+ * required malloc alignment.  Use sizeof(long double) for architecture
+ * independance.
+ *
+ * Note: if we implement a more sophisticated realloc, we should ensure that
+ * MALLOCALIGN is at least as large as MemNode.
+ */
+
+typedef struct Guard {
+    size_t	ga_Bytes;
+    size_t	ga_Magic;	/* must be at least 32 bits */
+} Guard;
+
+#define MATYPE		long double
+#define MALLOCALIGN	((sizeof(MATYPE) > sizeof(Guard)) ? sizeof(MATYPE) : sizeof(Guard))
+#define GAMAGIC		0x55FF44FD
+#define GAFREE		0x5F54F4DF
+
+#include "zalloc_protos.h"
+
diff -ruN sys/boot/i386/pxe_ng/libstand/zalloc_malloc.c sys/boot/i386/pxe_ng/libstand/zalloc_malloc.c
--- sys/boot/i386/pxe_ng/libstand/zalloc_malloc.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/zalloc_malloc.c	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,209 @@
+/*
+ * This module derived from code donated to the FreeBSD Project by 
+ * Matthew Dillon <dillon@backplane.com>
+ *
+ * Copyright (c) 1998 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * MALLOC.C - malloc equivalent, runs on top of zalloc and uses sbrk
+ */
+
+#include "zalloc_defs.h"
+
+static MemPool	MallocPool;
+
+#ifdef DMALLOCDEBUG
+static int MallocMax;
+static int MallocCount;
+
+void mallocstats(void);
+#endif
+
+#ifdef malloc
+#undef malloc
+#undef free
+#endif
+
+#ifdef __alpha__
+void
+free_region(void *start, void *end)
+{
+    zextendPool(&MallocPool, start, (caddr_t)end - (caddr_t)start);
+    zfree(&MallocPool, start, (caddr_t)end - (caddr_t)start);
+}
+#endif
+
+void *
+Malloc(size_t bytes, const char *file, int line)
+{
+    Guard *res;
+
+#ifdef USEENDGUARD
+    bytes += MALLOCALIGN + 1;
+#else
+    bytes += MALLOCALIGN;
+#endif
+
+    while ((res = znalloc(&MallocPool, bytes)) == NULL) {
+	int incr = (bytes + BLKEXTENDMASK) & ~BLKEXTENDMASK;
+	char *base;
+
+	if ((base = sbrk(incr)) == (char *)-1)
+	    return(NULL);
+	zextendPool(&MallocPool, base, incr);
+	zfree(&MallocPool, base, incr);
+    }
+#ifdef DMALLOCDEBUG
+    if (++MallocCount > MallocMax)
+	MallocMax = MallocCount;
+#endif
+#ifdef USEGUARD
+    res->ga_Magic = GAMAGIC;
+#endif
+    res->ga_Bytes = bytes;
+#ifdef USEENDGUARD
+    *((signed char *)res + bytes - 1) = -2;
+#endif
+
+    return((char *)res + MALLOCALIGN);
+}
+
+void
+Free(void *ptr, const char *file, int line)
+{
+    size_t bytes;
+
+    if (ptr != NULL) {
+	Guard *res = (void *)((char *)ptr - MALLOCALIGN);
+
+	if (file == NULL)
+		file = "unknown";
+#ifdef USEGUARD
+	if (res->ga_Magic == GAFREE) {
+	    printf("free: duplicate free @ %p from %s:%d\n", ptr, file, line);
+	    return;
+	}
+	if (res->ga_Magic != GAMAGIC)
+	    panic("free: guard1 fail @ %p from %s:%d", ptr, file, line);
+	res->ga_Magic = GAFREE;
+#endif
+#ifdef USEENDGUARD
+	if (*((signed char *)res + res->ga_Bytes - 1) == -1) {
+	    printf("free: duplicate2 free @ %p from %s:%d\n", ptr, file, line);
+	    return;
+	}
+	if (*((signed char *)res + res->ga_Bytes - 1) != -2)
+	    panic("free: guard2 fail @ %p + %d from %s:%d", ptr, res->ga_Bytes - MALLOCALIGN, file, line);
+	*((signed char *)res + res->ga_Bytes - 1) = -1;
+#endif
+
+	bytes = res->ga_Bytes;
+	zfree(&MallocPool, res, bytes);
+#ifdef DMALLOCDEBUG
+	--MallocCount;
+#endif
+    }
+}
+
+
+void *
+Calloc(size_t n1, size_t n2, const char *file, int line)
+{
+    iaddr_t bytes = (iaddr_t)n1 * (iaddr_t)n2;
+    void *res;
+
+    if ((res = Malloc(bytes, file, line)) != NULL) {
+	bzero(res, bytes);
+#ifdef DMALLOCDEBUG
+	if (++MallocCount > MallocMax)
+	    MallocMax = MallocCount;
+#endif
+    }
+    return(res);
+}
+
+/*
+ * realloc() - I could be fancier here and free the old buffer before
+ * 	       allocating the new one (saving potential fragmentation
+ *	       and potential buffer copies).  But I don't bother.
+ */
+
+void *
+Realloc(void *ptr, size_t size, const char *file, int line)
+{
+    void *res;
+    size_t old;
+
+    if ((res = Malloc(size, file, line)) != NULL) {
+	if (ptr) {
+	    old = *(size_t *)((char *)ptr - MALLOCALIGN) - MALLOCALIGN;
+	    if (old < size)
+		bcopy(ptr, res, old);
+	    else
+		bcopy(ptr, res, size);
+	    Free(ptr, file, line);
+	} else {
+#ifdef DMALLOCDEBUG
+	    if (++MallocCount > MallocMax)
+		MallocMax = MallocCount;
+#ifdef EXITSTATS
+	    if (DidAtExit == 0) {
+		DidAtExit = 1;
+		atexit(mallocstats);
+	    }
+#endif
+#endif
+	}
+    }
+    return(res);
+}
+
+void *
+Reallocf(void *ptr, size_t size, const char *file, int line)
+{
+    void *res;
+
+    if ((res = Realloc(ptr, size, file, line)) == NULL)
+	Free(ptr, file, line);
+    return(res);
+}
+
+#ifdef DMALLOCDEBUG
+
+void
+mallocstats(void)
+{
+    printf("Active Allocations: %d/%d\n", MallocCount, MallocMax);
+#ifdef ZALLOCDEBUG
+    zallocstats(&MallocPool);
+#endif
+}
+
+#endif
+
diff -ruN sys/boot/i386/pxe_ng/libstand/zalloc_mem.h sys/boot/i386/pxe_ng/libstand/zalloc_mem.h
--- sys/boot/i386/pxe_ng/libstand/zalloc_mem.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/zalloc_mem.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,55 @@
+/*
+ * This module derived from code donated to the FreeBSD Project by 
+ * Matthew Dillon <dillon@backplane.com>
+ *
+ * Copyright (c) 1998 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * H/MEM.H
+ *
+ * Basic memory pool / memory node structures.
+ */
+
+typedef struct MemNode {
+    struct MemNode	*mr_Next;
+    iaddr_t		mr_Bytes;
+} MemNode;
+
+typedef struct MemPool {
+    void		*mp_Base;  
+    void		*mp_End;
+    MemNode		*mp_First; 
+    iaddr_t		mp_Size;
+    iaddr_t		mp_Used;
+} MemPool;
+
+#define MEMNODE_SIZE_MASK       ((sizeof(MemNode) <= 8) ? 7 : 15)
+
+#define ZNOTE_FREE	0
+#define ZNOTE_REUSE	1
+
diff -ruN sys/boot/i386/pxe_ng/libstand/zalloc_protos.h sys/boot/i386/pxe_ng/libstand/zalloc_protos.h
--- sys/boot/i386/pxe_ng/libstand/zalloc_protos.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/libstand/zalloc_protos.h	2009-02-20 12:30:55.000000000 -0500
@@ -0,0 +1,35 @@
+/*
+ * This module derived from code donated to the FreeBSD Project by 
+ * Matthew Dillon <dillon@backplane.com>
+ *
+ * Copyright (c) 1998 The FreeBSD Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+Library void *znalloc(struct MemPool *mpool, iaddr_t bytes);
+Library void zfree(struct MemPool *mpool, void *ptr, iaddr_t bytes);
+Library void zextendPool(MemPool *mp, void *base, iaddr_t bytes);
+Library void zallocstats(struct MemPool *mp);
diff -ruN sys/boot/i386/pxe_ng/loader/Makefile sys/boot/i386/pxe_ng/loader/Makefile
--- sys/boot/i386/pxe_ng/loader/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/loader/Makefile	2009-03-02 21:20:26.000000000 -0500
@@ -0,0 +1,126 @@
+# $FreeBSD: src/sys/boot/i386/loader/Makefile,v 1.85 2007/05/29 14:35:57 simokawa Exp $
+
+.include <bsd.own.mk>
+
+PROG=		loader.sym
+INTERNALPROG=
+NEWVERSWHAT=	"bootstrap loader" i386
+
+# architecture-specific loader code
+SRCS=		main.c conf.c vers.c
+
+# Put LOADER_FIREWIRE_SUPPORT=yes in /etc/make.conf for FireWire/dcons support
+.if defined(LOADER_FIREWIRE_SUPPORT)
+CFLAGS+=	-DLOADER_FIREWIRE_SUPPORT
+LIBFIREWIRE=	${.OBJDIR}/../libfirewire/libfirewire.a
+.endif
+
+CFLAGS+=        -DLOADER_HTTP_SUPPORT
+
+# Enable HTTP support for PXE
+.if !defined(LOADER_HTTP_SUPPORT)
+
+# Enable PXE TFTP or NFS support, not both.
+.if defined(LOADER_TFTP_SUPPORT)
+CFLAGS+=        -DLOADER_TFTP_SUPPORT
+.else
+CFLAGS+=        -DLOADER_NFS_SUPPORT
+.endif
+
+.endif
+
+.if ${MACHINE_ARCH} == "amd64"
+CFLAGS+=        -DLOADER_AMD64_ELF_SUPPORT
+.endif
+
+# Include bcache code.
+HAVE_BCACHE=	yes
+
+# Enable PnP and ISA-PnP code.
+HAVE_PNP=	yes
+HAVE_ISABUS=	yes
+
+# Enable more pxe_http functions
+#CFLAGS+=       -DPXE_MORE
+
+.if ${MK_FORTH} != "no"
+# Enable BootForth
+BOOT_FORTH=	yes
+CFLAGS+=	-DBOOT_FORTH -I${.CURDIR}/../../ficl -I${.CURDIR}/../../ficl/i386
+LIBFICL=	${.OBJDIR}/../../ficl/libficl.a
+.endif
+
+.if defined(LOADER_BZIP2_SUPPORT)
+CFLAGS+=	-DLOADER_BZIP2_SUPPORT
+.endif
+.if !defined(LOADER_NO_GZIP_SUPPORT)
+CFLAGS+=	-DLOADER_GZIP_SUPPORT
+.endif
+
+# Always add MI sources 
+.PATH:		${.CURDIR}/../../common
+.include	"${.CURDIR}/../../common/Makefile.inc"
+CFLAGS+=	-I${.CURDIR}/../../common
+CFLAGS+=	-I.
+
+CLEANFILES=	vers.c loader loader.bin loader.help
+
+CFLAGS+=	-Wall
+LDFLAGS=	-static -Ttext 0x0
+
+# i386 standalone support library
+LIBI386=	${.OBJDIR}/libi386/libi386.a ${.OBJDIR}/../libpxe_http.a
+CFLAGS+=	-I${.CURDIR}/..
+
+# BTX components
+CFLAGS+=	-I${.CURDIR}/../btx/lib
+
+# pxe_http includes
+CFLAGS+=        -I${.CURDIR}/../pxe_ng
+
+# Debug me!
+#CFLAGS+=	-g
+#LDFLAGS+=	-g
+
+# Pick up ../Makefile.inc early.
+.include <bsd.init.mk>
+
+vers.c:	${.CURDIR}/../../common/newvers.sh ${.CURDIR}/version
+	sh ${.CURDIR}/../../common/newvers.sh ${.CURDIR}/version ${NEWVERSWHAT}
+
+loader: loader.bin ${BTXLDR} ${BTXKERN}
+	btxld -v -f aout -e ${LOADER_ADDRESS} -o ${.TARGET} -l ${BTXLDR} \
+		-b ${BTXKERN} loader.bin
+
+loader.bin: loader.sym
+	cp ${.ALLSRC} ${.TARGET}
+	strip -R .comment -R .note ${.TARGET}
+
+loader.help: help.common help.i386
+	cat ${.ALLSRC} | awk -f ${.CURDIR}/../../common/merge_help.awk > ${.TARGET}
+
+.PATH: ${.CURDIR}/../../forth 
+FILES=	loader loader.help loader.4th support.4th loader.conf
+FILES+= screen.4th frames.4th beastie.4th
+# XXX INSTALLFLAGS_loader= -b
+FILESMODE_loader= ${BINMODE} -b
+FILESDIR_loader.conf=	/boot/defaults
+
+.if !exists(${DESTDIR}/boot/loader.rc)
+FILES+=	loader.rc
+.endif
+
+# XXX crt0.o needs to be first for pxeboot(8) to work
+OBJS=	${BTXCRT} 
+
+DPADD=	${LIBFICL} ${LIBFIREWIRE} ${LIBI386} ${LIBSTAND}
+LDADD=	${LIBFICL} ${LIBFIREWIRE} ${LIBI386} -lstand
+
+.include <bsd.prog.mk>
+
+.if ${MACHINE_ARCH} == "amd64"
+beforedepend ${OBJS}: machine
+CLEANFILES+=	machine
+machine:
+	ln -sf ${.CURDIR}/../../../i386/include machine
+.endif
diff -ruN sys/boot/i386/pxe_ng/loader/conf.c sys/boot/i386/pxe_ng/loader/conf.c
--- sys/boot/i386/pxe_ng/loader/conf.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/loader/conf.c	2009-03-02 20:20:13.000000000 -0500
@@ -0,0 +1,171 @@
+/*-
+ * Copyright (c) 1998 Michael Smith <msmith@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/boot/i386/loader/conf.c,v 1.26 2007/05/29 14:35:57 simokawa Exp $");
+
+#include <stand.h>
+#include <bootstrap.h>
+#include "libi386/libi386.h"
+#include "pxe_http/httpfs.h"
+
+/*
+ * We could use linker sets for some or all of these, but
+ * then we would have to control what ended up linked into
+ * the bootstrap.  So it's easier to conditionalise things
+ * here.
+ *
+ * XXX rename these arrays to be consistent and less namespace-hostile
+ *
+ * XXX as libi386 and biosboot merge, some of these can become linker sets.
+ */
+
+#ifdef LOADER_HTTP_SUPPORT
+#undef LOADER_NFS_SUPPORT
+#undef LOADER_TFTP_SUPPORT
+#endif
+
+#if defined(LOADER_NFS_SUPPORT) && defined(LOADER_TFTP_SUPPORT)
+#error "Cannot have both tftp and nfs support yet."
+#endif
+
+#if defined(LOADER_FIREWIRE_SUPPORT)
+extern struct devsw fwohci;
+#endif
+
+/* Exported for libstand */
+struct devsw *devsw[] = {
+    &bioscd,
+    &biosdisk,
+#if defined(LOADER_NFS_SUPPORT) || defined(LOADER_TFTP_SUPPORT)  || \
+    defined(LOADER_HTTP_SUPPORT)
+    &pxedisk,
+#endif
+#if defined(LOADER_FIREWIRE_SUPPORT)
+    &fwohci,
+#endif
+    NULL
+};
+
+#ifdef LOADER_HTTP_SUPPORT
+/* free as much as possible memory, by removing unused by PXE filesystems */
+#undef LOADER_EXT2_SUPPORT
+#undef LOADER_DOS_SUPPORT
+#undef LOADER_CD9660_SUPPORT
+#undef LOADER_SPLITFS_SUPPORT
+#undef LOADER_NFS_SUPPORT
+#undef LOADER_TFTP_SUPPORT
+#else
+#define LOADER_NFS_SUPPORT
+#endif
+
+struct fs_ops *file_system[] = {
+    &ufs_fsops,
+#ifdef LOADER_EXT2_SUPPORT
+    &ext2fs_fsops,
+#endif
+#ifdef LOADER_DOS_SUPPORT
+    &dosfs_fsops,
+#endif
+#ifdef LOADER_CD9660_SUPPORT
+    &cd9660_fsops,
+#endif
+#ifdef LOADER_SPLITFS_SUPPORT
+    &splitfs_fsops,
+#endif
+#ifdef LOADER_GZIP_SUPPORT
+    &gzipfs_fsops,
+#endif
+#ifdef LOADER_BZIP2_SUPPORT
+    &bzipfs_fsops,
+#endif
+#ifdef LOADER_NFS_SUPPORT 
+    &nfs_fsops,
+#endif
+#ifdef LOADER_TFTP_SUPPORT
+    &tftp_fsops,
+#endif
+#ifdef LOADER_HTTP_SUPPORT
+    &http_fsops,
+#endif
+    NULL
+};
+
+/* Exported for i386 only */
+/* 
+ * Sort formats so that those that can detect based on arguments
+ * rather than reading the file go first.
+ */
+extern struct file_format	i386_elf;
+extern struct file_format	i386_elf_obj;
+#ifdef LOADER_AMD64_ELF_SUPPORT
+extern struct file_format	amd64_elf;
+extern struct file_format	amd64_elf_obj;
+#endif
+
+struct file_format *file_formats[] = {
+    &i386_elf,
+    &i386_elf_obj,
+#ifdef LOADER_AMD64_ELF_SUPPORT
+    &amd64_elf,
+    &amd64_elf_obj,
+#endif
+    NULL
+};
+
+/* 
+ * Consoles 
+ *
+ * We don't prototype these in libi386.h because they require
+ * data structures from bootstrap.h as well.
+ */
+extern struct console vidconsole;
+extern struct console comconsole;
+#if defined(LOADER_FIREWIRE_SUPPORT)
+extern struct console dconsole;
+#endif
+extern struct console nullconsole;
+
+struct console *consoles[] = {
+    &vidconsole,
+    &comconsole,
+#if defined(LOADER_FIREWIRE_SUPPORT)
+    &dconsole,
+#endif
+    &nullconsole,
+    NULL
+};
+
+extern struct pnphandler isapnphandler;
+extern struct pnphandler biospnphandler;
+extern struct pnphandler biospcihandler;
+
+struct pnphandler *pnphandlers[] = {
+    &biospnphandler,		/* should go first, as it may set isapnp_readport */
+    &isapnphandler,
+    &biospcihandler,
+    NULL
+};
diff -ruN sys/boot/i386/pxe_ng/loader/help.i386 sys/boot/i386/pxe_ng/loader/help.i386
--- sys/boot/i386/pxe_ng/loader/help.i386	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/loader/help.i386	2009-03-02 20:20:15.000000000 -0500
@@ -0,0 +1,63 @@
+################################################################################
+# TACPI DControl ACPI module behaviour
+
+	$acpi_load
+
+	If set, the ACPI module will be loaded.  Clear it with
+
+	unset acpi_load
+
+	$hint.acpi.0.disabled="1"
+
+	If set, the ACPI module won't be loaded.
+
+	Note that the ACPI autodetection sets a number of hints to
+	pass information to the ACPI module.  These should not be 
+	overridden, or system behaviour will be undefined.
+
+
+################################################################################
+# Treboot DReboot the system
+
+	reboot
+
+	Causes the system to immediately reboot.
+
+################################################################################
+# Theap DDisplay memory management statistics
+
+	heap
+
+	Requests debugging output from the heap manager.  For debugging use
+	only.
+
+################################################################################
+# Tset Snum_ide_disks DSet the number of IDE disks
+
+	NOTE: this variable is deprecated, use root_disk_unit instead.
+
+	set num_ide_disks=<value>
+
+	When booting from a SCSI disk on a system with one or more IDE disks,
+	and where the IDE disks are the default boot device, it is necessary
+	to tell the kernel how many IDE disks there are in order to have it
+	correctly locate the SCSI disk you are booting from.
+
+################################################################################
+# Tset Sroot_disk_unit DForce the root disk unit number.
+
+	set root_disk_unit=<value>
+
+	If the code which detects the disk unit number for the root disk is
+	confused, eg. by a mix of SCSI and IDE disks, or IDE disks with
+	gaps in the sequence (eg. no primary slave), the unit number can be
+	forced by setting this variable.
+
+################################################################################
+# Tsmap DDisplay BIOS SMAP table
+
+	smap
+
+	Displays the BIOS SMAP (system memory map) table.
+
+################################################################################
diff -ruN sys/boot/i386/pxe_ng/loader/loader.rc sys/boot/i386/pxe_ng/loader/loader.rc
--- sys/boot/i386/pxe_ng/loader/loader.rc	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/loader/loader.rc	2009-03-02 20:20:16.000000000 -0500
@@ -0,0 +1,21 @@
+\ Loader.rc
+\ $FreeBSD: src/sys/boot/i386/loader/loader.rc,v 1.4.4.1 2005/10/30 14:40:39 scottl Exp $
+\
+\ Includes additional commands
+include /boot/loader.4th
+
+\ Reads and processes loader.conf variables
+start
+
+\ Tests for password -- executes autoboot first if a password was defined
+check-password
+
+\ Load in the boot menu
+include /boot/beastie.4th
+
+echo "loading RAM-drive image"
+load -t mfs_root /boot/mfsroot
+set vfs.root.mountfrom="ufs:/dev/md0c"
+
+\ Start the boot menu
+beastie-start
diff -ruN sys/boot/i386/pxe_ng/loader/version sys/boot/i386/pxe_ng/loader/version
--- sys/boot/i386/pxe_ng/loader/version	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/loader/version	2009-03-02 20:20:20.000000000 -0500
@@ -0,0 +1,14 @@
+$FreeBSD: src/sys/boot/i386/loader/version,v 1.8 2001/12/11 00:49:33 jhb Exp $
+
+NOTE ANY CHANGES YOU MAKE TO THE BOOTBLOCKS HERE.  The format of this
+file is important.  Make sure the current version number is on line 6.
+
+1.1:	New calling conventions for fopen.
+1.0:	New semantics for finding the kernel, new boot.
+0.8:	Set/getenv & cia, copyin/out.
+0.7:	Supports large KVM
+0.6:	Increased dictionary size -- supports loader.4th
+0.5:	First release version
+0.2:	Initial integration with BTX
+0.1:	Initial i386 version, inspiration and some structure from the
+	NetBSD version.
diff -ruN sys/boot/i386/pxe_ng/ptelnet/README sys/boot/i386/pxe_ng/ptelnet/README
--- sys/boot/i386/pxe_ng/ptelnet/README	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/README	2009-03-02 20:20:22.000000000 -0500
@@ -0,0 +1,2 @@
+simple telnet client modules.
+based on code from D.E. Comer, D.L. Stevens, "Internetworking with TCP/IP", vol. III
\ No newline at end of file
diff -ruN sys/boot/i386/pxe_ng/ptelnet/options.c sys/boot/i386/pxe_ng/ptelnet/options.c
--- sys/boot/i386/pxe_ng/ptelnet/options.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/options.c	2009-03-02 20:20:24.000000000 -0500
@@ -0,0 +1,245 @@
+#include <sys/types.h>
+#include <stdint.h>
+#include <stand.h>
+
+#include "pxe_telnet.h"
+#include "telnet_fsm.h"
+
+extern uint8_t	doecho;		/* nonzero, if remote ECHO	*/
+extern uint8_t	rcvbinary;	/* non-zero if remote TRANSMIT-BINARY	*/
+extern int	substate;
+extern uint8_t	sndbinary;	/* non-zero if TRANSMIT-BINARY		*/
+extern uint8_t	termtype;	/* non-zero if received "DO TERMTYPE"	*/
+extern uint8_t	noga;
+
+int
+is_already(uint8_t val, uint8_t opt_cmd) 
+{
+
+	if (val) {
+		if (opt_cmd == TCWILL)
+			return (1);	/* already doing needed option */
+	} else if (opt_cmd == TCWONT)
+		return (1);		/* already NOT doing needed option */
+		
+	return (0);
+}
+
+void
+do_answer(uint8_t val, uint8_t c, int socket)
+{
+
+        putc(TCIAC, socket);
+	putc(val ? TCDO : TCDONT, socket);
+	putc(c, socket);
+}
+
+/* do_echo() - processes ECHO option
+ * in:
+ *	socket	- socket to place data to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+do_echo(int socket, int c)
+{
+
+	if (is_already(doecho, fsm_get_option_cmd()))
+		return (0);
+
+	doecho = !doecho;
+        do_answer(doecho, (uint8_t)c, socket);
+
+	return (0);
+}
+
+/* do_noga() - process "no go-ahead" option
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+do_noga(int socket, int c)
+{
+
+	if (is_already(noga, fsm_get_option_cmd()))
+		return (0);
+
+	noga = !noga;
+	do_answer(noga, (uint8_t)c, socket);
+	
+	return (0);
+}
+
+/* do_notsup() - process not supported will/won't option
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+do_notsup(int socket, int c)
+{
+
+	do_answer(0, (uint8_t)c, socket);
+	return (0);
+}
+
+
+/* do_txbinary() - process transmit binary option
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+do_txbinary(int socket, int c)
+{
+
+	if (is_already(rcvbinary, fsm_get_option_cmd()))
+		return (0);
+		
+	rcvbinary = !rcvbinary;
+	do_answer(rcvbinary, (uint8_t)c, socket);	
+	
+	return (0);
+}
+
+/* recopt() - process option type
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+recopt(int socket, int c)
+{
+
+	fsm_set_option_cmd((uint8_t)c);
+	
+	return (0);
+}
+
+/* no_op() - don't do anything
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+no_op(int socket, int c)
+{
+
+	return (0);
+}
+
+
+/* subend() - end of option subnegotiation
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+subend(int socket, int c)
+{
+
+	return fsm_setstate(FSM_SUBS, SS_START);
+}
+
+/* subopt() - do option subnegotiation FSM state change
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+subopt(int socket, int c)
+{
+
+	return fsm_process(FSM_SUBS, socket, c);
+}
+
+
+/* subtermtype() - terminal type subnegotiation
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+subtermtype(int socket, int c)
+{
+
+	putc(TCIAC, socket);
+	putc(TCSB, socket);
+	putc(TOTERMTYPE, socket);
+	putc(TT_IS, socket);
+	fputs("pxe_term", socket);
+	putc(TCIAC, socket);
+	putc(TCSE, socket);
+	
+	return (0);
+}
+
+/* will_notsup() - process not supported do/don't option
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+will_notsup(int socket, int c)
+{
+
+	putc(TCIAC, socket);
+	putc(TCWONT, socket);
+	putc((uint8_t)c, socket);
+	
+	return (0);
+}
+
+/* will_txbinary() - process transmit binary option
+ * in:
+ *	socket	- socket to place response to
+ *	c	- provided command
+ * out:
+ *	0	- ok
+ *	-1	- problems
+ */
+int
+will_txbinary(int socket, int c)
+{
+
+	if (is_already(sndbinary, fsm_get_option_cmd()))
+		return (0);
+		
+	sndbinary = !sndbinary;
+
+	putc(TCIAC, socket);
+	putc(sndbinary ? TCWILL : TCWONT, socket);
+	putc((char)c, socket);
+	
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.c sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.c
--- sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.c	2009-03-02 20:21:26.000000000 -0500
@@ -0,0 +1,116 @@
+#include <stand.h>
+#include <stdint.h>
+
+#include "pxe_telnet.h"
+#include "telnet_fsm.h"
+#include "telnet_opts.h"
+
+/* telnet_write() - writes sequence of bytes to connected socket
+ * in:
+ *	socket	- socket number
+ *	buf	- buffer to write data from
+ *	bufsize	- size of buffer
+ * out:
+ *	0	- all is ok
+ *	-1	- all is bad
+ *	>0	- count of written bytes
+ */
+int
+telnet_write(int socket, uint8_t *buf, size_t bufsize)
+{
+	return (0);
+}
+
+/* console_write() - writes sequence of bytes to console, extracting commands
+ * in:
+ *	buf	- buffer to output data from
+ *	bufsize	- size of buffer
+ * out:
+ *	0	- all is ok
+ *	-1	- all is bad
+ *	>0	- count of written bytes
+ */
+int
+console_write(uint8_t *buf, size_t bufsize)
+{
+	return (0);
+}
+
+/* console_read() - reads sequence of bytes from console
+ * in:
+ *	socket	- socket number
+ *	buf	- buffer to read data to
+ *	bufsize	- size of buffer
+ * out:
+ *	0	- all is ok, read ended
+ *	-1	- all is bad
+ *	>0	- count of read bytes
+ */
+int
+console_read(uint8_t *buf, size_t bufsize)
+{
+	return (0);
+}
+
+/* pxe_telnet() - connects via telnet protocol to host and interacts with user
+ * in:
+ *	addr - ip address of remote host
+ *	port - remote port to connect to
+ * out:
+ *	-1	- something failed
+ *	0	- all was ok
+ */
+int
+pxe_telnet(PXE_IPADDR *addr, uint16_t port)
+{
+	uint8_t	buf[PXE_TELNET_BUFSIZE];
+	int	byte_count = 0;
+	int	on = 1;
+	int	s = pxe_socket();
+	
+	if (s == -1) /* failed to create socket */
+		return (-1);
+		
+	int result = pxe_connect(s, addr, port);
+	
+	if (result == -1) { /* failed to connect */
+		pxe_close(s);
+		return (-1);
+	}
+	
+	fsmbuild(); /* set up finite state machines */
+
+	while (1) {
+		/* remote server input, TODO: nonblocking socket read */
+		byte_count = pxe_recv(s, buf, sizeof(buf), PXE_SOCK_NONBLOCKING);
+		
+		if (byte_count < 0) {
+			printf("\nerror: socket read failed\n");
+			break;
+		} else if ((byte_count == 0) && (pxe_sock_state(s) != PXE_SOCKET_CONNECTED)) {
+			printf("\nconnection closed.\n");
+			return (0);
+		} else { /* local console output */
+			console_write(buf, byte_count);
+		}
+
+		/* local console input */
+		byte_count = console_read(buf, sizeof(buf));
+		
+		if (byte_count < 0) {
+			printf("\nerror: tty read failed\n");
+			break;
+		} else if (byte_count == 0) {
+			pxe_close(s);
+			return (0)
+		} else {
+			/* output to remote server */
+			telnet_write(s, buf, byte_count);
+		}
+	}
+	
+	/* any error occured */
+	pxe_close(s);
+		
+	return (-1);
+}
diff -ruN sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.h sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.h
--- sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/pxe_telnet.h	2009-03-02 20:21:27.000000000 -0500
@@ -0,0 +1,56 @@
+#ifndef PXE_TELNET_INCLUDED
+#define PXE_TELNET_INCLUDED
+
+#include <stdint.h>
+#include "../pxe_ip.h"
+
+/* TELNET Command Codes: */
+#define	TCSB		(uint8_t)250	/* Start Subnegotiation		*/
+#define	TCSE		(uint8_t)240	/* End Of Subnegotiation	*/
+#define	TCNOP		(uint8_t)241	/* No Operation			*/
+#define	TCDM		(uint8_t)242	/* Data Mark (for Sync)		*/
+#define	TCBRK		(uint8_t)243	/* NVT Character BRK		*/
+#define	TCIP		(uint8_t)244	/* Interrupt Process		*/
+#define	TCAO		(uint8_t)245	/* Abort Output			*/
+#define	TCAYT		(uint8_t)246	/* "Are You There?" Function	*/ 
+#define	TCEC		(uint8_t)247	/* Erase Character		*/
+#define	TCEL		(uint8_t)248	/* Erase Line			*/
+#define	TCGA		(uint8_t)249	/* "Go Ahead" Function		*/
+#define	TCWILL		(uint8_t)251	/* Desire/Confirm Will Do Option*/
+#define	TCWONT		(uint8_t)252	/* Refusal To Do Option		*/
+#define	TCDO		(uint8_t)253	/* Request To Do Option		*/
+#define	TCDONT		(uint8_t)254	/* Request NOT To Do Option	*/
+#define	TCIAC		(uint8_t)255	/* Interpret As Command Escape	*/
+
+/* Telnet Option Codes: */
+#define	TOTXBINARY	(uint8_t)  0	/* TRANSMIT-BINARY option	*/
+#define	TOECHO		(uint8_t)  1	/* ECHO Option			*/
+#define	TONOGA		(uint8_t)  3	/* Suppress Go-Ahead Option	*/
+#define	TOTERMTYPE	(uint8_t) 24	/* Terminal-Type Option		*/
+
+/* Network Virtual Printer Special Characters: */
+#define	VPLF		'\n'	/* Line Feed				*/
+#define	VPCR		'\r'	/* Carriage Return			*/
+#define	VPBEL		'\a'	/* Bell (attention signal)		*/
+#define	VPBS		'\b'	/* Back Space				*/
+#define	VPHT		'\t'	/* Horizontal Tab			*/
+#define	VPVT		'\v'	/* Vertical Tab				*/
+#define	VPFF		'\f'	/* Form Feed				*/
+
+/* Keyboard Command Characters: */
+#define	KCESCAPE	035	/* Local escape character ('^]')	*/
+#define	KCDCON		'.'	/* Disconnect escape command		*/
+#define	KCNL		'\n'	/* Newline character			*/
+
+#define	KCANY		(NCHRS + 1)
+
+/* Option Subnegotiation Constants: */
+#define	TT_IS		0	/* TERMINAL_TYPE option "IS" command	*/
+#define	TT_SEND		1	/* TERMINAL_TYPE option "SEND" command	*/
+
+/* establishes telnet connection to server and interacts with user */
+int pxe_telnet(PXE_IPADDR *addr, uint16_t port);
+
+#define PXE_TELNET_BUFSIZE         1024    /* buffer size */
+
+#endif /* PXE_TELNET_INCLUDED */
\ No newline at end of file
diff -ruN sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.c sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.c
--- sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.c	2009-03-02 20:21:29.000000000 -0500
@@ -0,0 +1,255 @@
+#include "pxe_telnet.h"
+#include "telnet_fsm.h"
+#include "telnet_opts.h"
+
+uint8_t option_cmd = 0;
+
+int     substate = 0;
+uint8_t subfsm[NSSTATES][NCHRS];
+
+int	ttstate = 0;
+uint8_t	ttfsm[NTSTATES][NCHRS];
+
+int     sostate = 0;
+uint8_t sofsm[NKSTATES][NCHRS];
+
+#define TINVALID        0xff    /* an invalid transition index          */
+
+struct fsm_trans ttstab[] = {
+	/* State	Input		Next State	Action	*/
+	/* ------	------		-----------	-------	*/
+	{ TSDATA,	TCIAC,		TSIAC,		no_op		},
+	{ TSDATA,	TCANY,		TSDATA,		ttputc 		},
+	{ TSIAC,	TCIAC,		TSDATA,		ttputc		},
+	{ TSIAC,	TCSB,		TSSUBNEG,	no_op		},
+/* Telnet Commands */
+	{ TSIAC,	TCNOP,		TSDATA,		no_op		},
+//	{ TSIAC,	TCDM,		TSDATA,		tcdm		},
+/* Option Negotiation */
+	{ TSIAC,	TCWILL,		TSWOPT,		recopt		},
+	{ TSIAC,	TCWONT,		TSWOPT,		recopt		},
+	{ TSIAC,	TCDO,		TSDOPT,		recopt		},
+	{ TSIAC,	TCDONT,		TSDOPT,		recopt		},
+	{ TSIAC,	TCANY,		TSDATA,		no_op		},
+/* Option Subnegotion */
+	{ TSSUBNEG,	TCIAC,		TSSUBIAC,	no_op		},
+	{ TSSUBNEG,	TCANY,		TSSUBNEG,	subopt		},
+	{ TSSUBIAC,	TCSE,		TSDATA,		subend		},
+	{ TSSUBIAC,	TCANY,		TSSUBNEG,	subopt		},
+
+	{ TSWOPT,	TOECHO,		TSDATA,		do_echo		},
+	{ TSWOPT,	TONOGA,		TSDATA,		do_noga		},
+	{ TSWOPT,	TOTXBINARY,	TSDATA,		do_txbinary	},
+	{ TSWOPT,	TCANY,		TSDATA,		do_notsup	},
+
+	{ TSDOPT,	TOTXBINARY,	TSDATA,		will_txbinary	},
+	{ TSDOPT,	TCANY,		TSDATA,		will_notsup	},
+
+	{ FSINVALID,	TCANY,		FSINVALID,	abort		},
+};
+
+struct fsm_trans sostab[] = {
+	/* State        Input           Next State      Action  */
+	/* ------       ------          -----------     ------- */
+	/* Data Input */
+	{ KSREMOTE,     KCESCAPE,       KSLOCAL,        no_op           },
+	{ KSREMOTE,     KCANY,          KSREMOTE,       soputc          },
+
+	/* Local Escape Commands */
+	{ KSLOCAL,      KCESCAPE,       KSREMOTE,       soputc          },
+	{ KSLOCAL,      KCDCON,         KSREMOTE,       disconnect      },
+	{ KSLOCAL,      KCANY,          KSREMOTE,       sonotsup        },
+
+	{ FSINVALID,    KCANY,          FSINVALID,      abort           },
+};
+
+struct fsm_trans substab[] = {
+        /* State        Input           Next State      Action  */
+	/* ------       ------          -----------     ------- */
+	{ SS_START,     TOTERMTYPE,     SS_TERMTYPE,    no_op           },
+	{ SS_START,     TCANY,          SS_END,         no_op           },
+/*	{ SS_TERMTYPE,  TT_SEND,        SS_END,         subtermtype     },
+	{ SS_TERMTYPE,  TCANY,          SS_END,         no_op           }, */
+	{ SS_END,       TCANY,          SS_END,         no_op           },
+
+	{ FSINVALID,    TCANY,          FSINVALID,      abort           },
+};
+								
+
+/* fsmbuild()  build the Finite State Machine data structures
+ * in/out:
+ *	none
+ * NOTE: may be better to use prebuilt structure, or not use matrix to
+ *	reduce memory usage (~1kb).
+ */
+int
+fsmbuild()
+{
+
+	fsminit(ttfsm, ttstab, NTSTATES);
+	ttstate = TSDATA;
+		   
+	fsminit(sofsm, sostab, NKSTATES);
+	sostate = KSREMOTE;
+				   
+	fsminit(subfsm, substab, NSSTATES);
+	substate = SS_START;
+}
+
+
+
+/* fsminit() - inits Finite State Machine, actually performs build of matrix
+ *	structure.
+ * in:
+ *	fsm	- storage for neded matrix
+ *	ttab	- FSM description structures
+ *	nsatates - number of states
+ * out:
+ *	0	- all is ok
+ *	-1 	- failed
+ */
+int
+fsminit(uint8_t fsm[][NCHRS], struct fsm_trans  ttab[], int nstates)
+{
+	struct fsm_trans        *pt;
+	int                     sn, ti, cn;
+		   
+	for (cn = 0; cn < NCHRS; ++cn)
+	for (ti = 0; ti < nstates; ++ti)
+		fsm[ti][cn] = TINVALID;
+								   
+	for (ti = 0; ttab[ti].ft_state != FSINVALID; ++ti) {
+		pt = &ttab[ti];
+		sn = pt->ft_state;
+		
+		if (pt->ft_char == TCANY) {
+			for (cn = 0; cn < NCHRS; ++cn)
+		    		if (fsm[sn][cn] == TINVALID)
+					fsm[sn][cn] = ti;
+		} else
+        		fsm[sn][pt->ft_char] = ti;
+	}
+	
+	/* set all uninitialized indices to an invalid transition */
+	for (cn = 0; cn < NCHRS; ++cn)
+	for (ti = 0; ti < nstates; ++ti)
+		if (fsm[ti][cn] == TINVALID)
+			fsm[ti][cn] = ti;
+			
+	return (0);
+}
+
+/* fsm_setstate() - sets state of FSM, choosen by index
+ * in:
+ *	table_index	- index of FSM (one of FSM_... constants)
+ *	state		- state to set current state to
+ * out:
+ *	0	- all is ok
+ *	-1 	- failed
+ */
+int
+fsm_setstate(int table_index, int state)
+{
+	int	*state = NULL;
+
+	switch(table_index) {
+	case FSM_TERMINAL:
+		state = &ttstate;
+		break;
+		
+	case FSM_SOCKET:
+		state = &sostate;
+		break;
+		
+	case FSM_SUBS:
+		state = &substate;
+		break;
+		
+	default:
+		return (-1);
+	}
+
+	*state = state;	
+	
+	return (0);
+}
+
+/* fsm_process() - process FSM state change if any
+ * in:
+ *	table_index	- index of FSM (one of FSM_... constants)
+ *	c		- incoming char to process
+ *	socket		- socket to write to
+ * out:
+ *	0	- all is ok
+ *	-1 	- failed
+ */
+int
+fsm_process(int table_index, int socket, int c)
+{
+	uint8_t 		*fsm = NULL;
+	int			*state = NULL;
+	struct fsm_trans	*table = NULL;
+	int			ti = 0;
+	struct fsm_trans	*pt = NULL;
+	int			result = -1;
+	
+	switch(table_index) {
+	case FSM_TERMINAL:
+		fsm = ttfsm;
+		state = &ttstate;
+		table = ttstab;
+		break;
+		
+	case FSM_SOCKET:
+		fsm = sofsm;
+		state = &sostate;
+		table = sostab;
+		break;
+		
+	case FSM_SUBS:
+		fsm = subfsm;
+		state = &substate;
+		table = substab;
+		break;
+		
+	default:
+		return (-1);
+	}
+	
+	ti = fsm[ (*state) * NCHRS + c];
+	*pt = &table[ti];
+	
+	result =(pt->ft_action)(socket, c);
+	
+	if (result >= 0)
+		*state = pt->ft_next;
+						
+	return (result);
+}
+
+/* fsm_get_option_cmd() - return option_cmd
+ * in:
+ *	none
+ * out:
+ *	option_cmd (WILL/WONT & etc)
+ */
+uint8_t
+fsm_get_option_cmd()
+{
+
+	return (option_cmd);
+}
+
+/* fsm_set_option_cmd() - set option_cmd to provided value
+ * in:
+ *	opt		- value to set option_cmd to
+ * out:
+ *	none
+ */
+
+void
+fsm_set_option_cmd(uint8_t opt)
+{
+
+	option_cmd = opt;
+}
diff -ruN sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.h sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.h
--- sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/ptelnet/telnet_fsm.h	2009-03-02 20:21:31.000000000 -0500
@@ -0,0 +1,46 @@
+#ifndef __TELNET__FSM__
+#define __TELNET__FSM__
+
+#include <stdint.h>
+
+/* Telnet Socket-Input FSM States: */
+#define	TSDATA		 0	/* normal data processing		*/
+#define	TSIAC		 1	/* have seen IAC			*/
+#define	TSWOPT		 2	/* have seen IAC-{WILL/WONT}		*/
+#define	TSDOPT		 3	/* have seen IAC-{DO/DONT}		*/
+#define	TSSUBNEG	 4	/* have seen IAC-SB			*/
+#define	TSSUBIAC	 5	/* have seen IAC-SB-...-IAC		*/
+
+#define	NTSTATES	 6	/* # of TS* states			*/
+
+/* Telnet Keyboard-Input FSM States: */
+#define	KSREMOTE	 0	/* input goes to the socket		*/
+#define	KSLOCAL		 1	/* input goes to a local func.		*/
+#define	KSCOLLECT	 2	/* input is scripting-file name		*/
+
+#define	NKSTATES	 2	/* # of KS* states			*/
+
+/* Telnet Option Subnegotiation FSM States: */
+#define SS_START	0	/* initial state			*/
+#define	SS_TERMTYPE	1	/* TERMINAL_TYPE option subnegotiation	*/
+#define	SS_END		2	/* state after all legal input		*/
+
+#define	NSSTATES	3	/* # of SS_* states			*/
+
+#define	FSINVALID	0xff	/* an invalid state number		*/
+
+#define	NCHRS		256		/* number of valid characters	*/
+#define	TCANY		(NCHRS+1)	/* match any character		*/
+
+#define FSM_TERMINAL	0
+#define FSM_SOCKET	1
+#define FSM_SUBS	2
+
+struct fsm_trans {
+	uint8_t ft_state;		/* current state		*/
+	int16_t	ft_char;		/* input character		*/
+	uint8_t	ft_next;		/* next state			*/
+	int	(*ft_action)();		/* action to take		*/
+};
+
+#endif
\ No newline at end of file
diff -ruN sys/boot/i386/pxe_ng/pxe_arp.c sys/boot/i386/pxe_ng/pxe_arp.c
--- sys/boot/i386/pxe_ng/pxe_arp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_arp.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,387 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_arp.h"
+#include "pxe_await.h"
+#include "pxe_core.h"
+#include "pxe_mem.h"
+
+/* last entry used for PXE client ip/mac */
+static PXE_ARP_ENTRY		arp_table[MAX_ARP_ENTRIES + 1];
+static PXE_ARP_PACK_DATA	packet_to_send;	
+static int			arp_usage = 0;
+
+/*
+ *  pxe_arp_init() - initialisation of used by this module structures
+ *  in:
+ *	none
+ *  out:
+ *	none
+ */
+void
+pxe_arp_init()
+{
+#ifdef PXE_ARP_DEBUG
+	printf("pxe_arp_init() started.\n");
+	
+	if (packet_to_send.hdr.hsize != 0) {
+		printf("pxe_arp_init() already initialized.\n");
+		return;
+	}
+#endif
+	pxe_memset(&packet_to_send, 0, sizeof(PXE_ARP_PACK_DATA) );
+
+	pxe_memset(arp_table, 0, sizeof(arp_table));
+
+	/* filling packet_to_send, it will not change ever */	
+	packet_to_send.hdr.hwtype =htons(ETHER_TYPE);
+	packet_to_send.hdr.ptype = htons(PXE_PTYPE_IP);
+	packet_to_send.hdr.hsize = 6;	/* Ethernet MAC size */
+	packet_to_send.hdr.psize = 4;	/* ip4 size */
+	packet_to_send.hdr.operation = htons(PXE_ARPOP_REQUEST);
+
+	/* filling source related data: client ip & MAC */	
+	pxe_memcpy(pxe_get_mymac(), packet_to_send.body.src_hwaddr, 6);	
+
+	const PXE_IPADDR *addr = pxe_get_ip(PXE_IP_MY);;
+	packet_to_send.body.src_paddr = addr->ip;
+	
+	/* filling entry for own ip/mac*/	
+	pxe_memcpy(pxe_get_mymac(), arp_table[MAX_ARP_ENTRIES].mac, 6);	
+	arp_table[MAX_ARP_ENTRIES].addr.ip  = addr->ip;
+	
+	/* setting broadcast target address */
+	pxe_memset(packet_to_send.body.target_hwaddr, 0xff, 6); 
+}
+
+/*
+ *  pxe_arp_table_search() - searches entry in ARP table for given ip
+ *  in:
+ *	ip     - ip, for which to search MAC
+ *  out:
+ *	NULL   - not found such entry in arp_table
+ *	not NULL - pointer to MAC address
+ */
+const MAC_ADDR *
+pxe_arp_table_search(uint32_t ip)
+{
+#ifdef PXE_ARP_DEBUG_HELL
+	printf("pxe_arp_table_search(): started\n");
+#endif		
+	int entry = 0;
+	
+	for (; entry < MAX_ARP_ENTRIES + 1; ++entry) {
+
+		if (arp_table[entry].addr.ip == ip) {
+		
+			uint8_t *mac = &arp_table[entry].mac[0];
+#ifdef PXE_ARP_DEBUG_HELL
+			printf("pxe_arp_table_search(): %6D\n", mac, ":");
+#endif			
+			return (const MAC_ADDR *)mac;
+		}
+	}
+
+	return (NULL);
+}
+
+#ifdef PXE_MORE
+/* pxe_arp_stats() - show arp current table state
+ * in/out:
+ *	none
+ */
+void
+pxe_arp_stats()
+{
+	int entry = 0;
+	int limit = (arp_usage > MAX_ARP_ENTRIES) ? MAX_ARP_ENTRIES : arp_usage;
+
+	printf("ARP updates: %d\n", arp_usage);
+
+	for (; entry < limit; ++entry) {
+		
+		if ( (arp_table[entry].addr.ip == 0) ||
+		     (arp_table[entry].mac == NULL) )
+			continue;
+
+		printf("%s\t%6D\n",
+		    inet_ntoa(arp_table[entry].addr.ip),
+		    arp_table[entry].mac, ":");
+	}
+
+}
+#endif /* PXE_MORE */
+
+/*
+ *  pxe_arp_protocol() - process received arp packet, this function is called in
+ *			style of pxe_protocol_call function type, but last
+ *			parameter is unused
+ *  in:
+ *	pack     - rceived packet data
+ *	function - protocal function (will be always PXE_CORE_FRAG)
+ *  out:
+ *	always 0 - we are not interested in storing this packet in pxe_core queue
+ */
+int
+pxe_arp_protocol(PXE_PACKET *pack, uint8_t function)
+{
+#ifdef PXE_ARP_DEBUG_HELL
+	printf("pxe_arp_protocol() started.\n");
+#endif
+	PXE_ARP_PACK_DATA *arp_reply = (PXE_ARP_PACK_DATA *)pack->raw_data;
+
+	if (arp_reply->hdr.operation == htons(PXE_ARPOP_REQUEST) ) {
+	
+		uint8_t		*mac_src = arp_reply->body.src_hwaddr;
+		uint8_t		*mac_dst = arp_reply->body.target_hwaddr;		
+		PXE_IPADDR	ip4_src;
+		PXE_IPADDR	ip4_dst;
+		
+		const PXE_IPADDR *addr = pxe_get_ip(PXE_IP_MY);
+
+		ip4_src.ip = arp_reply->body.src_paddr;
+		ip4_dst.ip = arp_reply->body.target_paddr;
+		
+		if (ip4_src.ip == addr->ip) {
+			/* got broadcast send by us */
+#ifdef PXE_ARP_DEBUG_HELL
+			printf("arp request from myself ignored.\n");
+#endif
+			return (0);
+		}
+		
+#ifdef PXE_ARP_DEBUG		
+		printf("arp request from %6D/%s\n\t",
+		    mac_src, ":", inet_ntoa(ip4_src.ip));
+
+		printf("to: %6D/%s\n",
+		    mac_dst, ":", inet_ntoa(ip4_dst.ip));
+#endif		
+
+		/* somebody is looking for us */
+		if (ip4_dst.ip == arp_table[MAX_ARP_ENTRIES].addr.ip) {
+		
+			pxe_memcpy(arp_reply->body.src_hwaddr,
+			    packet_to_send.body.target_hwaddr, 6);
+			    
+			packet_to_send.body.target_paddr =
+			    arp_reply->body.src_paddr;
+			    
+			packet_to_send.hdr.operation = htons(PXE_ARPOP_REPLY);
+		
+			PXE_PACKET	pack;
+	
+			pack.raw_size = sizeof(PXE_ARP_PACK_DATA);
+			pack.raw_data = &packet_to_send;
+			pack.data = &packet_to_send.hdr;
+			pack.data_size =
+			    sizeof(PXE_ARP_PACK_DATA) - MEDIAHDR_LEN_ETH;
+			    
+		    	pack.protocol = PXE_PROTOCOL_ARP;
+			pack.dest_mac = (const MAC_ADDR *)
+			    &packet_to_send.body.target_hwaddr[0];
+			    
+			pack.flags = PXE_SINGLE;
+		
+			if (!pxe_core_transmit(&pack)) {
+			        printf("pxe_arp_protocol(): reply to arp request failed.\n");
+			}
+
+			/* cleaning packet_to_send back to initiakl state */
+			pxe_memset(packet_to_send.body.target_hwaddr, 0xff, 6);
+			packet_to_send.hdr.operation = htons(PXE_ARPOP_REQUEST);
+		}
+		
+		 /* we may cache information about packet sender */
+#ifdef PXE_ARP_SNIFF
+		/* just to skip operation filter below */
+		arp_reply->hdr.operation = htons(PXE_ARPOP_REPLY);
+#else
+		return (0);		
+#endif
+	}
+	
+	/* we don't need anything except replies on that stage */
+	if (arp_reply->hdr.operation != htons(PXE_ARPOP_REPLY) ) 
+		return (0);
+		
+	/* if arp_usage exceeds MAX_ARP_ENTRIES, occurs rewriting of earlier
+	 * placed ARP entries. MAC may be lost, so protocol must check this
+	 * case when creating packet (cause there used pointer to MAC
+	 * in arp_table). May be better way is to panic if arp_table is full.
+	 * In fact, we don't need many entries. Only two: one for gateway,
+	 * one for DNS-server or for proxy server. Default arp_table size is 8.
+	 * It seems more than enough.
+	 */	
+	 
+	const MAC_ADDR *kmac = pxe_arp_table_search(arp_reply->body.src_paddr);
+	if (NULL != kmac) {
+#ifdef PXE_ARP_DEBUG
+	        uint8_t *octet = (uint8_t *)&arp_reply->body.src_paddr;
+	        printf("MAC of %d.%d.%d.%d already known: %x:%x:%x:%x:%x:%x\n",
+		    octet[0], octet[1], octet[2], octet[3],
+		    (*kmac)[0], (*kmac)[1], (*kmac)[2],
+		    (*kmac)[3], (*kmac)[4], (*kmac)[5]
+		);
+#endif
+		/* NOTE: theoretically it's possible mac != known mac. Ignore. */
+		return (0);
+	}
+	
+	pxe_memcpy(&arp_reply->body.src_hwaddr,
+	    &arp_table[arp_usage % MAX_ARP_ENTRIES].mac, 6);
+	    
+	arp_table[arp_usage % MAX_ARP_ENTRIES].addr.ip =
+	    arp_reply->body.src_paddr;
+	    
+	++arp_usage;
+
+#ifdef PXE_ARP_DEBUG_HELL	
+	printf("pxe_arp_protocol(): arp usage = %d\n", arp_usage);
+#endif
+	
+	return (0); /* inform pxe_get_packet() we don't need this packet more. */
+}
+
+/*
+ *  pxe_arp_send_whois() - sends ARP request packet for given ip, received
+ *			  packets are handled in pxe_arp_protocol()
+ *  in:
+ *	ip	- target ip, for which to find MAC
+ *  out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_arp_send_whois(uint32_t ip)
+{
+        PXE_PACKET	pack;
+	
+	pack.raw_size = sizeof(PXE_ARP_PACK_DATA);
+	pack.raw_data = &packet_to_send;
+	pack.data = &packet_to_send.hdr;
+	pack.data_size = sizeof(PXE_ARP_PACK_DATA) - MEDIAHDR_LEN_ETH;
+	
+	pack.protocol = PXE_PROTOCOL_ARP;
+	pack.dest_mac = (const MAC_ADDR *)&packet_to_send.body.target_hwaddr[0];
+	pack.flags = PXE_BCAST;
+
+	packet_to_send.body.target_paddr = ip;
+
+	if (!pxe_core_transmit(&pack)) {
+		printf("pxe_arp_send_whois(): failed to send request.\n");
+		return (0);
+	}
+	
+	return (1);
+}
+
+/* pxe_arp_await() - await function for ARP replies
+ * in:
+ *	function	- await function
+ *	try_number	- number of try
+ *	timeout		- timeout from start of try
+ *	data		- pointer to PXE_ARP_WAIT_DATA
+ * out:
+ *	PXE_AWAIT_ constants
+ */
+int
+pxe_arp_await(uint8_t function, uint16_t try_number, uint32_t timeout,
+	      void *data)
+{
+	PXE_ARP_WAIT_DATA	*wait_data = (PXE_ARP_WAIT_DATA *)data;
+	const MAC_ADDR		*res = NULL;
+	switch (function) {
+
+	case PXE_AWAIT_STARTTRY:	/* handle start of new try */
+		if (!pxe_arp_send_whois(wait_data->addr.ip)) {	
+			/* failed to send request, try once more
+			 * after waiting a little
+			 */
+			delay(10000);		
+		        return (PXE_AWAIT_NEXTTRY);
+		}
+		break;
+
+	case PXE_AWAIT_NEWPACKETS:
+		/* check if ARP protocol was called and 
+		 * arp_table updated 
+		 */
+		res = pxe_arp_table_search(wait_data->addr.ip);
+		if (res != NULL) {
+			wait_data->mac = res;
+			return (PXE_AWAIT_COMPLETED);
+		}
+		
+		return (PXE_AWAIT_CONTINUE);
+		break;		
+
+	case PXE_AWAIT_FINISHTRY:
+		if (wait_data->mac == NULL) 	/* nothing got during try */
+			printf("\npxe_arp_await(): ARP reply timeout.\n");
+		break;	
+
+	case PXE_AWAIT_END:			/* wait ended */
+	default:
+		break;
+	}
+	
+	return (PXE_AWAIT_OK);
+}
+
+/*
+ *  pxe_arp_ip4mac() - returns MAC for given ip if it's found in arp_table,
+ *                     otherwise - performs request sending
+ *  in:
+ *	ip     - ip, for which to search MAC
+ *  out:
+ *	NULL   - not found such entry in arp_table
+ *	not NULL - pointer to MAC address
+ */
+const MAC_ADDR *
+pxe_arp_ip4mac(const PXE_IPADDR *addr)
+{
+	const MAC_ADDR *res = pxe_arp_table_search(addr->ip);
+
+	if (res != NULL)
+		return (res);
+#ifdef PXE_EXCLUSIVE
+	pxe_core_exclusive(PXE_PROTOCOL_ARP);
+#endif
+	PXE_ARP_WAIT_DATA	wait_data;
+	
+	wait_data.addr.ip = addr->ip;
+	wait_data.mac = NULL;
+	
+	pxe_await(pxe_arp_await, PXE_MAX_ARP_TRY, PXE_TIME_TO_DIE, &wait_data);
+#ifdef PXE_EXCLUSIVE
+	pxe_core_exclusive(0);
+#endif	
+	return (wait_data.mac);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_arp.h sys/boot/i386/pxe_ng/pxe_arp.h
--- sys/boot/i386/pxe_ng/pxe_arp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_arp.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,106 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_ARP_H
+#define PXE_ARP_H
+
+/*
+ *  Handles ARP requests and ARP table
+ *  Reference: RFC826
+ */
+
+#include <stand.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "libi386/pxe.h"
+#include "pxe_core.h"
+#include "pxe_ip.h"
+
+/* max MAC<->ip4 bindings to store */
+#define MAX_ARP_ENTRIES	4
+/* max try count to send/recieve ARP request/reply */
+#define PXE_MAX_ARP_TRY	3
+/* max timeout in millyseconds */
+#define PXE_TIME_TO_DIE 5000
+
+/* define to enable caching incoming ARP packet sender information */
+#define PXE_ARP_SNIFF
+
+typedef struct pxe_arp_entry {
+	PXE_IPADDR	addr;
+	MAC_ADDR	mac;
+} PXE_ARP_ENTRY;
+
+
+/* initialisation routine */
+void pxe_arp_init();
+
+/* find MAC by provided ip */
+const MAC_ADDR *pxe_arp_ip4mac(const PXE_IPADDR *addr);
+
+/* protocol handler for received packets */
+int pxe_arp_protocol(PXE_PACKET *pack, uint8_t function);
+
+/* ARP table statistics */
+void pxe_arp_stats();
+
+/* ARP packet types */
+#define PXE_ARPOP_REQUEST	1
+#define PXE_ARPOP_REPLY		2
+
+/* protocol types */
+#define PXE_PTYPE_IP	0x0800		/* IP4 protocol, used in ARP request */
+
+/* NOTE: here will be realised ARP for Ethernet and IP4 */
+typedef struct pxe_arp_packet {
+	uint16_t hwtype;	/* hardware type */
+	uint16_t ptype;		/* protocol type */
+	uint8_t  hsize;		/* size of hardware address */
+	uint8_t  psize;		/* size of protocol adress */
+	uint16_t operation;
+} __packed PXE_ARP_PACKET;
+
+typedef struct pxe_arp_packet_eth4 {
+	uint8_t  src_hwaddr[6];		/* source hardware address */
+	uint32_t src_paddr;		/* source protocol address */
+	uint8_t  target_hwaddr[6];	/* target hardware address if known */
+	uint32_t target_paddr;		/* target protocol address if known */
+} __packed PXE_ARP_PACKET_ETH4;
+
+typedef struct pxe_arp_pack_data {
+	uint8_t			media_hdr[MEDIAHDR_LEN_ETH];
+        PXE_ARP_PACKET		hdr;
+	PXE_ARP_PACKET_ETH4	body;
+} __packed PXE_ARP_PACK_DATA;
+
+typedef struct pxe_arp_wait_data {
+	PXE_IPADDR		addr;
+	const MAC_ADDR		*mac;
+} PXE_ARP_WAIT_DATA;
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_await.c sys/boot/i386/pxe_ng/pxe_await.c
--- sys/boot/i386/pxe_ng/pxe_await.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_await.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,118 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_core.h"
+
+/* pxe_await() - awaits for packets
+ * in:
+ * 	await_func	- callback function
+ *	trys		- how much trys to make
+ *	timeout		- timeout of waiting in ms
+ *	data		- additional data to give to callback function
+ * out:
+ *	0		- failed
+ *	1		- success
+ */
+int
+pxe_await(pxe_await_func await_func, uint16_t trys, uint32_t timeout, void *data)
+{
+	int		result = 0;
+	uint32_t	time_elapsed = 0;
+	uint16_t	try_counter = 0;
+	
+	while (try_counter < trys) {
+	
+		/* notify about start of try */
+		result = await_func(PXE_AWAIT_STARTTRY, try_counter, 0, data);
+		
+		switch (result) {
+		case PXE_AWAIT_NEXTTRY:
+			++try_counter;
+			time_elapsed = 0;	/* skip this try */
+			continue;
+			
+		case PXE_AWAIT_BREAK:	/* return failure */
+			return (0);
+			break;
+			
+		default:		/* other codes are good for us */
+			break;
+		}
+		
+		while (time_elapsed < timeout) {
+#ifdef PXE_DEBUG
+			twiddle();
+#endif
+        	        if (pxe_core_recv_packets()) {
+				/* means some packet was received */
+                	        
+				result = await_func(PXE_AWAIT_NEWPACKETS,
+					    try_counter, time_elapsed, data); 
+
+				if (result == PXE_AWAIT_COMPLETED) {
+					await_func(PXE_AWAIT_FINISHTRY,
+					    try_counter, time_elapsed, data);
+					    
+					return (1);
+				}
+				
+				if (result == PXE_AWAIT_NEXTTRY)
+					break;
+				
+				/* aborted waiting */
+				if (result == PXE_AWAIT_BREAK)
+					break;
+					
+				/* continue */		
+			}
+		
+	        	delay(TIME_DELTA);
+	    		time_elapsed += TIME_DELTA_MS;
+		}
+
+		/* notify about end of try */
+		result = await_func(PXE_AWAIT_FINISHTRY, try_counter,
+			    time_elapsed, data);
+		
+		if (result == PXE_AWAIT_BREAK)	/* failure */
+			return (0);
+
+		++try_counter;
+		time_elapsed = 0;
+	}
+	
+	/* notify about end of await, result is not interesting */
+	await_func(PXE_AWAIT_END, try_counter, time_elapsed, data);
+	
+	/* if waiting of packet successful,
+	 * control returned higher (PXE_AWAIT_COMPLETED)
+	 */
+	return (0);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_await.h sys/boot/i386/pxe_ng/pxe_await.h
--- sys/boot/i386/pxe_ng/pxe_await.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_await.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,60 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_AWAIT_H_INCLUDED
+#define PXE_AWAIT_H_INCLUDED
+
+/*
+ * Implements await functions wrapper
+ */
+
+#include <stdint.h>
+
+/* await callback function type */
+typedef int (*pxe_await_func)(uint8_t function, uint16_t try_counter,
+		uint32_t timeout,  void *data);
+
+#define PXE_AWAIT_NEWPACKETS	0x00	/* some packets received, check it */
+#define PXE_AWAIT_STARTTRY	0x01	/* start of new try */
+#define PXE_AWAIT_FINISHTRY	0x02	/* end of current try */
+#define PXE_AWAIT_END		0x03	/* ending of waiting */
+
+/* values that may be returned by await function */
+#define PXE_AWAIT_OK		0x00	/* ok, do what you want */
+#define PXE_AWAIT_COMPLETED	0x01	/* wait ended succefully */
+#define PXE_AWAIT_CONTINUE	0x02	/* continue waiting */
+#define PXE_AWAIT_NEXTTRY	0x03	/* continue with next try */
+#define PXE_AWAIT_BREAK		0x04	/* wait ended with failure */
+
+#define TIME_DELTA_MS		1
+#define TIME_DELTA		1000
+
+/* universal waiting function */
+int pxe_await(pxe_await_func func, uint16_t try_counter,
+	uint32_t timeout, void *data);
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_buffer.c sys/boot/i386/pxe_ng/pxe_buffer.c
--- sys/boot/i386/pxe_ng/pxe_buffer.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_buffer.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,427 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_buffer.h"
+#include "pxe_mem.h"
+
+#ifdef PXE_POOL_SLOTS
+/* statically allocated space, used for buffer allocating */
+static	uint8_t send_pool[PXE_DEFAULT_SEND_BUFSIZE * PXE_POOL_SLOTS];
+static	uint8_t recv_pool[PXE_DEFAULT_RECV_BUFSIZE * PXE_POOL_SLOTS];
+/* pool slot usage 0 - unused, 1 - used */
+static	uint8_t	send_pool_slots[PXE_POOL_SLOTS];
+static	uint8_t	recv_pool_slots[PXE_POOL_SLOTS];
+
+/* pxe_buffer_init() - initializes slots for statically allocated buffers
+ * in/ out:
+ *	none
+ */
+void
+pxe_buffer_init()
+{
+
+	int slot = 0;
+	
+	for ( ; slot < PXE_POOL_SLOTS; ++slot) {
+		send_pool_slots[slot] = 0;
+		recv_pool_slots[slot] = 0;
+	}
+}
+#endif
+
+/* pxe_buffer_write() - write data to buffer, if possible
+ * in:
+ *	buf	- pointer to buffer structure
+ *	from	- pointer to data to write
+ *	size	- size of data buffer
+ * out:
+ *	actual count of written bytes
+ */
+uint16_t
+pxe_buffer_write(PXE_BUFFER *buf, const void *from, uint16_t size)
+{
+
+	if (buf == NULL) {
+		printf("pxe_buffer_write(): NULL buffer\n");
+		return (0);
+	}
+	
+	uint16_t	to_write = (size < buf->bufleft) ? size : buf->bufleft;
+
+	if (buf->data == NULL) {
+		printf("pxe_buffer_write(): NULL buffer data\n");
+		return (0);
+	}
+	
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_buffer_write(): fstart %d, fend %d, bufleft %d (of %d),"
+	       " to_write %d (%d)\n", buf->fstart, buf->fend, buf->bufleft,
+	       buf->bufsize, to_write, size);
+#endif			
+
+	if (to_write == 0)	/* no space left*/
+		return (0);
+		
+	/* check if possible to place without cycling */
+	if (buf->fstart < buf->fend) { /* possible to place without cycling */
+	
+		pxe_memcpy(from, buf->data + buf->fstart, to_write);
+		buf->fstart += to_write;
+			
+	} else {/* may be need to place, using two memcpy operations */
+		
+		/* right part of buffer */
+		uint16_t part1 = buf->bufsize - buf->fstart;
+		/* left part of buffer */
+		uint16_t part2 = to_write - part1;
+
+		if (part1)
+			pxe_memcpy(from, buf->data + buf->fstart,
+			    (part1 < to_write) ? part1 : to_write);
+
+		if (part1 >= to_write) {
+			buf->fstart += to_write;
+		} else {
+			pxe_memcpy(from + part1, buf->data, part2);
+			buf->fstart = part2;
+		}
+	}
+
+	buf->bufleft -= to_write;
+
+#ifdef PXE_DEBUG
+	printf("pxe_buffer_write(): bufleft %d (-%d)\n", buf->bufleft, to_write);
+#endif	
+	return (to_write);
+}
+
+/* pxe_buffer_read() - reades data from buffer, if possible
+ * in:
+ *	buf	- pointer to buffer structure
+ *	to	- pointer to data to read to,
+ *		  if NULL - data is read but not placed anywhere
+ *	size	- size of data buffer
+ * out:
+ *	actual count of read bytes
+ */
+uint16_t
+pxe_buffer_read(PXE_BUFFER *buf, void *to, uint16_t size)
+{
+
+	if (buf == NULL) {
+		printf("pxe_buffer_read(): NULL buffer\n");
+		return (0);
+	}
+	
+	if (buf->data == NULL) {
+		printf("pxe_buffer_read(): NULL buffer data\n");
+		return (0);
+	}
+	
+	uint16_t	usage = buf->bufsize - buf->bufleft;
+	uint16_t	to_read = (size <= usage) ? size : usage;
+
+	if (to_read == 0)	/* nothing to read */
+		return (0);
+	
+	uint16_t fstart = buf->fstart;
+	uint16_t fend = buf->fend;
+	uint16_t bufsize = buf->bufsize;
+	
+	if (fstart <= fend) { /* two cases handling: |*s...e**|, |***se***| */
+
+		/* right part of buffer */
+		uint16_t part1 = bufsize - fend;
+		/* left part of buffer */
+		uint16_t part2 = to_read - part1;
+
+		if (part1 && (to != NULL) )
+			pxe_memcpy(buf->data + fend, to,
+			    (part1 < to_read) ? part1 : to_read);
+		
+		if (part1 >= to_read)
+			buf->fend += to_read;
+		else {
+			if (to != NULL)
+				pxe_memcpy(buf->data, to + part1, part2);
+			
+			buf->fend = part2;			
+		}
+		
+	} else  { /* third case: |..e**s...| */
+
+		if (to != NULL)	
+			pxe_memcpy(buf->data + buf->fend, to, to_read);
+		
+		buf->fend += to_read;	
+	} 
+
+	buf->bufleft += to_read;
+
+#ifdef PXE_DEBUG_HELL		
+	printf("pxe_buffer_read(): bufleft %d (+%d), fstart %d, fend %d\n",
+	    buf->bufleft, to_read, buf->fstart, buf->fend
+	);
+#endif	
+	return (to_read);
+}
+
+/* pxe_buffer_space() - returns free space in buffer
+ * in:
+ *	buffer - pointer to buffer structure
+ * out:
+ *	count in bytes of free space in buffer
+ */
+uint16_t
+pxe_buffer_space(PXE_BUFFER *buffer)
+{
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_buffer_space(): NULL buffer\n");
+#endif
+		return (0);
+	}
+	
+	return (buffer->bufleft);
+}
+
+#ifdef PXE_POOL_SLOTS
+int
+alloc_free_slot(uint8_t *slots, int slot_count)
+{
+	int slot = 0;
+	
+	for ( ; slot < slot_count; ++slot)
+		if (slots[slot] == 0) {
+			slots[slot] = 1;
+			return (slot);
+		}
+
+	return (-1);
+}
+
+/* pxe_buffer_memalloc() - allocates memory for buffer
+ * in:
+ *	buffer	- pointer to buffer structure
+ *	size	- bytes to allocate
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_buffer_memalloc(PXE_BUFFER *buffer, uint16_t size)
+{
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_buffer_memalloc(): NULL buffer\n");
+#endif
+		return (0);
+	}
+
+	if (buffer->data != NULL) {
+		/* buffer has same size */
+		if (buffer->bufsize == size)
+			return (1);
+		
+		/* theoretically we never must get here, cause of
+		 * current method of allocating buffers for sockets.
+		 */
+		printf("pxe_buffer_memalloc(): Unhandled alloc case.\n");
+		return (0);
+	}
+	
+	int	slot = -1;
+	uint8_t	*data = NULL;
+	
+	switch (size) {
+	case PXE_DEFAULT_RECV_BUFSIZE:
+		slot = alloc_free_slot(recv_pool_slots, PXE_POOL_SLOTS);
+		data = recv_pool + slot * size;
+		break;
+		
+	case PXE_DEFAULT_SEND_BUFSIZE:
+		slot = alloc_free_slot(send_pool_slots, PXE_POOL_SLOTS);
+		data = send_pool + slot * size;
+		break;
+		
+	default:
+		printf("pxe_buffer_memalloc(): unsupported size (%u bytes).\n",
+		    size);
+		break;
+	}
+
+	if (slot == -1)	/* failed to find free slot */
+		return (0);
+		
+	buffer->bufsize = size;
+	buffer->bufleft = size;
+        buffer->fstart = 0;
+        buffer->fend = size;
+	buffer->data = data;
+
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_buffer_memalloc(): buffer 0x%x, data 0x%x, bufleft %u.\n",
+	    buffer, buffer->data, buffer->bufleft
+	);
+#endif
+	return (1);
+}
+
+/* pxe_buffer_memfree() - release memory used by buffer
+ * in:
+ *	buffer	- pointer to buffer structure
+ * out:
+ *	none
+ */
+void
+pxe_buffer_memfree(PXE_BUFFER *buffer)
+{
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_buffer_memfree(): NULL buffer\n");
+#endif
+		return;
+	}
+	
+	if (buffer->data == NULL) { /* already released */
+		printf("pxe_buffer_memfree(): already released.\n");
+		return;
+	}
+
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_buffer_memfree(): buffer 0x%x, data 0x%x, bufleft: %d.\n",
+	    buffer, buffer->data, buffer->bufleft
+	);
+#endif
+	int	slot = -1;
+	uint8_t *slots = NULL;
+	
+	switch (buffer->bufsize) {
+	case PXE_DEFAULT_RECV_BUFSIZE:
+		slot = (buffer->data - (void *)recv_pool) / 
+			PXE_DEFAULT_RECV_BUFSIZE;
+			
+		slots = recv_pool_slots;
+		break;
+		
+	case PXE_DEFAULT_SEND_BUFSIZE:
+		slot = (buffer->data - (void *)send_pool) /
+			PXE_DEFAULT_SEND_BUFSIZE;
+			
+		slots = send_pool_slots;
+		break;
+	default:
+		printf("pxe_buffer_memfree(): unsupported size (%u bytes).\n",
+		    buffer->bufsize);
+		break;
+	}
+
+	if (slots && (slot > -1) && (slot < PXE_POOL_SLOTS)) {
+		slots[slot] = 0;
+	}
+
+	buffer->data = NULL;
+}
+#endif /* #ifdef PXE_POOL_SLOTS */
+
+/* pxe_buffer_memalloc() - allocates memory for buffer
+ * in:
+ *	buffer	- pointer to buffer structure
+ *	size	- bytes to allocate
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_buffer_memalloc(PXE_BUFFER *buffer, uint16_t size)
+{
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_buffer_memalloc(): NULL buffer\n");
+#endif
+		return (0);
+	}
+	
+	if (buffer->data == NULL) { /* alloc if not already allocated */
+		buffer->data = pxe_alloc(size);
+	
+		if (buffer->data == NULL)
+			return (0);
+	} else {
+		printf("pxe_buffer_memalloc(): already %u bytes, asked %u.\n",
+		    buffer->bufsize, size);
+	}
+
+	buffer->bufsize = size;
+	buffer->bufleft = size;
+        buffer->fstart = 0;
+        buffer->fend = size;
+
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_buffer_memalloc(): buffer 0x%x, data 0x%x, bufleft %u.\n",
+	    buffer, buffer->data, buffer->bufleft
+	);
+#endif
+	return (1);
+}
+
+/* pxe_buffer_memfree() - release memory used by buffer
+ * in:
+ *	buffer	- pointer to buffer structure
+ * out:
+ *	none
+ */
+void
+pxe_buffer_memfree(PXE_BUFFER *buffer)
+{
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_buffer_memfree(): NULL buffer\n");
+#endif
+		return;
+	}
+	
+	if (buffer->data == NULL) { /* already released */
+		printf("pxe_buffer_memfree(): already released.\n");
+		return;
+	}
+
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_buffer_memfree(): buffer 0x%x, data 0x%x, bufleft: %d.\n",
+	    buffer, buffer->data, buffer->bufleft
+	);
+#endif	
+	pxe_free(buffer->data);
+	buffer->data = NULL;
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_buffer.h sys/boot/i386/pxe_ng/pxe_buffer.h
--- sys/boot/i386/pxe_ng/pxe_buffer.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_buffer.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,74 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_BUFFER_H_INCLUDED
+#define PXE_BUFFER_H_INCLUDED
+
+/*
+ * Implements cyclic buffer routines
+ */
+ 
+#include <stdint.h>
+
+/* slot count in buffer pool, define this for statical buffer allocation */
+/* #define PXE_POOL_SLOTS 2 */
+
+/* buffer size choosed by default for sending/recieving */
+#define PXE_DEFAULT_RECV_BUFSIZE	16384
+#define PXE_DEFAULT_SEND_BUFSIZE        4096
+
+/* pxe_buffer - buffer related information */
+typedef struct pxe_buffer {
+
+	void        *data;      /* pointer to memory block, used for buffer */
+
+	uint16_t    fstart;	/* start of free space part in buffer */
+	uint16_t    fend;	/* end of free space part in buffer */
+	
+	uint16_t    bufsize;    /* size of memory block */
+	uint16_t    bufleft;    /* left buffer space */
+
+} PXE_BUFFER;
+
+/* allocates memory for buffer */
+int	 pxe_buffer_memalloc(PXE_BUFFER *buffer, uint16_t size);
+
+/* releases buffer memory */
+void	 pxe_buffer_memfree(PXE_BUFFER *buffer);
+
+/* writes data to buffer */
+uint16_t pxe_buffer_write(PXE_BUFFER *buffer, const void* data, uint16_t size);
+
+/* returns free space size in buffer */
+uint16_t pxe_buffer_space(PXE_BUFFER *buffer);
+
+/* performs initialization of buffer pool */
+#ifdef PXE_POOL_SLOTS
+void pxe_buffer_init();
+#endif
+
+#endif // PXE_BUFFER_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_connection.c sys/boot/i386/pxe_ng/pxe_connection.c
--- sys/boot/i386/pxe_ng/pxe_connection.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_connection.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,691 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_connection.h"
+#include "pxe_core.h"
+#include "pxe_filter.h"
+#include "pxe_ip.h"
+#include "pxe_segment.h"
+#include "pxe_sock.h"
+#include "pxe_tcp.h"
+
+/* connection structs storage */
+static PXE_TCP_CONNECTION       tcp_connections[PXE_MAX_TCP_CONNECTIONS];
+/* currently allocated connections */
+static int                      all_connections = 0;
+
+/* filter_to_connection() - returns connections,
+ *			    associated with provided filter
+ * in:
+ *	filter - pointer to filter entry structure,
+ *		for which connection is searched
+ * out:
+ *	NULL	- failed to find
+ *	not NULL- searched connections
+ */
+PXE_TCP_CONNECTION *
+filter_to_connection(PXE_FILTER_ENTRY *filter)
+{
+	int con_index = 0;
+	
+	for ( ; con_index < PXE_MAX_TCP_CONNECTIONS; ++con_index) {
+
+		if (tcp_connections[con_index].filter == filter)
+			return (&tcp_connections[con_index]);
+	}
+
+	return (NULL);
+}
+
+/* alloc_connection() - returns pointer to free connection structure
+ * in:
+ *	none
+ * out:
+ *	NULL	- failed to alloc
+ *	non NULL- pointer to allocated structure
+ */
+PXE_TCP_CONNECTION *
+alloc_connection()
+{
+
+	if (all_connections == PXE_MAX_TCP_CONNECTIONS)
+		return (NULL);
+		
+	uint16_t	index = 0;
+	
+	for ( ; index < PXE_MAX_TCP_CONNECTIONS; ++index) {
+	
+		if (tcp_connections[index].state == PXE_TCP_CLOSED) {
+			/* if state is closed, it's free structure*/
+			all_connections += 1;
+			return &tcp_connections[index];
+		}
+	}
+	
+	/* NOTE: we must not ever get here */
+	return (NULL);
+}
+
+/* force_alloc_connection() - returns pointer to free connection structure
+ *			forces connection structures in TIME_WAIT state to
+ *			be allocated if there are no free connection
+ *			structure.
+ * in:
+ *	none
+ * out:
+ *	NULL	- failed to alloc
+ *	non NULL- pointer to allocated structure
+ */
+PXE_TCP_CONNECTION *
+force_alloc_connection()
+{
+
+	if (all_connections < PXE_MAX_TCP_CONNECTIONS)
+		return alloc_connection();
+		
+	uint16_t	index = 0;
+	
+	for ( ; index < PXE_MAX_TCP_CONNECTIONS; ++index) {
+	
+		if (tcp_connections[index].state == PXE_TCP_TIME_WAIT) {
+			
+			tcp_connections[index].state = PXE_TCP_CLOSED;
+			
+			/* release filter */
+			PXE_FILTER_ENTRY *filter = tcp_connections[index].filter;
+					
+			if (filter != NULL) /* it must always be non NULL */
+			        pxe_filter_remove(filter);
+#ifdef PXE_TCP_DEBUG
+			printf("force_alloc_connection(): forced allocation\n");
+#endif
+			return &tcp_connections[index];
+		}
+	}
+	
+	return (NULL);
+}
+
+/* pxe_force_filter_release() - releases filter if used by connections
+ *			in TIME_WAIT state. Needed when filters table
+ *			is full, but there are no really active connections.
+ * in/out:
+ *	none
+ */
+void
+pxe_force_filter_release()
+{
+	uint16_t	index = 0;
+	
+	for ( ; index < PXE_MAX_TCP_CONNECTIONS; ++index) {
+	
+		if (tcp_connections[index].state == PXE_TCP_TIME_WAIT) {
+			/* free also connection structure */
+			tcp_connections[index].state = PXE_TCP_CLOSED;
+			
+			/* release filter */
+			PXE_FILTER_ENTRY *filter = tcp_connections[index].filter;
+					
+			if (filter != NULL) /* it must always be non NULL */
+			        pxe_filter_remove(filter);
+				
+			all_connections -= 1;
+#ifdef PXE_TCP_DEBUG
+			printf("pxe_force_filter_release(): filter released.\n");
+#endif
+			break;
+		}
+	}
+}
+
+/* free_connection() - releases connections
+ * in:
+ *	connection - pointer to connection to release
+ *		(assuming it's valid connection)
+ * out:
+ *	none
+ */
+void
+free_connection(PXE_TCP_CONNECTION *connection)
+{
+
+	connection->state = PXE_TCP_CLOSED;
+	all_connections -= 1;
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("free_connection(): %d connections used\n", all_connections);
+#endif
+}
+
+/* tcp_await() - await function for some TCP protocol functions (handshaking,
+ *	breaking connection).
+ * NOTE:
+ *	main work is done in pxe_tcp_callback()
+ */
+int
+tcp_await(uint8_t function, uint16_t try_number, uint32_t timeout, void *data)
+{
+	PXE_TCP_WAIT_DATA *wait_data = (PXE_TCP_WAIT_DATA *)data;
+	PXE_TCP_CONNECTION *conn = wait_data->connection;
+	
+        switch(function) {
+	        case PXE_AWAIT_NEWPACKETS:
+			/* check current state with needed to wait for */
+
+			if (wait_data->state <= conn->state)
+				return (PXE_AWAIT_COMPLETED);
+			
+			/* CLOSED at waiting means connection was breaked */
+			if (conn->state == PXE_TCP_CLOSED)
+				return (PXE_AWAIT_BREAK);
+
+			break;		
+		
+	        case PXE_AWAIT_FINISHTRY:
+			if (conn->state == PXE_TCP_CLOSED)
+				return (PXE_AWAIT_BREAK);
+				
+			pxe_resend_check(wait_data->connection);
+			break;
+
+	        case PXE_AWAIT_STARTTRY: /* nothing to do */
+		case PXE_AWAIT_END:
+		default:
+			break;
+	}
+	
+	return (PXE_AWAIT_OK);
+}
+
+/* pxe_tcp_connect() - connects TCP socket (performs handshaking).
+ *			Blocks until handshaking is done.
+ * in:
+ *	socket - socket
+ * out:
+ *	0	- failed to connect
+ *	1	- handshaking successful
+ */
+int
+pxe_tcp_connect(PXE_SOCKET *sock)
+{
+
+/*	if (all_connections == PXE_MAX_TCP_CONNECTIONS) {
+		printf("pxe_tcp_connect(): too many connections.\n");
+		return (0);
+	}
+*/
+	PXE_FILTER_ENTRY	*filter = sock->filter;	
+	PXE_TCP_CONNECTION	*connection = force_alloc_connection();
+
+	if (connection == NULL) {
+		printf("pxe_tcp_connect(): too many connections.\n");
+		return (0);
+	}
+	
+	pxe_memset(connection, 0, sizeof(PXE_TCP_CONNECTION));
+			
+	connection->dst_port = filter->src_port;
+	connection->src_port = filter->dst_port;
+	connection->dst.ip = filter->src.ip;
+	connection->next_recv = 0;
+	
+	/* NOTE: need to make more correct initial number */
+	connection->iss = (filter->src.ip + filter->dst.ip) +
+			  (uint32_t)pxe_get_secs();
+			  
+	connection->next_send = connection->iss;
+	
+	connection->filter = filter;
+	connection->recv = &sock->recv_buffer;
+	connection->send = &sock->send_buffer;
+	
+	pxe_resend_init(connection);
+
+	if (!pxe_tcp_syssend(connection, PXE_TCP_SYN)) {
+		printf("pxe_tcp_connect(): failed to send SYN.\n");
+		free_connection(connection);
+		return (0);
+	}
+
+	connection->state = PXE_TCP_SYN_SENT;
+	connection->next_send = connection->iss + 1;
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_connect(): new state - SYN_SENT\n");
+#endif		
+	PXE_TCP_WAIT_DATA wait_data;
+	wait_data.connection = connection;
+	
+	wait_data.state = PXE_TCP_ESTABLISHED;
+	
+	/* await ESTABLISHED state.
+	 * connection will fell in this state in pxe_tcp_callback(),
+	 * after receiving SYN ACK and sending ACK to remote host
+	 */
+	if (!pxe_await(tcp_await, 5, PXE_TCP_MSL / 5, &wait_data)) {
+		/* failed to get SYN/ACK */
+	    	free_connection(connection);
+		return (0);
+	}
+
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_connect(): connection established.\n");
+#endif	
+	return (1);
+}
+
+/* pxe_tcp_disconnect() - interrupts TCP connection. Blocks until is done.
+ * in:
+ *	socket - socket
+ * out:
+ *	0	- failed to disconnect (timeout)
+ *	1	- disconnect successful
+ */
+int
+pxe_tcp_disconnect(PXE_SOCKET *sock)
+{
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_disconnect(): started.\n");
+#endif
+	PXE_FILTER_ENTRY	*filter = sock->filter;	
+	
+	if (filter == NULL) {
+		/* NULL filters means there are no connection for socket */
+		printf("pxe_tcp_disconnect(): NULL filter\n");
+		return (1);
+	}
+	
+	PXE_TCP_CONNECTION	*connection = filter_to_connection(filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_disconnect(): NULL connection\n");
+		return (0);
+	}
+
+	/* process recieved,  queued but not processed packets.
+	 * This is useful if server requested breaking of connection
+	 * (passive closing) and our disconnect just finishes initiated
+	 * by server sequence, no need to send initial FIN (active closing)
+	 */
+	pxe_core_recv_packets();
+	
+	if ( connection->state == PXE_TCP_CLOSED) { /* already  closed */
+#ifdef PXE_TCP_DEBUG
+		printf("pxe_tcp_disconnect(): connection already is closed.\n");
+#endif
+		return (1);
+	}
+	
+	if (!pxe_tcp_syssend(connection, PXE_TCP_FIN | PXE_TCP_ACK)) { 
+		printf("pxe_tcp_disconnect(): failed to send FIN.\n");
+		free_connection(connection);
+		return (0);
+	}
+	/* update sequence number */	
+	connection->next_send += 1;
+	
+	PXE_TCP_WAIT_DATA wait_data;
+	wait_data.connection = connection;
+
+	if (connection->state == PXE_TCP_ESTABLISHED) {
+		/* active closing by our host */
+		connection->state = PXE_TCP_FIN_WAIT1;
+#ifdef PXE_TCP_DEBUG
+		printf("pxe_tcp_disconnect(): new state - FIN_WAIT_1\n");
+#endif
+		wait_data.state = PXE_TCP_TIME_WAIT;
+	
+	} else { /* if connection breaked by remote host */
+		connection->state = PXE_TCP_LAST_ACK;
+		wait_data.state = PXE_TCP_CLOSED;
+	}
+
+	connection->state_out = PXE_TCP_FIN;
+
+	/* awaiting expected state to close connection
+	 * connection will fell in this state in pxe_tcp_callback()
+	 */
+	if (!pxe_await(tcp_await, 5, PXE_TCP_MSL / 5, &wait_data)) {
+		/* failed to get expected state */
+	    	free_connection(connection);
+	
+		if (connection->state != PXE_TCP_CLOSED) {
+#ifdef PXE_TCP_DEBUG		
+			printf("pxe_tcp_disconnect(): felt to wrong state.\n");
+#endif
+			return (0);
+		}
+	}
+
+	if (connection->state == PXE_TCP_CLOSED) {
+		pxe_filter_remove(filter);
+		free_connection(connection);
+	}
+	
+	pxe_resend_free(connection);
+	
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_disconnect(): connection closed.\n");
+#endif
+	return (1);
+}
+
+/* pxe_connection_init() - inits connections related structures
+ * in/out:
+ *	none
+ */
+void
+pxe_connection_init()
+{
+
+	/* clear connections data */
+	pxe_memset(tcp_connections, 0, sizeof(tcp_connections));
+}
+
+/* pxe_tcp_write() - transmit data via TCP protocol
+ * in:
+ *      sock		- TCP socket to write to
+ *	data		- pointer to data to send
+ *      size_to_send    - data size
+ * out:
+ *      -1	- failed
+ *      >=0     - actual bytes written
+ */
+int
+pxe_tcp_write(PXE_SOCKET *sock, void *data, uint16_t size_to_send)
+{
+	PXE_TCP_CONNECTION	*connection = filter_to_connection(sock->filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_write(): no connection for filter 0x%x "
+		       "(socket: 0x%x).\n", sock->filter, sock);
+		return (-1);
+	}
+	
+	if ( (connection->state != PXE_TCP_ESTABLISHED) &&
+	     (connection->state != PXE_TCP_CLOSE_WAIT) )
+	{
+		return (-1);	/* cannot write, incorrect state */
+	}
+	
+	/* trying current segment */
+	PXE_TCP_QUEUED_SEGMENT *segment = connection->segment;
+	
+	uint16_t sent_data = 0;
+	uint16_t bufleft = 0;
+    	uint16_t send_now = 0;
+	void	 *segment_data = (void *)(segment + 1);
+	
+	while (sent_data < size_to_send) {
+		
+		/* have no allocated segment for writing data, try allocate it */
+		if (segment == NULL) {
+			/* allocating new segment */
+			segment = tcp_segment_alloc(connection, PXE_SEGMENT_BIG);
+			
+			if (segment == NULL) {
+		    		printf("pxe_tcp_write(): failed to allocate segment.\n");
+	    			return (sent_data == 0) ? (-1) : sent_data;
+			}
+		
+			connection->segment = segment;
+			segment_data = (void *)(segment + 1);
+			
+			tcp_start_segment(connection, segment,
+			    PXE_SEGMENT_OPTS_NO);
+		}
+		
+		/* calculating free space in segment packet */
+		bufleft = connection->chunk_size * PXE_TCP_CHUNK_COUNT;
+		bufleft -= sizeof(PXE_TCP_QUEUED_SEGMENT) + segment->size;
+		/* how much left to send */
+		send_now = size_to_send - sent_data;
+
+		if (send_now < bufleft) {
+			/* copy data to segment space, actually there is no send,
+			 * till segment is fully filled or called pxe_tcp_push()
+			 */
+			pxe_memcpy(data + sent_data,
+			    segment_data + segment->size, send_now);
+			    
+			segment->size += send_now;
+			sent_data += send_now;
+			
+			return (sent_data);
+		}
+		
+		/* if we got here, then we need to finish current segment
+		 * and alloc new segment
+		 */
+		pxe_memcpy(data + sent_data,
+		    segment_data + segment->size, bufleft);
+		    
+		segment->size += bufleft;
+		sent_data += bufleft;
+		
+		/* finish segment */
+		tcp_finish_segment(connection, segment, PXE_TCP_ACK);
+		/* updating next_send counter */
+		connection->next_send += segment->size - sizeof(PXE_TCP_PACKET);
+
+		segment->resend_at = pxe_get_secs() + PXE_RESEND_TIME;
+    
+		if (!pxe_tcp_send_segment(connection, segment)) {
+			printf("pxe_tcp_write(): failed to send segment.\n");
+			/* this segment will be resent later,
+			 * so continue normal processing
+			 */
+		}
+		
+		pxe_core_recv_packets();
+		segment = NULL;
+		connection->segment = NULL;
+	}
+
+	return (sent_data);
+}
+
+/* pxe_tcp_read() - wrapper to read data from TCP socket
+ * in:
+ *      sock		- TCP socket to read from
+ *	data		- buffer to read data
+ *      size_to_read    - buffer size
+ * out:
+ *      -1	- failed
+ *      >=0     - actual bytes read
+ */
+int
+pxe_tcp_read(PXE_SOCKET *sock, void *data, uint16_t size_to_read)
+{
+	PXE_TCP_CONNECTION	*connection = filter_to_connection(sock->filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_read(): no connection for filter 0x%x "
+		       "(socket: 0x%x).\n", sock->filter, sock);
+		return (-1);
+	}
+
+	PXE_BUFFER	*recv_buffer = connection->recv;
+			
+	if ( (connection->state != PXE_TCP_ESTABLISHED) &&
+	     (recv_buffer->bufleft == recv_buffer->bufsize) )
+	{
+#ifdef PXE_DEBUG
+		printf("pxe_tcp_read(): state %u, no data in buffer\n",
+		    connection->state);
+#endif
+		return (-1);	/* connection closed and no data in buffer */
+	}
+
+	int result = pxe_buffer_read(recv_buffer, data, size_to_read);
+
+	if (result != 0) { 
+
+		/* if receive window was zero and now is big enough,
+		 * notify remote host
+		 */
+		if ( (connection->winlock == 1) &&
+		     (recv_buffer->bufleft > PXE_DEFAULT_RECV_BUFSIZE / 4))
+		{
+			if (!pxe_tcp_syssend(connection, PXE_TCP_ACK))
+				printf("pxe_tcp_read(): failed to notify "
+				       "remote host about window.\n");
+			else
+				connection->winlock = 0;
+		}
+	}
+	
+	/* process new packets if too low data in buffer */
+	if (recv_buffer->bufleft > recv_buffer->bufsize / 2)
+		pxe_core_recv_packets();
+	
+	return (result);
+}
+
+/* pxe_tcp_push() - flushes send buffer (actually current send segment)
+ * in:
+ *      filter		- filter of socket, which buffers need to flush
+ * out:
+ *      0	- failed
+ *      1	- success
+ */
+int
+pxe_tcp_push(PXE_FILTER_ENTRY *filter)
+{
+	PXE_TCP_CONNECTION	*connection = filter_to_connection(filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_push(): no connection for filter 0x%x.\n",
+		    filter);
+		    
+		return (0);
+	}
+
+	if ( (connection->state != PXE_TCP_ESTABLISHED) &&
+	     (connection->state != PXE_TCP_CLOSE_WAIT) )
+	{
+		printf("pxe_tcp_push(): connection 0x%x is in wrong state %d.\n",
+		    connection, connection->state);
+		/* connection not in established state, ignore available data */
+		return (0);	
+	}
+	
+	PXE_TCP_QUEUED_SEGMENT	*segment = connection->segment;
+	
+	if (segment == NULL)	/* nothing to push */
+		return (1);
+
+	/* finish segment */
+	tcp_finish_segment(connection, segment, PXE_TCP_ACK | PXE_TCP_PSH);
+
+	segment->resend_at = pxe_get_secs() + PXE_RESEND_TIME;
+    	connection->next_send += segment->size - sizeof(PXE_TCP_PACKET);
+	
+	if (!pxe_tcp_send_segment(connection, segment)) {
+		printf("pxe_tcp_push(): failed to send segment.\n");
+		/* this segment will be resent later,
+		 * so continue normal processing
+		 */
+	}
+
+	segment = NULL;
+	connection->segment = NULL;
+
+	return (1);
+}
+
+/* pxe_tcp_check_connection() - checks connections state by sending ACK,
+ *				used e.g. to notify remote host about
+ *				enough window to recv
+ * in:
+ *      sock		- TCP socket to check connection for
+ * out:
+ *      0	- failed
+ *      1	- success
+ */
+int
+pxe_tcp_check_connection(PXE_SOCKET *sock)
+{
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_check_connection(): started.\n");
+#endif
+	PXE_TCP_CONNECTION	*connection = filter_to_connection(sock->filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_check_connection(): no connection for filter "
+		       "0x%x (socket: 0x%x).\n", sock->filter, sock);
+		return (0);
+	}
+
+	if (connection->state != PXE_TCP_ESTABLISHED) {
+		printf("pxe_tcp_check_connection(): connection 0x%x "
+		       "is not in established state(%d).\n",
+		       connection, connection->state);
+		/* connection not in established state, ignore available data */
+		return (0);	
+	}
+	
+	PXE_BUFFER *buffer = connection->recv;
+	
+	/* send ACK ony if we place enough space */
+	if (buffer->bufleft < buffer->bufsize / 3)
+		return (0);
+	
+	if (!pxe_tcp_syssend(connection, PXE_TCP_ACK)) {
+		printf("pxe_tcp_check_connection(): failed to send ACK.\n");
+		return (0);
+	}
+	
+	return (1);
+}
+
+#ifdef PXE_MORE
+/* pxe_connection_stats() - shows brief information about connections
+ * in/out:
+ * 	none
+ */
+void
+pxe_connection_stats()
+{
+	printf("pxe_connection_stats(): %d connections\n", all_connections);
+
+	int con_index = 0;
+	PXE_TCP_CONNECTION *connection = NULL;
+	
+	for ( ; con_index < PXE_MAX_TCP_CONNECTIONS; ++con_index) {
+
+		connection = &tcp_connections[con_index];
+		
+		printf("%d: filter: 0x%x, state: %d\n"
+		       "  nxt_snd: %lu, nxt_rcv: %lu, iss: %lu, irs: %lu\n",
+		       con_index, connection->filter, connection->state,
+		       connection->next_send, connection->next_recv,
+		       connection->iss, connection->irs);
+	}
+}
+#endif /* PXE_MORE */
diff -ruN sys/boot/i386/pxe_ng/pxe_connection.h sys/boot/i386/pxe_ng/pxe_connection.h
--- sys/boot/i386/pxe_ng/pxe_connection.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_connection.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,132 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_CONNECTION_INCLUDED
+#define PXE_CONNECTION_INCLUDED
+
+/*
+ * Provides TCP connection related routines
+ */
+ 
+#include <stdint.h>
+
+#include "pxe_buffer.h"
+#include "pxe_filter.h"
+#include "pxe_sock.h"
+
+/* maximum existing connections at one time */
+#define PXE_MAX_TCP_CONNECTIONS 8
+
+/* connection states */
+#define PXE_TCP_STATE_MASK      0x0f
+
+#define PXE_TCP_CLOSED          0x00    /* closed */
+
+#define PXE_TCP_SYN_SENT        0x01    /* active */
+#define PXE_TCP_SYN_RECEIVED    0x02    /* sent & received SYN */
+#define PXE_TCP_ESTABLISHED     0x03    /* established connection */
+#define PXE_TCP_CLOSE_WAIT      0x04    /* got FIN, waiting to close */
+#define PXE_TCP_LAST_ACK        0x05    /* got FIN, closing & waiting FIN ACK */
+
+#define PXE_TCP_FIN_WAIT1       0x06    /* CLOSE, sent FIN */
+#define PXE_TCP_CLOSING         0x07    /* got FIN, sent ACK, waiting FIN ACK */
+#define PXE_TCP_FIN_WAIT2       0x08    /* got FIN ACK */
+#define PXE_TCP_TIME_WAIT       0x09    /* closed, waiting 2MSL*/
+#define PXE_TCP_ALL_STATES      10
+
+#define PXE_TCP_BLOCK_COUNT	8
+#define PXE_TCP_CHUNK_COUNT	8
+
+typedef struct pxe_tcp_connecton {
+
+    uint8_t     state;          /* current TCP conenction state */
+    uint8_t     state_out;      /* show latest acked packet flags
+				 * (e.g. we sent FIN and it was ACKed,
+				 * here will be PXE_TCP_FIN.
+				 */
+    uint8_t	winlock;	/* flag becomes 1 when recieve window is zero*/
+    uint32_t    next_recv;      /* next sequence number to accept */
+    uint32_t    next_send;      /* next sequence number to send */
+    uint32_t    una;            /* unaccepted sequence number */
+		    
+    uint32_t    iss;            /* initial send sequence */
+    uint32_t    irs;            /* initial recv sequence */
+    uint16_t    remote_window;  /* remote host window size */
+				
+    uint16_t    src_port;       /* source port */
+    uint16_t    dst_port;       /* destination port */
+    PXE_IPADDR  dst;         /* destination ip */
+					    
+    PXE_BUFFER  *recv;          /* recieve buffer */
+    PXE_BUFFER  *send;          /* send buffer */
+						    
+    PXE_FILTER_ENTRY* filter;   /* filter, associated with connection */
+
+    /* current segment to fill, NULL - if unknown */
+    /* PXE_TCP_QUEUED_SEGMENT	*segment; */
+    void	*segment;
+					
+    /* send buffer usage map */
+    uint8_t     buf_blocks[PXE_TCP_BLOCK_COUNT];
+    uint16_t    chunk_size;     /* buffer chunk size */
+
+    /* TODO: check if two members below needed */
+    time_t      last_sent;      /* timestamp of last sending event */
+    time_t      last_recv;      /* timestamp of last received event */
+} PXE_TCP_CONNECTION;
+
+/* initialisztion routine */
+void pxe_connection_init();
+
+/* statistics */
+void pxe_connection_stats();
+
+/* returns associated connection by filter */
+PXE_TCP_CONNECTION * filter_to_connection(PXE_FILTER_ENTRY *filter);
+
+/* initates handshaking */
+int pxe_tcp_connect(PXE_SOCKET *sock);
+
+/* initates connection break */
+int pxe_tcp_disconnect(PXE_SOCKET* sock);
+
+/* sends user data */
+int pxe_tcp_write(PXE_SOCKET *sock, void *data, uint16_t size);
+
+/* receives user data */
+int pxe_tcp_read(PXE_SOCKET *sock, void *data, uint16_t size);
+
+/* pushes current segment data */
+int pxe_tcp_push(PXE_FILTER_ENTRY *entry);
+
+/* checks connection, by sending ACK */
+int pxe_tcp_check_connection(PXE_SOCKET *sock);
+
+/* forces release of unused filters */
+void pxe_force_filter_release();
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_core.h sys/boot/i386/pxe_ng/pxe_core.h
--- sys/boot/i386/pxe_ng/pxe_core.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_core.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,161 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_CORE_H_INCLUDED
+#define PXE_CORE_H_INCLUDED
+
+/*
+ *  contains wrappers for PXE API functions
+ */
+ 
+#include <stand.h>
+#include <stdint.h>
+#include <stddef.h>
+
+#include "libi386/pxe.h"
+#include "pxe_ip.h"
+
+#define PXE_BUFFER_SIZE		0x0800
+
+/* define to use statically allocated buffers */
+#define PXE_CORE_STATIC_BUFFERS
+
+/* packet states for packets, used by pxe_core.
+ * Currently (only one packet at any time) - is unused.
+ */
+#define PXE_PACKET_STATE_FREE		0
+#define PXE_PACKET_STATE_USING		1
+
+#define PXE_DOWN			0
+#define PXE_INITING			1
+#define PXE_READY			2
+
+/* size of media header, used in allocating memmory for packet */
+#define	MEDIAHDR_LEN_ETH		14
+/* packet type: broadcast and directed */
+#define PXE_BCAST			1
+#define PXE_SINGLE			0
+/*
+ *   structure, used to provide information about packet in pxe_core
+ */
+typedef struct pxe_packet {
+
+    uint8_t     protocol;   /* protocol, used in packet */
+    uint8_t     state;      /* state of  packet (PXE_PACKET_STATE_ ... ) */
+    uint8_t	flags;      /* flags if it is broadcast packet */
+    
+    void*	raw_data;   /* pointer to data, including media header */
+    size_t	raw_size;   /* real size of packet */
+    
+    void*       data;       /* pointer to buffer with packet data */
+    size_t      data_size;  /* size of packet data */
+                            
+    const MAC_ADDR *dest_mac;   /* destination media address */
+
+    void*       user_data;  /* pointer to user data.
+			     * used by higher level protocols
+			     */
+} PXE_PACKET;
+
+#define PXE_PROTOCOL_UNKNOWN    0
+#define PXE_PROTOCOL_IP         1
+#define PXE_PROTOCOL_ARP        2
+#define PXE_PROTOCOL_RARP       3
+#define PXE_PROTOCOL_OTHER      4
+
+/* init of PXE core structures. */
+int pxe_core_init(pxenv_t* pxenv_p, pxe_t* pxe_p);
+
+/* cleanup */
+int pxe_core_shutdown();
+
+/* sends packet to a network */
+int pxe_core_transmit(PXE_PACKET *pack);
+
+/* allocates buffer for packet */
+PXE_PACKET *pxe_core_alloc_packet(size_t packet_size);
+
+/* recieves all packets waiting in queue, and calls protocols if needed */
+int pxe_core_recv_packets();
+
+/* copies in real mode from one segment to another. */
+void pxe_core_copy(uint16_t seg_from, uint16_t off_from, uint16_t seg_to,
+	uint16_t off_to, uint16_t size);
+
+/* installs irq handler*/
+void pxe_core_install_isr();
+
+/* removes irq handler*/
+void pxe_core_remove_isr();
+
+/* call to PXE API */
+int pxe_core_call(int func);
+
+#define PXE_CORE_HANDLE    0x0
+#define PXE_CORE_FRAG      0x1
+/* protocol callback function type */
+typedef int (*pxe_protocol_call)(PXE_PACKET *pack, uint8_t function);
+
+/* registers protocol */
+void pxe_core_register(uint8_t ip_proto, pxe_protocol_call proc);
+
+/* set this protocol exclusive, other packets are ignored */
+#ifdef PXE_EXCLUSIVE
+void pxe_core_exclusive(uint8_t proto);
+#endif
+
+/* returns NIC MAC */
+const MAC_ADDR *pxe_get_mymac();
+
+#define PXE_IP_MY		0
+#define PXE_IP_NET		1
+#define PXE_IP_NETMASK		2
+#define PXE_IP_NAMESERVER	3
+#define PXE_IP_GATEWAY		4
+#define PXE_IP_BROADCAST	5
+#define PXE_IP_SERVER		6
+#define PXE_IP_WWW		7
+#define PXE_IP_ROOT		8
+#define PXE_IP_MAX		9
+const PXE_IPADDR *pxe_get_ip(uint8_t id);
+void pxe_set_ip(uint8_t id, const PXE_IPADDR *ip);
+
+/* returns time in seconds */
+time_t	pxe_get_secs();
+
+#define pxe_get_secs	getsecs
+
+/* updates IPs after getting them via DHCP/BOOTP */
+void pxe_core_update_bootp();
+
+#ifndef FNAME_SIZE
+#define FNAME_SIZE      128
+#endif
+extern char rootpath[FNAME_SIZE];
+extern char servername[256];
+			     
+#endif // PXE_CORE_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_dhcp.c sys/boot/i386/pxe_ng/pxe_dhcp.c
--- sys/boot/i386/pxe_ng/pxe_dhcp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_dhcp.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,456 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_core.h"
+#include "pxe_dhcp.h"
+#include "pxe_ip.h"
+
+#ifdef PXE_BOOTP_USE_LIBSTAND
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <net.h>
+#include <bootp.h>
+#else
+#include "pxe_await.h"
+#include "pxe_mem.h"
+#include "pxe_sock.h"
+#include "pxe_udp.h"
+#endif
+
+#ifndef PXE_BOOTP_USE_LIBSTAND
+/* adds option to provided buffer 
+ * in:
+ *	opt	- current pointer in options section of DHCP packet
+ *	option	- option id
+ *	opt_data- pointer to related to option data
+ *	opt_len	- size of data, pointed by opt_data
+ * out:
+ *	new pointer in options sections
+ */
+uint8_t *
+add_option(uint8_t *opt, uint8_t option, const void *opt_data, uint8_t opt_len)
+{
+	PXE_DHCP_OPT_HDR *opt_hdr = (PXE_DHCP_OPT_HDR *)opt;
+	
+	opt_hdr->option = option;
+	opt_hdr->len = opt_len;
+	
+	if ( (opt_data != NULL) && (opt_len != 0) )
+		pxe_memcpy(opt_data, opt + sizeof(PXE_DHCP_OPT_HDR), opt_len);
+	
+	return (opt + sizeof(PXE_DHCP_OPT_HDR) + opt_len);
+}
+
+/* parses options section of packet
+ * in:
+ *	opts 		- pointer to options section
+ *	max_size 	- size of option section data
+ *	result		- pointer to result return structure
+ * out:
+ *	result		- result of parsing options
+ */
+void
+pxe_dhcp_parse_options(uint8_t *opts, uint16_t max_size,
+		       PXE_DHCP_PARSE_RESULT *result)
+{
+        uint8_t *p=opts;
+        uint8_t code = opts[0];
+        uint8_t len = 0;
+
+        printf("DHCP options:\n");
+				
+        while (code != PXE_DHCP_OPT_END) {
+                ++p;
+                len = 1 + (*p);
+
+                switch (code) {
+	                case 0: /* pad */
+	                        len = 0;
+	                        break;
+
+	                case PXE_DHCP_OPT_NETMASK:
+	                        printf("netmask: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+				result->netmask.ip = *((uint32_t *)(p + 1));
+	                        break;
+
+	                case PXE_DHCP_OPT_ROUTER: 
+	                        printf("first router: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+				result->gw.ip = *((uint32_t *)(p + 1));
+	                        break;
+
+	                case PXE_DHCP_OPT_NAMESERVER:
+	                        printf("first nameserver: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+				result->ns.ip = *((uint32_t *)(p + 1));
+	                        break;
+
+	                case PXE_DHCP_OPT_TYPE:
+				result->message_type = *(p + 1);
+#ifdef PXE_DEBUG
+	                        printf("message type: 0x%x\n",
+				    result->message_type);
+#endif				
+	                        break;
+			
+			case PXE_DHCP_OPT_WWW_SERVER:
+	                        printf("www server ip: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+				result->www.ip = *((uint32_t *)(p + 1));
+	                        break;
+			
+			case PXE_DHCP_OPT_ROOTPATH:
+				pxe_memcpy((p + 1), result->rootpath, len - 1);
+				printf("root path: %s\n", result->rootpath);
+				break;
+#ifdef PXE_MORE				
+	                case PXE_DHCP_OPT_LEASE_TIME:
+#ifdef PXE_DEBUG
+	                        printf("lease time: %d secs\n",
+				    ntohl( *((uint32_t *)(p + 1)) ));
+#endif				
+	                        break;				
+
+	                case PXE_DHCP_OPT_RENEWAL_TIME:
+#ifdef PXE_DEBUG
+			        printf("renewal in: %d secs\n",
+				    ntohl( *((uint32_t *)(p + 1)) ));
+#endif				
+	                        break;
+				
+	                case PXE_DHCP_OPT_REBINDING_TIME:
+#ifdef PXE_DEBUG
+	                        printf("rebinding in: %d secs\n",
+				    ntohl( *((uint32_t *)(p + 1)) ));
+#endif				
+	                        break;
+				
+	                case PXE_DHCP_OPT_BROADCAST_IP:
+	                        printf("broadcast: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+				result->bcast_addr.ip = *((uint32_t *)(p + 1));
+	                        break;						
+
+	                case PXE_DHCP_OPT_ID:
+#ifdef PXE_DEBUG
+	                        printf("server id: %d.%d.%d.%d\n",
+				    *(p + 1), *(p + 2), *(p + 3), *(p + 4));
+#endif
+	                        break;					
+
+			case PXE_DHCP_OPT_DOMAIN_NAME:
+#ifdef PXE_DEBUG
+	                        printf("domain name: %s\n", (p + 1));
+#endif
+	                        break;
+#endif /* PXE_MORE */
+	                default:
+#ifdef PXE_DEBUG
+				printf("DHCP Option %d (%d bytes) ignored\n",
+				    code, len);
+#endif
+	                        break;
+                };
+																																																				
+                p += len;
+                code = *p;
+                len = 0;
+	    
+	        if (p - opts > max_size)
+	                break;
+        }
+}
+
+/* create_dhcp_packet() - fills header of request packet
+ * in:
+ *	wait_data - pointer to filled PXE_DHCP_WAIT_DATA
+ * out:
+ *	none
+ */
+void
+create_dhcp_packet(PXE_DHCP_WAIT_DATA *wait_data)
+{
+	uint8_t		*buf = wait_data->data;
+	PXE_DHCP_HDR	*dhcp_hdr = (PXE_DHCP_HDR *)buf;
+
+	dhcp_hdr->op = PXE_DHCP_REQUEST;
+	dhcp_hdr->htype = ETHER_TYPE;
+	dhcp_hdr->hlen = 6;
+	dhcp_hdr->hops = 0;
+	dhcp_hdr->secs = 0;
+	dhcp_hdr->xid = wait_data->xid;
+	
+	const PXE_IPADDR *my = pxe_get_ip(PXE_IP_MY);
+	dhcp_hdr->ciaddr = my->ip;
+	dhcp_hdr->magic = htonl(PXE_MAGIC_DHCP);
+	
+	pxe_memcpy(pxe_get_mymac(), dhcp_hdr->chaddr, dhcp_hdr->hlen);
+}
+
+/* dhcp_send_request() - creates socket, sends DHCP request
+ * in:
+ *	wait_data - pointer to filled PXE_DHCP_WAIT_DATA
+ * out:
+ *	0 - failed
+ *	1 - success
+ */
+int
+dhcp_send_request(PXE_DHCP_WAIT_DATA *wait_data)
+{
+	uint8_t	*options = wait_data->data + sizeof(PXE_DHCP_HDR);	
+/*	uint8_t	message_type =  PXE_DHCPREQUEST; */
+	uint8_t	message_type =  PXE_DHCPDISCOVER;
+
+	/* cleaning up packet data */
+	pxe_memset(wait_data->data, 0, wait_data->size);
+	
+	create_dhcp_packet(wait_data);
+
+	/* setting INFORM type */
+	options = add_option(options, PXE_DHCP_OPT_TYPE, &message_type, 1);
+
+	/* requesting for my ip */
+	const PXE_IPADDR *client_ip = pxe_get_ip(PXE_IP_MY);
+	
+	options = add_option(options, PXE_DHCP_OPT_REQUEST_IP,
+		    &(client_ip->ip), sizeof(client_ip->ip));
+
+	/* end of options */
+	options = add_option(options, PXE_DHCP_OPT_END, NULL, 0);
+		
+	/* send */
+	uint16_t	send_size = options - wait_data->data;	
+	int		socket = pxe_socket();
+
+	if (socket == -1) {
+		printf("dhcp_send_request(): failed to create socket.\n");
+		return (0);
+	}
+	
+	if (pxe_bind(socket, client_ip, PXE_DHCP_CLIENT_PORT,
+		PXE_UDP_PROTOCOL) == -1)
+	{
+		printf("dhcp_send_request(): failed bind client DHCP port.\n");
+		pxe_close(socket);
+		return (0);	
+	}
+	
+	PXE_IPADDR bcast;
+	bcast.ip = PXE_IP_BCAST;
+	
+	if (send_size != pxe_sendto(socket, &bcast, PXE_DHCP_SERVER_PORT,
+			    wait_data->data, send_size))
+	{
+		printf("dhcp_send_request(): failed to send DHCP request.\n");
+		pxe_close(socket);
+		return (0);	
+	}
+	
+	wait_data->socket = socket;
+
+	return (1);
+}
+
+/* dhcp_parse() - parses received packet, drops if it is invalid
+ * in:
+ *	data	- pointer to buffer with data
+ *	size	- szie of buffer
+ *	xid	- client/transaction id
+ * out:
+ *	0 	- failed
+ *	1	- success
+ */
+int
+dhcp_parse(void *data, int size, uint32_t xid)
+{
+	PXE_DHCP_HDR *dhcp_hdr = (PXE_DHCP_HDR *)data;
+	
+	if (dhcp_hdr->magic != htonl(PXE_MAGIC_DHCP) ) /* unknown magic */
+		return (0);
+
+	if (dhcp_hdr->op != PXE_DHCP_REPLY) {
+		printf("dhcp_parse(): got request, not reply.\n");
+		return (0);
+	}
+	
+	if (dhcp_hdr->xid != xid) {
+		printf("dhcp_parse(): wrong xid 0x%x, need 0x%x.\n",
+		    dhcp_hdr->xid, xid);
+		return (0);
+	}
+	
+	PXE_DHCP_PARSE_RESULT opts_result;
+	pxe_memset(&opts_result, 0, sizeof(PXE_DHCP_PARSE_RESULT));
+	
+	/* parsing options section */
+	pxe_dhcp_parse_options(data + sizeof(PXE_DHCP_HDR),
+	    size - sizeof(PXE_DHCP_HDR), &opts_result);
+	
+	if ( (opts_result.message_type != PXE_DHCPOFFER) &&
+	     (opts_result.message_type != PXE_DHCPACK) )
+	{
+		/* not our packet */
+		return (0);
+	}
+	
+	/* if successfuly parsed, setting appropriate ip data */
+	if (opts_result.ns.ip)
+		pxe_set_ip(PXE_IP_NAMESERVER, &opts_result.ns);
+	
+	if (opts_result.gw.ip)
+		pxe_set_ip(PXE_IP_GATEWAY, &opts_result.gw);
+	
+	if (opts_result.netmask.ip)
+		pxe_set_ip(PXE_IP_NETMASK, &opts_result.netmask);
+
+	if (opts_result.bcast_addr.ip)
+		pxe_set_ip(PXE_IP_BROADCAST, &opts_result.bcast_addr);
+	
+	if (opts_result.www.ip)
+		pxe_set_ip(PXE_IP_WWW, &opts_result.www);
+	
+	if (opts_result.rootpath[0])
+		strcpy(PXENFSROOTPATH, opts_result.rootpath);
+		
+	return (1);
+}
+
+/* dhcp_await() - await function for DHCP replies
+ * in:
+ *      function        - await function
+ *      try_number      - number of try
+ *      timeout         - timeout from start of try
+ *      data            - pointer to PXE_DHCP_WAIT_DATA
+ * out:
+ *      PXE_AWAIT_ constants
+ */
+int
+dhcp_await(uint8_t function, uint16_t try_number, uint32_t timeout, void *data)
+{
+	PXE_DHCP_WAIT_DATA	*wait_data = (PXE_DHCP_WAIT_DATA *)data;
+
+	int			size = 0;
+	
+	switch (function) {
+		  
+	case PXE_AWAIT_STARTTRY:
+	    
+		if (!dhcp_send_request(wait_data))
+			return (PXE_AWAIT_NEXTTRY);
+			
+		break;
+		
+	case PXE_AWAIT_NEWPACKETS:
+		/* some packets were received, need checking our socket */
+		size = pxe_recv(wait_data->socket, wait_data->data,
+			    wait_data->size, PXE_SOCK_NONBLOCKING);
+			    
+		if ( size > 0) {
+			/* something felt to socket */
+			if (dhcp_parse(wait_data->data, size, wait_data->xid))
+				return (PXE_AWAIT_COMPLETED);
+		}
+		
+		return (PXE_AWAIT_CONTINUE);		
+        	break;
+
+        case PXE_AWAIT_FINISHTRY:
+		/* close socket if it is valid */
+		if (wait_data->socket != -1)
+			pxe_close(wait_data->socket);
+		
+        	break;
+		
+        case PXE_AWAIT_END:
+        default:
+        	break;
+        }
+
+	return (PXE_AWAIT_OK);
+}
+
+/* pxe_dhcp_query() - sends DHCP query, using provided client id
+ * in:
+ *	xid - client/transaction id, used to differ packets
+ * out:
+ *	none
+ */
+void
+pxe_dhcp_query(uint32_t xid)
+{
+	uint8_t			dhcp_pack[PXE_MAX_DHCPPACK_SIZE];
+	PXE_DHCP_WAIT_DATA	wait_data;
+
+	printf("pxe_dhcp_query(): getting parameters using DHCP.\n");
+
+	wait_data.data = dhcp_pack;
+	wait_data.socket = -1;
+	wait_data.size = PXE_MAX_DHCPPACK_SIZE;
+	wait_data.xid = xid;
+	
+	if (!pxe_await(dhcp_await, 3, 60000, &wait_data)) {
+		printf("pxe_dhcp_query(): failed to get parameters via DHCP\n");
+	} 
+}
+#else /* defined(PXE_BOOTP_USE_LIBSTAND) */
+
+extern int pxe_sock;
+
+void
+pxe_dhcp_query(uint32_t xid)
+{
+
+	printf("pxe_dhcp_query(): starting libstand bootp()\n");
+	bootp(pxe_sock, BOOTP_PXE);
+
+	/* setting pxe_core variables */
+	PXE_IPADDR addr;
+	
+	addr.ip = nameip.s_addr;
+	pxe_set_ip(PXE_IP_NAMESERVER, &addr);
+	
+	addr.ip = netmask;
+	pxe_set_ip(PXE_IP_NETMASK, &addr);
+	
+	addr.ip = rootip.s_addr;
+	pxe_set_ip(PXE_IP_ROOT, &addr);
+	pxe_set_ip(PXE_IP_WWW, &addr);
+	
+	/* "network route". direct connect for those addresses */
+	pxe_ip_route_add(pxe_get_ip(PXE_IP_MY), netmask, NULL);
+	
+	addr.ip =  gateip.s_addr;
+	pxe_set_ip(PXE_IP_GATEWAY, &addr);
+	
+	/* need update gateway information, cause it's already set to default */
+	pxe_ip_route_default(&addr);
+}
+
+#endif /* PXE_BOOTP_USE_LIBSTAND */
diff -ruN sys/boot/i386/pxe_ng/pxe_dhcp.h sys/boot/i386/pxe_ng/pxe_dhcp.h
--- sys/boot/i386/pxe_ng/pxe_dhcp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_dhcp.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,147 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_DHCP_H_INCLUDED
+#define PXE_DHCP_H_INCLUDED
+
+/* Implements simple DHCP client, able to retrieve nameserver
+ * and gateway ip data from DHCP-server.
+ * Reference: RFC 2131
+ */
+ 
+#include <stdint.h>
+
+/* define if want use bootp() instead of functions, provided by
+ * pxe_dhcp module 
+ * NOTE: bootp() doesn't sets nameserver
+ */
+/* #define PXE_BOOTP_USE_LIBSTAND */
+
+
+/* DHCP request/reply packet header */
+typedef struct pxe_dhcp_hdr {
+	uint8_t		op;	/* request or reply */
+	uint8_t		htype;	/* harsware type */
+	uint8_t		hlen;	/* hardware address length */
+	uint8_t		hops;	/* used by relay agents, zero for client */
+	uint32_t	xid;	/* transaction id */
+	uint16_t	secs;	/* time elapsed after renewal process */
+	uint16_t	flags;
+	uint32_t	ciaddr;	/* client ip, filled in BOUND, RENEW,
+				 * or REBINDING */
+	uint32_t	yiaddr;	/* client ip addr */
+	uint32_t	siaddr;	/* next server ip */
+	uint32_t	giaddr;	/* relay agent ip */
+	uint8_t		chaddr[16];	/* client hardware address */
+	uint8_t		sname[64];	/* optional server hostname */
+	uint8_t		file[128];	/* boot file name */
+	uint32_t	magic;		/* DHCP magic cookie */
+} __packed PXE_DHCP_HDR;
+
+/* options  structure */
+typedef struct pxe_dhcp_opt_hdr {
+	uint8_t	option;			/* option id */
+	uint8_t len;			/* size of data,
+					 * followed after this member */
+} __packed PXE_DHCP_OPT_HDR;
+
+/* dhcp packet types */
+#define PXE_DHCP_REQUEST		0x01
+#define PXE_DHCP_REPLY			0x02
+/* maximal size of buffer for packet */
+#define PXE_MAX_DHCPPACK_SIZE		1024
+/* broadcast packet flag */
+#define PXE_DHCP_BROADCAST		0x8000
+/* magic */
+#ifdef VM_RFC1048
+/* it's defined in pxe.h */
+    #define	PXE_MAGIC_DHCP		VM_RFC1048
+#else
+    #define	PXE_MAGIC_DHCP		0x63825363
+#endif
+
+/* DHCP server port*/
+#define PXE_DHCP_SERVER_PORT		67
+/* local port to listen replies */
+#define PXE_DHCP_CLIENT_PORT		68
+
+#define PXE_DHCPDISCOVER 		0x01
+#define PXE_DHCPOFFER			0x02
+#define PXE_DHCPREQUEST			0x03
+#define PXE_DHCPACK       		0x05
+#define PXE_DHCPINFORM       		0x08
+
+/* theese are unused in this DHCP client
+#define PXE_DHCPDECLINE			0x04
+#define PXE_DHCPNAK			0x06
+#define PXE_DHCPRELEASE			0x07
+*/
+
+/* DHCP options */
+#define PXE_DHCP_OPT_NETMASK		1
+#define PXE_DHCP_OPT_ROUTER		3
+#define PXE_DHCP_OPT_NAMESERVER		6
+#define PXE_DHCP_OPT_DOMAIN_NAME	15
+#define PXE_DHCP_OPT_ROOTPATH		17
+#define PXE_DHCP_OPT_BROADCAST_IP	28
+#define PXE_DHCP_OPT_REQUEST_IP		50
+#define PXE_DHCP_OPT_LEASE_TIME		51
+#define PXE_DHCP_OPT_TYPE		53
+#define PXE_DHCP_OPT_ID			54
+#define PXE_DHCP_OPT_RENEWAL_TIME	58
+#define PXE_DHCP_OPT_REBINDING_TIME	59
+#define PXE_DHCP_OPT_WWW_SERVER		72
+#define PXE_DHCP_OPT_END		255
+
+/* used in await function */
+typedef struct pxe_dhcp_wait_data {
+	int		socket;		/* current socket to check replies */
+	uint8_t		*data;		/* query packet data */
+	uint16_t	size;		/* max size of packet */
+	uint32_t	xid;		/* session id */
+} PXE_DHCP_WAIT_DATA;
+
+typedef struct pxe_dhcp_parse_result {
+	PXE_IPADDR	netmask;
+	PXE_IPADDR	bcast_addr;
+	PXE_IPADDR	ns;
+	PXE_IPADDR	gw;
+	PXE_IPADDR	www;
+	char		rootpath[256];
+	uint8_t		message_type;
+} PXE_DHCP_PARSE_RESULT;
+
+/* sends DHCPINFORM packet and updates nameserver
+ * and gateway data
+ */
+void pxe_dhcp_query(uint32_t xid);
+
+/* prints out known DHCP options */
+void pxe_dhcp_parse_options(uint8_t *opts, uint16_t max_size,
+	PXE_DHCP_PARSE_RESULT *res);
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_dns.c sys/boot/i386/pxe_ng/pxe_dns.c
--- sys/boot/i386/pxe_ng/pxe_dns.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_dns.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,589 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_core.h"
+#include "pxe_dns.h"
+#include "pxe_ip.h"
+#include "pxe_sock.h"
+
+static 	PXE_DNS_WAIT_DATA	static_wait_data;
+
+/* write_question_for()-  writes labels for provided domain name 
+ * in:
+ *	question - where to write
+ *	name	 - domain name
+ * out:
+ *	NULL	- if failed
+ *	non NULL- ponits to the next byte after labeled name.
+ */
+char *
+write_question_for(uint8_t *question, const char *name) 
+{
+	size_t	len = strlen(name);
+
+	if (len > 255)	/* oversize */
+		return (NULL);
+
+	size_t	ind = len;
+	uint8_t	symbol_count = 0;
+	uint8_t		*res = question + len;
+	const char	*np = name + len - 1;
+	question[len + 1] = 0; /* label end of question */	
+	
+	/* placing from the end, replacing dots with symbol counter */
+	for ( ; ind != 0; --ind) {
+
+		*res = *np;
+		
+		if ( *res == '.') {
+			
+			if (symbol_count == 0) { /* example..of.error */
+				return (NULL);
+			}
+			
+			*res = symbol_count;
+			symbol_count = 0;
+			
+		} else {
+			++symbol_count;
+		}
+		
+		--res;
+		--np;
+	}
+	
+	*res = symbol_count; /* length for first label */
+		
+	/* +1 for first length, +1 for \0 */
+	return (question + len + 2);
+}
+
+/* create_dns_packet()-  creates DNS request packet 
+ * in:
+ *	wd	- pointer to wait data structure
+ *	id	 - request id to distinguish requests
+ * out:
+ *	0	- failed
+ *	>0	- size of created packet
+ */
+int
+create_dns_packet(PXE_DNS_WAIT_DATA *wd, uint16_t id, uint16_t query_type)
+{
+	char	*name = wd->name;
+	void	*data = wd->data;
+	int	max_size = wd->size;
+	
+	PXE_DNS_REQUEST_HDR	*request = (PXE_DNS_REQUEST_HDR *)data;
+	pxe_memset(request, 0, sizeof(PXE_DNS_REQUEST_HDR));
+	
+	uint8_t	*question =
+		    (uint8_t *)(data + sizeof(PXE_DNS_REQUEST_HDR));
+	
+	/* header set with zeroes, so fill only needed values */	
+	request->id = htons(id);
+	request->flags = htons(PXE_DNS_DEFAULT_FLAGS);
+	request->qdcount = htons(1);
+	
+	question = write_question_for(question, name);
+	
+	if (question == NULL)	/* failed to write question section */
+		return (0);	/* may be, name size is to big */
+		
+	PXE_DNS_REQUEST_FOOT *foot = (PXE_DNS_REQUEST_FOOT *)question;
+
+	/* finishing creating of packet */ 
+	foot->qtype = htons(query_type);
+	foot->qclass = htons(PXE_DNS_CLASS_IN);
+	 
+	question += sizeof(PXE_DNS_REQUEST_FOOT);
+	
+	/* return total size of packet */
+	return (((void *)question) - data);
+}
+
+/* skip_name() - gets name from answers
+ * in:
+ *	org - pointer to packet data start
+ *	off - offset to name or part of name to get
+ *	to_place - where to place name. NULL, if not interesting for us
+ * out:
+ *	bytes, read from offset (name definition length)
+ */
+int
+skip_name(uint8_t *org, uint16_t off, uint8_t *to_place)
+{
+	uint8_t	label[64];
+	label[0] = 0;
+	
+	int res =0 ;
+	uint8_t *data = org + off;
+	
+	while (*data != 0) {
+	
+		if (*data < 64) { /* just a label */
+			pxe_memcpy(data + 1, label, *data);
+			label[*data] = 0;
+
+			if (to_place != 0) {
+				/* updating to_place, add dot, if there is
+				 * part of name in buffer */
+				if (to_place[0] != 0) 
+					strcat((char *)to_place, ".");
+					
+				strcat((char *)to_place, (const char*)label);
+			}
+				
+			res += (1 + *data);
+			data += (1 + *data);
+			
+		} else {/* compression  enabled, this is part of pointer */
+			uint16_t off = (((*data) & 0x3f) << 8) + *(data + 1);
+			skip_name(org, off, to_place);
+			
+			res += 1;
+			break;
+		}
+	}
+	
+	res += 1;	/* ending zero skip */
+	return (res);
+}
+
+/* parse_dns_reply() - parses reply from DNS server
+ * in:
+ *	wd - pointer to waiting data structure
+ * out:
+ *	0 	- parsing failed, or packet has no information about our domain
+ *	1	- success, wait_data->result contains ip
+ */
+int
+parse_dns_reply(PXE_DNS_WAIT_DATA *wd)
+{
+	uint8_t *data = wd->data;
+	int	size = wd->size;
+	char	*name = wd->name;
+	uint16_t id = wd->id;
+	uint8_t *cname = wd->cname;
+	
+	cname[0] = 0;
+	
+	if (size < sizeof(PXE_DNS_REQUEST_HDR) + 8) {
+		/* too small packet to be with data */
+#ifdef PXE_DEBUG
+		printf("parse_dns_reply(): too small packet.\n");
+#endif
+		return (0);
+	}
+	
+	PXE_DNS_REQUEST_HDR	*hdr = (PXE_DNS_REQUEST_HDR *)data;
+	uint8_t			*answer = data + sizeof(PXE_DNS_REQUEST_HDR);
+	
+	if ( hdr->id != htons(id)) { /* wrong id */
+#ifdef PXE_DEBUG
+		printf("parse_dns_reply(): wrong id %d, expected %d.\n",
+		    ntohs(hdr->id), id);
+#endif
+		return (0);
+	}
+	
+	uint16_t flags = ntohs(hdr->flags);
+	
+	if ( (flags & 0xf800) != 0x8000) { /* QR != 1 */
+#ifdef PXE_DEBUG
+		printf("parse_dns_reply(): got request. Ignoring it.\n");
+#endif	
+		return (0);
+	}
+
+#ifdef PXE_DEBUG
+	printf("parse_dns_reply(): query/answer/ns/additional = %d/%d/%d/%d\n",
+	    ntohs(hdr->qdcount), ntohs(hdr->ancount),
+	    ntohs(hdr->nscount), ntohs(hdr->arcount));
+#endif
+	/* getting server return code */
+	int rcode = (flags & 0x000f);
+	
+	switch(rcode) {
+	case 0: /* good */
+		break;
+	case 1:
+	        printf("parse_dns_reply(): server said format error.\n");
+		return (0);
+		break;
+	case 2:
+	        printf("parse_dns_reply(): server failed.\n");
+		return (0);
+		break;
+	case 3:
+	        printf("parse_dns_reply(): name error, domain not exists?\n");
+		return (0);
+		break;	
+	case 4:
+	        printf("parse_dns_reply(): operation not implemented.\n");
+		return (0);
+		break;		
+	case 5:
+	        printf("parse_dns_reply(): access refused.\n");
+		return (0);
+		break;		
+	default:
+	        printf("parse_dns_reply(): unknown rcode = %d.\n", rcode);
+		return (0);
+		break;
+	}
+	
+	/* server reported success */
+	
+	if (hdr->ancount == 0) { /* there is no answers */
+	        printf("parse_dns_reply(): there are no answers in DNS reply.\n");
+		return (0);	
+	}
+
+	uint8_t	 aname[256];	/* storage for domain names in answers */
+	
+	switch (ntohs(hdr->qdcount)) {
+	case 0:	/* best case, nothing must be skipped to get answer data */
+		break;
+	case 1:
+
+		aname[0] = 0;
+		answer += skip_name(data, answer - data, aname);
+#ifdef PXE_DEBUG
+		printf("question: %s\n", aname);
+#endif		
+		/* answer points qclass/qtypr, skipping it */
+		answer += sizeof(PXE_DNS_REQUEST_FOOT);
+		break;
+	
+	default: /* error */
+		printf("parse_dns_reply(): me sent only one query, "
+		       "but server says %d.\n", ntohs(hdr->qdcount));
+		return (0);
+	}
+	
+	
+	/* parsing answers, authorative section and additional section,
+	 * hoping to find A resource record
+	 */
+	uint16_t index = ntohs(hdr->ancount) + ntohs(hdr->nscount) +
+			 ntohs(hdr->arcount);
+	
+	while (index) {
+
+		aname[0] = 0;		
+		answer += skip_name(data, answer - data, aname);
+
+#ifdef PXE_DEBUG
+		printf("answer: %s", aname);	
+#endif		
+		PXE_DNS_REQUEST_FOOT	*ans_foot =
+					    (PXE_DNS_REQUEST_FOOT *)answer;
+	
+		if (ntohs(ans_foot->qclass) != PXE_DNS_CLASS_IN) {
+			printf("parse_dns_reply(): IN expected, got 0x%x.\n",
+			    ntohs(ans_foot->qclass));
+			    
+			return (0);
+		}
+	
+		answer += sizeof(PXE_DNS_REQUEST_FOOT);	
+
+		PXE_DNS_REQUEST_FOOT2	*ans_foot2 =
+					    (PXE_DNS_REQUEST_FOOT2 *)answer;
+
+		answer += sizeof(PXE_DNS_REQUEST_FOOT2);
+		
+		uint16_t qtype = ntohs(ans_foot->qtype);
+		uint16_t rdlength = ntohs(ans_foot2->rdlength);
+			
+		if (qtype == PXE_DNS_QUERY_A) {
+			/* successfully got A record */
+			
+/* A for our address */	if ( (!strcmp(aname, name)) ||	
+/* A for our CNAME */	     ((cname[0]) && (!strcmp(aname, cname))) ) 
+			{
+				/* sanity check */
+				if (rdlength != 4) {
+					/* wrong length of ip4 adrress length*/
+					return (0);
+				}
+		
+				/* answer points to rdata = ip4 */	
+
+				wd->result.octet[0] = answer[0];
+				wd->result.octet[1] = answer[1];
+				wd->result.octet[2] = answer[2];
+				wd->result.octet[3] = answer[3];
+#ifdef PXE_DEBUG
+				printf(" = %s\n", inet_ntoa(wd->result.ip));
+#endif				
+				return (1);
+			}
+
+#ifdef PXE_DEBUG
+			printf("parse_dns_reply(): A resource record '%s' "
+			       "is strange. Ignoring it.\n", aname);
+#endif
+		}
+
+		if (qtype == PXE_DNS_QUERY_CNAME) {
+
+			cname[0] = 0;
+			skip_name(data, answer - data, cname);			
+#ifdef PXE_DEBUG
+			printf(" is alias to %s\n", (char *)cname);
+#endif
+			
+		} else {
+			printf("parse_dns_reply(): A or CNAME expected, "
+			       "but got 0x%x, rdlength: %d.\n", qtype, rdlength);
+		}
+		
+		answer += rdlength;
+		--index;
+	}
+
+	/* have not found anything good */
+	return (0);	
+}
+
+/* converts provided string representation of of address to uint32_t
+ * in:
+ *	str - string to convert
+ * out:
+ *	0   	- failed
+ *	not 0 	- ip4 addr
+ */
+uint32_t
+pxe_convert_ipstr(char* str)
+{
+        PXE_IPADDR      ip;
+        ip.ip = 0;
+		
+        int     octet_index = 0;
+        int     accum = 0;
+        int     ch_index = 0;
+	
+        for ( ; ch_index < strlen(str); ++ch_index) {
+
+		if (str[ch_index] == '.') {
+                        ip.octet[octet_index] = accum;
+                        accum = 0;
+                        ++octet_index;
+
+	                if (octet_index == 4)
+	                        break;
+	
+	                continue;
+	        }
+	
+	        if (!isdigit(str[ch_index]))
+	                return (0);
+    
+                accum *= 10;
+                accum += (str[ch_index] - 0x30);
+        }
+
+	if (octet_index < 4)
+    		ip.octet[octet_index] = accum;
+    
+        return ip.ip;
+}
+
+/* dns_request() - creates and sends request
+ * in:
+ *	wait_data - DNS waiting data
+ * out:
+ *	0 - failed
+ *	1 - success
+ */
+int
+dns_request(PXE_DNS_WAIT_DATA *wait_data)
+{
+	int socket = pxe_socket();
+	
+	if (socket == -1) {
+		printf("dns_request(): failed to create socket.\n");
+		return (0);
+	}
+
+	uint16_t size = create_dns_packet(wait_data, wait_data->id,
+			    PXE_DNS_QUERY_A);
+	
+	if (size == 0) {
+		printf("dns_request(): failed to create request.\n");
+		pxe_close(socket);
+		return (0);	    
+	}
+
+	if (size != pxe_sendto(socket, pxe_get_ip(PXE_IP_NAMESERVER), 53,
+			wait_data->data, size))
+	{
+		printf("dns_request(): failed to send DNS request.\n");
+		pxe_close(socket);
+		return (0);
+	}
+	
+	wait_data->socket = socket;
+	
+	return (1);
+}
+
+/* dns_await() - await callback function for DNS requests/replies
+ * in:
+ *	function	- await function
+ *	try_number	- current number of try
+ *	timeout		- current timeout from start of try
+ *	data		- pointer to PXE_DNS_WAIT_DATA
+ * out:
+ *	PXE_AWAIT_ constants
+ */
+int
+dns_await(uint8_t function, uint16_t try_number, uint32_t timeout, void *data)
+{
+	PXE_DNS_WAIT_DATA	*wait_data = (PXE_DNS_WAIT_DATA *)data;
+	int			size = -1;
+
+	switch(function) {
+
+	case PXE_AWAIT_STARTTRY:
+		if (!dns_request(wait_data)) {
+			return (PXE_AWAIT_NEXTTRY);
+		}
+		break;
+		
+	case PXE_AWAIT_FINISHTRY:
+		if (wait_data->socket != -1)
+			pxe_close(wait_data->socket);
+			
+		wait_data->id += 1;
+		break;
+
+	case PXE_AWAIT_NEWPACKETS:
+		size = pxe_recv(wait_data->socket, wait_data->data,
+			    wait_data->size, PXE_SOCK_NONBLOCKING);
+
+		if (size > 0) {
+#ifdef PXE_DEBUG
+			printf("dns_await(): Received DNS reply (%d bytes).\n",
+			    size);
+#endif			    
+			parse_dns_reply(wait_data);
+			
+			if (wait_data->result.ip != 0) {
+			        return (PXE_AWAIT_COMPLETED);
+			}
+				
+			if (wait_data->cname[0] != 0) {
+				/* failed to get A, but found CNAME,
+				 * need to send other request 
+				 * with CNAME as name to resolve
+				 */
+				strcpy(wait_data->name, wait_data->cname);
+					
+				size = create_dns_packet(wait_data,
+					    wait_data->id,
+					    PXE_DNS_QUERY_A);
+	
+				if (size == 0) {
+					printf("dns_await(): failed to create request.\n");
+					return (PXE_AWAIT_NEXTTRY); /* next try */
+				}
+
+				if (size != pxe_send(wait_data->socket,
+						wait_data->data, size))
+				{
+					printf("dns_await(): failed to send DNS request.\n");
+					return (PXE_AWAIT_NEXTTRY);
+				}			
+			}
+
+		}
+		return (PXE_AWAIT_CONTINUE);
+		break;
+	
+	case PXE_AWAIT_END:
+	default:
+		break;
+	}
+	
+	return (PXE_AWAIT_OK);
+}
+
+/* pxe_gethostbyname() - returns ip4 address by domain name
+ * in:
+ *	name - domain name to resolve
+ * out:
+ *	NULL 	- if failed
+ *	ip addr - if success
+ */
+const PXE_IPADDR *
+pxe_gethostbyname(char *name)
+{
+	/* sanity check */
+	if (name == NULL)
+		return (0);
+	
+	uint32_t res = pxe_convert_ipstr(name);
+
+	if (res != 0) {
+		static_wait_data.result.ip = res;
+		return (&static_wait_data.result);
+	}
+		
+	/* 512 bytes is limit for packet, sent via UDP */
+	uint8_t	dns_pack[PXE_DNS_MAX_PACKET_SIZE];
+	uint8_t	cname[256];
+	char	tname[256];
+
+	size_t len = strlen(name);
+	
+	if (len < 256)
+		strcpy(tname, name);
+	else {
+		strncpy(name, tname, 255);
+		tname[255] = 0;
+	}
+	
+	pxe_memset(dns_pack, 0, sizeof(dns_pack));
+	
+	static_wait_data.socket = -1;
+	static_wait_data.id = 1;
+	static_wait_data.data = dns_pack;
+	static_wait_data.cname = cname;
+	static_wait_data.name = tname;
+	static_wait_data.size = PXE_DNS_MAX_PACKET_SIZE;
+	static_wait_data.result.ip = 0;
+
+	if (!pxe_await(dns_await, 4, 20000, &static_wait_data))
+		return (NULL);
+	
+	return (&static_wait_data.result);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_dns.h sys/boot/i386/pxe_ng/pxe_dns.h
--- sys/boot/i386/pxe_ng/pxe_dns.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_dns.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,124 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_DNS_H_INCLUDED
+#define PXE_DNS_H_INCLUDED
+
+/* Implements DNS-client for getting A and CNAME records
+ * Reference: RFC 1035
+ */
+ 
+#include <stdint.h>
+
+/* max seconds to wait DNS reply in milliseconds */
+#define PXE_MAX_DNS_TIMEOUT		10000
+/* how many times to try, if there is no reply */
+#define	PXE_MAX_DNS_TRYS		3
+/* query flags, set only RecursionDesired bit */
+#define PXE_DNS_DEFAULT_FLAGS		0x0100
+/* query A and CNAME records */
+#define	PXE_DNS_QUERY_A			0x0001
+#define	PXE_DNS_QUERY_CNAME		0x0005
+/* query class */
+#define	PXE_DNS_CLASS_IN		0x0001
+/* maximum UDP packet size */
+#define PXE_DNS_MAX_PACKET_SIZE		512
+
+/* returns ip address by name, or 0 if failed */
+const PXE_IPADDR *pxe_gethostbyname(char *name);
+
+/* converts string value of ip to uint32_t value */
+uint32_t	pxe_convert_ipstr(char *str);
+
+typedef struct pxe_dns_request_hdr {
+	uint16_t	id;	/* query identifier */
+	uint16_t	flags;
+
+
+	uint16_t	qdcount; /* number of entries in the question section */
+	uint16_t	ancount; /* number of RRs in the answer section */
+	uint16_t	nscount; /* name server resource records in the
+				  *   authority records section.
+				  */
+	uint16_t	arcount; /* number of resource records in the additional
+				  *   records section.
+				  */
+} __packed PXE_DNS_REQUEST_HDR;
+
+/* flags are (copied from RFC 1035):
+ *                                1  1  1  1  1  1
+ *  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
+ * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
+ * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ *  QR - 0 for query, 1 for reply
+ *  OPCODE -  kind of query
+ *              0 -  a standard query (QUERY)
+ *              1 -  an inverse query (IQUERY)
+ *              2 -  a server status request (STATUS)
+ *  AA - set if authorative
+ *  TC - set if message truncated
+ *  RD - set if recursion desired
+ *  RA - set if recursion available
+ *  Z  - reserved, must be zeroed
+ *  RCODE - return code:
+ *              0 - no error
+ *              1 - format error
+ *              2 - server failed
+ *              3 - name error
+ *              4 - not implemented
+ *              5 - refused
+ */
+
+/* RCODE values */
+#define PXE_RCODE_NOERROR		0x0
+#define PXE_RCODE_FORMAT_ERROR		0x1
+#define PXE_RCODE_SERVER_FAILED		0x2
+#define PXE_RCODE_NAME_ERROR		0x3
+#define PXE_RCODE_NOT_IMPLEMENTED	0x4
+#define PXE_RCODE_REFUSED		0x5
+
+typedef struct pxe_dns_request_foot {
+	uint16_t	qtype;		/* type of query, e.g. A */
+	uint16_t	qclass;		/* class of query, e.g. IN */
+} __packed PXE_DNS_REQUEST_FOOT;
+
+typedef struct pxe_dns_request_foot2 {
+	uint32_t	ttl;	  /* seconds answer will be valid to cache */
+	uint16_t	rdlength; /* length of data, followed by this struct */
+} __packed PXE_DNS_REQUEST_FOOT2;
+
+typedef struct pxe_dns_wait_data {
+	int		socket;	/* socket, to send/recv data */
+	uint16_t	id;	/* id, used to differ packets */
+	uint8_t		*data;	/* pointer to buffer */
+	uint16_t	size;	/* size of buffer */
+	uint8_t		*cname; /* not NULL when resolved to CNAME */
+	char		*name;	/* name to resolve */
+	PXE_IPADDR	result; /* result of resolving */
+} PXE_DNS_WAIT_DATA;
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_filter.c sys/boot/i386/pxe_ng/pxe_filter.c
--- sys/boot/i386/pxe_ng/pxe_filter.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_filter.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,438 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_ip.h"
+#include "pxe_filter.h"
+
+/* table with all filters */
+static PXE_FILTER_ENTRY	filters_table[MAX_PXE_FILTERS];
+static int 		all_filters = 0;	/* used count of filters */
+static PXE_FILTER_ENTRY *filters_head = NULL;	/* head of filters list */
+static PXE_FILTER_ENTRY *free_head = NULL;	/* head of free filters list */
+
+/* pxe_filter_init() - init of filter module, filter lists
+ * in/out:
+ *	none
+ */
+void
+pxe_filter_init()
+{
+
+	if (all_filters)	/* already was and inited and is used */
+		return;
+	
+	printf("pxe_filter_init(): initing socket ip packet filters.\n");
+	
+        pxe_memset(filters_table, 0, sizeof(filters_table));
+
+	/* init 2 linked list */
+	int index = 0;
+	
+	for ( ; index < MAX_PXE_FILTERS; ++index) {
+
+		filters_table[index - 1].next = &filters_table[index];
+		filters_table[index].prev = &filters_table[index - 1];
+	}
+
+	free_head = filters_table;	
+	filters_head = NULL;
+}
+
+/* filter_alloc() - allocates filter entry from free filters list
+ * in:
+ *	none
+ * out:
+ *	NULL	- if failed
+ *	not NULL- pointer to filter entry if success
+ */
+PXE_FILTER_ENTRY *
+filter_alloc()
+{
+	PXE_FILTER_ENTRY	*res = NULL;
+
+#ifdef PXE_DEBUG_HELL
+	printf("filter_alloc(): head = 0x%x, filters = %d.\n",
+	    free_head, all_filters);
+#endif
+
+	if (free_head != NULL) {
+
+		res = free_head;
+
+		free_head = free_head->next;
+		free_head->prev = NULL;
+		++all_filters;
+	}
+
+#ifdef PXE_DEBUG_HELL
+	printf("filter_alloc(): entry = 0x%x, head = 0x%x, filters = %d.\n",
+	    res, free_head, all_filters);
+#endif
+	return (res);
+}
+
+/* filter_free() - releases filter entry
+ * in:
+ *	entry - filter entry to release
+ * out:
+ *	none
+ */
+void
+filter_free(PXE_FILTER_ENTRY *entry)
+{
+
+	entry->next = free_head;
+	entry->prev = NULL;
+	
+	if (free_head != NULL)
+		free_head->prev = entry;
+
+	free_head = entry;
+
+#ifdef PXE_DEBUG_HELL
+	printf("filter_free(): entry = 0x%x, head = 0x%x, filters = %d.\n",
+	    entry, free_head, all_filters);
+#endif
+
+	--all_filters;
+}
+
+/* pxe_filter_add() - installs new filter
+ * in:
+ *	src_ip	- source IP address
+ *	src_port- source port
+ *	dst_ip	- destination IP address
+ *	dst_port- destination port
+ *	socket	- pointer to socket
+ *	proto	- IP stack protocol (e.g. UDP)
+ * out:
+ *	NULL	- if failed
+ *	not NULL- pointer to new installed entry
+ */
+PXE_FILTER_ENTRY *
+pxe_filter_add(const PXE_IPADDR *src, uint16_t src_port, const PXE_IPADDR *dst,
+	       uint16_t dst_port, void *socket, uint8_t proto)
+{
+
+	if (socket == NULL) {
+#ifdef PXE_DEBUG		
+		printf("pxe_filter_add(): NULL socket.\n");
+#endif
+		return (NULL);
+	}
+
+	if (free_head == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_filter_add(): filter table is full (used = %d).\n",
+		    all_filters);
+#endif		    
+		return (NULL);	/* there is no space for filters */
+	}
+
+	PXE_FILTER_ENTRY	*new_filter = filter_alloc();
+	
+	if (new_filter == NULL) {
+		printf("pxe_filter_add(): cannot alloc filter entry.\n");
+		return (NULL);
+	}
+
+	/* fillling data */
+	new_filter->src.ip = (src != NULL) ? src->ip : 0;
+	new_filter->dst.ip = dst->ip;
+	new_filter->src_port = src_port;
+	new_filter->dst_port = dst_port;
+
+	/* default mask allows pckets specified  source and port
+	 * to specified ip and port
+	 */
+	new_filter->src_mask = 0xffffffff;
+	new_filter->dst_mask = 0xffffffff;
+	new_filter->src_port_mask = 0xffff;
+	new_filter->dst_port_mask = 0xffff;
+	
+	new_filter->socket = socket;
+	new_filter->protocol = proto;
+
+	/* updating list, may be rewrite all using some default list
+	 *  implementations?
+	 *  list is growing LIFO: last added filter become first
+	 */
+	new_filter->prev = NULL;	
+	
+	if (filters_head != NULL) {
+
+		new_filter->next = filters_head;
+		filters_head->prev = new_filter;
+
+	} else  /* means, adding first filter */
+		new_filter->next = NULL;
+
+	filters_head = new_filter;	
+
+	return (new_filter);
+}
+
+/* pxe_filter_mask() - fills filter masks 
+ * in:
+ *	filter		- filter, for which masks are changed
+ *	src_ip_mask	- source IP address mask
+ *	src_port_mask	- source port mask
+ *	dst_ip_mask	- destination IP address mask
+ *	dst_port_mask	- destination port mask
+ * out:
+ *	0 - failed
+ *	1 - success
+ */
+int
+pxe_filter_mask(PXE_FILTER_ENTRY *filter, uint32_t src_ip_mask,
+	        uint16_t src_port_mask, uint32_t dst_ip_mask,
+		uint16_t dst_port_mask)
+{
+
+	if (filter == NULL) {	/* sanity check */
+#ifdef PXE_DEBUG
+		printf("pxe_filter_mask(): NULL filter.\n");
+#endif
+		return (0);
+	}
+	
+	
+	filter->src_mask = src_ip_mask;
+	filter->dst_mask = dst_ip_mask;
+	filter->src_port_mask = src_port_mask;
+	filter->dst_port_mask = dst_port_mask;
+		
+	return (1);
+}
+
+#ifdef PXE_MORE
+/* pxe_filter_before() - adds new filter before provided 
+ * in:
+ *	filter	- pointer to filter to add before
+ *	def	- pointer to definition of new filter
+ * out:
+ *	NULL	- if failed
+ *	not NULL- pointer to newly added filter, if success
+ */
+PXE_FILTER_ENTRY *
+pxe_filter_before(PXE_FILTER_ENTRY *filter, const PXE_FILTER_ENTRY* def)
+{
+
+	if ((def == NULL) ) {	/* sanity check */
+#ifdef PXE_DEBUG
+		printf("pxe_filter_before(): invalid filter.\n");
+#endif
+		return (NULL);
+	}
+	
+	PXE_FILTER_ENTRY *res = NULL;
+	
+	if (filter == NULL) { /*  handle it as usual filter_add with masking */
+	
+		res = pxe_filter_add(	&def->src, def->src_port,
+					&def->dst, def->dst_port,
+					def->socket, def->protocol );
+					
+		if (res == NULL)
+			return (NULL);
+		
+		if (!pxe_filter_mask(res, def->src_mask, def->src_port_mask,
+				     def->dst_mask, def->dst_port_mask))
+		{
+			pxe_filter_remove(res);
+			
+			return (NULL);
+		}
+		
+		return(res);
+	}
+	
+	/* allocating new filter entry */
+	res = filter_alloc();
+	
+	if (res == NULL)
+		return (NULL);
+	
+	/* copy needded data*/
+	pxe_memcpy(def, res, sizeof(PXE_FILTER_ENTRY));
+	
+	if (filter == filters_head) {	/* special case, must change head */
+
+		filter->prev = res;
+		res->next = filters_head;
+		res->prev = NULL;
+		filters_head =  res;
+
+	} else { /* adding to list */
+		
+		res->prev = filter->prev;
+		res->next = filter;
+		
+		if (res->prev) {	/* sanity check, must be always
+					 * not NULL anyway (if not head)
+					 */
+			res->prev->next = res;
+		}
+	}
+		
+	return (res);
+}
+#endif /* PXE_MORE */
+
+/* pxe_filter_remove() -removes filter from filter_table
+ * in:
+ *	filter - filter to remove
+ * out:
+ *	0 - failed
+ *	1 - success
+ */
+int
+pxe_filter_remove(PXE_FILTER_ENTRY *filter)
+{
+#ifdef PXE_DEBUG
+    if (filter == NULL) {
+	    printf("pxe_filter_remove(): NULL filter.\n");
+	    return (0);
+    }
+    
+    printf("pxe_filter_remove(): removing filter 0x%x.\n", filter);
+    
+#endif
+
+    if (filter != filters_head) { /* non head filter */
+
+	    PXE_FILTER_ENTRY	*prev = filter->prev;
+	    PXE_FILTER_ENTRY	*next = filter->next;
+	    
+	    if (prev) 	/* it must be always non NULL*/
+		    prev->next = next;
+	    
+	    if (next)  /* may be NULL for tail */
+		    next->prev = prev;
+    	    
+    } else {	/* removing head filter */
+    
+	filters_head = filter->next;
+	
+	if (filters_head)
+		filters_head->prev = NULL;
+    }
+    
+    filter_free(filter);
+    
+    return (1);
+}
+
+/* pxe_filter_check() - returns pointer to socket, if parameters matches filter
+ * in:
+ *	src_ip	- source IP address
+ *	src_port- source port
+ *	dst_ip	- destination IP address
+ *	dst_port- destination port
+ *	proto	- IP stack protocol
+ * out:
+ *	NULL	- if no filter matches this parameters
+ *	not NULL- pointer to socket structure
+ */
+void *
+pxe_filter_check(const PXE_IPADDR *src, uint16_t src_port,
+		 const PXE_IPADDR *dst, uint16_t dst_port, uint8_t proto)
+{
+	int			filter_index = 0;
+	PXE_FILTER_ENTRY	*entry = filters_head;
+	PXE_FILTER_ENTRY	*filter = NULL;	
+
+	while (entry != NULL) {
+	
+		filter = entry;
+		entry = entry->next;
+		
+		/* checking conditions */
+		if (filter->protocol != proto)
+			continue;
+			
+		if ( (filter->src.ip & filter->src_mask) !=
+		     (src->ip & filter->src_mask) )
+			continue;
+			
+		if ( (filter->src_port & filter->src_port_mask) != 
+		     (src_port & filter->src_port_mask) )
+			continue;
+			
+		if ( (filter->dst.ip & filter->dst_mask) !=
+		     (dst->ip & filter->dst_mask) )
+			continue;
+			
+		if ( (filter->dst_port & filter->dst_port_mask) !=
+		     (dst_port & filter->dst_port_mask) )
+			continue;
+			
+		/* filter triggered */
+
+		/* sanity check */
+		if (filter->socket == NULL)
+			continue;
+			
+		return filter->socket;
+	}
+	
+	return (NULL);
+}
+
+#ifdef PXE_MORE
+/* pxe_filter_stats() - shows active filter stats
+ * in/out:
+ *	none
+ */
+void
+pxe_filter_stats()
+{
+	PXE_FILTER_ENTRY 	*entry = filters_head;
+	PXE_IPADDR		src;
+	PXE_IPADDR		dst;
+
+	printf("pxe_filter_stats(): %d/%d filters\n",
+	    all_filters, MAX_PXE_FILTERS);
+
+	while (entry != NULL) {
+	
+		printf("\t0x%x: %s/%x %u/%x ->",
+		    entry->protocol,
+		    inet_ntoa(entry->src.ip), ntohl(entry->src_mask),
+		    entry->src_port, ntohs(entry->src_port_mask));
+		
+		printf("%s/%x %u/%x\tsocket: 0x%x\n",
+		    inet_ntoa(entry->dst.ip), ntohl(entry->dst_mask),
+		    entry->dst_port, ntohs(entry->dst_port_mask),
+		    entry->socket);
+		    
+		entry = entry->next;
+	}
+}
+#endif /* PXE_MORE */
diff -ruN sys/boot/i386/pxe_ng/pxe_filter.h sys/boot/i386/pxe_ng/pxe_filter.h
--- sys/boot/i386/pxe_ng/pxe_filter.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_filter.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,98 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_FILTER_H_INCLUDED
+#define PXE_FILTER_H_INCLUDED
+
+/*
+ * Packet filters for sockets.
+ */
+#include <stdint.h>
+
+#include "pxe_ip.h"
+
+#define PXE_FILTER_ACTIVE	0x01	/* filter is active (entry is used) */
+#define PXE_FILTER_PARENT	0x02	/* forks subfilters and creates sockets
+					 * for them. */
+#define PXE_FILTER_CONSUME	0x04	/* may send recved data to buffer */
+
+#define PXE_FILTER_LISTEN	(PXE_FILTER_PARENT | PXE_FILTER_ACTIVE)
+#define PXE_FILTER_ROOT		0x80
+
+typedef struct pxe_filter_entry {
+
+	uint16_t	src_port;	/* source port */
+	uint16_t	src_port_mask;	/* source port mask */
+	uint16_t	dst_port;	/* destination port */
+	uint16_t	dst_port_mask;	/* destination port mask */
+
+	PXE_IPADDR	src;		/* source IP address */
+	uint32_t	src_mask;	/* source IP address mask */
+	PXE_IPADDR	dst;		/* destination IP address */
+	uint32_t	dst_mask;	/* destination IP address mask */
+
+	void		*socket;	/* socket, which receives data,
+					 * passed through this filter
+					 * NULL - if unknown.
+					 */
+	uint8_t		protocol;	/* IP based protocol */
+
+	struct pxe_filter_entry *next;	/* next filter */
+	struct pxe_filter_entry *prev;	/* previous filter */
+	
+} PXE_FILTER_ENTRY;
+
+/* number of filter is must be at least equal to  number of sockets */
+#define MAX_PXE_FILTERS		8
+
+/* init filter module */
+void pxe_filter_init();
+
+/* show active filters */
+void pxe_filter_stats();
+
+/* installs new filter*/
+PXE_FILTER_ENTRY *pxe_filter_add(const PXE_IPADDR *src_ip, uint16_t src_port,
+		    const PXE_IPADDR *dst_ip, uint16_t dst_port, void *socket,
+		    uint8_t proto);
+
+/* install filter earlier provided filter */
+PXE_FILTER_ENTRY *pxe_filter_before(PXE_FILTER_ENTRY *filter,
+		    const PXE_FILTER_ENTRY *def);
+
+/* fills filter masks */
+int pxe_filter_mask(PXE_FILTER_ENTRY *filter, uint32_t src_ip_mask,
+	uint16_t src_port_mask, uint32_t dst_ip_mask, uint16_t dst_port_mask);
+
+/* removes filter from filter_table*/
+int pxe_filter_remove(PXE_FILTER_ENTRY *filter);
+
+/* returns socket, if found trigerred filter */
+void *pxe_filter_check(const PXE_IPADDR *src_ip, uint16_t src_port,
+	const PXE_IPADDR *dst_ip, uint16_t dst_port, uint8_t proto);
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_http.c sys/boot/i386/pxe_ng/pxe_http.c
--- sys/boot/i386/pxe_ng/pxe_http.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_http.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,876 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_core.h"
+#include "pxe_dns.h"
+#include "pxe_http.h"
+#include "pxe_ip.h"
+#include "pxe_tcp.h"
+
+/* #ifndef FNAME_SIZE
+#define FNAME_SIZE	128
+#endif
+*/
+/* for testing purposes, used by pxe_fetch() */
+#ifdef PXE_MORE
+static char http_data[PXE_MAX_HTTP_HDRLEN];
+#endif
+
+/* extern char rootpath[FNAME_SIZE]; */
+
+/* parse_size_t() - converts zero ended string to size_t value
+ * in:
+ *	str	- string to parse
+ *	result	- where store result
+ * out:
+ *	NULL	- failed, ignore result value
+ *	not NULL- pointer to next character after last parsed
+ */
+char *
+parse_size_t(char *str, size_t *result)
+{
+	char *p = str;
+	
+	while ( (*p != '\0') && (!isdigit(*p)) ) {
+		++p;
+	}
+	
+	if (!isdigit(*p)) 	/* nothing to parse */
+		return (NULL);
+	
+	size_t accum = 0;
+	
+	while ( (*p) && (isdigit(*p))) {
+		accum *= 10;
+		accum += (*p - '0');
+		++p;
+	}
+	
+	*result = accum;
+	
+	return (p);
+}
+
+/* http_reply_parse() - parses http reply, gets status code and length
+ * in:
+ *	data		- pointer to reply data
+ *	count		- max bytes to process [now ignored]
+ *	parse_data	- where to store result of parsing
+ * out:
+ *	0	- failed, ignore parse_data
+ *	1	- parsed successfully
+ */
+int
+http_reply_parse(char *data, int count, PXE_HTTP_PARSE_DATA *parse_data)
+{
+	if (strncmp(data, "HTTP/1.1", 8) != 0) /* wrong header */
+		return (0);
+	
+	size_t result = 0;
+	
+	char *found = parse_size_t(data + 8, &result);
+	parse_data->code = (uint16_t) result;
+	
+	if (found == NULL)
+		return (0);	/* failed to parse response code */
+
+	parse_data->isKeepAlive = 1;
+#ifdef PXE_HTTP_AUTO_KEEPALIVE
+	found = strstr(data, "Connection: close");
+	
+	if (found != NULL)
+		parse_data->isKeepAlive = 0;
+#endif 
+	found = strstr(data, "Content-Length:");
+
+	parse_data->size = PXE_HTTP_SIZE_UNKNOWN;
+	
+	if (found != NULL) /* parsing message body size */
+		found = parse_size_t(found + strlen("Content-Length:"),
+			    &parse_data->size);
+	
+	return (1);
+}
+
+/* http_get_header() - gets from socket data related to http header
+ * in:
+ *	socket		- socket descriptor
+ *	data		- pointer to working buffer
+ *	maxsize		- buffer size
+ * 	found_result	- if not NULL, there stored pointer to end of header
+ *	count_result	- if not NULL, received count stored
+ * out:
+ *	-1	- failed
+ *	>=0	- success
+ */
+int
+http_get_header(int socket, char *data, size_t maxsize,
+		char **found_result, size_t *count_result)
+{
+	int		result = -1;
+	size_t		count = 0;
+	char		*found = NULL;
+	char		ch = '\0';
+	
+	while (count < maxsize - 1) {
+		result = pxe_recv(socket, &data[count], maxsize - 1 - count,
+			    PXE_SOCK_BLOCKING);
+		
+		if (result == -1) {	/* failed to recv */
+#ifdef PXE_HTTP_DEBUG_HELL
+			printf("http_get_header(): pxe_recv() failed\n");
+#endif
+			break;
+		}
+		
+		if (result == 0)	/* nothing received yet */
+			continue;
+
+		/* make string ended with '\0' */
+		ch = data[count + result];
+		data[count + result] = '\0';
+		
+		/* searching end of reply */
+		found = strstr(&data[count], "\r\n\r\n");
+
+		/* restore char replaced by zero */
+		data[count + result] = ch;
+		
+		count += result;
+
+#ifdef PXE_HTTP_DEBUG_HELL
+		if (found != NULL)
+			printf("%s", data);
+#endif		
+
+		if (found != NULL)
+			break;
+	}
+
+	if (found_result)
+		*found_result = found;
+	
+	if (count_result)
+		*count_result = count;
+	
+	return (result);
+}
+
+#ifdef PXE_HTTPFS_CACHING
+/* http_get_header2() - gets from socket data related to http header
+ *			byte by byte.
+ * in:
+ *	socket		- socket descriptor
+ *	data		- pointer to working buffer
+ *	maxsize		- buffer size
+ * 	found_result	- if not NULL, there stored pointer to end of header
+ *	count_result	- if not NULL, received count stored
+ * out:
+ *	-1	- failed
+ *	>=0	- success
+ */
+int
+http_get_header2(int socket, char *data, size_t maxsize,
+		char **found_result, size_t *count_result)
+{
+	int		result = -1;
+	size_t		count = 0;
+	char		*found = NULL;
+	char		ch = '\0';
+	
+	while (count < maxsize - 1) {
+		result = pxe_recv(socket, &data[count], 1, PXE_SOCK_BLOCKING);
+		
+		if (result == -1) {	/* failed to recv */
+#ifdef PXE_HTTP_DEBUG_HELL
+			printf("http_get_header2(): pxe_recv() failed\n");
+#endif
+			break;
+		}
+		
+		if (result == 0)	/* nothing received yet */
+			continue;
+
+		count += 1;
+
+		if (count < 4)	/* wait at least 4 bytes */
+			continue;
+		
+		/* make string ended with '\0' */
+		ch = data[count];
+		data[count] = '\0';
+		
+		/* searching end of reply */
+		found = strstr(&data[count - 4], "\r\n\r\n");
+
+#ifdef PXE_HTTP_DEBUG_HELL
+		if (found != NULL)
+			printf("%s", data);
+#endif
+		/* restore char replaced by zero */
+		data[count] = ch;
+		
+		if (found != NULL)
+			break;
+	}
+
+	if (found_result)
+		*found_result = found;
+	
+	if (count_result)
+		*count_result = count;
+	
+	return (result);
+}
+
+/* http_await() - await callback function for filling buffer
+ * in:
+ *      function        - await function
+ *      try_number      - current number of try
+ *      timeout         - current timeout from start of try
+ *      data            - pointer to PXE_DNS_WAIT_DATA
+ * out:
+ *      PXE_AWAIT_ constants
+ */
+int
+http_await(uint8_t function, uint16_t try_number, uint32_t timeout, void *data)
+{
+	PXE_HTTP_WAIT_DATA	*wait_data = (PXE_HTTP_WAIT_DATA *)data;
+	uint16_t		space = 0;
+	
+	switch(function) {
+     
+		case PXE_AWAIT_NEWPACKETS:
+			space = pxe_buffer_space(wait_data->buf);
+			
+			/* check, have we got enough? */
+			if (wait_data->start_size - space >=
+			    wait_data->wait_size)
+				return (PXE_AWAIT_COMPLETED);
+
+			/* check, is socket still working? */
+			if (pxe_sock_state(wait_data->socket) !=
+			    PXE_SOCKET_ESTABLISHED)
+				return (PXE_AWAIT_BREAK);
+
+			return (PXE_AWAIT_CONTINUE);
+		default:
+			break;
+	}
+
+	return (PXE_AWAIT_OK);
+}
+	
+#endif /* PXE_HTTPFS_CACHING */
+
+#ifdef PXE_MORE
+/* pxe_fetch() - testing function, if size = from = 0, retrieve full file,
+ *		otherwise partial 
+ * in:
+ *	server_name	- web server name
+ *	filename	- path to file to fetch
+ *	from		- offset in file (if supported by server)
+ * 	size		- size of part to receive
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_fetch(char *server_name, char *filename, off_t from, size_t size)
+{
+	const PXE_IPADDR *server = NULL;
+	
+	printf("pxe_fetch(): fetching http://%s:80/%s (%llu+%lu)\n",
+	    server_name, filename, from, size);
+	
+	server = pxe_gethostbyname(server_name);
+	
+	if (server == NULL) {
+		printf("pxe_fetch(): cannot resolve server name.\n");
+		return (0);
+	} else
+		printf("pxe_fetch(): resolved as: %s\n", inet_ntoa(server->ip));
+	
+	int socket = pxe_socket();
+	
+	int result = pxe_connect(socket, server, 80, PXE_TCP_PROTOCOL);
+	
+	if (result == -1) {
+		printf("pxe_fetch(): failed to connect.\n");
+		pxe_close(socket);		
+		return (0);
+	}
+
+	if ( (from == 0) && (size == 0) )
+		snprintf(http_data, PXE_MAX_HTTP_HDRLEN,
+		    "GET /%s HTTP/1.1\r\nHost: %s\r\nConnection: Close\r\n"
+		    "User-Agent: pxe_http/0\r\n\r\n", filename, server_name);
+	else
+		snprintf(http_data, PXE_MAX_HTTP_HDRLEN,
+		    "GET /%s HTTP/1.1\r\nHost: %s\r\nRange: bytes=%llu-%llu\r\n"
+		    "Connection: Close\r\nUser-Agent: pxe_http/0\r\n\r\n",
+		    filename, server_name, from, from + size - 1);
+
+	size_t len = strlen(http_data);
+
+	if (len != pxe_send(socket, http_data, len)) {
+		printf("pxe_fetch(): failed to send request.\n");
+		pxe_close(socket);
+		return (0);
+	}
+
+	if (pxe_flush(socket) == -1) {
+		printf("pxe_fetch(): failed to push request.\n");
+		pxe_close(socket);
+		return (0);
+	}
+
+	size_t	count = 0;
+	char	*found = NULL;
+
+	/* retrieve header */	
+	result = http_get_header(socket, http_data, PXE_MAX_HTTP_HDRLEN - 1,
+		    &found, &count);
+
+	if (found == NULL) {	/* haven't found end of header */
+		pxe_close(socket);
+		return (0);
+	}
+	
+	/* parse header */
+	PXE_HTTP_PARSE_DATA	parse_data;
+	pxe_memset(&parse_data, 0, sizeof(PXE_HTTP_PARSE_DATA));
+	
+	if (!http_reply_parse(http_data, count, &parse_data)) {
+		pxe_close(socket);
+		return (0);
+	}
+
+	printf("pxe_fetch(): response %u, length = %lu\n",
+	    parse_data.code, parse_data.size);
+	    
+	delay(2000000);
+	
+	if ( (parse_data.code < 200) ||
+	     (parse_data.code >= 300) )
+	{
+		printf("pxe_fetch(): failed to fetch.\n");
+		pxe_close(socket);
+		return (0);
+	}
+
+	http_data[count] = '\0';
+	
+	/* update counter, substruct header size */
+	count -= (found - http_data) + 4;
+			
+	/* process body data */
+	printf("%s", found + 4);
+	
+	while (1) {
+		result = pxe_recv(socket, http_data, PXE_MAX_HTTP_HDRLEN - 1,
+			    PXE_SOCK_BLOCKING);
+		
+		if (result == -1)
+			break;
+		
+		if (result == 0)
+			continue;
+		
+		http_data[result] = '\0';
+		
+		printf("%s", http_data);
+		
+		count += result;
+	}
+	
+	pxe_close(socket);
+	printf("\npxe_fetch(): %lu of %lu byte(s) received.\n",
+	    count, parse_data.size);
+	
+	return (1);
+}
+#endif
+
+/* pxe_get() - gets portion of file
+ * in:
+ *	hh	- descriptor of file to read data from
+ *	size	- size of part to read starting at from hh->offset
+ * out:
+ *	-1	- failed
+ *	>=0	- actual bytes read
+ */
+int
+pxe_get(PXE_HTTP_HANDLE *hh, size_t size, void *buffer)
+{
+
+	size_t size_to_get = (size > 0) ? size : hh->size;
+	
+	if (hh->isKeepAlive == 0) {
+#ifdef PXE_HTTP_AUTO_KEEPALIVE
+		/* if connection is not keep-alived, then try pxe_get_close() */
+		return pxe_get_close(hh, size_to_get, buffer);
+#endif
+		printf("pxe_get(): auto keep-alive feature not enabled "
+		       "during compile time. Connection is closed.\n");
+
+		return (-1);
+	}
+
+	
+#ifdef PXE_HTTP_DEBUG_HELL
+	printf("pxe_get(): %s:%s:%llu+%lu(%lu:%lu) to 0x%x\n",
+	    inet_ntoa(hh->addr.ip), hh->filename, hh->offset,
+	    size_to_get, size, hh->size, hh->buf);
+#endif
+
+	if (hh->socket == -1) {
+		printf("pxe_get(): invalid socket.\n");
+		return (-1);
+	}
+	
+	if (pxe_sock_state(hh->socket) != PXE_SOCKET_ESTABLISHED) {
+		/* means connection was closed, due e.g. for Apache
+		 * - MaxKeepAliveRequests exceeds for that connection
+		 * - Waited between read attempts more than KeepAliveTimeout
+		 *  or
+		 * some other problem
+		 * need to reestablish connection
+		 */
+		 
+		 /* close socket gracefully */
+		 pxe_close(hh->socket);
+		 hh->socket = -1;
+		 
+		 if (!pxe_exists(hh)) {
+#ifdef PXE_HTTP_DEBUG
+			printf("pxe_get(): connection breaked.\n");
+#endif
+			return (-1);
+		 }
+		 /* reestablished, continue normal work */
+	}
+
+	if ( (size_to_get < PXE_HTTP_SIZE_UNKNOWN) &&
+	     (size_to_get > 0))
+	{
+		snprintf(hh->buf, hh->bufsize, "GET %s%s HTTP/1.1\r\nHost: %s\r\n"
+		    "Range: bytes=%llu-%llu\r\nConnection: keep-alive\r\n"
+		    "Keep-Alive: 300\r\nUser-Agent: pxe_http/0\r\n\r\n",
+		    rootpath, hh->filename, hh->servername, hh->offset,
+		    hh->offset + size - 1);
+	} else {
+		/* asked zero bytes, or size of file is unknown */
+		printf("pxe_get(): internal error\n");
+		return (-1);
+	}
+    
+	size_t len = strlen(hh->buf);
+
+#ifdef PXE_HTTPFS_CACHING
+	PXE_HTTP_WAIT_DATA	wait_data;	
+	wait_data.buf = pxe_sock_recv_buffer(hh->socket);
+	/* assuming recv_buffer always is not NULL */
+	wait_data.start_size = pxe_buffer_space(wait_data.buf);
+	wait_data.wait_size = (uint16_t)size;
+	wait_data.socket = hh->socket;
+#endif
+	if (len != pxe_send(hh->socket, hh->buf, len)) {
+		printf("pxe_get(): failed to send request.\n");
+		return (-1);
+	}
+
+	if (pxe_flush(hh->socket) == -1) {
+		printf("pxe_get(): failed to push request.\n");
+		return (-1);
+	}
+
+	size_t	count = 0;
+	char	*found = NULL;
+
+	/* retrieve header */	
+#ifndef PXE_HTTPFS_CACHING
+	int result = http_get_header(hh->socket, hh->buf, hh->bufsize - 1,
+		    &found, &count);
+#else
+	int result = http_get_header2(hh->socket, hh->buf, hh->bufsize - 1,
+		    &found, &count);
+#endif
+	
+	if (found == NULL) {	/* haven't found end of header */
+		printf("pxe_get(): cannot find reply header.\n");
+		return (-1);
+	}
+	
+	/* parse header */
+	PXE_HTTP_PARSE_DATA	parse_data;
+	pxe_memset(&parse_data, 0, sizeof(PXE_HTTP_PARSE_DATA));
+	
+	if (!http_reply_parse(hh->buf, count, &parse_data)) {
+		printf("pxe_get(): cannot parse reply header.\n");
+		return (-1);
+	}
+
+	if ( (parse_data.code < 200) ||
+	     (parse_data.code >= 300) )
+	{
+		printf("pxe_get(): failed to get (status: %u).\n",
+		    parse_data.code);
+		    
+		return (-1);
+	}
+
+	/* update counter, substruct header size */
+	count -= (found - hh->buf) + 4;
+
+	/* process body data */
+	if (count > size_to_get) { /* sanity check, never must be  */
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_get(): warning:1, count: %lu, size_to_get: %lu\n",
+		    count, size);
+#endif		
+		count = size_to_get;
+	}
+
+#ifndef PXE_HTTPFS_CACHING
+	pxe_memcpy((char *)found + 4, buffer, count);
+	
+	while (count < size_to_get) {
+	
+		result = pxe_recv(hh->socket, buffer + count,
+			    size_to_get - count, PXE_SOCK_BLOCKING);
+		
+		if (result == -1)
+			break;
+		
+		if (result == 0)
+			continue;
+		
+		count += result;
+	}
+	
+#ifdef PXE_HTTP_DEBUG_HELL
+	printf("\npxe_get(): %lu of %lu byte(s) received.\n", count, size);
+#endif
+
+	if (count > size_to_get) { /* sanity check, never must be */
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_get(): warning:2, count: %lu, size_to_get: %lu\n",
+		    count, size);
+#endif
+		count = size_to_get;
+	}
+#else
+	/* waiting buffer space become filled by our data,
+	 * main difference with normal processing, that we don't need read
+	 * received data here. Main trick is just receive it, and store
+	 * in buffer, httpfs code will read it when needed.
+	 */
+	
+	if (wait_data.start_size - pxe_buffer_space(wait_data.buf) < size)
+		/* receiving data, maximum wait 1 minute */
+		pxe_await(http_await, 1, 60000, &wait_data);
+	
+	count = wait_data.start_size -
+		pxe_buffer_space(wait_data.buf);
+
+	hh->cache_size += count;
+
+#ifdef PXE_HTTP_DEBUG
+	printf("%lu read, cache: %lu \n", count, hh->cache_size);
+#endif
+	
+#endif /* PXE_HTTPFS_CACHING */
+	return (count);
+}
+
+#if defined(PXE_MORE) || defined(PXE_HTTP_AUTO_KEEPALIVE)
+/* pxe_get_close() - gets portion of file, closing socket after getting
+ * in:
+ *	hh	- descriptor of file to read data from
+ *	size	- size of part to read starting at from offset
+ * out:
+ *	-1	- failed
+ *	>=0	- actual bytes read
+ */
+int
+pxe_get_close(PXE_HTTP_HANDLE *hh, size_t size, void *buffer)
+{
+	size_t size_to_get = (size > 0) ? size : hh->size;
+	
+#ifdef PXE_HTTP_DEBUG_HELL
+	printf("pxe_get_close(): %s:%s:%llu+%lu(%lu:%lu) to 0x%x\n",
+	    inet_ntoa(hh->addr.ip), hh->filename, hh->offset,
+	    size_to_get, size, hh->size, hh->buf);
+#endif
+	int socket = pxe_socket();
+	
+	if (socket == -1) {
+		printf("pxe_get_close(): failed to create socket.\n");
+		return (-1);
+	}
+
+	int result = pxe_connect(socket, &hh->addr, 80, PXE_TCP_PROTOCOL);
+	
+	if (result == -1) {
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_get_close(): failed to connect.\n");
+#endif
+		pxe_close(socket);
+		return (-1);
+	}
+
+	if ( (size_to_get < PXE_HTTP_SIZE_UNKNOWN) &&
+	     (size_to_get > 0))
+	{
+		snprintf(hh->buf, hh->bufsize, "GET %s%s HTTP/1.1\r\nHost: %s\r\n"
+		    "Range: bytes=%llu-%llu\r\nConnection: Close\r\n"
+		    "User-Agent: pxe_http/0\r\n\r\n",
+		    rootpath, hh->filename, hh->servername,
+		    hh->offset, hh->offset + size - 1);
+	} else {
+		snprintf(hh->buf, hh->bufsize,
+		    "GET %s%s HTTP/1.1\r\nHost: %s\r\nConnection: Close\r\n"
+		    "User-Agent: pxe_http/0\r\n\r\n",
+		    rootpath, hh->filename, hh->servername);
+	}
+
+	size_t len = strlen(hh->buf);
+
+#ifdef PXE_HTTPFS_CACHING
+	PXE_HTTP_WAIT_DATA	wait_data;	
+	wait_data.buf = pxe_sock_recv_buffer(socket);
+	/* assuming recv_buffer always is not NULL */
+	wait_data.start_size = pxe_buffer_space(wait_data.buf);
+	wait_data.wait_size = (uint16_t)size;
+	wait_data.socket = socket;
+#endif
+	if (len != pxe_send(socket, hh->buf, len)) {
+		printf("pxe_get_close(): failed to send request.\n");
+		pxe_close(socket);
+		return (-1);
+	}
+
+	if (pxe_flush(socket) == -1) {
+		printf("pxe_get_close(): failed to push request.\n");
+		pxe_close(socket);
+		return (-1);
+	}
+
+	size_t	count = 0;
+	char	*found = NULL;
+
+	/* retrieve header */
+
+#ifndef PXE_HTTPFS_CACHING
+	result = http_get_header(socket, hh->buf, hh->bufsize - 1,
+		    &found, &count);
+#else
+	result = http_get_header2(socket, hh->buf, hh->bufsize - 1,
+		    &found, &count);
+#endif
+
+	if (found == NULL) {	/* haven't found end of header */
+		printf("pxe_get_close(): cannot find reply header\n");
+		pxe_close(socket);
+		return (-1);
+	}
+	
+	/* parse header */
+	PXE_HTTP_PARSE_DATA	parse_data;
+	pxe_memset(&parse_data, 0, sizeof(PXE_HTTP_PARSE_DATA));
+	
+	if (!http_reply_parse(hh->buf, count, &parse_data)) {
+		printf("pxe_get_close(): cannot parse reply header\n");
+		pxe_close(socket);
+		return (-1);
+	}
+
+	if ( (parse_data.code < 200) ||
+	     (parse_data.code >= 300) )
+	{
+		printf("pxe_get_close(): failed to get (status: %u).\n",
+		    parse_data.code);
+		    
+		pxe_close(socket);
+		return (-1);
+	}
+
+	/* update counter, substruct header size */
+	count -= (found - hh->buf) + 4;
+
+	/* process body data */
+	if (count > size_to_get) { /* sanity check, never must be  */
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_get_close(): warning:1, count: %lu, "
+		       "size_to_get: %lu\n", count, size);
+#endif		
+		count = size_to_get;
+	}
+
+#ifndef PXE_HTTPFS_CACHING
+	pxe_memcpy((char *)found + 4, buffer, count);
+	
+	while (count < size_to_get) {
+		result = pxe_recv(socket, buffer + count, size_to_get - count,
+			    PXE_SOCK_BLOCKING);
+		
+		if (result == -1)
+			break;
+		
+		if (result == 0)
+			continue;
+		
+		count += result;
+	}
+#ifndef PXE_HTTP_AUTO_KEEPALIVE
+	pxe_close(socket);
+#endif
+
+#ifdef PXE_HTTP_DEBUG
+	printf("\npxe_get_close(): %lu of %lu byte(s) received.\n",
+	    count, size);
+#endif
+
+	if (count > size_to_get) { /* sanity check, never must be */
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_get_close(): warning:2, count: %lu, "
+		       "size_to_get: %lu\n",  count, size);
+#endif		       
+		count = size_to_get;
+	}
+#else /* PXE_HTTPFS_CACHING */
+
+	if (wait_data.start_size - pxe_buffer_space(wait_data.buf) < size)
+		/* receiving data, maximum wait 1 minute */
+		pxe_await(http_await, 1, 60000, &wait_data);
+	
+	count = wait_data.start_size -
+		pxe_buffer_space(wait_data.buf);
+
+	hh->cache_size += count;
+
+	hh->socket = socket;
+		
+#ifdef PXE_HTTP_DEBUG
+	printf("%lu read, cache: %lu \n", count, hh->cache_size);
+#endif
+
+#endif /* PXE_HTTPFS_CACHING */
+	return (count);
+}
+#endif /* PXE_MORE || PXE_HTTP_AUTO_KEEPALIVE */
+
+/* pxe_exists() - checks if file exists and gets it's size
+ * in:
+ *	hh	- descriptor of file to read data from
+ * out:
+ *	0	- failed, not exists
+ *	1	- ok, file exists
+ */
+int
+pxe_exists(PXE_HTTP_HANDLE *hh)
+{
+	int socket = pxe_socket();
+	
+	int result = pxe_connect(socket, &hh->addr, 80, PXE_TCP_PROTOCOL);
+	
+	if (result == -1) {
+		pxe_close(socket);
+		return (0);
+	}
+
+	snprintf(hh->buf, hh->bufsize,
+	    "HEAD %s%s HTTP/1.1\r\nHost: %s\r\nConnection: keep-alive\r\n"
+	    "User-Agent: pxe_http/0\r\n\r\n", rootpath, hh->filename,
+	    hh->servername);
+
+	size_t len = strlen(hh->buf);
+
+	if (len != pxe_send(socket, hh->buf, len)) {
+		printf("pxe_exists(): failed to send request.\n");
+		pxe_close(socket);
+		return (0);
+	}
+
+	if (pxe_flush(socket) == -1) {
+		printf("pxe_exists(): failed to push request.\n");
+		pxe_close(socket);
+		return (0);
+	}
+
+	size_t	count = 0;
+	char	*found = NULL;
+
+	/* retrieve header */	
+	result = http_get_header(socket, hh->buf, hh->bufsize, &found, &count);
+
+	if (found == NULL) {	/* haven't found end of header */
+		pxe_close(socket);
+		return (0);
+	}
+	
+	
+	/* parse header */
+	PXE_HTTP_PARSE_DATA	parse_data;
+	pxe_memset(&parse_data, 0, sizeof(PXE_HTTP_PARSE_DATA));
+	
+	if (!http_reply_parse(hh->buf, count, &parse_data)) {
+		pxe_close(socket);
+		return (0);
+	}
+
+	if ( (parse_data.code < 200) ||
+	     (parse_data.code >= 300) )
+	{
+#ifdef PXE_HTTP_DEBUG
+		printf("pxe_exists(): failed to get header (status: %u).\n",
+		    parse_data.code);
+#endif
+		pxe_close(socket);
+		return (0);
+	}
+	
+	/* server doesn't support keep-alive connections */
+	if (parse_data.isKeepAlive == 0) {
+		printf("pxe_exists(): Server denied keep-alive connection.\n");
+		pxe_close(socket);
+		socket = -1;
+	}
+	
+	hh->socket = socket;
+	hh->size = parse_data.size;
+	hh->isKeepAlive = parse_data.isKeepAlive;
+
+#ifdef PXE_HTTP_DEBUG
+	printf("pxe_exists(): size = %lu bytes\n", hh->size);
+#endif
+	return (1);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_http.h sys/boot/i386/pxe_ng/pxe_http.h
--- sys/boot/i386/pxe_ng/pxe_http.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_http.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_HTTP_INCLUDED
+#define PXE_HTTP_INCLUDED
+
+/*
+ * http downloading functions.
+ */
+
+#include <sys/types.h>
+#include <stdint.h>
+
+#ifdef PXE_HTTPFS_CACHING
+#include "pxe_buffer.h"
+#endif
+
+/* default buffer size for generating/getting http header */
+#define PXE_MAX_HTTP_HDRLEN	1024
+/* testing function, outputs received data to screen */
+int pxe_fetch(char *server, char *filename, off_t from, size_t size);
+
+typedef struct pxe_http_handle {
+
+	char		*filename;	/* filename including path on server */
+	char		*servername;	/* server name */
+	
+	int		socket;		/* opened socket, or -1 */
+	
+	char		*buf;		/* buffer for creating requests */
+	uint16_t	bufsize;	/* size of buffer */
+	
+	PXE_IPADDR	addr;		/* web server ip */
+	off_t		offset;		/* current offset in bytes from
+					 * beginning of file */
+#ifdef PXE_HTTPFS_CACHING
+/*	off_t		cache_start;	/* cached block, to reduce http requests */
+	uint16_t	cache_size;	/* size of cached block */
+#endif
+	size_t		size;		/* file size if known */
+	int		isKeepAlive;	/* if connection keep-alive? */
+} PXE_HTTP_HANDLE;
+
+/* gets requested data from server */
+int pxe_get(PXE_HTTP_HANDLE *hh, size_t size, void *buffer);
+
+/* gets requested data from server, closing connection after */
+int pxe_get_close(PXE_HTTP_HANDLE *hh, size_t size, void *buffer);
+
+/* checks if file exists and fills filesize if known */
+int pxe_exists(PXE_HTTP_HANDLE *hh);
+
+#define PXE_HTTP_SIZE_UNKNOWN	-1
+
+typedef struct pxe_http_parse_data {
+	uint16_t	code;	/* response code */
+	size_t		size;	/* size of data if known */
+	int		isKeepAlive;	/* positive if server supports
+					 * keep-alive connections
+					 */
+} PXE_HTTP_PARSE_DATA;
+
+#ifdef PXE_HTTPFS_CACHING
+/* used in waiting function */
+typedef struct pxe_http_wait_data {
+	PXE_BUFFER	*buf;		/* buffer, waiting to fill */
+	int		socket;		/* socket, which buffer is above */
+	uint16_t	wait_size;	/* how much must be filled */
+	uint16_t	start_size;	/* how much were in buffer before waiting */
+} PXE_HTTP_WAIT_DATA;
+#endif
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_httpls.c sys/boot/i386/pxe_ng/pxe_httpls.c
--- sys/boot/i386/pxe_ng/pxe_httpls.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_httpls.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,130 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <stand.h>
+
+#include "pxe_httpls.h"
+#include "pxe_sock.h"
+
+/* fgetch() - returns one char from opened file
+ * in:
+ *	fd - file descriptor
+ * out:
+ *	-1 - if failed
+ *	>0 - read char
+ */
+int
+fgetch(int fd)
+{
+	char	ch = 0;
+	ssize_t result = read(fd, &ch, 1);	
+
+	return (result != -1) ? ch : -1;
+}
+
+/* http_parse_index() - parses index file generated by server for directory,
+ *			print result data to screen. 
+ * in:
+ *	fd - descriptor of file to parse
+ * out:
+ *	none
+ */
+void
+http_parse_index(int fd)
+{
+	char	ch = 0;
+	int	stream_state	= TAG_EXPECT_OPEN;
+	char	tag_body[TAG_MAX_BODY] = {0};
+	int	tag_size = 0;
+	int	dir_listing = 0;
+	
+	while( (ch = fgetch(fd)) != -1) {
+					
+		switch(ch) {
+		case '<':
+			if (stream_state == TAG_EXPECT_OPEN) {
+				stream_state = TAG_EXPECT_BODY;
+				tag_size = 0;
+				/* printf("{TEB}"); */
+				continue;
+			}
+			break;
+							
+		case '>':
+			if ( (stream_state == TAG_EXPECT_CLOSE) || 
+			     (stream_state == TAG_EXPECT_BODY)) 
+			{
+				stream_state = TAG_EXPECT_OPEN;
+				/* printf("{TEO}");*/
+									
+				/* check for <HR> */
+				if (tag_size == 2) {
+												
+					if ( ((tag_body[0] == 'h') ||
+					      (tag_body[0] == 'H')) &&
+					     ((tag_body[1] == 'r') ||
+					      (tag_body[1] == 'R')))
+					{	/* it's <HR>, inverting dir_listing 
+						 * for apache1.3 directory listing is
+						 * between <hr> tags.
+						 */
+						dir_listing = 1 - dir_listing;	
+	
+						if (dir_listing == 0)
+							return;
+					}
+				}
+										
+				continue;
+			}
+			break;
+						
+		case ' ': case '\t': // whitespace
+			if (stream_state == TAG_EXPECT_BODY) {
+				stream_state = TAG_EXPECT_CLOSE;
+				/* printf("{TEC}"); */
+				continue;
+			}
+			break;
+						
+		default:
+			break;
+		}
+					
+		if ( (stream_state == TAG_EXPECT_OPEN) && (dir_listing == 1))
+			printf("%c", ch);
+			
+		if (stream_state == TAG_EXPECT_BODY) {
+			if (tag_size < TAG_MAX_BODY) {
+				tag_body[tag_size] = ch;
+				tag_size += 1;
+			} else {
+				stream_state = TAG_EXPECT_CLOSE;
+			}
+		}
+	}
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_httpls.h sys/boot/i386/pxe_ng/pxe_httpls.h
--- sys/boot/i386/pxe_ng/pxe_httpls.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_httpls.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,45 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_HTTPLS_INCLUDED
+#define PXE_HTTPLS_INCLUDED
+
+/* stream state flags during parsing of html */
+/* expecting opening of tag: ..<tag.. >*/
+#define TAG_EXPECT_OPEN			0
+/* expecting tag body: tag.. */
+#define TAG_EXPECT_BODY			1
+/* expecting tag closing: .. > */
+#define TAG_EXPECT_CLOSE			2
+/* max characters of tag body to store during parsing */
+#define TAG_MAX_BODY					4
+
+/* parses autogenerated index for directory, it's assumed that file descriptor
+   provides data in html format */
+void http_parse_index(int fd);
+
+#endif /* PXE_HTTPLS_INCLUDED */
diff -ruN sys/boot/i386/pxe_ng/pxe_icmp.c sys/boot/i386/pxe_ng/pxe_icmp.c
--- sys/boot/i386/pxe_ng/pxe_icmp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_icmp.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,259 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+#ifdef PXE_MORE 
+#include <stand.h>
+
+#include "pxe_arp.h"
+#include "pxe_core.h"
+#include "pxe_icmp.h"
+#include "pxe_ip.h"
+
+/* used in echo replying */
+static PXE_IPADDR	pinging;	/* ip to accept replies from */
+static uint16_t		seq_number;	/* next sequence number to accept */
+/* last sequence number accepted */
+static uint16_t		last_accepted = 0xffff;
+/* 1 - show messages on screen while ping, 0 - not */
+static int		echo_flags = 0;
+
+/* pxe_icmp_callback() - callback function, executed by pxe_core
+ * in:
+ *	pack	- packet describing data
+ *	function- function, which must be performed
+ * out:
+ *	always 0
+ */
+int
+pxe_icmp_callback(PXE_PACKET *pack, uint8_t function)
+{
+
+	if (function == PXE_CORE_FRAG)
+		return (1);
+
+	/* icmp header */
+	PXE_IP_HDR	*iphdr = (PXE_IP_HDR *)pack->data;
+	size_t		iphdr_len = (iphdr->ver_ihl & 0x0f) * 4;
+	size_t		data_size = ntohs(iphdr->length) -
+				    iphdr_len - sizeof(PXE_ICMP_HDR);
+	PXE_ICMP_HDR	*icmphdr = (PXE_ICMP_HDR *)(pack->data + iphdr_len);
+
+#ifdef PXE_DEBUG
+	printf("pxe_icmp_callback(): data size %d (of %d) bytes, type: %d\n",
+	    data_size, pack->data_size, icmphdr->type);
+#endif
+	/* TODO: verify checksum */
+
+	/* reply */
+	PXE_IP_HDR	*reply_iphdr = NULL;
+	PXE_ICMP_HDR	*reply_icmphdr = NULL;
+	size_t		reply_size = sizeof(PXE_IP_HDR) + sizeof(PXE_ICMP_HDR) +
+				     data_size;
+
+	uint16_t	reply_number = ntohl(icmphdr->seq_num);
+	
+	/* we are interested only in echo related packets*/
+	switch(icmphdr->type) {
+	case PXE_ICMP_ECHO_REQUEST:
+	case PXE_ICMP_ECHO_REPLY:
+ /*	case PXE_ICMP_DEST_UNREACHABLE:
+ 	case PXE_ICMP_REDIRECT_MESSAGE:
+ */
+		break;
+	default:
+		return (0);   /* instruct pxe core to drop packet*/
+	};
+
+	if (icmphdr->type == PXE_ICMP_ECHO_REPLY) {
+
+		if ( (reply_number != seq_number) && (icmphdr->code != 0)) {
+#ifdef PXE_DEBUG		
+			printf("pxe_icmp_callback(): seq %d != %d expected\n",
+			    reply_number, seq_number);
+#endif
+			return (0);	/* ignore this packet */
+		}
+		
+		uint16_t	id = (uint16_t)(seq_number*seq_number);
+		if (icmphdr->packet_id != id) {
+			if (echo_flags)
+				printf("pxe_icmp_callback(): skipping id 0x%x, "
+				       "0x%x expected\n", icmphdr->packet_id, id);
+				
+			return (0);
+		}
+
+		if (pinging.ip == iphdr->src_ip) {
+
+			if (echo_flags) {
+				printf("pxe_ping(): echo reply from %d.%d.%d.%d,"
+				       " seq=%ld ",
+				       pinging.octet[0], pinging.octet[1],
+				       pinging.octet[2], pinging.octet[3],
+				       seq_number);
+			}
+			
+			/* notify pxe_ping() code that we received reply */
+			last_accepted = seq_number;
+		}
+			    
+		return (0);
+	}
+
+	/* all we need now is echo reply */
+
+	/* using buffer of recieved packet to avoid additional
+	 * memory copy operations */
+
+	reply_iphdr = (PXE_IP_HDR *)pack->data;
+	reply_icmphdr = (PXE_ICMP_HDR *)(pack->data + iphdr_len);
+
+	reply_icmphdr->type = PXE_ICMP_ECHO_REPLY;
+	reply_icmphdr->checksum = 0;
+	reply_icmphdr->checksum =
+	    ~pxe_ip_checksum(reply_icmphdr, sizeof(PXE_ICMP_HDR) + data_size);
+	
+	PXE_IPADDR addr;
+	addr.ip = iphdr->src_ip;
+	
+	if (!pxe_ip_send(pack->data, &addr, PXE_ICMP_PROTOCOL,
+		pack->data_size) && echo_flags)
+	{
+		printf("pxe_ping(): failed to send echo reply.\n");
+	}
+
+	return (0);	/* drop it, we don't need this packet more.
+			 * this is a little bit ugly, may be
+			 * using of more return codes will be more flexible
+			 */
+}
+
+/* pxe_icmp_init() - register ICMP protocol in pxe_core protocols table
+ * in:
+ *	none
+ * out:
+ *	always 1. TODO: think about making this function void
+ */
+int
+pxe_icmp_init()
+{
+	/* register protocol in pxe_core protocols table. */
+	pxe_core_register(PXE_ICMP_PROTOCOL, pxe_icmp_callback);
+
+	return (1);
+}
+
+/* pxe_ping() - pings choosed ip with 32 bytes of data packets
+ * in:
+ *	ip	- ip to send echo requests
+ *	count	- count of requests
+ *	flags	- 0 to hide output, 1 to show
+ * out:
+ *	number of successfull pings
+ */
+int
+pxe_ping(const PXE_IPADDR *ip, int count, int flags)
+{
+
+	seq_number = 0;
+	last_accepted = 0xffff;
+	echo_flags = flags;
+	
+	/* creating data storage for packet */
+	uint8_t		data[sizeof(PXE_IP_HDR) + sizeof(PXE_ICMP_HDR) + 32];
+	
+	size_t		pack_size =
+			    sizeof(PXE_IP_HDR) + sizeof(PXE_ICMP_HDR) + 32;
+	PXE_IP_HDR	*iphdr = NULL;
+	PXE_ICMP_HDR	*icmphdr = NULL;
+	uint32_t	wait_time = 0;
+	int		scount = 0;
+
+	if (flags)
+		printf("pxe_ping(): pinging %s, 32 bytes\n", inet_ntoa(ip->ip));
+	
+	pinging.ip = ip->ip;
+
+	iphdr = (PXE_IP_HDR *)data;
+	icmphdr = (PXE_ICMP_HDR *)(data + sizeof(PXE_IP_HDR));
+
+	/* base icmp header side */
+	icmphdr->type = PXE_ICMP_ECHO_REQUEST;
+	icmphdr->code = 0;
+
+	while (seq_number < count) {
+
+		++seq_number;
+		
+		icmphdr->seq_num = htons(seq_number);
+		/* is this good idea? */
+		icmphdr->packet_id = (uint16_t)(seq_number*seq_number); 
+
+		/* recalc for every packet */
+		icmphdr->checksum = 0;
+		icmphdr->checksum =
+		    ~(pxe_ip_checksum(icmphdr, sizeof(PXE_ICMP_HDR) + 32));
+
+	    	if (!pxe_ip_send(data, ip, PXE_ICMP_PROTOCOL, pack_size) &&
+		    echo_flags)
+		{
+			printf("pxe_ping(): failed to send echo reply.\n");
+		}	
+
+		/* echo reply waiting */
+		wait_time = 0;
+		
+		while (wait_time < PXE_ICMP_TIMEOUT) {
+			
+			twiddle();
+			wait_time += 10;
+			
+			if (!pxe_core_recv_packets())
+				delay(10000);
+			
+			if (last_accepted == seq_number) {
+
+				if (flags)
+					printf("< %d ms\n", wait_time);
+
+				++scount;
+				break;
+			}
+		}
+
+		if ( (last_accepted != seq_number) && flags)
+			printf("ping timeout.\n");
+		
+		/* wait a little, to avoid ICMP flood */
+		delay(500000);
+	}
+
+	pinging.ip = 0;
+	echo_flags = 0;
+	
+	return (scount);
+}
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_icmp.h sys/boot/i386/pxe_ng/pxe_icmp.h
--- sys/boot/i386/pxe_ng/pxe_icmp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_icmp.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,99 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_ICMP_H_INCLUDED
+#define PXE_ICMP_H_INCLUDED
+
+/* ICMP related code
+ * reference: RFC792
+ */
+ 
+#include <stdint.h>
+
+#include "pxe_ip.h"
+
+/* ICMP protocol number in IP stack */
+#define PXE_ICMP_PROTOCOL	0x01
+/* ICMP header */
+typedef struct pxe_icmp_hdr {
+    uint8_t	type;		/* type of ICMP  packet */
+    uint8_t	code;		/* code, used to identify session */
+    uint16_t	checksum;	/* ICMP header checksum */
+    uint16_t	packet_id;	/* for echo */
+    uint16_t	seq_num;	/* for echo */
+} __packed PXE_ICMP_HDR;
+
+/* timeout in milliseconds */
+#define PXE_ICMP_TIMEOUT	5000
+
+/* pxe_ping - send icmp echo request packets to host
+ *    in:
+ *       ip      - host ip address
+ *       count   - packets to send
+ *	 flags	 - 1 echo ping information to screen
+ *   out:
+ *       successfull recieved echo's count
+ */
+int pxe_ping(const PXE_IPADDR *ip, int count, int flags);
+
+/* pxe_icmp_init - inits icmp protocol
+ *    in:
+ *       none
+ *   out:
+ *       positive    - if successful
+ *       0           - failed
+ */
+int pxe_icmp_init();
+
+#define PXE_ICMP_ECHO_REPLY         0
+#define PXE_ICMP_DEST_UNREACHABLE   3
+#define PXE_ICMP_REDIRECT_MESSAGE   5
+#define PXE_ICMP_ECHO_REQUEST       8
+
+#define PXE_ICMP_ALT_HOST_ADAPTER   6
+#define PXE_ICMP_SOURCE_QUENCH      4
+
+
+/*  other packet types
+ *    9 - Router Advertisement
+ *   10 - Router Solicitation
+ *   11 - Time Exceeded
+ *   12 - Parameter Problem
+ *   13 - Timestamp
+ *   14 - Timestamp Reply
+ *   15 - Information Request
+ *   16 - Information Reply
+ *   17 - Address Mask Request
+ *   18 - Address Mask Reply
+ *   30 - Traceroute
+ *   31 - Datagram Conversion Error
+ *   32 - Mobile Host Redirect
+ *   35 - Mobile Registration Request
+ *   36 - Mobile Registration Reply
+ *   38 - Domain Name Reply
+ */
+#endif // PXE_ICMP_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_ip.c sys/boot/i386/pxe_ng/pxe_ip.c
--- sys/boot/i386/pxe_ng/pxe_ip.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_ip.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,423 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <stand.h>
+
+#include "pxe_core.h"
+#include "pxe_ip.h"
+#ifdef PXE_MORE
+#include "pxe_icmp.h"
+#endif
+
+/* routing table */
+static PXE_IP_ROUTE_ENTRY	route_table[PXE_MAX_ROUTES];
+/* total count of routes in table */
+static int			all_routes = 0;
+/* id of packets */
+static uint16_t 		packet_id = 1;
+
+/* pxe_ip_route() - init default routes
+ * in:
+ *	def_gw	- default gateway ip
+ * out:
+ *	none
+ */
+void
+pxe_ip_route_init(const PXE_IPADDR *def_gw)
+{
+
+        if (all_routes)	/* already inited */
+		return;
+		
+	/* add default gw */
+	pxe_ip_route_default(def_gw);
+	all_routes += 1;
+
+	/* if using libstand, set network route in pxe_dhcp_query() */
+#ifndef PXE_BOOT_USE_LIBSTAND
+	const PXE_IPADDR* 	myip = pxe_get_ip(PXE_IP_MY);
+	
+	/* make route for local network */
+	const PXE_IPADDR	*netmask = pxe_get_ip(PXE_IP_NETMASK);
+	uint32_t		mask = netmask->ip;
+	
+	if (mask == 0)	/* mask isn't set via DHCP/BOOTP, setting it manually */
+		mask = pxe_ip_get_netmask(myip);
+	
+	if (mask == 0) {
+		printf("pxe_ip_route_init(): my ip is class D or class E,"
+		       " don't know how understand this.\n");
+		return;
+	}
+	
+	pxe_ip_route_add(myip, mask, NULL);
+#endif
+}
+
+/* pxe_ip_get_netmask() - returns class based mask for provided ip.
+ * in:
+ *	ip - ip address, from which network class is extracted 
+ * out:
+ *	0	- failed
+ *	not 0	- network mask
+ */
+uint32_t
+pxe_ip_get_netmask(const PXE_IPADDR *addr)
+{
+	uint8_t		net_class = ((addr->ip) & 0x000000F0) >> 4;
+	
+	if ( (net_class & 0x0c) == 0x0c)	/* class C */
+		return (0x00ffffff);
+	else if ((net_class & 0x08) == 0x08)	/* class B */
+	        return (0x0000ffff);
+	else if ((net_class & 0x08) == 0x00)	/* class A */
+	        return (0x000000ff);
+	
+	/* D & E classes are not supported yet... */
+	return (0);
+}
+
+/* pxe_ip_route_add() - adds one more route to routing table
+ * in:
+ *	net	- network to route to
+ *	mask	- network mask
+ *	gw	- gateway for this network
+ * out:
+ *	0	- failed to add route
+ *	1	- success
+ */
+int
+pxe_ip_route_add(const PXE_IPADDR *net, uint32_t mask, const PXE_IPADDR *gw)
+{
+
+	printf("pxe_ip_route_add(): adding net %s mask %8x gw ",
+	    inet_ntoa(net->ip), ntohl(mask));
+	
+	if (gw && gw->ip)
+	    printf("%s\n", inet_ntoa(gw->ip));
+	else
+	    printf("pxenet0\n");
+	
+	if (all_routes == PXE_MAX_ROUTES) {
+		printf("pxe_ip_route_add(): failed, routing table is full.\n");
+		return (0);
+	}
+
+#ifdef PXE_MORE
+	if ( (gw!=NULL) && (gw->ip) && (pxe_ping(gw, 3, 0) == 0) ) {
+		printf("pxe_ip_route_add(): failed, gateway is unreachable.\n");
+		return (0);
+	}
+#endif	
+        route_table[all_routes].net.ip = (net->ip & mask);
+	route_table[all_routes].mask = mask;
+	route_table[all_routes].gw.ip = (gw != NULL) ? gw->ip : 0;
+	
+	++all_routes;
+	
+	return (1);
+}
+
+#ifdef PXE_MORE
+/* pxe_ip_route_del() - removes route from routing table
+ * in:
+ *	net	- network to route to
+ *	mask	- network mask
+ *	gw	- gateway for this network
+ * out:
+ *	0	- failed to remove (e.g. no such route found)
+ *	1	- success
+ */
+int
+pxe_ip_route_del(const PXE_IPADDR *net, uint32_t mask, const PXE_IPADDR *gw)
+{
+	int route_index = 1;
+	
+	printf("pxe_ip_route_add(): deleting net %s mask %8x gw",
+	    inet_ntoa(net->ip), htonl(mask));
+	    
+	printf("%s\n", inet_ntoa(gw->ip));
+	
+	for ( ; route_index < all_routes; ++route_index) {
+	        
+		if ((route_table[route_index].net.ip == net->ip) &&
+	    	    (route_table[route_index].gw.ip == gw->ip) &&
+		    (route_table[route_index].mask == mask)) 
+		{
+			--all_routes;    		
+			
+			if (route_index == all_routes)
+				return (1);
+			
+			/* shift routes */
+			pxe_memcpy(&route_table[route_index + 1],
+				    &route_table[route_index],
+				    sizeof(PXE_IP_ROUTE_ENTRY) *
+				    (all_routes - route_index));
+			
+			return (1);
+		}
+
+	}
+	
+	printf("pxe_ip_route_del(): there is no such route.\n");
+	return (0);
+}
+#endif /* PXE_MORE */
+
+/* pxe_ip_route_default() - sets default gateway
+ * in:
+ *	gw - ip address of default gateway
+ * out:
+ *	0	- failed (e.g. gateway is unreachable for pings)
+ *	1	- success
+ */
+int
+pxe_ip_route_default(const PXE_IPADDR *gw)
+{
+
+	printf("pxe_ip_route_default(): setting default gateway %s\n",
+	    inet_ntoa(gw->ip));
+	
+#ifdef PXE_MORE
+	/* don't check if there are no any entries */
+	if (all_routes && (pxe_ping(gw, 3, 0) == 0) ) {
+		printf("pxe_ip_route_add(): failed, gateway is unreachable.\n");
+		return (0);
+	}
+#endif	
+        route_table[0].net.ip = 0;
+	route_table[0].mask = 0;
+	route_table[0].gw.ip = gw->ip;
+	
+	return (1);
+}
+
+/* pxe_ip_checksum() -  calculates 16bit checksum of 16bit words
+ * in:
+ *	data - pointer to buffer to calc checksum for
+ *	size - size of buffer
+ * out:
+ *	checksum
+ */
+uint16_t
+pxe_ip_checksum(const void *data, size_t size)
+{
+	const uint8_t   *cur = data;
+	uint32_t        sum = 0;
+	uint32_t        ind = 0;
+
+	for (; ind < size; ++ind, ++cur) {
+		uint32_t byte = (*cur);
+
+		if (ind & 1) /* odd */
+			byte <<= 8;
+
+		sum += byte;
+
+		if (sum & 0xF0000) /* need carry out */
+			sum -= 0xFFFF;
+	}
+
+	return (uint16_t)( (sum) & 0x0000FFFF);
+}
+
+#ifdef PXE_MORE
+/* pxe_ip_route_stat() - shows current routes
+ * in:
+ *	none
+ * out:
+ *	none
+ */
+void
+pxe_ip_route_stat()
+{
+	int index = 0;
+	
+	printf("Destination\t\tGateway\t\tMAC\n");
+	for ( ; index < all_routes; ++index) {
+
+        	printf("%s/%x\t\t",
+		    inet_ntoa(route_table[index].net.ip),
+		    ntohl(route_table[index].mask));
+	    
+		if (route_table[index].gw.ip == 0)
+		        printf("pxenet0");
+		else {
+		        printf("%s\t\t",
+			    inet_ntoa(route_table[index].gw.ip));
+			
+			uint8_t *mac =
+			    (uint8_t *)pxe_arp_ip4mac(&route_table[index].gw);
+
+			if (mac != NULL)
+				printf("%6D", mac, ":");
+		}
+		printf("\n");
+	}
+}
+#endif /* PXE_MORE */
+
+/* pxe_create_ip_hdr() - creates IP header for data,
+ *			placing header in this buffer
+ * in:
+ *	data	- buffer with data in which header will be created
+ *	dst_ip	- destination IP address
+ *	protocol- IP protocol (e.g. UDP)
+ *	size	- size of buffer
+ *	opts_size - size of IP header options. Currently unused, set 0.
+ * out:
+ *	none
+ */
+void
+pxe_create_ip_hdr(void* data, const PXE_IPADDR *dst, uint8_t protocol,
+		  uint16_t size, uint16_t opts_size)
+{
+	PXE_IP_HDR *iphdr = (PXE_IP_HDR *)data;
+	const PXE_IPADDR *addr = pxe_get_ip(PXE_IP_MY);
+
+	iphdr->checksum = 0;
+	iphdr->length = htons(size);
+	iphdr->protocol = protocol;
+	iphdr->checksum = 0;
+
+	/* data_off - offset of fragment, need to think about renaming. */
+	iphdr->data_off = 0;
+	iphdr->dst_ip = dst->ip;
+	iphdr->id = htons(++packet_id);
+	iphdr->tos = 0;
+	iphdr->src_ip = addr->ip;
+	iphdr->ttl = 64;
+
+	/* 0x45 [ver_ihl] = 0x4 << 4 [ip version] |
+         *                  0x5 [header length = 20 bytes, no opts]
+         */
+	iphdr->ver_ihl = 0x45;
+	iphdr->ver_ihl += (opts_size >> 2);
+
+	iphdr->checksum =
+	    ~pxe_ip_checksum(data, sizeof(PXE_IP_HDR) + opts_size);
+}
+
+/* pxe_ip_route_find() - searches gateway to destination 
+ * in:
+ *	dst	- destination IP address
+ * out:
+ *	dst	- if there is no gateway, or dst_ip directly accessible
+ *	otherwise  - gateway IP address
+ */
+const PXE_IPADDR *
+pxe_ip_route_find(const PXE_IPADDR *dst)
+{
+        int index = 1;	/* route 0 - default gateway */
+	
+	/* if there are no routes, try to send directly */
+	if (all_routes == 0)
+		return (dst);
+
+	PXE_IP_ROUTE_ENTRY	*route = &route_table[1];
+    
+	for ( ; index < all_routes; ++index) {
+    
+		if ( (dst->ip & route->mask) == route->net.ip ) {
+			/* found route */
+#ifdef PXE_IP_DEBUG_HELL
+			printf("pxe_ip_route_find(): route 0x%x\n",
+			    (route->gw.ip == 0) ? dst : &route->gw);
+#endif		    
+			/* gateway == 0 only for local network */
+			return (route->gw.ip == 0) ? dst : &route->gw;
+		}
+	}
+	
+	/* return default gateway */
+	return &route_table[0].gw;
+}
+
+/* pxe_ip_send() - transmits packet provided destination address,
+ *		 using routing table
+ * in:
+ *	data	- buffer to transmit
+ *	dst_ip	- destination IP address
+ *	protocol- IP stack protocol (e.g. UDP)
+ *	size	- size of data buffer
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_ip_send(void *data, const PXE_IPADDR *dst, uint8_t protocol, uint16_t size)
+{
+	PXE_PACKET	pack_out;
+	int		status = 0;
+	
+	pack_out.data = data;
+	pack_out.data_size = size;
+	
+	/* creating ip header */
+	pxe_create_ip_hdr(pack_out.data, dst, protocol, size, 0);
+	 
+	/* setting pxe_core packet parameters */
+        pack_out.flags = (dst->ip != PXE_IP_BCAST) ? PXE_SINGLE : PXE_BCAST;
+        pack_out.protocol = PXE_PROTOCOL_IP;
+	
+	/* find gateway or direct MAC */
+	const PXE_IPADDR *ip_to_send = dst;
+
+	if (pack_out.flags != PXE_BCAST) {
+		ip_to_send = pxe_ip_route_find(dst);
+	        pack_out.dest_mac = pxe_arp_ip4mac(ip_to_send);
+	} else {
+		pack_out.dest_mac = NULL;
+	}
+	
+#ifdef PXE_IP_DEBUG_HELL
+	printf("pxe_ip_send(): %d proto, %s (%6D), %s.\n", protocol,
+	    inet_ntoa(ip_to_send->ip),
+	    pack_out.dest_mac != NULL ? pack_out.dest_mac : "\0\0\0\0\0\0", ":",
+	    pack_out.flags == PXE_SINGLE ? "single" : "bcast");
+#endif	
+
+        if ( (pack_out.flags != PXE_BCAST) && (pack_out.dest_mac == NULL) ) {
+		/* MAC is not found for destination ip or gateway */
+#ifdef PXE_IP_DEBUG
+		printf("pxe_ip_send(): cannot send ip packet to %s, ",
+			inet_ntoa(dst->ip));
+			
+		printf("MAC is unknown for %s\n", inet_ntoa(ip_to_send->ip));
+#endif
+        } else  {
+                if (!pxe_core_transmit(&pack_out)) {
+#ifdef PXE_IP_DEBUG
+                        printf("pxe_ip_send(): failed to send packet.\n");
+#endif			
+	        } else
+			status = 1;
+        }
+
+	return (status);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_ip.h sys/boot/i386/pxe_ng/pxe_ip.h
--- sys/boot/i386/pxe_ng/pxe_ip.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_ip.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,117 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_IP_H_INCLUDED
+#define PXE_IP_H_INCLUDED
+
+/*
+ * IP related declarations
+ * Reference: RFC791
+ */
+ 
+#include <stdint.h>
+#include <stddef.h>
+
+#include "libi386/pxe.h"
+
+/* IPv4 header */
+typedef struct pxe_ip_hdr {
+
+        uint8_t     ver_ihl;        /* version & IHL (size / 4 octets)*/
+	uint8_t     tos;            /* type of service */
+        uint16_t    length;         /* packet total length */
+	uint16_t    id;             /* packet id */
+        uint16_t    data_off;       /* this frame data offset */
+	uint8_t     ttl;            /* time to live */
+        uint8_t     protocol;       /* protocol */
+	uint16_t    checksum;	/* header checksum */
+        uint32_t    src_ip;         /* source ip address */
+	uint32_t    dst_ip;         /* destination ip address */
+} __packed  PXE_IP_HDR;
+
+/* pseudo header, used in checksum calculation for UDP and TCP */
+typedef struct pxe_ip4_pseudo_hdr {
+
+        uint32_t    src_ip;     /* source ip */
+        uint32_t    dst_ip;     /* destination ip */
+        uint8_t     zero;       /* filled by zero */
+        uint8_t     proto;      /* protocol */
+        uint16_t    length;     /* length (protocol header + data) */
+} __packed  PXE_IP4_PSEUDO_HDR;
+					
+/* IPv4 address */
+typedef struct pxe_ipaddr {
+        union {
+	        uint32_t ip;
+	        uint8_t  octet[4];
+        };
+} __packed PXE_IPADDR;
+
+/* often used here broadcast ip */
+#define PXE_IP_BCAST	0xffffffff
+/* maximum route table size */
+#define	PXE_MAX_ROUTES	4
+
+/* routing related structure */
+typedef struct pxe_ip_route_entry {
+	PXE_IPADDR	net;	/* network address */
+	uint32_t	mask;	/* network mask */
+	PXE_IPADDR	gw;	/* gateway to this network */
+} PXE_IP_ROUTE_ENTRY;
+
+/* calculates checksum */
+uint16_t pxe_ip_checksum(const void *data, size_t size);
+
+/* fills ip header data */
+void pxe_create_ip_hdr(void *data, const PXE_IPADDR *dst, uint8_t protocol,
+	uint16_t size, uint16_t opts_size);
+
+/* inits routing table */
+void pxe_ip_route_init(const PXE_IPADDR *def_gw);
+
+/* adds route to routing table */
+int pxe_ip_route_add(const PXE_IPADDR *net, uint32_t mask,
+	const PXE_IPADDR *gw);
+
+/* dels route from routing table */
+int pxe_ip_route_del(const PXE_IPADDR *net, uint32_t mask,
+	const PXE_IPADDR *gw);
+
+/* returns class based netmask for ip */
+uint32_t pxe_ip_get_netmask(const PXE_IPADDR *ip);
+
+/* adds default gateway */
+int pxe_ip_route_default(const PXE_IPADDR *gw);
+
+/* sends ip packet */
+int pxe_ip_send(void *data, const PXE_IPADDR *dst, uint8_t protocol,
+	uint16_t size);
+
+/* show route table */
+void pxe_ip_route_stat();
+
+#endif // PXE_IP_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_ip6.h sys/boot/i386/pxe_ng/pxe_ip6.h
--- sys/boot/i386/pxe_ng/pxe_ip6.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_ip6.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,75 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#ifndef PXE_IP6_H_INCLUDED
+#define PXE_IP6_H_INCLUDED
+
+/*
+ * IP6 related declarations
+ */
+ 
+#include <stdint.h>
+#include <stddef.h>
+
+#include "libi386/pxe.h"
+
+/* IPv6 header */
+typedef struct pxe_ip6_hdr {
+	uint32_t   label;		/* version (0-3), traffic class (4-11),
+					   and label (12-31) */
+	uint16_t   use_size;		/* data size */
+	uint8_t	   next_hdr;		/* next header */
+	uint8_t	   hops;		/* hop count */
+	uint8_t    src_ip[16];		/* source ip6 address */
+	uint8_t    dst_ip[16];		/* destination ip6 address */
+} __packed  PXE_IP_HDR;
+
+/* IPv6 address */
+typedef struct pxe_ipaddr {
+	        uint8_t  octet[16];
+} __packed PXE_IPADDR;
+
+/* often used here broadcast ip */
+#define PXE_IP_BCAST	0xffffffff
+/* maximum route table size */
+#define	PXE_MAX_ROUTES	4
+
+/* routing related structure */
+typedef struct pxe_ip6_route_entry {
+	PXE_IPADDR	net;	/* network address */
+	uint32_t	mask;	/* network mask in ::123/40 format mask == 40 */
+	PXE_IPADDR	gw;	/* gateway to this network */
+} PXE_IP_ROUTE_ENTRY;
+
+/* fills ipv6 header data */
+void pxe_create_ip6_hdr(void *data, const PXE_IPADDR *dst, uint8_t proto,
+    uint16_t size, uint16_t opts);
+
+/* sends ipv6 packet */
+int pxe_ip6_send(void *data, const PXE_IPADDR *dst, uint8_t proto, uint16_t size);
+
+#endif // PXE_IP6_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_isr.S sys/boot/i386/pxe_ng/pxe_isr.S
--- sys/boot/i386/pxe_ng/pxe_isr.S	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_isr.S	2009-03-02 20:16:33.000000000 -0500
@@ -0,0 +1,455 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+/*  ISR, ISR installer, PXE API calling, etc.
+ *  references: Intel PXE 2.1 specification, PXE SDK
+ *              pxe.c
+ */ 
+		.globl  __pxe_isr_occured
+		.globl	__pxe_nic_irq
+		.globl	__pxe_entry_off, __pxe_entry_seg
+		.globl	__pxe_entry_off2, __pxe_entry_seg2		
+		.globl  __pxe_call
+		.globl  __isr_install
+		.globl  __isr_remove
+		.globl	__pxe_isr
+		.globl	__chained_irq_off
+		.globl	__chained_irq_seg
+		.globl	__mask_irq
+		.globl	__mem_copy
+	
+		.code16
+		.p2align 4,0x90
+						# s_PXENV_UNDI_ISR start, look pxe.h
+		.set UISR_STATUS,0x00           # s_PXENV_UNDI_ISR Status
+		.set UISR_FUNC_FLAG,0x02	# s_PXENV_UNDI_ISR FuncFlag
+		.set UISR_BUFFER_LEN,0x04	# s_PXENV_UNDI_ISR BufferLength
+		.set UISR_FRAME_LEN,0x06	# s_PXENV_UNDI_ISR FrameLength
+		.set UISR_HEADER_LEN,0x08	# s_PXENV_UNDI_ISR FrameHeaderLength
+		.set UISR_FRAME_OFFSET,0x10	# s_PXENV_UNDI_ISR Frame
+		.set UISR_FRAME_SEG,0x12	# s_PXENV_UNDI_ISR Frame
+		.set UISR_PROTO_TYPE,0x14	# s_PXENV_UNDI_ISR ProtType
+		.set UISR_PACKET_TYPE,0x15	# s_PXENV_UNDI_ISR PktType
+						# s_PXENV_UNIDI_ISR end
+		.set PXENV_UNDI_ISR_IN_START,0x1
+
+		.set PXENV_UNDI_ISR_OUT_OURS,0x0
+		.set PXENV_UNDI_ISR_OUT_NOT_OUTS,0x1
+
+		.set PXENV_UNDI_ISR,0x0014	# PXE_UNDI_ISR function
+
+		/* interrupt registers */
+		.set I8259_EOI,0x20    		 # EOI
+		.set I8259_EOI_REG,0x20		 # Interrupt Control Register
+		.set I8259_AT_INTR_CTRL_REG,0xA0 # AT Interrupt Control Register
+		.set I8259_PC_INTR_MASK_REG,0x21 # PC Interrupt Mask Register
+		.set I8259_AT_INTR_MASK_REG,0xA1 # AT Interrupt Mask Register
+
+		/* offsets from data_start to needed variables*/
+		.set CHAINED_OFF, 0x2		# to __chained_irq_off
+		.set ISR_OFF, 0x8		# to s_pxenv_undi_isr
+		.set NIC_IRQ_OFF, 0x6		# to __pxe_nic_irq
+		.set USER_MEM, 0xa000		# start of user memory
+#
+data_start:
+__pxe_isr_occured:	.word   0x0000		# flagged if isr occured
+__chained_irq_off:	.word	0x0000		# original ISR handler offset
+__chained_irq_seg:	.word	0x0000		# original ISR handler segment
+__pxe_nic_irq:		.word   0x0000		# NIC irq number	
+s_pxenv_undi_isr:	.word	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0	
+
+/*
+ * Adopted from libi386/pxetramp.S
+ * pxe_call
+ * in:
+ *	DX - segment of data structure, used by PXE
+ *	AX - offset
+ *	BX - PXE function number
+ * out:
+ *	AX - 0, if call was successfull
+ *	   - not 0, in other case
+ */
+__pxe_call:	push %dx			# seg
+		push %ax			# off
+		push %bx			# uint16_t func no
+		.byte   0x9a			# far call
+__pxe_entry_off:
+		.word   0x0000			# PXE API entry point offset
+__pxe_entry_seg:
+		.word   0x0000			# PXE API entry point segment
+		add $6, %sp			# restore stack
+		.byte	0xcb
+
+/*
+ * __pxe_isr() - handles interrupt, checks is interrupt ours
+ *		and updates __pxe_isr_occured if needed
+ * in:
+ *	none
+ * out:
+ *	none
+ */
+__pxe_isr:	cli				# no interrupts
+		pushw	%ds			# saving all affected registers
+		pushl	%eax			# 
+		pushl	%edi			#
+
+        	movl	$data_start, %edi	# data_start is starting address
+		addl	$USER_MEM, %edi		# of all our data
+		movl	%edi, %eax
+		shrl	$4, %eax		# calc segment
+		movw	%ax, %ds		#  our data segment
+		andl	$0xf, %edi		# calc offset
+						# %ds:%di - address of start_data
+		
+		pushw	%di			# saving initial offset
+
+/*
+ * initing s_pxenv_undi_isr struct
+ */		
+		addw	$ISR_OFF, %di		# setting to s_pxenv_undi_isr
+		movw	$0x0, %ds:UISR_STATUS(%di)	# status member = 0
+						# starting interrupt verification
+							
+		movw	$PXENV_UNDI_ISR_IN_START, %ds:UISR_FUNC_FLAG(%di)
+		
+		pushw	%ds			# seg:off to s_pxenv_undi_isr
+		pushw	%di
+		pushw	$PXENV_UNDI_ISR		# starting handling (_IN_START)
+
+		.byte   0x9a			# far call to PXE entry
+__pxe_entry_off2:
+		.word   0x0000			# PXE API entry point offset
+__pxe_entry_seg2:
+		.word   0x0000			# PXE API entry point segment
+
+		add	$6, %sp			# restore stack		
+
+		cmpw	$0, %ax			# is ok?
+		jne	pxe_isr.not_our		#  nope
+						# getting result func flag
+		movw	%ds:UISR_FUNC_FLAG(%di), %ax	
+		popw	%di			# restore offset to data_start
+/*
+ * if interrupt not ours - just return 
+ */		
+		cmpw	$PXENV_UNDI_ISR_OUT_OURS, %ax	# is interrupt ours?
+		jne	pxe_isr.not_our			#  no
+
+#		addw	$0x0, %di		# offset of __pxe_isr_occured
+		movw 	$0x1, %ds:(%di)		# flagging it
+/*
+ * sending EOI to appropriate NIC.
+ */
+		pushw	%dx
+		movw	%ds:NIC_IRQ_OFF(%di), %ax	# getting irq number
+ 		movb	%al, %dl			# moving it to dl
+ 		movb	$I8259_EOI, %al			# set EOI control word 
+ 
+ 		cmpb	$0x8, %dl			# is IRQ8-IRQ15?
+ 		jb	pxe_isr.master			#  no, use pic1
+ 
+ 		movw	$I8259_AT_INTR_CTRL_REG, %dx	# send EOI to PIC2
+ 		outb	%al, %dx			#
+ 
+pxe_isr.master: movw	$I8259_EOI_REG, %dx		# send EOI to master
+ 		outb	%al, %dx			#
+ 	
+		popw	%dx
+
+pxe_isr.exit:	popl	%edi				# restore affected registers
+		popl	%eax				#
+		popw	%ds				#
+
+		sti
+		iret
+
+pxe_isr.not_our:
+/*
+ * checking, if we have chained handler
+ */
+		je	pxe_isr.2
+		/* ignore chained handler */
+		popw	%di			# restore offset to data_start
+		addw	$CHAINED_OFF, %di	# set di for __chained_irq_off
+		
+		movw	%ds:(%di), %ax		# get it value
+		cmpw	$0, %ax			# have chained interrupt handler?
+		je	pxe_isr.2		#  no, we think - dont
+
+		sti				# enable interrupts
+		pushf				# push flags
+
+/*
+ *  here is calling of chained interrupt handler.
+ */
+		pushw	%es			# store es register
+		pushw	%bx
+		
+		movw	%ax, %bx
+ 		movw	%ds:2(%di), %es		# getting segment
+ 		call	*%es:(%bx)		# call chained handler
+		
+		popw	%bx			# restore registers
+ 		popw	%es			#
+ 
+		popf				# restore flags word
+
+
+/* from Intel PXE SDK:
+ * If say "not my interrupt" by passing control to next in handler list, may
+ * end up invoking the BIOS, which will turn off the interrupt at the PIC.
+ * In case this happens, on return from next-handler call, see if must restore.
+ * This only executes when an interrupt is fielded which is not ours to handle.
+ */
+
+/*
+ *  NOTE: need to understand, if it is needed
+ */
+
+/*		pushw	%dx
+		
+ 		movw    $I8259_PC_INTR_MASK_REG, %dx	# use master
+ 		movw    __pxe_nic_irq, %bx
+		cmpb    $0x8, %bl                       # is IRQ8-IRQ15?
+ 		jb      pxe_isr.1                       #  no
+ 		movw    $I8259_AT_INTR_MASK_REG, %dx	# use PIC2
+ 	
+ pxe_isr.1:	movb    save_int_mask, %bl		# get saved mask
+ 		inb     %dx, %al
+ 		notb    %bl
+ 		testb   %bl, %al
+ 		jz      pxe_isr.2
+ 
+ 		notb    %bl
+ 		andb 	%bl, %al
+ 		outb    %al, %dx
+		
+*/
+pxe_isr.2:
+		jmp	pxe_isr.exit
+
+/* _mem_copy() - copies memory block
+ * in:
+ *	EAX - seg:off to source
+ *	EBX - seg:off to destination
+ *	ECX - byte count to copy
+ * out:
+ *	none
+ */
+ __mem_copy:	pushw	%es			# store affected registers
+		pushw	%di			#
+		pushw	%ds			#
+		pushw	%si			#
+		pushf				# store affected by cld flags
+ 
+		cld				# set index increment flag
+
+		movw	%ax, %si		# setting source seg:off
+		shrl	$0x10, %eax		#
+		movw	%ax, %ds		#
+
+		movw	%bx, %di		# setting destination  seg:off
+		shrl	$0x10, %ebx		#
+		movw	%bx, %es		#
+
+		rep	movsb			# copy byte by byte
+				
+		popf				# restore affected registers
+		popw	%si			#
+		popw	%ds			#
+		popw	%di			#
+		popw	%es			#
+		
+		.byte	0xcb
+
+/*
+ * __isr_install() - installs interrupt handler for provided IRQ,
+ *		saves previous ("chained") handler
+ * in:
+ * 	AX - interrupt number (not IRQ)
+ * 	BX - ISR segment
+ * 	DX - ISR offset
+ * out:
+ *	BX - chained ISR segment
+ *      DX - chained ISR offset
+ */
+__isr_install:	
+		cli				# no interrupts
+		pushl   %edi			# saving affected registers
+		pushw	%ds			#
+						# calc interrupt vector address
+		shlw    $2, %ax			# multiply by 4 
+		xorw    %di, %di		# clear di
+		movw    %di, %ds		# setting 0 to data segment
+		movw	%ax, %di                # di offset to interrupt vector
+	    
+		xchgw	%dx, %ds:(%di)		# installing ISR offset
+		xchgw	%bx, %ds:2(%di)		# installing ISR segment
+
+/*
+ *	Masking is not our task
+ *
+ * 		call	mask_int		# masking
+ */
+
+    		popw	%ds			# restore affected registers
+		popl	%edi			#
+		sti				# start interrupts
+		.byte	0xcb			# back to vm86
+
+
+/* __isr_remove() - uninstalls ISR
+ * Adopted from Intel PXE SDK
+ * removes interrupt handler for provided IRQ, restores previous handler
+ * in:
+ * 	AX - interrupt number (not IRQ)
+ *	BX - chained ISE offset
+ * out:
+ *	none
+ */
+__isr_remove:	pushf
+		pushl	%ebx
+		
+		shlw    $2, %bx			# calculating offset of
+						#  interrupt vector
+		xorw    %cx, %cx		# clearing segment register es
+		movw    %cx, %es
+
+		movw	%es:(%bx), %ax		# get offset to current handler
+
+isr_remove.3:	#movl   chained_irq_off, %eax	# getting old chained handler
+		#movl   %eax, %es:(%bx)		# restore it
+
+/*
+ *  Forget about unmasking for now
+ *
+ *		call    unmask_int		# unmasking
+ **/
+
+isr_remove.fin:
+#		movl    $0x0, chained_irq_off
+		popl	%ebx
+		popf
+		clc
+		ret
+		
+		
+/*******************************************************************************/
+
+/* __mask_irq() - masks hardware interrupt
+ * Adopted from Intel PXE SDK
+ *  
+ * in:
+ *   BX - IRQ number
+ *   CX - original mask
+ */
+__mask_irq:	pushw	%dx				# saving registers
+		pushw	%cx
+		pushw	%ax				#  in fact, not useful
+
+		cmpw	$0x7, %bx			# see if this master PIC
+		jbe	mask_irq.master			#  yes, it is PIC1
+
+		movw	$I8259_AT_INTR_MASK_REG, %dx	# setting PIC2 register
+		jmp	mask_irq.1
+
+mask_irq.master:
+		movw	I8259_PC_INTR_MASK_REG, %dx	# setting master PIC
+
+mask_irq.1:	movw	%bx, %cx
+		andw	$0x07, %cx			# mask 0..2 bits
+		movb	$0x1, %bl			# setting cl-th bit
+		shlb	%cl, %bl			# 
+		notb	%bl				# 
+		
+		pushf					# saving FLAGS register
+		cli					# stop interrupts
+		
+		inb	%dx, %al
+		andb	%bl, %al
+
+		nop
+		nop
+			
+		outb	%al, %dx
+		popw	%ax				# popping FLAGS
+
+		testw	$0x200, %ax			# check interrupt flag
+		jz	mask_irq.2			#
+		
+		sti                                     # starting interrupts
+mask_irq.2:
+		popw	%ax
+		popw	%cx
+		popw	%dx
+		
+		.byte	0xcb				# return
+
+/*
+ * Adopted from Intel PXE SDK
+ *  unmasks hardware interrupt
+ */
+#unmask_int:	pushw	%ax				# save all affected
+#		pushw	%cx				#  registers
+#		pushw	%dx				#
+#
+#		movw	__pxe_nic_irq, %bx		# getting irq number		
+#		cmpw	$0x07, %bx			# is it PIC2?
+#		jbe	unmask_int.master		#  no, it is master
+#
+#		subw	$0x08, %bx
+#		mov	$I8259_AT_INTR_MASK_REG, %dx	# slave PIC register
+#		jmp	unmask_int.2
+#
+#unmask_int.master:
+#		mov	$I8259_PC_INTR_MASK_REG, %dx	# master PIC register
+#
+#unmask_int.2:	movw	%bx, %cx
+#		andw	$0x07, %cx			# masking first 3 bits
+#		movb	$0x01, %bl			# 
+#		shlb	%cl, %bl			# shifting 1 bit to left
+#		notb	%bl
+#
+#		movb	%bl, save_int_mask		# saving mask
+#
+#		pushf                                   # saving FLAGS register
+#		cli
+#
+#		inb	%dx, %al			# sending control word
+#		movb	%al, original_mask              # saving mask
+#		andb	%bl, %al			# and it with saved
+#		outb	%al, %dx			# out result
+#
+#		popw	%ax				# popping flags
+#		testw   $0x200, %ax			# IF==1 ?
+#		jz      unmask_int.3			#  yes
+#		sti					# set IF=1
+#
+#unmask_int.3:	popw	%dx                             # restore registers
+#		popw	%cx				# 
+#		popw	%ax                             #
+#		ret
diff -ruN sys/boot/i386/pxe_ng/pxe_isr.h sys/boot/i386/pxe_ng/pxe_isr.h
--- sys/boot/i386/pxe_ng/pxe_isr.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_isr.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,61 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+		 
+#ifndef PXE_ISR_H_INCLUDED
+#define PXE_ISR_H_INCLUDED
+
+/*
+ *  Declarations for functions, defined in pxe_isr.s
+ */
+ 
+#include <stdint.h>
+
+/* 1 - if interrupt occured, 0 - means nothing to do */
+extern uint16_t __pxe_isr_occured;
+/* IRQ number of NIC */
+extern uint16_t __pxe_nic_irq;	
+/* PXE! API entry offset, used in __pxe_call() */
+extern uint16_t __pxe_entry_off;
+/* PXE! API entry segment, used in __pxe_call() */
+extern uint16_t __pxe_entry_seg;
+/* PXE! API entry offset, used in __pxe_isr() */
+extern uint16_t __pxe_entry_off2;
+/* PXE! API entry segment, used in __pxe_isr()  */
+extern uint16_t __pxe_entry_seg2;
+/* chained ISR segment:offset */
+extern uint16_t __chained_irq_seg;
+extern uint16_t __chained_irq_off;
+
+extern void __pxe_call(void);	/* PXE API call */
+extern void __pxe_isr(void);	/* PXE API call */
+
+extern void	__mask_irq(void);	/* masks irq */
+extern void	__isr_install(void);	/* installs handler for interrupt */
+extern void	__isr_remove(void);	/* remove handler, ! not working ! now */
+extern void	__mem_copy(void);	/* copies memory in vm86 mode */
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_mem.c sys/boot/i386/pxe_ng/pxe_mem.c
--- sys/boot/i386/pxe_ng/pxe_mem.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_mem.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,68 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#include <stand.h>
+
+#include "pxe_mem.h"
+
+void *
+pxe_alloc(size_t bsize)
+{
+
+    return malloc(bsize);
+}
+
+void
+pxe_free(void *pmem)
+{
+
+    free(pmem);
+}
+
+int
+pxe_init_mem(void *pool, size_t size)
+{
+
+    /* dummy */
+    return (1);
+}
+
+void
+pxe_memset(void *mblock, int toset, size_t size)
+{
+    if (toset == 0)
+	bzero(mblock, size);
+    else
+        memset(mblock, toset, size);
+}
+
+
+void
+pxe_memcpy(const void *from, void *to, size_t size)
+{
+    bcopy(from, to, size);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_mem.h sys/boot/i386/pxe_ng/pxe_mem.h
--- sys/boot/i386/pxe_ng/pxe_mem.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_mem.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,87 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#ifndef PXE_MEM_H_INCLUDED
+#define PXE_MEM_H_INCLUDED
+
+/*
+ * Contains wrappers to memory routines, needed for allocating
+ * and releasing memory blocks.
+ */
+ 
+#include <stddef.h>
+
+/* pxe_alloc() - allocates memory block of requested size
+ * in:
+ *	bsize - size in bytes of requeseted memory block
+ * out:
+ *	NULL     - failed to allocate
+ *	not NULL - pointer to allocated memory
+ */
+void	*pxe_alloc(size_t bsize);
+
+/* pxe_free() - frees previously allocated memory block
+ * in:
+ *	pmem -  pointer to memory block. Attempt to free unallocated block
+ *               may cause undefined behaviour.
+ * out:
+ *	none
+ */
+void 	pxe_free(void *pmem);
+
+/* pxe_init_mem() - inits internal structures for memory routines
+ * in:
+ *	chunk   -   non NULL pointer to memory address, from which starts pool,
+ *                   used to allocate memory blocks
+ *	size    -   size of provided memory pool
+ * out:
+ *	positive - all is ok
+ *	0        - failed to init structures.
+ */
+int	pxe_init_mem(void *pool, size_t size);
+
+/* pxe_memset() - set specified memory block with given value
+ * in:
+ *	mblock  -   non NULL pointer to memory block
+ *	toset   -   value to set in every byte in memory block
+ *	size    -   size of memory block
+ * out:
+ *	none
+ */
+void 	pxe_memset(void *mblock, int toset, size_t size);
+
+/* pxe_memcpy() - copy memory block
+ * in:
+ *	from    -   non NULL pointer to source memory block
+ *	to      -   non NULL pointer to destination memory block
+ *	size    -   size of memory block
+ * out:
+ *	none
+ */
+void	pxe_memcpy(const void *from, void *to, size_t size);
+
+#endif // PXE_MEM_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_segment.c sys/boot/i386/pxe_ng/pxe_segment.c
--- sys/boot/i386/pxe_ng/pxe_segment.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_segment.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,754 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#include <stand.h>
+
+#include "pxe_buffer.h"
+#include "pxe_segment.h"
+#include "pxe_connection.h"
+#include "pxe_core.h"
+#include "pxe_ip.h"
+#include "pxe_tcp.h"
+
+/* pxe_resend_free() - releases all used by connection structures
+ * in:
+ *	connection	- connection to release data
+ * out:
+ *	none
+ */
+void
+pxe_resend_free(PXE_TCP_CONNECTION *connection)
+{
+ /* In fact we must not do anything here due current resendeng queue
+  * organization(allocating segments in place), memory released in sockets
+  * buffer related code. But in case it'll be redone to be more effective
+  * or just using other segment allocation algorithm - this function may
+  * be needed.
+  */
+	 
+#if defined(PXE_TCP_DEBUG) && defined(PXE_MORE)
+	tcp_resend_stats(connection);
+#endif
+}
+
+/* pxe_resend_init() - initialize buffer map for connection
+ * in:
+ *	connection	- connection to initialize
+ * out:
+ *	none
+ */
+void
+pxe_resend_init(PXE_TCP_CONNECTION *connection)
+{
+	PXE_BUFFER		*buffer = connection->send;
+	PXE_TCP_QUEUED_SEGMENT	*segment = NULL;
+	void			*data = buffer->data;
+
+	int			all_chunks =
+				    PXE_TCP_BLOCK_COUNT * PXE_TCP_CHUNK_COUNT;
+				    
+	int			chunk_index = 0;
+	
+	/* NOTE: may be it's better to define macro for all this values
+	 * and don't calculate all_chunks and chunk_size in runtime
+	 */
+	connection->chunk_size = PXE_DEFAULT_SEND_BUFSIZE / all_chunks;
+	
+	/* marking all chunks in all blocks free */
+	for ( ; chunk_index < all_chunks; ++chunk_index) {
+
+		segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+		segment->status = PXE_SEGMENT_FREE;
+		
+		data += connection->chunk_size;
+	}
+	
+	/* zeroing block map */
+	pxe_memset(connection->buf_blocks, 0, PXE_TCP_BLOCK_COUNT);
+}
+
+/* tcp_segment_alloc() - allocates from send buffer memory for packet,
+ *			including segment data, IP & TCP headers
+ * in:
+ *	connection	- connection, from which send buffer segment is
+ *			allocated
+ *	allocBig	- 1 if need big segment, 0 otherwise
+ * out:
+ *	NULL		- failed to allocate memory chunk(s) for segment
+ *	not NULL	- pointer to segment structure
+ */
+PXE_TCP_QUEUED_SEGMENT *
+tcp_segment_alloc(PXE_TCP_CONNECTION *connection, int allocBig)
+{
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_segment_alloc(): connection 0x%x, big = %d.\n",
+	    connection, allocBig);
+#endif
+	int			block_index = 0;
+	PXE_BUFFER		*buffer = connection->send;
+	uint8_t			*buf_blocks = connection->buf_blocks;
+	void			*data = NULL;
+	PXE_TCP_QUEUED_SEGMENT	*segment = NULL;
+	
+	if (connection->send == NULL)
+		return (NULL);
+	
+	for ( ; block_index < PXE_TCP_BLOCK_COUNT; ++block_index) {
+
+		/* start of block */
+		data = buffer->data +
+		       PXE_TCP_CHUNK_COUNT * block_index * connection->chunk_size;
+		       
+		segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+		
+		/* alloc small packet (alloc chunk)? */
+		if (allocBig == PXE_SEGMENT_SMALL) {
+			/* checking if block is not fully used */
+			if (buf_blocks[block_index] < PXE_TCP_BLOCK_USED) {
+				/* search free chunk in block */
+				int chunk_index = 0;
+				
+				for ( ; chunk_index < PXE_TCP_CHUNK_COUNT; ++chunk_index) {
+					
+					if (segment->status == PXE_SEGMENT_FREE) {
+					
+						segment->status = PXE_SEGMENT_USED;
+						buf_blocks[block_index] += 1;
+						
+						return (segment);
+					}
+					
+					/* next chunk in block */
+					data += connection->chunk_size;
+					segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+				}
+			}
+			
+		} else { /* alloc big one (entire block) */
+
+			if (buf_blocks[block_index] == PXE_TCP_BLOCK_FREE) {
+
+				buf_blocks[block_index] = PXE_TCP_BLOCK_EXCLUSIVE;
+				segment->status = PXE_SEGMENT_USED;
+
+				return (segment);
+			}
+		}
+	} /* block_index for end */
+
+	return (NULL);
+}
+
+/* pxe_segment_free() - releases used by segment chunks
+ * in:
+ *	connection	- connection to release chunks
+ *	block_index	- index of block to which chunk belongs
+ *	segment		- segment to release
+ * out:
+ *	none
+ */
+void
+tcp_segment_free(PXE_TCP_CONNECTION *connection, int block_index,
+		 PXE_TCP_QUEUED_SEGMENT *segment)
+{
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_segment_free(): connection: 0x%x, block: %d, chunk: 0x%x\n",
+	    connection, block_index, segment);
+#endif
+	uint8_t		*block = &connection->buf_blocks[block_index];
+	
+	if (segment->status == PXE_SEGMENT_FREE) /* already released */
+		return;
+	
+	segment->status = PXE_SEGMENT_FREE;
+	
+	/* check if block is exlusively used */
+	if ( *block == PXE_TCP_BLOCK_EXCLUSIVE)
+		*block = PXE_TCP_BLOCK_FREE;
+	else /* update used chunk count */
+		*block -= 1;
+}
+
+/* pxe_resend_check() - checks if need to resend segment
+ * in:
+ *	connection - connection to check resending needs for
+ * out:
+ *	none
+ */
+void
+pxe_resend_check(PXE_TCP_CONNECTION *connection)
+{
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_resend_check(): started, state %d.\n", connection->state);
+#endif
+        PXE_BUFFER              *buffer = connection->send;
+        void                    *data = buffer->data;
+        int                     block_index = 0;
+        PXE_TCP_QUEUED_SEGMENT  *segment = NULL;
+	uint8_t			*buf_blocks = connection->buf_blocks;
+				
+        time_t                  cur_time = pxe_get_secs();
+			
+        for ( ; block_index < PXE_TCP_BLOCK_COUNT; ++block_index) {
+						
+                if (buf_blocks[block_index] == PXE_TCP_BLOCK_FREE)
+                        continue;       /* block is unused */
+
+		/* pointer to head chunk of block */
+		data = buffer->data +
+		       block_index * PXE_TCP_CHUNK_COUNT * connection->chunk_size;
+
+                segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+		
+                /* block is used exclusevely by one "big" packet */
+                if (buf_blocks[block_index] == PXE_TCP_BLOCK_EXCLUSIVE) {
+		
+			if (segment->status != PXE_SEGMENT_SENT)
+				continue;	/* it was not ever sent yet */
+			
+			/* check if it's time to resend */
+                        if (cur_time >= segment->resend_at) {
+#ifdef PXE_TCP_DEBUG_HELL
+				printf("pxe_resend_check(): %lu:%lu "
+				       "resending (next try at: %lu)\n",
+				    segment->resend_at, cur_time,
+				    cur_time +
+				    PXE_RESEND_TIME * (segment->trys + 1));
+#endif				
+				segment->trys += 1;
+								
+				segment->resend_at = cur_time +
+				    PXE_RESEND_TIME * segment->trys;
+				
+				if (segment->trys == PXE_RESEND_TRYS) {
+					/* TODO: need to break connection */
+				}
+				
+				tcp_update_segment(connection, segment);
+                                pxe_tcp_send_segment(connection, segment);
+
+            		}
+                        continue;
+                }
+
+                /* block is dirty, need to check chunks manually  */
+                int chunk_index = 0;
+
+                for ( ; chunk_index < PXE_TCP_CHUNK_COUNT; ++chunk_index) {
+
+                        if (segment->status == PXE_SEGMENT_SENT) {
+				/* check time to resend */
+                                if (cur_time >= segment->resend_at) {
+#ifdef PXE_TCP_DEBUG_HELL
+					printf("pxe_resend_check(): %lu:%lu "
+					       "resending (next try at: %lu)\n",
+					    segment->resend_at, cur_time,
+					    cur_time +
+					    PXE_RESEND_TIME * (segment->trys + 1));
+#endif
+					/* resend later, with more delay 
+					 * with every try */
+					segment->trys += 1;
+					
+					segment->resend_at = cur_time +
+					    PXE_RESEND_TIME * segment->trys;
+
+					if (segment->trys == PXE_RESEND_TRYS) {
+					/* TODO: need to break connection */
+					}
+					
+					tcp_update_segment(connection, segment);
+	                                pxe_tcp_send_segment(connection, segment);
+	                        }
+	                }
+
+                        /* point segment to next chunk */
+			data += connection->chunk_size;
+                        segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+                }
+        } /* block_index for end */
+}
+
+/* pxe_resend_drop_same() - removes from resend queue older segments with same
+ *			sequence number to avoid duplicate resending of same
+ *			ACKs and etc.
+ * in:
+ *	connection	- connection to update segments for
+ *	segment		- segment to check with
+ * out:
+ *	none
+ */
+void
+pxe_resend_drop_same(PXE_TCP_CONNECTION *connection,
+		     PXE_TCP_QUEUED_SEGMENT *new_segment)
+{
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_resend_drop_same(): started.\n");
+#endif
+	if (connection->send == NULL) {
+		printf("pxe_resend_drop_same(): send buffer is NULL.\n");
+		return;
+	}
+	
+	uint32_t		drop_seq = new_segment->seq;
+        PXE_BUFFER              *buffer = connection->send;
+        void                    *data = buffer->data;
+        int                     block_index = 0;
+        PXE_TCP_QUEUED_SEGMENT  *segment = NULL;
+	uint8_t			*buf_blocks = connection->buf_blocks;
+				
+        for ( ; block_index < PXE_TCP_BLOCK_COUNT; ++block_index) {
+		
+	        /* block is used exclusevely by one "big" packet, skip this */
+                if (buf_blocks[block_index] == PXE_TCP_BLOCK_EXCLUSIVE)
+			continue;
+
+                if (buf_blocks[block_index] == PXE_TCP_BLOCK_FREE)
+                        continue;       /* block is unused */
+
+		/* pointer to head chunk of block */
+		data = buffer->data +
+		       block_index * PXE_TCP_CHUNK_COUNT * connection->chunk_size;
+
+                segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+		
+		if (segment == new_segment)
+			continue;
+		
+                /* block is dirty, need to check chunks manually  */
+                int chunk_index = 0;
+
+                for ( ; chunk_index < PXE_TCP_CHUNK_COUNT; ++chunk_index) {
+			/* skip segment if it's new_segment */
+			if (segment == new_segment) 
+				continue;
+				
+                        if ( (segment->status != PXE_SEGMENT_FREE) &&
+			     (segment->seq == drop_seq) )
+			{ /* this segment is updated by new segment */
+#ifdef PXE_TCP_DEBUG_HELL
+				printf("pxe_resend_drop_same(): drop chunk %d#%d.\n",
+				    chunk_index, block_index);
+#endif			
+				tcp_segment_free(connection, block_index,
+				    segment);
+	                }
+
+                        /* point segment to next chunk */
+			data += connection->chunk_size;
+                        segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+                }
+        }	
+}
+
+/* pxe_resend_update() - update segments that were acked
+ * in:
+ *	connection	- connection to update segments for
+ * out:
+ *	none
+ */
+void
+pxe_resend_update(PXE_TCP_CONNECTION *connection)
+{
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("pxe_resend_update(): started.\n");
+#endif
+        PXE_BUFFER              *buffer = connection->send;
+        void                    *data = buffer->data;
+        int                     block_index = 0;
+        PXE_TCP_QUEUED_SEGMENT  *segment = NULL;
+				
+        for ( ; block_index < PXE_TCP_BLOCK_COUNT; ++block_index) {
+						
+                if (connection->buf_blocks[block_index] == PXE_TCP_BLOCK_FREE)
+                        continue;       /* block is unused */
+		
+		/* pointer to head chunk of block */
+		data = buffer->data +
+		       block_index * PXE_TCP_CHUNK_COUNT * connection->chunk_size;
+
+                segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+
+                /* block is used exclusevely by one "big" packet */
+                if (connection->buf_blocks[block_index] == PXE_TCP_BLOCK_EXCLUSIVE) {
+		
+			if (segment->status != PXE_SEGMENT_SENT)
+				continue;	/* it was not ever sent yet */
+
+                        if (connection->una >= segment->seq) {
+				/* segment was acked, release it */
+#ifdef PXE_TCP_DEBUG_HELL
+				printf("pxe_resend_update(): block %d acked.\n",
+				    block_index);
+#endif
+				tcp_segment_free(connection, block_index,
+				    segment);
+            		}
+                        continue;
+                }
+
+                /* block is dirty, need to check chunks manually  */
+                int chunk_index = 0;
+
+                for ( ; chunk_index < PXE_TCP_CHUNK_COUNT; ++chunk_index) {
+
+                        if (segment->status == PXE_SEGMENT_SENT) {
+
+                            if (connection->una >= segment->seq) {
+				/* segment was acked */
+#ifdef PXE_TCP_DEBUG_HELL
+				printf("pxe_resend_update(): chunk %d@%d acked.\n",
+				    chunk_index, block_index);
+#endif
+	                            tcp_segment_free(connection, block_index,
+					segment);
+	                    }
+	                }
+
+                        /* point segment to next chunk */
+			data += connection->chunk_size;
+                        segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+                }
+        }
+}
+
+/* pxe_start_segment() - fills initial data in headers for provided segment
+ * in:
+ *	connection	- connection to update segments for
+ *	segment		- segment to start
+ *	add_options	- 1 if add default options (mss), 0 - don't add anything
+ * out:
+ *	none
+ */
+void
+tcp_start_segment(PXE_TCP_CONNECTION *connection,
+		  PXE_TCP_QUEUED_SEGMENT *segment, int add_options)
+{
+	if (segment == NULL) {
+		printf("tcp_start_segment(): segment = NULL.\n");
+		return;
+	}
+	
+	PXE_TCP_PACKET  *tcp_packet = (PXE_TCP_PACKET  *)(segment + 1);
+		
+	/* reserving 8 bytes for options */
+	uint16_t length = sizeof(PXE_TCP_PACKET);
+	
+	tcp_packet->tcphdr.src_port = htons(connection->src_port);
+	tcp_packet->tcphdr.dst_port = htons(connection->dst_port);
+	tcp_packet->tcphdr.checksum = 0;
+	tcp_packet->tcphdr.sequence = htonl(connection->next_send);
+	tcp_packet->tcphdr.data_off = sizeof(PXE_TCP_HDR);
+	
+	if (add_options == PXE_SEGMENT_OPTS_DEFAULT) {
+		/* reserving 8 bytes for options */
+		length += 8;
+		tcp_packet->tcphdr.data_off += 8;
+		
+		/* pointing to options, leading tcp_header */
+		PXE_TCP_DEFAULT_OPTIONS *options =
+				    (PXE_TCP_DEFAULT_OPTIONS *)(tcp_packet + 1);
+				    
+		pxe_memset(options, 0, sizeof(PXE_TCP_DEFAULT_OPTIONS));
+		
+		options->kind = 2;
+		options->size = 4;
+		options->mss = htons(PXE_TCP_MSS);
+	}
+	
+	tcp_packet->tcphdr.data_off = (tcp_packet->tcphdr.data_off / 4) << 4;
+	tcp_packet->tcphdr.urgent = 0;
+	
+	segment->trys = 0;
+	segment->resend_at = 0;
+	segment->size = length;
+	segment->seq = connection->next_send;
+}
+
+/* pxe_finish_segment() - finishes segmentm calculates checksums and fills
+ *			sequence numbers
+ * in:
+ *	connection	- connection to update segments for
+ *	segment		- segment to start
+ *	tcp_flags	- flags of header (PXE_TCP_...)
+ * out:
+ *	none
+ */
+void
+tcp_finish_segment(PXE_TCP_CONNECTION *connection,
+		   PXE_TCP_QUEUED_SEGMENT *segment, uint8_t tcp_flags)
+{
+	if (segment == NULL) {
+		printf("tcp_finish_segment(): segment = NULL.\n");
+		return;
+	}
+	
+	PXE_TCP_PACKET  *tcp_packet = (PXE_TCP_PACKET  *)(segment + 1);
+		
+	uint16_t length = segment->size - sizeof(PXE_IP_HDR);
+	
+	tcp_packet->tcphdr.ack_next = htonl(connection->next_recv);
+	tcp_packet->tcphdr.flags = tcp_flags;
+												
+	PXE_BUFFER *recv_buffer = connection->recv;
+	
+	/* set window size to free buffer space size,
+	 * or to zero if recv_buffer == NULL
+	 */
+	tcp_packet->tcphdr.window_size = (recv_buffer != NULL) ?
+					 htons(recv_buffer->bufleft) : 0;
+	tcp_packet->tcphdr.checksum = 0;
+	
+	PXE_IP4_PSEUDO_HDR      pseudo_hdr;
+	const PXE_IPADDR	*my = pxe_get_ip(PXE_IP_MY);
+
+        pseudo_hdr.src_ip = my->ip;
+        pseudo_hdr.dst_ip = connection->dst.ip;
+        pseudo_hdr.zero = 0;
+        pseudo_hdr.proto = PXE_TCP_PROTOCOL;
+        pseudo_hdr.length = htons(length);
+					
+       /* adding pseudo header checksum to checksum of tcp header with data
+        * and make it complimentary
+        */
+	uint16_t part1 = pxe_ip_checksum(&pseudo_hdr,
+			    sizeof(PXE_IP4_PSEUDO_HDR));
+			    
+	uint16_t part2 = pxe_ip_checksum(&tcp_packet->tcphdr, length);
+									       
+	uint32_t tmp_sum = ((uint32_t)part1) + ((uint32_t)part2);
+										       
+	if (tmp_sum & 0xf0000)  /* need carry out */
+		tmp_sum -= 0xffff;
+	
+	tcp_packet->tcphdr.checksum = ~((uint16_t)(tmp_sum & 0xffff));
+	
+	/* special case */
+	if (tcp_packet->tcphdr.checksum == 0)
+		tcp_packet->tcphdr.checksum = 0xffff;
+
+	/* setting sequence number next to the segment last byte
+	 * when connection->una become this value we must remove packet
+	 * from resend queue.
+	 */
+	segment->seq += (length - 4 * (tcp_packet->tcphdr.data_off >> 4));
+	
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_finish_segment(): checksum 0x%4x for %d bytes\n",
+	    tcp_packet->tcphdr.checksum, length);
+#endif
+}
+
+/* pxe_update_segment() - updates segment at resending, recalcs checksum
+ *			for updated header
+ * in:
+ *	connection	- connection to update segments for
+ *	segment		- segment to start
+ * out:
+ *	none
+ */
+void
+tcp_update_segment(PXE_TCP_CONNECTION *connection,
+		   PXE_TCP_QUEUED_SEGMENT *segment)
+{
+	if (segment == NULL) {
+		printf("tcp_update_segment(): segment = NULL.\n");
+		return;
+	}
+	
+	PXE_TCP_PACKET  *tcp_packet = (PXE_TCP_PACKET  *)(segment + 1);
+		
+	uint16_t length = segment->size - sizeof(PXE_IP_HDR);
+	
+	tcp_packet->tcphdr.ack_next = htonl(connection->next_recv);
+												
+	PXE_BUFFER *recv_buffer = connection->recv;
+	
+	/* set window size to free buffer space size,
+	 * or to zero if recv_buffer == NULL
+	 */
+	tcp_packet->tcphdr.window_size = (recv_buffer != NULL) ?
+					 htons(recv_buffer->bufleft) : 0;
+	tcp_packet->tcphdr.checksum = 0;
+	
+	PXE_IP4_PSEUDO_HDR      pseudo_hdr;
+	const PXE_IPADDR	*my = pxe_get_ip(PXE_IP_MY);
+	
+        pseudo_hdr.src_ip = my->ip;
+        pseudo_hdr.dst_ip = connection->dst.ip;
+        pseudo_hdr.zero = 0;
+        pseudo_hdr.proto = PXE_TCP_PROTOCOL;
+        pseudo_hdr.length = htons(length);
+					
+       /* adding pseudo header checksum to checksum of tcp header with data
+        * and make it complimentary
+        */
+	uint16_t part1 = pxe_ip_checksum(&pseudo_hdr,
+			    sizeof(PXE_IP4_PSEUDO_HDR));
+			    
+	uint16_t part2 = pxe_ip_checksum(&tcp_packet->tcphdr, length);
+									       
+	uint32_t tmp_sum = ((uint32_t)part1) + ((uint32_t)part2);
+										       
+	if (tmp_sum & 0xf0000)  /* need carry out */
+		tmp_sum -= 0xffff;
+	
+	tcp_packet->tcphdr.checksum = ~((uint16_t)(tmp_sum & 0xffff));
+	
+	/* special case */
+	if (tcp_packet->tcphdr.checksum == 0)
+		tcp_packet->tcphdr.checksum = 0xffff;
+
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_update_segment(): checksum 0x%4x for %d bytes\n",
+	    tcp_packet->tcphdr.checksum, length);
+#endif
+}
+
+/* pxe_tcp_send_segment() - send data segment via TCP protocol
+ * in:
+ *	connection	- connection to which segment belongs
+ *      segment         - segment to send
+ * out:
+ *      0       - failed
+ *      1       - success
+ */
+int
+pxe_tcp_send_segment(PXE_TCP_CONNECTION *connection,
+		     PXE_TCP_QUEUED_SEGMENT *segment)
+{
+	if (segment == NULL) {
+		printf("pxe_tcp_send_segment(): segment = NULL.\n");
+		return (0);
+	}
+	
+	PXE_TCP_PACKET *tcp_packet = (PXE_TCP_PACKET *)(segment + 1);
+	
+	if (!pxe_ip_send(tcp_packet, &connection->dst,
+		PXE_TCP_PROTOCOL, segment->size))
+	{
+		printf("pxe_tcp_send_segment(): failed send tcp packet to %s\n",
+		    inet_ntoa(connection->dst.ip));
+		    
+		return (0);
+	}
+
+	/* mark segment to be checked in resend and update calls*/
+	segment->status = PXE_SEGMENT_SENT;
+	
+#ifdef PXE_TCP_DEBUG
+	const PXE_IPADDR	*from = pxe_get_ip(PXE_IP_MY);
+
+	printf("pxe_tcp_send_segment(): tcp packet from %s:%u to ",
+		inet_ntoa(from->ip), connection->src_port);
+		
+	printf("%s:%u\n next seq %lu",
+	       inet_ntoa(connection->dst.ip), connection->dst_port,
+	       connection->next_send - connection->iss);
+
+	uint8_t flags = tcp_packet->tcphdr.flags;
+
+	if (flags & PXE_TCP_FIN)
+	        printf(" fin,");
+
+	if (flags & PXE_TCP_SYN)
+	        printf(" syn,");
+
+	if (flags & PXE_TCP_RST)
+	        printf(" rst,");
+
+	if (flags & PXE_TCP_ACK)
+	        printf(" ack %lu,", connection->next_recv - connection->irs);
+
+	if (flags & PXE_TCP_URG)
+	        printf(" urg,");
+
+	if (flags & PXE_TCP_URG)
+	        printf(" psh,");
+	
+	uint16_t length = segment->size - sizeof(PXE_IP_HDR) -
+			  4 * (tcp_packet->tcphdr.data_off >> 4);
+	
+	printf(" %lu bytes.\n", length);
+#endif
+        return (1);
+}
+
+#ifdef PXE_MORE
+/* tcp_resend_stats() - shows statistics for chunks in resend queue
+ * in:
+ *	connection - which connection's resend queue to show
+ * out:
+ *	none
+ */
+void
+tcp_resend_stats(PXE_TCP_CONNECTION *connection)
+{
+	int	block_index = 0;
+	PXE_BUFFER		*buffer = connection->send;
+	uint8_t			*buf_blocks = connection->buf_blocks;
+	void			*data = NULL;
+	PXE_TCP_QUEUED_SEGMENT	*segment = NULL;
+	
+	printf("pxe_resend_stats(): stats for connection 0x%x\n", connection);
+		
+	for ( ; block_index < PXE_TCP_BLOCK_COUNT; ++block_index) {
+
+		/* start of block */
+		data = buffer->data +
+		       PXE_TCP_CHUNK_COUNT * block_index * connection->chunk_size;
+		       
+		segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+		    
+		if (buf_blocks[block_index] != PXE_TCP_BLOCK_FREE) {
+
+		    if (buf_blocks[block_index] != PXE_TCP_BLOCK_EXCLUSIVE) {
+			/* search free chunk in block */
+			int chunk_index = 0;
+				
+			for ( ; chunk_index < PXE_TCP_CHUNK_COUNT; ++chunk_index) {
+					
+			    if (segment->status != PXE_SEGMENT_FREE) {
+
+				printf("\tchunk %d@%d awaiting %lu ack.\n",
+				    chunk_index, block_index,
+				    segment->seq - connection->iss);
+			    }
+					
+			    /* next chunk in block */
+			    data += connection->chunk_size;
+			    segment = (PXE_TCP_QUEUED_SEGMENT *)data;
+			}
+			
+		    } else {
+			printf("pxe_resend_stats(): block %d awaiting %lu ack.\n",
+			    block_index, segment->seq - connection->iss);
+		    } /* check exclusive end*/
+		} /* check free end */
+	} /* cycle end */
+}
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_segment.h sys/boot/i386/pxe_ng/pxe_segment.h
--- sys/boot/i386/pxe_ng/pxe_segment.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_segment.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,135 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#ifndef PXE_SEGMENT_INCLUDED
+#define PXE_SEGMENT_INCLUDED
+
+/*
+ * Contains functions to send/resend tcp segments
+ */
+ 
+#include <stdint.h>
+
+#include "pxe_connection.h"
+
+/* free status for segment */
+#define PXE_SEGMENT_FREE	0x00
+/* segment is used, e.g. data is written to it */
+#define PXE_SEGMENT_USED	0x01
+/* segment is filled with data, sent but not ACKed yet */
+#define PXE_SEGMENT_SENT	0x02
+/* default resend time if not acked, in seconds */
+#define PXE_RESEND_TIME		1
+/* default resend trys */
+#define PXE_RESEND_TRYS		5
+
+/* how much blocks in buffer */
+#define PXE_TCP_BLOCK_COUNT     8
+/* how much chunks in one block */
+#define PXE_TCP_CHUNK_COUNT     8
+
+/* chunk is unused */
+#define PXE_TCP_BLOCK_FREE      0x00
+/* 1..(PXE_TCP_CHUNK_COUNT - 1) are dirty flags, partially used block */
+#define PXE_TCP_BLOCK_USED      PXE_TCP_CHUNK_COUNT
+/* block is entirely owned by one segment */
+#define PXE_TCP_BLOCK_EXCLUSIVE 0x80
+
+/* resend queue in this project organized as just a bunch of segments.
+ * to update queue it's needed to check all used chunks.
+ * buffer is divided in PXE_TCP_BLOCK_COUNT blocks, each block divided
+ * in PXE_TCP_CHUNK_COUNT chunks, so by default we have 64 chunks at all
+ * with size 64 bytes for each (for default buffer size 4096)
+ * packets may be "small" (e.g. system packets ACK, RST and etc) and contain
+ * no user data. In such case usualy will be enough one chunk for packet
+ * sizeof(iphdr+tcphdr) = 40 bytes + options < 52 = 64 - sizeof(tcp_queue_segment)
+ * also packets may be "big", but not bigger than
+ * one block size - sizeof(tcp_queue_segment)
+ * in such case packet exclusevely uses all chunks in block for own purposes.
+ * by default this means 500 bytes packet maximum (or about 460 bytes of
+ * user data per packet). For client-side usage this must be enough in
+ * this project
+ */
+
+typedef struct pxe_tcp_queued_segment {
+        uint32_t	seq;		/* sequence number */
+        uint32_t	resend_at;	/* time to ressend at */
+        uint16_t	size;		/* size of ready to send packet */
+        uint8_t		trys;		/* how many resend trys were done */
+        uint8_t		status;		/* segment status */
+} PXE_TCP_QUEUED_SEGMENT;
+
+
+
+/* checks if need to resend some segments of connection */
+void pxe_resend_check(PXE_TCP_CONNECTION *connection);
+
+/* updates resend queue, removes ACKed segments */
+void pxe_resend_update(PXE_TCP_CONNECTION *connection);
+
+/* removes segments that are dublicates or old versions of new segment */
+void pxe_resend_drop_same(PXE_TCP_CONNECTION *connection,
+	PXE_TCP_QUEUED_SEGMENT *segment);
+
+/* destroys resend queue */
+void pxe_resend_free(PXE_TCP_CONNECTION *connection);
+
+/* inits buffer map of connection  */
+void pxe_resend_init(PXE_TCP_CONNECTION *connection);
+
+/* sends chhosed segment to adrressee */
+int pxe_tcp_send_segment(PXE_TCP_CONNECTION *connection,
+	PXE_TCP_QUEUED_SEGMENT *segment);
+
+#define PXE_SEGMENT_BIG		1
+#define PXE_SEGMENT_SMALL	0
+/* allocates in buffer space segment */
+PXE_TCP_QUEUED_SEGMENT	*tcp_segment_alloc(PXE_TCP_CONNECTION *connection,
+			    int allocBig);
+
+/* releases memory used by segment */
+void tcp_segment_free(PXE_TCP_CONNECTION *connection, int block_index,
+	PXE_TCP_QUEUED_SEGMENT *segment);
+
+#define PXE_SEGMENT_OPTS_DEFAULT	1
+#define PXE_SEGMENT_OPTS_NO		0
+/* fills most of fields of tcp header of segment */
+void tcp_start_segment(PXE_TCP_CONNECTION *connection,
+	PXE_TCP_QUEUED_SEGMENT *segment, int add_options);
+
+/* finishes filling of tcp header, adds checksum */
+void tcp_finish_segment(PXE_TCP_CONNECTION *connection,
+	PXE_TCP_QUEUED_SEGMENT *segment, uint8_t tcp_flags);
+
+/* when resending updates ack and checksum */
+void tcp_update_segment(PXE_TCP_CONNECTION *connection,
+	PXE_TCP_QUEUED_SEGMENT *segment);
+
+/* when resending updates ack and checksum */
+void tcp_resend_stats(PXE_TCP_CONNECTION *connection);
+
+#endif
diff -ruN sys/boot/i386/pxe_ng/pxe_sock.c sys/boot/i386/pxe_ng/pxe_sock.c
--- sys/boot/i386/pxe_ng/pxe_sock.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_sock.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,862 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_buffer.h"
+#include "pxe_core.h"
+#include "pxe_filter.h"
+#include "pxe_mem.h"
+#include "pxe_sock.h"
+#include "pxe_tcp.h"
+#include "pxe_udp.h"
+
+/* storage for socket describing structures */
+static PXE_SOCKET	pxe_sockets[PXE_DEFAULT_SOCKETS];
+/* next available local port to use */
+static uint16_t		avail_port = 1025;
+
+/* pxe_socket_init() - initialization of socket module
+ * in/out:
+ *	none
+ */
+void
+pxe_socket_init()
+{
+
+	pxe_memset(pxe_sockets, 0, sizeof(pxe_sockets));
+}
+
+/* pxe_socket_alloc() - allocates new socket describing structure
+ * in:
+ *	none
+ * out:
+ *	-1		- failed
+ *	nonnegative	- success
+ */
+int
+pxe_socket_alloc()
+{
+	int sock_index = 0;
+
+	/* searching free sockets */
+	for (; sock_index < PXE_DEFAULT_SOCKETS; ++sock_index) {
+
+		if (pxe_sockets[sock_index].state == PXE_SOCKET_FREE) {
+			/* found free socket */
+			pxe_memset(&pxe_sockets[sock_index], 0,
+			    sizeof(PXE_SOCKET));
+			    
+			pxe_sockets[sock_index].state = PXE_SOCKET_USED;
+			
+			return sock_index;
+		}
+	}
+
+	return (-1); /* no socket found :( */
+}
+
+/* pxe_socket_free() - releases socket describing structure
+ * in:
+ *	socket		- socket descriptor
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_socket_free(int socket)
+{
+	PXE_SOCKET *sock = &pxe_sockets[socket];
+
+	sock->state = PXE_SOCKET_FREE;
+	pxe_buffer_memfree(&sock->recv_buffer);
+	pxe_buffer_memfree(&sock->send_buffer);
+	
+	return (1);
+}
+
+/* pxe_socket() - creates new socket
+ * in:
+ *	none
+ * out:
+ *	-1		- failed
+ *	nonnegative	- success
+ */
+int
+pxe_socket()
+{
+	int socket = pxe_socket_alloc();
+
+	/* allocating structure */
+	if (socket == -1)
+		return (-1);
+
+#ifdef PXE_DEBUG
+	printf("pxe_socket(): initing socket %d.\n", socket);
+#endif
+	/* creating buffers */
+	PXE_BUFFER	*rbuf = &pxe_sockets[socket].recv_buffer;
+	PXE_BUFFER	*sbuf = &pxe_sockets[socket].send_buffer;
+	
+	if (!pxe_buffer_memalloc(sbuf, PXE_DEFAULT_SEND_BUFSIZE)) {
+	
+		pxe_socket_free(socket);
+		return (-1);
+	}
+	
+	if (!pxe_buffer_memalloc(rbuf, PXE_DEFAULT_RECV_BUFSIZE)) {
+	
+		pxe_socket_free(socket);
+		return (-1);
+	}
+#ifdef PXE_DEBUG
+	printf("pxe_socket(): socket %d created.\n", socket);
+#endif	
+	return (socket);		
+}
+
+/* pxe_close() - closes socket
+ * in:
+ *	socket		- socket descriptor number
+ * out:
+ *	0		- failed
+ *	1		- success
+ */
+int
+pxe_close(int socket)
+{
+#ifdef PXE_DEBUG
+	printf("pxe_close(): closing socket %d\n", socket);
+#endif	
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_close(): invalid socket %d\n", socket);
+		return (0);
+	}
+#endif	
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+
+	if (sock->state == PXE_SOCKET_FREE) {
+#ifdef PXE_DEBUG
+		printf("pxe_close(): socket %d already closed.\n", socket);
+#endif 	
+		return (0);
+	}
+
+	PXE_FILTER_ENTRY *filter = sock->filter;
+	/* flush data in buffers */
+	pxe_flush(socket);
+
+	if (filter == NULL) { /* sanity check */
+#ifdef PXE_DEBUG
+		printf("pxe_close(): filter is NULL.\n");
+#endif
+		return (0);
+	}
+	
+	/* UDP socket closing is simple */	
+	if (filter->protocol == PXE_UDP_PROTOCOL) {
+
+		if (filter != NULL)	
+			pxe_filter_remove(sock->filter);
+#ifdef PXE_DEBUG
+		else
+			printf("pxe_close(): filter for socket already NULL.\n");
+#endif
+	} else	 /* filter removing is done in check_time_to_die() */
+		 pxe_tcp_disconnect(sock);
+
+#ifdef PXE_DEBUG
+	printf("pxe_close(): closed\n");
+#endif
+	return pxe_socket_free(socket);
+}
+
+#ifdef PXE_MORE
+/* pxe_listen() - setups filter for socket and waits new connections
+ * in:
+ *	socket		- socket descriptor number
+ *	proto		- IP stack protocol number
+ *	port		- local port to listen connections on
+ * out:
+ *	-1		- if failed
+ *	nonnegative	- number of waiting connections
+ */
+int
+pxe_listen(int socket, uint8_t proto, uint16_t port) 
+{
+#ifdef PXE_DEBUG
+	printf("pxe_listen(): proto 0x%x, port: %d.\n", proto, port);
+#endif
+	const PXE_IPADDR* to = pxe_get_ip(PXE_IP_MY);
+	
+	PXE_FILTER_ENTRY *filter = pxe_filter_add(0, 0, to,
+					port, &pxe_sockets[socket], proto);
+	
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_listen(): failed to add filter.\n");
+#endif
+		return (-1);
+	}
+	
+	pxe_filter_mask(filter, 0, 0, 0xffffffff, 0xffff);
+	
+	pxe_sockets[socket].filter = filter;
+	
+	if (proto == PXE_UDP_PROTOCOL) {	/* for UDP it's fake listen */
+		return (socket);
+	}
+	
+	while (pxe_sockets[socket].waiting == 0) {
+#ifdef PXE_DEBUG
+		twiddle();
+#endif		
+		if (!pxe_core_recv_packets()) {
+			delay(100000);
+		}
+	}
+	
+	return (pxe_sockets[socket].waiting);
+}
+
+/* pxe_accept() - accepts connections for listening socket and
+ *		returns accepted socket
+ * in:
+ *	socket	- listening socket
+ * out:
+ *	-1		- failed
+ *	nonnegative 	- newly created socket descriptor number
+ */
+int
+pxe_accept(int socket)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET *sock = &pxe_sockets[socket];
+	
+	if (sock->waiting == 0)
+		return (-1);
+	
+	int	back = sock->waiting;
+	
+	PXE_FILTER_ENTRY	*entry = sock->filter;
+	
+	for ( ; back != 0; --back) {
+
+		/* filter childs are earlier */
+		entry = entry->prev;
+
+		if (entry == NULL) {
+#ifdef PXE_DEBUG
+			printf("pxe_accept(): corrupted waiting count.\n");
+#endif		
+			return (-1);
+		}
+	}
+
+	int accepted_socket = pxe_socket();
+	
+	if (accepted_socket == -1)
+		return (-1);
+		
+	/* decreasing waiting queue */
+	--sock->waiting;
+	
+	sock = &pxe_sockets[accepted_socket];
+	
+	sock->filter = entry;
+	entry->socket = sock;
+
+	return (accepted_socket);
+}
+
+/* pxe_sock_stats() - show active sockets information
+ * in/out:
+ *	none
+ */
+void
+pxe_sock_stats()
+{
+	int		socket = 0;
+	PXE_SOCKET*	sock = pxe_sockets;
+	
+	for ( ; socket < PXE_DEFAULT_SOCKETS; ++socket, ++sock) {
+	
+		if (sock->state == PXE_SOCKET_FREE)
+			continue;
+			
+		printf("%d: filter 0x%x, recv/sent: %d/%d, waiting: %d.\n", 
+		    socket, sock->filter, sock->recv, sock->sent, sock->waiting);
+	}
+}
+#endif /* PXE_MORE */
+
+/* pxe_next_port() - returns local port
+ * in:
+ *	none
+ * out:
+ *	0  - no free port
+ *	>0 - port number
+ */
+uint16_t
+pxe_next_port()
+{	/* dummy, TODO: check filters, if port used */
+    
+	if (avail_port == 40000)
+		avail_port = 1025;
+
+	return (avail_port++);
+}
+
+/* NOTE: now assuming that only UDP is implemented */
+/* pxe_sendto() - sends data to chosen ip:port, connecting socket if needed
+ * in:
+ *	socket	- socket descriptor number
+ *	dst	- IP address to send to
+ *	port	- remote port
+ *	data	- data buffer to send
+ *	size	- size of data buffer
+ * out:
+ *	-1		- failed
+ *	nonnegative	- actual bytes sended
+ */
+int
+pxe_sendto(int socket, const PXE_IPADDR *dst, uint16_t port, void *data,
+	   uint16_t size)
+{
+
+	if (size + sizeof(PXE_UDP_PACKET) > PXE_DEFAULT_SEND_BUFSIZE) {
+		printf("pxe_sendto(): send buffer too small for %u bytes.\n",
+		    size);
+		    
+		return (-1);
+	}
+
+	PXE_SOCKET	*sock = &pxe_sockets[socket];	
+
+	if ( sock->state == PXE_SOCKET_BINDED) {
+		/* if socket binded filter must not be NULL,
+		 * cause pxe_bind() installs filter
+		 */
+		if (sock->filter == NULL) {
+			printf("pxe_sendto(): NULL filter for binded socket %d.\n",
+			    socket);
+			    
+			return (-1);
+		}
+		
+	} else  { /* not binded, connect */
+	
+		/* NOTE: if it's already connected, return error */
+		if (pxe_connect(socket, dst, port, PXE_UDP_PROTOCOL) == -1) {
+			printf("pxe_sendto(): failed to connect.\n");
+			return (-1);
+		}
+	}
+	
+	PXE_FILTER_ENTRY *filter = sock->filter;
+		
+	/* for UDP socket, send buffer used only for one dgram */
+	PXE_UDP_PACKET	*udp_pack = (PXE_UDP_PACKET *)sock->send_buffer.data;
+	
+	/* copy user data */
+	pxe_memcpy(data, udp_pack + 1, size);
+	
+	/* filters are useful for  incoming packet, so dst_port
+	 * is local port. It's always set on this step (both for binded and
+	 * connected sockets). for binded sockets pxe_connect() skipped, so
+	 * need manually call pxe_next_port() to get local port (don't use
+	 * binded local port, it seems correct behaviour)
+	 */
+	uint16_t lport = filter->dst_port;
+
+#ifdef PXE_DEBUG
+	printf("pxe_sendto(): %8x:%u -> %8x:%u, size = %u bytes.\n",
+	    (pxe_get_ip(PXE_IP_MY))->ip, lport, dst->ip, port, size);
+#endif	
+
+	if (!pxe_udp_send(udp_pack, dst, port, lport,
+		size + sizeof(PXE_UDP_PACKET)))
+	{
+		printf("pxe_sendto(): failed to send data.\n");
+		return (-1);
+	}
+
+	return (size);
+}
+
+/* pxe_connect() - connect to remote ip:port
+ * in:
+ *	socket	- socket descriptor number
+ *	dst	- IP address to connect to
+ *	port	- remote port to connect to
+ *	proto	- IP stack protocol
+ * out:
+ *	-1		- failed
+ *	0		- success
+ */	
+int
+pxe_connect(int socket, const PXE_IPADDR *dst, uint16_t port, uint8_t proto)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		return (-1);
+	}
+#endif
+#ifdef PXE_DEBUG
+	printf("pxe_connect(): started\n");
+#endif
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+	
+	if (sock->state >= PXE_SOCKET_CONNECTED) {
+		printf("pxe_connect(): socket %d already connected.\n", socket);
+		return (-1);
+	}
+	
+	/* socket was already initalized */
+	if (sock->filter != NULL) {
+	
+		pxe_filter_remove(sock->filter);
+		sock->filter = NULL;		/* just to be sure... */
+	}
+	
+	uint16_t lport = pxe_next_port();	/* getting free local port */
+	
+	if (port == 0) {
+		printf("pxe_connect(): failed to allocate local port.\n");
+		return (-1);
+	}
+	
+	PXE_FILTER_ENTRY *entry = pxe_filter_add(dst, port,
+					pxe_get_ip(PXE_IP_MY),
+					lport, sock, proto);
+	    
+	if (entry == NULL) {
+	
+		/* try to get free filter from inactive connections */
+		if (proto == PXE_TCP_PROTOCOL) {
+#ifdef PXE_DEBUG
+			printf("pxe_connect(): forcing filter release\n");
+#endif
+			pxe_force_filter_release();
+			entry = pxe_filter_add(dst, port, pxe_get_ip(PXE_IP_MY),
+				    lport, sock, proto);
+		}
+		
+		if (entry == NULL)  {
+			printf("pxe_connect(): failed to add filter.\n");
+			return (-1);
+		}
+	}
+	
+	sock->filter = entry;
+	sock->state = PXE_SOCKET_CONNECTED;
+	
+	if (proto == PXE_TCP_PROTOCOL) {
+		/* trying handshaking */
+		if (pxe_tcp_connect(sock)) {
+			sock->state = PXE_SOCKET_ESTABLISHED;
+		} else { /* failed, cleanup */
+			pxe_filter_remove(entry);
+			return (-1);
+		}
+	}
+
+#ifdef PXE_DEBUG
+	printf("pxe_connect(): socket %d connected, 0x%x:%u -> 0x%x:%u\n",
+	    socket, (pxe_get_ip(PXE_IP_MY))->ip, lport, dst->ip, port);
+#endif	
+	/* all is ok */
+	return (0);
+}
+
+/* pxe_send() - send data to socket
+ * in:
+ *	socket	- socket descriptor number to send data to
+ *	buf	- buffer with data to send
+ *	buflen	- size of buffer
+ * out:
+ *	-1		- failure
+ *	nonnegative	- actual count of bytes sent
+ */
+int
+pxe_send(int socket, void *buf, uint16_t buflen)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_send(): invalid socket %d.\n", socket);
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET		*sock = &pxe_sockets[socket];
+	PXE_FILTER_ENTRY	*filter = sock->filter;
+	int			result = -1;
+	
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_send(): NULL filter\n");
+#endif
+		return (-1);
+	}
+	
+	if (filter->protocol == PXE_UDP_PROTOCOL)
+		result = pxe_udp_write(sock, buf, buflen);
+
+	else if (filter->protocol == PXE_TCP_PROTOCOL)
+		result = pxe_tcp_write(sock, buf, buflen);
+
+	else
+		printf("pxe_send(): only TCP and UDP sockets are implemented\n");
+
+	if (result > 0)
+		sock->sent += result;
+
+	return (result);
+}
+
+/* pxe_recv() - receive data to socket
+ * in:
+ *	socket	- socket descriptor number to recieve data from
+ *	tobuf	- buffer to receive data to
+ *	buflen	- size of buffer
+ *	flags	- PXE_SOCK... flags
+ * out:
+ *	-1		- failure
+ *	nonnegative	- actual count of bytes received
+ */
+int
+pxe_recv(int socket, void *tobuf, uint16_t buflen, int flags)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_recv(): invalid socket %d.\n", socket);
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+	PXE_FILTER_ENTRY *filter = sock->filter;
+
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_recv(): NULL filter\n");
+#endif
+		return (-1);
+	}
+	
+	if ( (filter->protocol != PXE_UDP_PROTOCOL) &&
+	     (filter->protocol != PXE_TCP_PROTOCOL) )
+	{
+		printf("pxe_recv(): only TCP and UDP sockets are implemented\n");
+		return (-1);
+	}
+	
+	uint32_t timer = 0;
+#ifdef PXE_TCP_AGRESSIVE
+	uint32_t check_timer = 0;
+#endif
+	int	 result = 0;	
+	
+	while (1) {
+		
+		if (filter->protocol == PXE_UDP_PROTOCOL) {
+	
+		    result =  pxe_udp_read(sock, tobuf, buflen, NULL);
+		
+		} else {
+	
+		    result =  pxe_tcp_read(sock, tobuf, buflen);
+		} 
+		
+		if ((result != 0) || (flags == PXE_SOCK_NONBLOCKING))
+			break;
+		
+		if (timer > PXE_SOCKET_TIMEOUT)
+			break;
+#ifdef PXE_TCP_AGRESSIVE		
+		if (filter->protocol == PXE_TCP_PROTOCOL) {
+
+			if (check_timer > PXE_SOCKET_CHECK_TIMEOUT) {
+				check_timer = 0;
+				pxe_tcp_check_connection(sock);
+			}
+		}
+		
+		check_timer += TIME_DELTA;
+#endif
+		timer += TIME_DELTA;
+		/* idle 10 ms */
+		delay(TIME_DELTA_MS);
+	}
+	
+	if (result > 0)
+		sock->recv += result;
+		
+	return (result);
+}
+
+#ifdef PXE_MORE
+/* pxe_recvfrom() - receive data to socket with information about sender
+ * in:
+ *	socket	- socket descriptor number to recieve data from
+ *	tobuf	- buffer to receive data to
+ *	buflen	- size of buffer
+ *	src_ip	- pointer to memory, where store IP of sender
+ *	flags	- one of PXE_SOCK... flags
+ * out:
+ *	-1		- failure
+ *	nonnegative	- actual count of bytes received
+ */
+int
+pxe_recvfrom(int socket, void *tobuf, size_t buflen, uint32_t *src_ip, int flags)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_recvfrom(): invalid socket %d.\n", socket);
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+	PXE_FILTER_ENTRY *filter = sock->filter;
+
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_recvfrom(): NULL filter\n");
+#endif
+		return (-1);
+	}
+	
+	if ( (filter->protocol != PXE_UDP_PROTOCOL) &&
+	     (filter->protocol != PXE_TCP_PROTOCOL) )
+	{
+		printf("pxe_recvfrom(): only TCP and UDP sockets are implemented\n");
+		return (-1);
+	}
+	
+	uint32_t timer = 0;
+	uint32_t check_timer = 0;
+
+	int	 result = 0;	
+
+	PXE_UDP_DGRAM	dgram;
+	
+	while (1) {
+		
+		if (filter->protocol == PXE_UDP_PROTOCOL) {
+	
+		    result =  pxe_udp_read(sock, tobuf, buflen, &dgram);
+		
+		} else {
+	
+		    result =  pxe_tcp_read(sock, tobuf, buflen);
+		} 
+		
+		if ((result != 0) || (flags == PXE_SOCK_NONBLOCKING))
+			break;
+		
+		if (timer > PXE_SOCKET_TIMEOUT)
+			break;
+		
+		if (filter->protocol == PXE_TCP_PROTOCOL) {
+
+			if (check_timer > PXE_SOCKET_CHECK_TIMEOUT) {
+				check_timer = 0;
+				pxe_tcp_check_connection(sock);
+			}
+		}
+		
+		check_timer += 5;
+		timer += 5;
+		/* idle 5 ms */
+		delay(5000);
+	}
+	
+	if (result >= 0) {
+		sock->recv += result;
+		
+		if (src_ip != NULL) {	/* return source of data, if not NULL */
+			if (filter->protocol == PXE_TCP_PROTOCOL)
+				*src_ip = filter->src.ip;
+			else
+				*src_ip = dgram.src.ip;
+		}
+	}
+		
+	return (result);
+}
+#endif /* PXE_MORE */
+
+/* pxe_bind() - bind socket to local ip:port
+ * in:
+ *      socket  - socket descriptor number
+ *      to      - local ip to bind to
+ *      lport   - local port to bind to
+ *      proto   - IP stack protocol number
+ * out:
+ *      -1      - failed
+ *      0       - success
+ */
+int
+pxe_bind(int socket, const PXE_IPADDR *to, uint16_t lport, uint8_t proto)
+{
+#ifdef PXE_SOCKET_ACCURATE
+        if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+                printf("pxe_bind(): invalid socket %d.\n", socket);
+                return (-1);
+        }
+#endif
+        PXE_SOCKET      *sock = &pxe_sockets[socket];
+
+        if (sock->state == PXE_SOCKET_CONNECTED) {
+                printf("pxe_bind(): cannot bind connected socket %d.\n",
+                    socket);
+
+                return (-1);
+	}
+	/* socket was already initalized */
+	if (sock->filter != NULL) {
+	        pxe_filter_remove(sock->filter);
+	        sock->filter = NULL;
+	}
+	
+	PXE_FILTER_ENTRY *entry =
+		            pxe_filter_add( NULL, 0, to, lport, sock, proto);
+
+        if ( entry == NULL ) {
+                printf("pxe_bind(): failed to add filter.\n");
+                return (0);
+        }
+
+        /* allow any src_ip:port to our ip:lport */
+        pxe_filter_mask(entry, 0, 0, 0xffffffff, 0xffff);
+        sock->filter = entry;
+
+        /* all is ok */
+
+        sock->state = PXE_SOCKET_BINDED;
+        return (0);
+}
+																																					
+/* pxe_flush() - flushes send buffers
+ * in:
+ *	socket	- socket descriptor number
+ * out:
+ *	-1	- failed
+ *	0	- success
+ */
+int
+pxe_flush(int socket)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_flush(): invalid socket %d.\n", socket);
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+	PXE_FILTER_ENTRY *filter = sock->filter;
+	
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_flush(): NULL filter\n");
+#endif
+		return (-1);	
+	}
+	
+	if (filter->protocol == PXE_UDP_PROTOCOL) /* it's always flushed */
+		return (0);
+	else if (filter->protocol == PXE_TCP_PROTOCOL)
+		return (pxe_tcp_push(sock->filter) == 0) ? (-1) : 0;
+	
+	printf("pxe_flush(): only TCP and UDP sockets are implemented.\n");
+
+	return (-1);
+}
+
+/* pxe_sock_state() - returns current state of socket
+ * in:
+ *	socket	- socket descriptor number
+ * out:
+ *	-1	- if failed
+ *	one of PXE_SOCKET_ state flags otherwise
+ */
+int
+pxe_sock_state(int socket)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_sock_state(): invalid socket %d.\n", socket);
+		return (-1);
+	}
+#endif	
+	PXE_SOCKET	*sock = &pxe_sockets[socket];
+	PXE_FILTER_ENTRY *filter = sock->filter;
+	
+	if (filter == NULL) {
+#ifdef PXE_DEBUG
+		printf("pxe_sock_state(): NULL filter\n");
+#endif
+		return (PXE_SOCKET_USED);
+	}
+	
+	if (filter->protocol == PXE_UDP_PROTOCOL) /* it's always 'established' */
+		return (PXE_SOCKET_ESTABLISHED);
+		
+	else if (filter->protocol == PXE_TCP_PROTOCOL) {
+		/* for TCP connections need to check state */
+		PXE_TCP_CONNECTION *connection = filter_to_connection(filter);
+		
+		if (connection && (connection->state == PXE_TCP_ESTABLISHED) )
+			return (PXE_SOCKET_ESTABLISHED);
+	}
+	
+	return (PXE_SOCKET_CONNECTED);
+}
+
+/* pxe_sock_recv_buffer() - returns recv buffer of socket
+ * in:
+ *	socket	- socket descriptor number
+ * out:
+ *	NULL	 - if failed
+ *	non NULL - pointer to buffer
+ */
+PXE_BUFFER *
+pxe_sock_recv_buffer(int socket)
+{
+#ifdef PXE_SOCKET_ACCURATE
+	if ( (socket >= PXE_DEFAULT_SOCKETS) || (socket == -1)) {
+		printf("pxe_sock_recv_buffer(): invalid socket %d.\n", socket);
+		return (NULL);
+	}
+#endif
+	return (&pxe_sockets[socket].recv_buffer);
+}
+
diff -ruN sys/boot/i386/pxe_ng/pxe_sock.h sys/boot/i386/pxe_ng/pxe_sock.h
--- sys/boot/i386/pxe_ng/pxe_sock.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_sock.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,145 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#ifndef PXE_SOCK_H_INCLUDED
+#define PXE_SOCK_H_INCLUDED
+
+/*
+ * Implements simple sockets API
+ */
+  
+#include <stdint.h>
+#include <stddef.h>
+
+#include "pxe_buffer.h"
+#include "pxe_filter.h"
+#include "pxe_ip.h"
+
+/* default count of sockets used at the same time */
+#define PXE_DEFAULT_SOCKETS             4
+/* default count of waiting queue */
+#define PXE_DEFAULT_WAITCOUNT           3
+/* socket timeout when receiving data, in milliseconds */
+#define PXE_SOCKET_TIMEOUT		30000
+/* timeout, after that force connection checking, in milliseconds */
+#define PXE_SOCKET_CHECK_TIMEOUT	100
+/* define to add extra socket validating at every function */
+ #define PXE_SOCKET_ACCURATE
+/* socket states */
+/* socket unused and free for allocating  */
+#define PXE_SOCKET_FREE                 0x0
+/* socket structure used */
+#define PXE_SOCKET_USED                 0x1
+/* socket binded (set local ip/local port). TODO: check if need */
+#define PXE_SOCKET_BINDED		0x2
+/* socket connected (set remote ip/remote port). TODO: check if need  */
+#define PXE_SOCKET_CONNECTED		0x3
+/* connection established. TODO: check if need */
+#define PXE_SOCKET_ESTABLISHED		0x4
+
+#define PXE_SOCK_NONBLOCKING		0
+#define PXE_SOCK_BLOCKING		1
+
+/* socket */
+typedef struct pxe_socket {
+	PXE_BUFFER  send_buffer;	/* sending buffer */
+	PXE_BUFFER  recv_buffer;	/* receiving buffer */
+
+	/* transmit and status counters*/
+	uint32_t    sent;		/* bytes sent to socket */
+	uint32_t    recv;		/* bytes received from socket */
+	uint8_t     state;		/* current state */
+	uint8_t     waiting;		/* number of connections waiting
+					 * to be accepted */
+	/* for resending usage */
+	uint32_t    last_time_sent;
+	uint32_t    last_time_recv;
+	PXE_FILTER_ENTRY    *filter;	/* filter, that feeds data to socket */
+} PXE_SOCKET;
+
+/* inits this module */
+void	pxe_sock_init();
+
+/* allocates pxe_socket structure */
+/* int	pxe_socket_alloc(); */
+
+/* frees socket structure */
+/* int	pxe_socket_free(int socket); (/
+
+/* shows socket usage statistics */
+void	pxe_sock_stats();
+
+/* returns current socket state */
+int	pxe_sock_state(int socket);
+
+PXE_BUFFER * pxe_sock_recv_buffer(int socket);
+
+/* pxe_listen() - creates "listening" socket 
+ *    it's not the same as normal listen() system call.
+ * Every pxe_listen() call creates pxe_socket structure
+ * and adds filter to filter table.
+ * WARN:
+ *	-1 - means failed
+ *	>= 0 - socket for UDP
+ *	== 0 - success for TCP
+ */
+int	pxe_listen(int socket, uint8_t proto, uint16_t port);
+
+/* accept awaiting connections */
+int	pxe_accept(int socket);
+
+/* send to provided ip/port, updating filter for socket */
+int	pxe_sendto(int socket, const PXE_IPADDR *dst, uint16_t port,
+	    void *data, uint16_t size);
+
+/* moves socket to connected state */
+int	pxe_connect(int socket, const PXE_IPADDR *ip, uint16_t port,
+	    uint8_t proto);
+
+/* send data to socket, blocking */
+int	pxe_send(int socket, void *buf, uint16_t buflen);
+
+/* receive data from socket, blocking  */
+int	pxe_recv(int socket, void *buf, uint16_t buflen, int flags);
+
+/* create new socket */
+int	pxe_socket();
+
+/* binding */
+int	pxe_bind(int socket, const PXE_IPADDR *ip, uint16_t port,
+	    uint8_t proto);
+
+/* flushes send buffers */
+int	pxe_flush(int socket);
+
+/* close socket */
+int	pxe_close(int socket);
+
+/* returns next available local port */
+uint16_t pxe_next_port();
+
+#endif // PXE_SOCK_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_tcp.c sys/boot/i386/pxe_ng/pxe_tcp.c
--- sys/boot/i386/pxe_ng/pxe_tcp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_tcp.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,888 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#include <stand.h>
+
+#include "pxe_await.h"
+#include "pxe_buffer.h"
+#include "pxe_connection.h"
+#include "pxe_core.h"
+#include "pxe_filter.h"
+#include "pxe_ip.h"
+#include "pxe_segment.h"
+#include "pxe_tcp.h"
+
+/* used by pxe_tcp_syssend, when connection have no buffers */
+static PXE_BUFFER		sysbuf;
+/* buffer space for sysbuf */
+static uint8_t			bufdata[PXE_TCP_SYSBUF_SIZE];
+
+#ifdef PXE_TCP_DEBUG_HELL
+/* states in  human friendly */
+static char			strstates[PXE_TCP_ALL_STATES][15] = {
+				    "CLOSED",
+				    "SYN_SENT",
+				    "SYN_RECEIVED",
+				    "ESTABLISHED",
+				    "CLOSE_WAIT",
+				    "LAST_ACK",
+				    "FIN_WAIT_1",
+				    "CLOSING",
+				    "FIN_WAIT_2",
+				    "TIME_WAIT"
+				};
+#endif
+		
+/* tcp_check_time_to_die() - moves to CLOSED state connections from state
+ *	TIME_WAIT if last received packet (ACK for FIN in most cases)
+ *	was more than 2*MSL time ago.
+ * in:
+ *	connection - connection to check
+ * out:
+ *	none
+ */
+static void
+tcp_check_time_to_die(PXE_TCP_CONNECTION *connection)
+{
+	/* if connection in other states - do nothing */
+	if (connection->state != PXE_TCP_TIME_WAIT)
+		return;
+		
+	time_t cur_time = pxe_get_secs();
+
+	if (cur_time - connection->last_recv > 2 * PXE_TCP_MSL) {
+#ifdef PXE_TCP_DEBUG
+		printf("tcp_check_time_to_die(): time for 0x%x connection.\n",
+		    connection);
+#endif
+		/* release filter */
+		PXE_FILTER_ENTRY *filter = connection->filter;
+		
+		if (filter != NULL) /* it must always be non NULL */
+			pxe_filter_remove(filter);
+		
+		/* release connection */
+		free_connection(connection);
+	}
+}
+
+/* tcp_send_rst_for() - sends RST in reply to provided packet
+ * in:
+ *	tcp_packet - packet which caused RST sending
+ * out:
+ *	0 - failed
+ *	1 - success
+ */
+static int
+tcp_send_rst_for(PXE_TCP_PACKET *tcp_packet, uint32_t ack, uint32_t seq,
+		 uint8_t flags, uint16_t seglen)
+{
+	PXE_TCP_CONNECTION	connection;
+	pxe_memset(&connection, 0, sizeof(PXE_TCP_CONNECTION));
+			
+	connection.dst_port = tcp_packet->tcphdr.src_port;
+	connection.src_port = tcp_packet->tcphdr.dst_port;
+	connection.dst.ip = tcp_packet->iphdr.src_ip;
+	
+	connection.next_recv = seq + seglen;	/* acking */
+	connection.next_send = ack;		/* next send */
+	
+	connection.chunk_size = PXE_TCP_SYSBUF_SIZE;
+	connection.buf_blocks[0] = PXE_TCP_BLOCK_FREE;
+	connection.send = &sysbuf;
+	
+	return pxe_tcp_syssend(&connection, flags);
+}
+
+/* tcp_is_acceptable() - first check for SYN_RECEIVED, ESTABLISHED, FIN_WAIT_1,
+ *			FIN_WAIT_2, CLOSE_WAIT, CLOSING, LAST_ACK, TIME_WAIT
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ *	seglen	   - segment length
+ * out:
+ *	0	- not acceptable
+ *	1	- acceptable
+ */
+int
+tcp_is_acceptable(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet,
+		  uint16_t seglen)
+{
+	if (connection == NULL)
+		return (0);
+
+	if (connection->recv == NULL)
+		return (0);
+	
+	uint16_t window = pxe_buffer_space(connection->recv);
+	uint32_t seq = tcp_packet->tcphdr.sequence;
+	
+	if (seglen == 0) {
+	
+		if (window == 0) {
+			if (seq == connection->next_recv)
+				return (1);
+		}
+		
+		if (connection->next_recv > seq)
+			return (0);
+		
+		if (seq < connection->next_recv + window)
+			return (1);
+		
+	} else { /* segment size > 0 */
+	
+		if (window == 0)
+			return (0);
+			
+		if ((connection->next_recv <= seq) &&
+		    (seq < connection->next_recv + window) )
+			return (1);
+
+		/* or? */	
+		if ((connection->next_recv <= seq + seglen - 1) &&
+		    (seq + seglen - 1 < connection->next_recv + window) )
+			return (1);
+	}
+	
+	return (0);
+}
+
+/* tcp checks has same numbers as in RFC 793, page 65+ */
+
+/* tcp_check_1() - check if packet is acceptable, sends ACK if not
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ *	seglen	   - segment length
+ * out:
+ *	0	- not acceptable
+ *	1	- acceptable
+ */
+static int inline
+tcp_check_1(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet,
+	    uint16_t seglen)
+{
+	if (tcp_is_acceptable(connection, tcp_packet, seglen))
+		return (1);
+
+	PXE_BUFFER	*buffer = connection->recv;
+	
+	if (buffer && (buffer->bufleft == 0))
+		connection->winlock = 1;
+
+	pxe_tcp_syssend(connection, PXE_TCP_ACK);
+
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_check_1(): failed\n");
+#endif
+	return (0);
+}
+
+/* tcp_check_2() - check if packet has RST flag
+ * in:
+ *	tcp_packet - received packet
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static int inline
+tcp_check_2(PXE_TCP_PACKET *tcp_packet)
+{
+	if (tcp_packet->tcphdr.flags & PXE_TCP_RST)
+		return (1);
+
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_check_2(): failed\n");
+#endif	
+	return (0);
+}
+
+/* tcp_check_3() - check precedence
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ * out:
+ *	0	- failed
+ *	1	- precedence ok
+ */
+static int inline
+tcp_check_3(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet)
+{
+	/* TODO?: implement */
+	return (1);
+}
+
+/* tcp_check_4() - check if packet has SYN flag and sends RST
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ *	seglen	   - segment length
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static int inline
+tcp_check_4(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet,
+	    uint16_t seglen)
+{
+
+	if ( (tcp_packet->tcphdr.flags & PXE_TCP_SYN) == 0) {
+#ifdef PXE_TCP_DEBUG_HELL
+		printf("tcp_check_4(): failed\n");
+#endif
+		return (0);
+	}
+	
+	tcp_send_rst_for(tcp_packet, 0, connection->next_send, PXE_TCP_RST,
+	    seglen);
+	
+	return (1);
+}
+
+/* tcp_check_5() - check if packet has ACK flag
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static int inline
+tcp_check_5(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet)
+{
+	if ((tcp_packet->tcphdr.flags & PXE_TCP_ACK) == 0) {
+#ifdef PXE_TCP_DEBUG_HELL
+		printf("tcp_check_5(): failed\n");
+#endif	
+		return (0);
+	}
+		
+	uint32_t ack = tcp_packet->tcphdr.ack_next;
+	
+	if (ack > connection->next_send) {
+		/* acked something, that was not sent */
+#ifdef PXE_TCP_DEBUG_HELL
+		printf("tcp_check_5(): failed, acked %d, but next_snd = %d\n",
+		    ack - connection->iss,
+		    connection->next_send - connection->iss);
+#endif
+		pxe_tcp_syssend(connection, PXE_TCP_ACK);
+		return (0);
+	}
+	
+	if ( connection->una <= ack) {
+	        connection->una = ack;
+		pxe_resend_update(connection);
+	} else  { /* ignore dublicate packet */
+#ifdef PXE_TCP_DEBUG
+		printf("tcp_check_5(): failed\n");
+#endif
+		return (0);
+	}
+	
+	connection->remote_window = tcp_packet->tcphdr.window_size;
+	
+	return (1);
+}
+
+/* tcp_check_6() - check if packet has URG flag
+ * in:
+ *	tcp_packet - received packet
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static int inline
+tcp_check_6(PXE_TCP_PACKET *tcp_packet)
+{
+	if (tcp_packet->tcphdr.flags & PXE_TCP_URG)
+		return (1);
+
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_check_6(): failed\n");
+#endif	
+	return (0);
+}
+
+/* tcp_process_7() - processes data and sends ACK
+ * in:
+ *	connection - connection for which packet received
+ *	tcp_packet - received packet
+ *	seglen	   - segment length
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static void inline
+tcp_process_7(PXE_TCP_CONNECTION *connection, PXE_TCP_PACKET *tcp_packet,
+	      uint16_t seglen)
+{
+	connection->next_recv += seglen;
+	
+	if (tcp_packet->tcphdr.flags & (PXE_TCP_SYN | PXE_TCP_FIN) )
+		connection->next_recv += 1;
+
+	if ( (seglen > 0) && (connection->state == PXE_TCP_ESTABLISHED)) {
+		/* write data to buffer, always enough space,
+		 * if packet is acceptable
+		 */
+		void *data = ((void *)tcp_packet) + sizeof(PXE_IP_HDR) +
+			     4 * (tcp_packet->tcphdr.data_off >> 4);
+			     
+		pxe_buffer_write(connection->recv, data, seglen);
+	}
+
+	pxe_tcp_syssend(connection, PXE_TCP_ACK);
+	connection->last_recv = pxe_get_secs();	
+}
+
+/* tcp_check_8() - check if packet has FIN flag
+ * in:
+ *	tcp_packet - received packet
+ * out:
+ *	0	- not have
+ *	1	- have
+ */
+static int inline
+tcp_check_8(PXE_TCP_PACKET *tcp_packet)
+{
+	if (tcp_packet->tcphdr.flags & PXE_TCP_FIN)
+		return (1);
+		
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("tcp_check_8(): failed\n");
+#endif	
+	return (0);
+}
+
+/* tcp_syn_sent() - SYN_SENT state handler
+ * in:
+ *	tcp_packet - incoming packet data
+ *	connection - current connection
+ * out:
+ *	0 - don't interested more in this packet
+ *	1 - interested
+ */
+static int
+tcp_syn_sent(PXE_TCP_PACKET *tcp_packet, PXE_TCP_CONNECTION *connection,
+	     uint16_t seglen)
+{
+	uint8_t		flags = tcp_packet->tcphdr.flags;
+	uint32_t	ack = tcp_packet->tcphdr.ack_next;
+	uint32_t	seq = tcp_packet->tcphdr.sequence;
+	int		acceptable = 1;
+	
+	/* first check */
+	if ( flags & PXE_TCP_ACK) {
+		
+		if ( (ack <= connection->iss) ||
+		     (ack > connection->next_send) )
+		{
+			if ( (flags & PXE_TCP_RST) == 0) {
+				/* sending RST, if it was not sent to us */
+#ifdef PXE_TCP_DEBUG
+				printf("tcp_syn_sent(): resetting, ack = %d, "
+				       "iss = %d, nxt = %d\n", ack,
+				       connection->iss, connection->next_send);
+#endif
+				tcp_send_rst_for(tcp_packet, ack, 0,
+				    PXE_TCP_RST, 0);
+			}
+			
+			/* drop segment and return */
+			return (0);
+		}
+	
+		/* check if ACK acceptable */
+		if ( (connection->una > ack) || (ack > connection->next_send) )
+			acceptable = 0;
+	}
+	
+	/* second check, check RST */	
+	if (flags & PXE_TCP_RST) {
+	
+		if (acceptable == 0) /* just drop */
+			return (0);
+		
+		/* destroy connection */
+#ifdef PXE_TCP_DEBUG
+		printf("tcp_syn_sent(): new state - CLOSED\n");
+#endif		
+		connection->state = PXE_TCP_CLOSED;
+		return (0);
+	}
+	
+	/* third check */
+	/* TODO?: check security/compartment and precedence */
+	
+	/* fourth check, check SYN */
+	if (flags & PXE_TCP_SYN) {
+
+		if (acceptable == 1) {
+			connection->next_recv = seq + 1;
+			connection->irs = seq;
+			connection->una = ack;
+			pxe_resend_update(connection);
+		}
+		
+		if ((connection->una > connection->iss) || (acceptable == 1) ) {
+		    /* acking */
+			if (pxe_tcp_syssend(connection, PXE_TCP_ACK)) {
+#ifdef PXE_TCP_DEBUG
+				printf("tcp_syn_sent(): new state - ESTABLISHED\n");
+#endif			
+				connection->state = PXE_TCP_ESTABLISHED;
+				connection->last_recv = pxe_get_secs();
+			} else
+				printf("tcp_syn_sent(): ack syn reply failed.\n");
+		
+		} else {
+			/* enter SYN_RECEIVED, form SYN+ACK */
+		}
+	}
+	
+	return (0);
+}
+
+/* pxe_tcp_process() - processes incoming packets in states, other than SYN_SENT
+ * in:
+ *	tcp_packet - incoming packet data
+ *	connection - current connection
+ *	
+ * out:
+ *	0 - don't interested more in this packet
+ *	1 - interested
+ */
+static int
+pxe_tcp_process(PXE_TCP_PACKET *tcp_packet, PXE_TCP_CONNECTION * connection,
+		uint16_t seglen)
+{
+	uint8_t	state = connection->state;
+	uint8_t state_out = connection->state_out;
+	
+	/* first check, if acceptable at all */
+	if (!tcp_check_1(connection, tcp_packet, seglen))
+		return (0);
+
+	/* check establishing of commmunication */
+	if (state == PXE_TCP_SYN_SENT) {
+	    
+		if (tcp_packet->tcphdr.flags & PXE_TCP_SYN) {
+		
+			uint32_t	ack = tcp_packet->tcphdr.ack_next;
+			uint32_t	seq = tcp_packet->tcphdr.sequence;
+
+			connection->next_recv = seq + 1;
+			connection->irs = seq;
+			connection->una = ack;
+			pxe_resend_update(connection);
+		}
+		
+		if (pxe_tcp_syssend(connection, PXE_TCP_ACK)) {
+			connection->state = PXE_TCP_ESTABLISHED;
+			connection->last_recv = pxe_get_secs();
+		} else {
+			printf("tcp_syn_sent(): ack syn reply failed.\n");
+			return (0);
+		}
+	}
+	
+	/* check, if have RST flag, sequentially incorrect or have SYN */
+	if (( tcp_check_2(tcp_packet)) ||
+	    ( tcp_check_4(connection, tcp_packet, seglen)))
+	{
+		connection->state = PXE_TCP_CLOSED;
+		pxe_resend_free(connection);
+		
+	/*	if (state == PXE_TCP_TIME_WAIT) */
+		free_connection(connection);
+			
+		return (0);
+	}
+
+	/* fifth check, if ACK received */
+	if (!tcp_check_5(connection, tcp_packet))
+		return (0);
+	
+	switch (state) {
+	case PXE_TCP_FIN_WAIT1:
+		connection->next_send = tcp_packet->tcphdr.ack_next;
+		
+		/* if acked our FIN */
+		if (state_out == PXE_TCP_FIN) {
+			connection->state = PXE_TCP_FIN_WAIT2;
+		/*	return (0); */
+		}
+		break;
+	
+	case PXE_TCP_FIN_WAIT2:
+		connection->next_send = tcp_packet->tcphdr.ack_next;
+		break;
+	
+	case PXE_TCP_CLOSING:
+		if (state_out == PXE_TCP_FIN)
+			connection->state = PXE_TCP_TIME_WAIT;
+		break;
+		
+	case PXE_TCP_LAST_ACK:
+		if (state_out == PXE_TCP_FIN) {
+			connection->state = PXE_TCP_CLOSED;
+			pxe_resend_free(connection);
+			free_connection(connection);
+			return (0);
+		}
+		break;
+	
+	case PXE_TCP_TIME_WAIT:
+		/* in that state only retransmission of FIN may arrive 
+		 * ACKing it
+		 */
+		pxe_tcp_syssend(connection, PXE_TCP_ACK);
+		break;
+		
+	default:
+		break;
+	}
+	
+	/* FIN_WAIT_2
+	if (tcp_queue_size(connection) == 0) {
+		connection->state = PXE_TCP_CLOSE;
+	}
+	*/
+	
+	/* sixth check, if urgent. Ignoring. */
+	/* if (tcp_check_6(tcp_packet)) 
+		return (0);
+	*/
+
+	/* seventh, process segment */
+	switch (state) {
+	case PXE_TCP_ESTABLISHED:
+	case PXE_TCP_FIN_WAIT1:
+	case PXE_TCP_FIN_WAIT2:
+		tcp_process_7(connection, tcp_packet, seglen);
+		break;
+
+	case PXE_TCP_LAST_ACK:
+		/* if got here, means we have ACK */
+		connection->state = PXE_TCP_CLOSED;
+		return (0);
+		break;
+		
+	case PXE_TCP_TIME_WAIT:
+		/* check TIME_WAIT time */
+		tcp_check_time_to_die(connection);
+		/* going to return */
+
+	case PXE_TCP_CLOSE_WAIT:
+		/* just return */
+
+	default:
+		return (0);
+		break;
+	}
+	
+	/* eighth, check FIN */
+	if (tcp_check_8(tcp_packet)) {
+	
+		switch (connection->state) {
+		case PXE_TCP_ESTABLISHED:
+			/* remote host requested connection break */
+			connection->state = PXE_TCP_CLOSE_WAIT;
+			break;
+			
+		case PXE_TCP_FIN_WAIT1:
+			if (state_out == PXE_TCP_FIN) {
+				connection->state = PXE_TCP_TIME_WAIT;
+			}  else {
+				connection->state = PXE_TCP_CLOSING;
+			}
+			break;
+
+		case PXE_TCP_FIN_WAIT2:
+			connection->state = PXE_TCP_TIME_WAIT;
+			break;
+			
+		default:
+			break;
+		}
+	}
+
+	return (0);
+}
+
+/* pxe_tcp_callback() - TCP protocol callback function, executed by pxe_core
+ * in:
+ *	pack	- packet description
+ *	function- function to perform
+ * out:
+ *	1	- if packet is fragment and code is interested in it
+ *	0	- if success or error
+ */
+int
+pxe_tcp_callback(PXE_PACKET *pack, uint8_t function)
+{
+	PXE_TCP_PACKET	*tcp_packet = pack->data;
+	PXE_IPADDR	from;
+	PXE_IPADDR	to; 
+	
+	from.ip = tcp_packet->iphdr.src_ip;
+	to.ip = tcp_packet->iphdr.dst_ip;
+	
+	/* conversion to little endian */
+	tcp_packet->tcphdr.sequence = ntohl(tcp_packet->tcphdr.sequence);
+	tcp_packet->tcphdr.ack_next = ntohl(tcp_packet->tcphdr.ack_next);
+	tcp_packet->tcphdr.src_port = ntohs(tcp_packet->tcphdr.src_port);
+	tcp_packet->tcphdr.dst_port = ntohs(tcp_packet->tcphdr.dst_port);
+
+	tcp_packet->tcphdr.window_size =
+				    ntohs(tcp_packet->tcphdr.window_size);
+	
+	uint16_t	src_port = tcp_packet->tcphdr.src_port;
+	uint16_t	dst_port = tcp_packet->tcphdr.dst_port;
+	
+	PXE_IP_HDR	*iphdr = pack->data;
+
+	/* calculating data size from ip length minus headers length */
+	uint16_t	data_size = ntohs(iphdr->length) -
+				    4 * ((iphdr->ver_ihl & 0x0F) +
+				    (tcp_packet->tcphdr.data_off >> 4));
+#ifdef PXE_TCP_DEBUG_HELL
+	printf("packet: size = %u(%u), ip_hdr = %u(%u), tcp_hdr = %u (%u)\n",
+	    data_size, pack->data_size, 4 * (iphdr->ver_ihl & 0x0F),
+	    sizeof(PXE_IP_HDR), 4 * (tcp_packet->tcphdr.data_off >> 4),
+	    sizeof(PXE_TCP_HDR));
+#endif
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_callback(): tcp packet from %s:%u",
+	    inet_ntoa(from.ip), src_port);
+	    
+	printf(" to %s:%u\n",
+	    inet_ntoa(to.ip), dst_port);
+#endif
+
+	uint8_t		flags = tcp_packet->tcphdr.flags;
+	
+	PXE_SOCKET	*sock = pxe_filter_check(&from, src_port, &to,
+				    dst_port, PXE_TCP_PROTOCOL);
+
+	if (sock == NULL) {	/* nobody is interested in this packet */
+#ifdef PXE_TCP_DEBUG
+		printf("pxe_tcp_callback(): packet filtered out, sending RST.\n");
+#endif
+		if (flags & PXE_TCP_ACK)
+			tcp_send_rst_for(tcp_packet, 0,
+			    tcp_packet->tcphdr.ack_next, PXE_TCP_RST, data_size);
+		else
+			tcp_send_rst_for(tcp_packet,
+			    tcp_packet->tcphdr.ack_next + data_size, 0,
+			    PXE_TCP_RST | PXE_TCP_ACK, data_size);
+		
+		return (0);	
+	}
+	
+	/* inform, we are interested in whole packet */
+	if (function == PXE_CORE_FRAG)	
+		return (1);
+
+	/* Here filter is not NULL, that means packet is for connected socket or
+	 * connection is trying to be established/breaked correctly
+	 */
+	
+	PXE_TCP_CONNECTION *connection = filter_to_connection(sock->filter);
+
+	if (connection == NULL) {
+		printf("pxe_tcp_callback(): no connection for filter 0x%x\n",
+		    sock->filter);
+		    
+		pxe_filter_remove(sock->filter);
+		return (0);	/* NOTE: this is internal error, if got here */
+	}
+
+#ifdef PXE_TCP_DEBUG
+	printf(" seq %lu,", tcp_packet->tcphdr.sequence - connection->irs);
+	
+	if (flags & PXE_TCP_FIN)
+	    printf(" fin,");
+	
+	if (flags & PXE_TCP_SYN)
+	    printf(" syn,");
+	    
+	if (flags & PXE_TCP_RST)
+	    printf(" rst,");
+
+	if (flags & PXE_TCP_ACK)
+	    printf(" ack %lu,", tcp_packet->tcphdr.ack_next - connection->iss);
+	    
+	if (flags & PXE_TCP_URG)
+	    printf(" urg,");
+
+	if (flags & PXE_TCP_URG)
+	    printf(" psh,");
+	
+	printf(" %u bytes.\n", data_size);
+#endif	
+	/* TODO:  verify checksum  */
+	
+	uint32_t seq = tcp_packet->tcphdr.sequence;	
+	
+	if (flags & PXE_TCP_RST) {
+		/* connection aborted (hard error) by remote host */
+		connection->state = PXE_TCP_CLOSED;
+#ifdef PXE_TCP_DEBUG
+		printf("pxe_tcp_callback(): new state - CLOSED\n");
+#endif		
+		return (0);
+	}
+
+	if (connection->state > PXE_TCP_SYN_SENT) {
+
+		/* if we know sequence number, then check it */
+		if (seq != connection->next_recv) {
+			/* not next in order, drop it, send ACK */
+#ifdef PXE_TCP_DEBUG
+			printf("pxe_tcp_callback(): got %d != awaited %d\n",
+			    seq - connection->irs,
+			    connection->next_recv - connection->irs);
+#endif
+			pxe_tcp_syssend(connection, PXE_TCP_ACK);
+			return (0);
+		}
+	} else {
+	    /* in case of SYN_SENT state we don't know sequence number yet */
+	}
+	
+	int result = 0;
+	
+	/* calling appropriate state handler, if it's not NULL */
+	if (connection->state < PXE_TCP_ALL_STATES) {
+	
+		while (1) {
+#ifdef PXE_TCP_DEBUG_HELL
+			printf("pxe_tcp_callback(): connection state = %s\n",
+			    strstates[connection->state]);
+#endif
+				
+			if (connection->state == PXE_TCP_SYN_SENT) {
+				result = tcp_syn_sent(tcp_packet, connection, data_size);
+			} else {
+
+				result = pxe_tcp_process(tcp_packet, connection, data_size);
+			}
+			    
+			if (result == 2)
+				continue;
+			
+			break;
+		}
+	}
+	
+	/* check ACKed packets */
+	pxe_resend_update(connection);
+	
+	/* check if need to resend some segments */
+	pxe_resend_check(connection);
+	
+	/* check time to die */
+	if (connection->state == PXE_TCP_TIME_WAIT)
+		tcp_check_time_to_die(connection);
+	
+	return (result);
+}                                                            
+
+/* pxe_tcp_init() - initialization of TCP module
+ * in/out:
+ *	none
+ */
+void
+pxe_tcp_init()
+{
+#ifdef PXE_TCP_DEBUG
+	printf("pxe_tcp_init(): started\n");
+#endif
+	pxe_connection_init();
+
+	/* registering protocol */
+	pxe_core_register(PXE_TCP_PROTOCOL, pxe_tcp_callback);
+
+	/* sysbuf init */
+	pxe_memset(&bufdata, 0 , PXE_TCP_SYSBUF_SIZE);
+	sysbuf.data = &bufdata;
+	/* not really need, cause not using buffer realted functions */
+	sysbuf.bufleft = PXE_TCP_SYSBUF_SIZE;
+	sysbuf.bufsize = PXE_TCP_SYSBUF_SIZE;
+	sysbuf.fstart = 0;
+	sysbuf.fend = PXE_TCP_SYSBUF_SIZE;
+}
+
+/* pxe_tcp_syssend() - send system packets via TCP protocol
+ * in:
+ *	connection	- connection to send to
+ *	tcp_flags	- one or more PXE_TCP_.. flags
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_tcp_syssend(PXE_TCP_CONNECTION *connection, uint8_t tcp_flags)
+{
+	/* allocating "small" segment */
+	PXE_TCP_QUEUED_SEGMENT *segment = tcp_segment_alloc(connection,
+						PXE_SEGMENT_SMALL);
+	
+	if (segment == NULL) {
+		printf("pxe_tcp_syssend(): failed to allocate segment.\n");
+		return (0);
+	}
+
+	/* add to every system segment default options */
+	tcp_start_segment(connection, segment, PXE_SEGMENT_OPTS_DEFAULT);
+	
+	/* finish segment */
+	tcp_finish_segment(connection, segment, tcp_flags);
+	
+	/* Here is simpliest ever in the world way to calculate resend time.
+	 * For more reliable resend time calculation need to implement RTT
+	 * calculating and use more accurate timer.
+	 */
+	segment->resend_at = pxe_get_secs() + PXE_RESEND_TIME;
+
+	/* remove other segments with same sequence number,
+	 * so this segment is last
+	 */
+	pxe_resend_drop_same(connection, segment);
+	
+	if ( /* (connection->state != PXE_TCP_ESTABLISHED) && */
+	     (!pxe_tcp_send_segment(connection, segment)))
+	{
+		printf("pxe_tcp_syssend(): failed to send segment.\n");
+		return (0);
+	}
+
+	return (1);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_tcp.h sys/boot/i386/pxe_ng/pxe_tcp.h
--- sys/boot/i386/pxe_ng/pxe_tcp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_tcp.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,108 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#ifndef PXE_TCP_H_INCLUDED
+#define PXE_TCP_H_INCLUDED
+
+/*
+ * Contains functions needed to transmit tcp packets, using pxe_segment.h module
+ */
+
+#include <stdint.h>
+#include <stddef.h>
+
+#include "pxe_buffer.h"
+#include "pxe_connection.h"
+#include "pxe_ip.h"
+#include "pxe_filter.h"
+
+/* TCP IP stack protocol number*/
+#define PXE_TCP_PROTOCOL	6
+/* maximum segment life time in ms */
+#define PXE_TCP_MSL		60000
+/* buffer size used for system messages for packets without real connection */
+#define PXE_TCP_SYSBUF_SIZE	64
+
+/* tcp packet flags */
+#define PXE_TCP_FIN 0x01
+#define PXE_TCP_SYN 0x02
+#define PXE_TCP_RST 0x04
+#define PXE_TCP_PSH 0x08
+#define PXE_TCP_ACK 0x10
+#define PXE_TCP_URG 0x20
+
+typedef struct pxe_tcp_hdr {
+
+    uint16_t src_port;		/* local port */
+    uint16_t dst_port;		/* remote port */
+    uint32_t sequence;		/* seqence number */
+    uint32_t ack_next;		/* ACK'd number */
+    uint8_t  data_off;		/* offset to data */
+    uint8_t  flags;		/* TCP flags, see higher TCP_FLAG_ */
+    uint16_t window_size;	/* current window size */
+    uint16_t checksum;		/* packet checksum*/
+    uint16_t urgent;		/* urgent flags */
+} __packed PXE_TCP_HDR;
+
+/* #define PXE_TCP_MSS	1460 */
+#define PXE_TCP_MSS	1260
+
+/* default TCP options for sending data structure */
+typedef struct pxe_tcp_default_options {
+
+	uint8_t		kind;	/* kind = 2, maximum segment size option */
+	uint8_t		size;	/* size of option including
+				 * sizeof(kind) + sizeof(size)
+				 */
+	uint16_t	mss;	/* maximum segment size in octets */
+	uint8_t		end;	/* kind = 0 */
+	uint8_t		pad[3];	/* padding, not nessesary */
+} __packed PXE_TCP_DEFAULT_OPTIONS;
+
+typedef struct pxe_tcp_packet {
+
+    PXE_IP_HDR			iphdr;
+    PXE_TCP_HDR			tcphdr;
+} __packed PXE_TCP_PACKET;
+
+typedef struct pxe_tcp_wait_data {
+
+    uint8_t			state;	     /* what state is waited for */
+    PXE_TCP_CONNECTION		*connection; /* which connection is monitored */
+} __packed PXE_TCP_WAIT_DATA;
+
+/* state function handler type */
+typedef int (*pxe_tcp_state_func)(PXE_TCP_PACKET *tcp_packet,
+		    PXE_TCP_CONNECTION *connection, uint16_t seglen);
+
+/* init tcp */
+void pxe_tcp_init();
+
+/* sends "system" (no user data) segment */
+int pxe_tcp_syssend(PXE_TCP_CONNECTION *connection, uint8_t tcp_flags);
+
+#endif // PXE_TCP_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/pxe_udp.c sys/boot/i386/pxe_ng/pxe_udp.c
--- sys/boot/i386/pxe_ng/pxe_udp.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_udp.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,348 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+			 
+#include <stand.h>
+
+#include "pxe_buffer.h"
+#include "pxe_core.h"
+#include "pxe_filter.h"
+#include "pxe_ip.h"
+#include "pxe_sock.h"
+#include "pxe_udp.h"
+
+#ifdef UDP_DEFAULT_SOCKET
+PXE_BUFFER	def_buffer;
+#endif
+
+/* pxe_udp_callback() - UDP protocol callback function, executed by pxe_core
+ * in:
+ *	pack	- packet description
+ *	function- function to perform
+ * out:
+ *	1	- if packet is fragment and code is interested in it
+ *	0	- if success or error
+ */
+int
+pxe_udp_callback(PXE_PACKET *pack, uint8_t function)
+{
+	PXE_UDP_PACKET	*udp_packet = pack->data;
+	PXE_IPADDR	from;
+	PXE_IPADDR	to; 
+	
+	from.ip = udp_packet->iphdr.src_ip;
+	to.ip = udp_packet->iphdr.dst_ip;
+
+	uint16_t	src_port = ntohs(udp_packet->udphdr.src_port);
+	uint16_t	dst_port = ntohs(udp_packet->udphdr.dst_port);	
+
+#ifdef PXE_DEBUG
+	printf("pxe_udp_callback(): udp packet from %s:%u to ",
+	    inet_ntoa(from.ip), src_port);
+	
+	printf("%s:%u\n", inet_ntoa(to.ip), dst_port);
+#endif
+
+	PXE_SOCKET *sock = pxe_filter_check(&from, src_port, &to, dst_port,
+				PXE_UDP_PROTOCOL);
+
+	if (sock == NULL) {	/* nobody is interested in this packet */
+#ifndef UDP_DEFAULT_SOCKET
+#ifdef PXE_DEBUG
+		printf("pxe_udp_callback(): packet filtered out.\n");
+#endif
+		return (0);	
+#endif
+	}
+	
+	/* informm, we are interested in whole packet */
+	if (function == PXE_CORE_FRAG)	
+		return (1);
+		
+	/* TODO:  verify checksum  */
+
+	uint16_t data_size = pack->data_size - sizeof(PXE_UDP_PACKET);
+
+#ifdef UDP_DEFAULT_SOCKET
+	PXE_BUFFER* recv_buffer =
+			(sock != NULL) ? &sock->recv_buffer : &def_buffer;
+#else
+	PXE_BUFFER* recv_buffer = &sock->recv_buffer;
+#endif
+	PXE_UDP_DGRAM udp_dgram;
+		
+	if (pxe_buffer_space(recv_buffer) < data_size + sizeof(PXE_UDP_DGRAM))
+		printf("pxe_udp_callback(): socket 0x%x buffer has no space\n",
+		    sock);
+	else {
+		udp_dgram.magic = PXE_MAGIC_DGRAM;
+		udp_dgram.src.ip = from.ip;
+		udp_dgram.src_port = src_port;
+		udp_dgram.size = data_size;
+		
+		/* NOTE: here is assuming that there is no other writings to
+		 * buffer, so, to writes, place data sequentially in bufer.
+		 */
+		pxe_buffer_write(recv_buffer, &udp_dgram,
+		    sizeof(PXE_UDP_DGRAM));
+		    
+		pxe_buffer_write(recv_buffer,
+		    pack->data + sizeof(PXE_UDP_PACKET), data_size);
+	}
+	
+	return (0);
+}
+
+/* pxe_udp_init() - initialization of UDP module
+ * in/out:
+ *	none
+ */
+void
+pxe_udp_init()
+{
+#ifdef PXE_DEBUG
+	printf("pxe_udp_init(): started\n");
+#endif
+	pxe_core_register(PXE_UDP_PROTOCOL, pxe_udp_callback);
+	
+#ifdef UDP_DEFAULT_SOCKET
+	pxe_buffer_memalloc(&def_buffer, 16384);
+#endif
+}
+
+
+/* pxe_udp_shutdown() - cleanup of used memory buffer
+ * in/out:
+ *	none
+ */
+void
+pxe_udp_shutdown()
+{
+#ifdef UDP_DEFAULT_SOCKET
+	pxe_buffer_memfree(&def_buffer);
+#endif
+}
+
+
+/* pxe_udp_send() - send data via UDP protocol
+ * in:
+ *	data	- buffer of data to send
+ *	dst_ip	- destination IP address
+ *	dst_port- destination port
+ *	src_port- source port
+ *	size	- size of data
+ *	flags	- 1 if space for UDP & IP headers reserved in buffer,
+ *		  0 otherwise
+ * out:
+ *	0	- failed
+ *	1	- success
+ */
+int
+pxe_udp_send(void *data, const PXE_IPADDR *dst, uint16_t dst_port,
+	     uint16_t src_port, uint16_t size)
+{
+	PXE_UDP_PACKET	*udp_packet = (PXE_UDP_PACKET *)data;
+
+	uint16_t length = size - sizeof(PXE_IP_HDR);
+	udp_packet->udphdr.src_port = htons(src_port);
+	udp_packet->udphdr.dst_port = htons(dst_port);
+	udp_packet->udphdr.length = htons(length);
+	udp_packet->udphdr.checksum = 0;
+
+	PXE_IP4_PSEUDO_HDR	pseudo_hdr;
+	const PXE_IPADDR	*my = pxe_get_ip(PXE_IP_MY);
+
+#ifdef PXE_DEBUG
+        printf("pxe_udp_send(): %s:%u -> ",
+	    inet_ntoa(my->ip), src_port);
+	    
+	printf("%s:%u, size = %u bytes.\n",
+	    inet_ntoa(dst->ip), dst_port, size);
+#endif
+
+	pseudo_hdr.src_ip = my->ip;
+        pseudo_hdr.dst_ip = dst->ip;
+	pseudo_hdr.zero = 0;
+	pseudo_hdr.proto = PXE_UDP_PROTOCOL;
+        pseudo_hdr.length = udp_packet->udphdr.length;
+
+	/* adding pseudo header checksum to checksum of udp header with data
+	 * and make it complimentary 
+	 */
+
+	uint16_t part1 = pxe_ip_checksum(&pseudo_hdr,
+			    sizeof(PXE_IP4_PSEUDO_HDR));
+			    
+	uint16_t part2 = pxe_ip_checksum(&udp_packet->udphdr, length);
+	
+	uint32_t tmp_sum = ((uint32_t)part1) + ((uint32_t)part2);
+
+	if (tmp_sum & 0xf0000) /*need carry out */
+		tmp_sum -= 0xffff;
+	
+	udp_packet->udphdr.checksum = ~((uint16_t)(tmp_sum & 0xffff));
+	
+	/* special case */
+	if (udp_packet->udphdr.checksum == 0)
+		udp_packet->udphdr.checksum = 0xffff;
+	
+#ifdef PXE_DEBUG_HELL
+	printf("pxe_udp_send(): checksum 0x%4x for %u bytes\n",
+	    udp_packet->udphdr.checksum, length);
+#endif
+
+	if (!pxe_ip_send(udp_packet, dst, PXE_UDP_PROTOCOL,
+		length + sizeof(PXE_IP_HDR)))
+	{
+		printf("pxe_udp_send(): failed to send udp packet to %s\n",
+		    inet_ntoa(dst->ip));
+
+		return (0);
+	}
+		
+	return (1);	
+}
+
+/* pxe_udp_read() - performs reading from UDP socket
+ * in:
+ *	sock		- UDP socket to read from
+ *	tobuf		- buffer, where to read
+ *	buflen		- buffer size
+ *	dgram_out	- if not NULL, here placed dgram info
+ * out:
+ *	-1	- failed
+ *	>= 0	- actual bytes were read
+ */
+int
+pxe_udp_read(PXE_SOCKET *sock, void *tobuf, uint16_t buflen,
+	     PXE_UDP_DGRAM *dgram_out)
+{
+        PXE_UDP_DGRAM   udp_dgram;
+	
+	PXE_BUFFER	*buffer = NULL;
+
+	if (sock == NULL) {
+#ifndef UDP_DEFAULT_SOCKET
+		return (-1); /* bad socket */
+#else
+		buffer = &def_buffer;
+#endif
+	} else 
+		buffer = &sock->recv_buffer;
+
+	if (buffer == NULL) {
+#ifdef PXE_DEBUG
+                printf("pxe_udp_read(): NULL buffer.\n");
+#endif
+                return (0);
+	}
+	
+	uint16_t	usage = buffer->bufsize - pxe_buffer_space(buffer);
+	  
+        if (sizeof(PXE_UDP_DGRAM) != pxe_buffer_read(buffer, &udp_dgram,
+	    sizeof(PXE_UDP_DGRAM)))
+	{
+#ifdef PXE_DEBUG_HELL
+                printf("pxe_udp_read(): failed to read datagram data.\n");
+#endif
+                return (0);
+        }
+
+        if (udp_dgram.magic != PXE_MAGIC_DGRAM) { /* sanity check failed */
+#ifdef PXE_DEBUG
+                printf("pxe_udp_sock_recv(): dgram magic failed.\n");
+#endif
+                return (0);
+        }
+
+        uint16_t tocopy = ((uint16_t)buflen < udp_dgram.size) ?
+			    (uint16_t)buflen : udp_dgram.size;
+			    
+        uint16_t result = pxe_buffer_read(buffer, tobuf, tocopy);
+
+        if (result < udp_dgram.size) /* free truncated dgram part */
+                pxe_buffer_read(buffer, NULL, udp_dgram.size - result);
+
+	if (dgram_out != NULL) {
+		pxe_memcpy(&udp_dgram, dgram_out, sizeof(PXE_UDP_DGRAM));
+	}
+		
+        return ((int)result);
+}
+
+/* pxe_udp_write() - performs writing to UDP socket
+ * in:
+ *	sock	- UDP socket to write to
+ *	tobuf	- buffer  with data to write
+ *	buflen	- buffer size
+ * out:
+ *	-1	- failed
+ *	>= 0	- actual bytes were written
+ */
+int
+pxe_udp_write(PXE_SOCKET *sock, void *buf, uint16_t buflen)
+{
+
+        if (buflen + sizeof(PXE_UDP_PACKET) > PXE_DEFAULT_SEND_BUFSIZE) {
+                printf("pxe_udp_write(): send buffer too small for %d bytes.\n",
+		    buflen);
+		    
+                return (-1);
+	}
+						
+        /* for UDP socket, send buffer used only for one dgram */
+        PXE_UDP_PACKET		*udp_pack =
+				    (PXE_UDP_PACKET *)sock->send_buffer.data;
+				    
+	PXE_FILTER_ENTRY	*filter = sock->filter;
+										
+        if (filter == NULL) { /* not connected socket */
+                printf("pxe_udp_write(): socket is not connected.\n");
+                return (-1);
+        }
+																
+        /* copy user data */
+        pxe_memcpy(buf, udp_pack + 1, buflen);
+	
+	const PXE_IPADDR *my = pxe_get_ip(PXE_IP_MY);
+
+#ifdef PXE_DEBUG
+        printf("pxe_udp_write(): %s:%u -> ",
+	    inet_ntoa(my->ip), filter->dst_port);
+	
+	printf("%s:%u, size = %u bytes.\n",
+	    inet_ntoa(filter->src.ip), filter->src_port, buflen);
+#endif
+
+        if (!pxe_udp_send(udp_pack, &filter->src, filter->src_port,
+	    filter->dst_port, buflen + sizeof(PXE_UDP_PACKET)))
+	{
+		printf("pxe_udp_write(): failed to send data.\n");
+                return (-1);
+        }
+
+        return (buflen);
+}
diff -ruN sys/boot/i386/pxe_ng/pxe_udp.h sys/boot/i386/pxe_ng/pxe_udp.h
--- sys/boot/i386/pxe_ng/pxe_udp.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/pxe_udp.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2007 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef PXE_UDP_H_INCLUDED
+#define PXE_UDP_H_INCLUDED
+
+/*
+ * UDP related declarations
+ * Reference: RFC 768
+ */
+ 
+#include <stdint.h>
+#include <stddef.h>
+
+#include "libi386/pxe.h"
+
+/* define to use default UDP socket, for incoming packets if there are no
+ * filters, sockets and etc
+ */
+/* #define UDP_DEFAULT_SOCKET */
+/* UDP number in IP stack */
+#define PXE_UDP_PROTOCOL	0x11
+
+/* UDP header */
+typedef struct pxe_udp_hdr {
+
+        uint16_t    src_port;        /* source port */
+	uint16_t    dst_port;        /* destination port */
+        uint16_t    length;          /* packet total length,
+				      * including this header
+				      */
+	uint16_t    checksum;        /* header, pseudo header and
+				      * data checksum
+				      */
+} __packed  PXE_UDP_HDR;
+
+typedef struct pxe_udp_packet {
+
+	PXE_IP_HDR	iphdr;
+	PXE_UDP_HDR	udphdr;
+} __packed  PXE_UDP_PACKET;
+
+#define PXE_MAGIC_DGRAM		0x26101982
+
+/* structure is used to store datagrams in receive buffer of socket */
+typedef struct pxe_udp_dgram {
+
+	uint32_t	magic;		/* magic for debug purposes */
+	PXE_IPADDR	src;		/* ip of dgram sender */
+	uint16_t	src_port;	/* source port */
+	uint16_t	size;		/* size of datagram */
+		
+} PXE_UDP_DGRAM;
+
+/* UDP module init */
+void pxe_udp_init();
+
+/* UDP module shutdown routine */
+void pxe_udp_shutdown();
+
+/* sends udp packet */
+int pxe_udp_send(void *data, const PXE_IPADDR *dst, uint16_t dst_port,
+	uint16_t src_port, uint16_t size);
+
+/* writes data to udp socket */
+/* int pxe_udp_write(PXE_SOCKET *sock, void *buf, uint16_t buflen); */
+
+/* reads data from udp socket */
+/*int pxe_udp_read(PXE_SOCKET *sock, void *tobuf, uint16_t buflen,
+	PXE_UDP_DGRAM *dgram_out);*/
+
+
+#endif // PXE_IP_H_INCLUDED
diff -ruN sys/boot/i386/pxe_ng/socketfs.c sys/boot/i386/pxe_ng/socketfs.c
--- sys/boot/i386/pxe_ng/socketfs.c	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/socketfs.c	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,190 @@
+/*-
+ * Copyright (c) 2008 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+ 
+#include <sys/types.h>
+#include <stand.h>
+
+#include "pxe_core.h"
+#include "pxe_ip.h"
+#include "pxe_sock.h"
+#include "socketfs.h"
+
+static int	socket_open(const char *path, struct open_file *f);
+static int	socket_close(struct open_file *f);
+static int	socket_read(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static int	socket_write(struct open_file *f, void *buf, size_t size,
+		    size_t *resid);
+static off_t	socket_seek(struct open_file *f, off_t offset, int where);
+static int	socket_stat(struct open_file *f, struct stat *sb);
+
+struct fs_ops	socket_fsops = {
+	"socketfs",
+	socket_open,
+	socket_close,
+	socket_read,
+	socket_write,
+	socket_seek,
+	socket_stat,
+	null_readdir
+};
+
+void
+handle_cleanup(PXE_SOCKET_HANDLE *socketfile)
+{
+	if (socketfile == NULL)
+		return;
+		
+	if (socketfile->socket != -1)
+		pxe_close(socketfile->socket);
+	
+	free(socketfile);
+}
+
+static int 
+socket_open(const char *path, struct open_file *f)
+{
+#ifdef PXE_HTTP_DEBUG
+	printf("socket_open(): %s\n", path);
+#endif
+	PXE_SOCKET_HANDLE *socketfile =
+	    (PXE_SOCKET_HANDLE *)malloc(sizeof(PXE_SOCKET_HANDLE));
+	
+	if (socketfile == NULL)
+		return (ENOMEM);
+
+	pxe_memset(socketfile, 0, sizeof(PXE_SOCKET_HANDLE));
+
+	socketfile->offset = 0;
+	socketfile->socket = -1;
+	
+	/* DUMMY: need to get port, protocol and address from string */
+	PXE_IPADDR	*addr = pxe_gethostbyname(path[4]);
+	int		port = 80;
+	
+	if (addr == NULL) {
+		handle_cleanup(socketfile);
+		return (EINVAL);
+	}
+	
+	socketfile->socket = pxe_socket();
+	
+	if (socketfile->socket == -1) {
+		handle_cleanup(socketfile);
+		return (EROFS);
+	}
+	
+	if (-1 == pxe_connect(socketfile->socket, addr, port, PXE_TCP_PROTOCOL)) {
+		handle_cleanup(socketfile);
+		return (EROFS);
+	}
+	
+        f->f_fsdata = (void *) socketfile;
+
+	return (0);
+}
+
+static int 
+socket_read(struct open_file *f, void *addr, size_t size, size_t *resid)
+{
+	PXE_SOCKET_HANDLE *socketfile = (PXE_SOCKET_HANDLE *) f->f_fsdata;
+	int		result = -1;
+		
+	if (socketfile == NULL) {
+		printf("socket_read(): NULL file descriptor.\n");
+		return (EINVAL);
+	}
+	
+	result = pxe_recv(socketfile->socket, addr, size, PXE_SOCK_BLOCKING);
+	
+	if (result == -1) {
+		printf("socket_read(): failed to read\n");
+		return (EINVAL);
+	}
+
+	socketfile->offset += result;
+
+	if (resid)
+		*resid = size - result;
+
+	return (0);
+}
+
+static int 
+socket_close(struct open_file *f)
+{
+	PXE_SOCKET_HANDLE *socketfile = (PXE_SOCKET_HANDLE *) f->f_fsdata;
+	handle_cleanup(socketfile);
+	
+	return (0);
+}
+
+static int 
+socket_write(struct open_file *f, void *start, size_t size, size_t *resid)
+{
+	PXE_SOCKET_HANDLE *socketfile = (PXE_SOCKET_HANDLE *) f->f_fsdata;
+
+	if (socketfile == NULL) {
+		printf("socket_write(): NULL file descriptor.\n");
+		return (EINVAL);
+	}
+
+	int result = pxe_send(socketfile->socket, start, size);
+
+	if (result == -1) {
+		printf("socket_write(): failed to write\n");
+		return (EINVAL);
+	}
+	
+	if (resid)
+		*resid = size - result;
+		
+	return (0);
+}
+
+static int 
+socket_stat(struct open_file *f, struct stat *sb)
+{
+	PXE_SOCKET_HANDLE *socketfile = (PXE_SOCKET_HANDLE *) f->f_fsdata;
+	
+	sb->st_mode = 0666 | S_IFREG;
+	sb->st_nlink = 1;
+	sb->st_uid = 0;
+	sb->st_gid = 0;
+
+	sb->st_size = -1;
+	
+	return (0);
+}
+
+static off_t 
+socket_seek(struct open_file *f, off_t offset, int where)
+{
+	errno = EOFFSET;
+
+	return (-1);
+}
diff -ruN sys/boot/i386/pxe_ng/socketfs.h sys/boot/i386/pxe_ng/socketfs.h
--- sys/boot/i386/pxe_ng/socketfs.h	1969-12-31 19:00:00.000000000 -0500
+++ sys/boot/i386/pxe_ng/socketfs.h	2009-03-02 21:36:44.000000000 -0500
@@ -0,0 +1,47 @@
+/*-
+ * Copyright (c) 2008 Alexey Tarasov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef SOCKETFS_INCLUDED
+#define SOCKETFS_INCLUDED
+
+/* 
+ * Implements httpfs - allows working with PXE sockets as with files
+ */
+ 
+#include <stand.h>
+
+extern struct fs_ops socket_fsops;
+
+typedef struct pxe_socket_handle {
+
+        int		socket;
+	off_t           offset;         /* current offset in stream from start
+					 *  of reading */
+} PXE_SOCKET_HANDLE;
+															 
+							
+#endif
