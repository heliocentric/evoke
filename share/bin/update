#!/bin/sh
# Copyright 2007-2009 Dylan Cochran
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


# $Id$

# the for field specifier, so call for like so: local IFS="${FORFS}" \n for blah in blah

FORFS="
"

OLDFS=" 	
"

PATH="${PATH}:/usr/libexec"

if [ ! -c "${DEVICES}/null" ] ; then
	if [ -c "/dev/null" ] ; then
		DEVICES=/dev
	else
		echo "Error, no device nodes found"
		exit 1
	fi
fi

if [ ! -d "${TMPDIR}" ] ; then
	TMPDIR="/tmp"
fi

if [ ! -d "${EVOKE_MNTDIR}" ] ; then
	EVOKE_MNTDIR="/media"
	mkdir -p "${EVOKE_MNTDIR}"
fi

GLOBAL_ERRORCODE="0"
PREVDIR="$(pwd)"

apply_patch() {
	PATCHFILE="${1}"
	SOURCEFILE="${2}"
	DESTFILE="${3}"
	SOURCEHASH="${4}"
	DESTHASH="${5}"

	case "${SOURCEFILE}" in
		*.gz)
			gunzip -9nc "${SOURCEFILE}" >"${TEMPDIR}/${SOURCEHASH}"
			RFILE="${TEMPDIR}/${SOURCEHASH}"
		;;
		*)
			RFILE="${SOURCEFILE}"
		;;
	esac
	DFILE="${TEMPDIR}/${DESTHASH}"

	bspatch "${RFILE}" "${DFILE}" "${PATCHFILE}"

	case "${DESTFILE}" in
		*.gz)
			rm "${TEMPDIR}/${DESTHASH}.gz" 2>/dev/null 1>/dev/null
			gzip -9nc "${TEMPDIR}/${DESTHASH}" >"${TEMPDIR}/${DESTHASH}.gz"
			mv "${TEMPDIR}/${DESTHASH}.gz" "${TEMPDIR}/${DESTHASH}"
		;;
		*.bz2)
		;;
	esac

	REALHASH="$(sha256 -q "${TEMPDIR}/${DESTHASH}")"

	if [ "${REALHASH}" != "${DESTHASH}" ] ; then
		echo "4"
	else
		echo "0"
		mv "${TEMPDIR}/${DESTHASH}" "${DESTFILE}"
	fi
}

real_update() {
	if [ -d "${1}" ] ; then
		DESTDIR="${1}"
	else
		echo "Destination directory not found."
		exit 65
	fi

	mkdir -p ${SCRATCHDIR}/download
	mkdir -p ${PATCHDIR}

	VERSION="${2}"
	find_mirror "evoke/${VERSION}/trackfile" "${TEMPDIR}/trackfile"
	TRACKFILE="${TEMPDIR}/trackfile" OPTIONS="quiet" verify
	ERRORCODE="$?"

	if [ "${ERRORCODE}" = 0 ] ; then
		DEST_TRACKFILE="$(grep -a ^F: ${TEMPDIR}/trackfile)"
	else
		echo "Trackfile is corrupted"
		exit "${ERRORCODE}"
	fi

	DEST_TRACKFILE="$(grep -a ^F: ${TEMPDIR}/trackfile)"
	mkdir -p "${DESTDIR}/evoke/"
	cd "${DESTDIR}/evoke/"

	VERSIONLIST="$(for version in $(echo */*/trackfile) 
	do
		case "${version}" in
			misc/*)
			;;
			\*/\*/trackfile)
				echo "error"
			;;
			*)
				echo "$(stat -f '%m' "${version}"):$(dirname ${version})"
			;;
		esac
	done | sort -r | head -n 7 | cut -d : -f 2)"

	# Let's find out how many bytes we have to download.
	BYTECOUNT="$(echo "${DEST_TRACKFILE}" | awk -F ":" '{ SUM += $4; } END { print SUM; }')"
	MB="$((${BYTECOUNT} / 1000 / 1000))"
	if [ "${VERBOSE}" = "NO" ] ; then
		echo "The update utility will attempt to keep the total size of files downloaded to a"
		echo "minimum, where possible."
		echo ""
		echo "In the worst case, update will download ${BYTECOUNT} bytes (~ ${MB}M)"
		read -p "Continue? [Y/n]: " PROMPT
	else
		PROMPT="y"
	fi
	case "${PROMPT}" in
		[nN])
		;;
		*)
			# No reference points? Just fetch!
			if [ "${VERSIONLIST}" = "error" ] ; then
				for filespec in ${DEST_TRACKFILE}
				do
					unset RETVAL
					cd "${DESTDIR}/evoke/"

					vecho "Starting ${FILENAME} \{\n"
					vecho "\tFetching full files \{\n"

					HASH="$(echo "${filespec}" | cut -d ":" -f 3)"
					FILENAME="$(echo "${filespec}" | cut -d ":" -f 2)"
					PDESTDIR="${STAGEDIR}/$(dirname ${FILENAME})"
					BASENAME="$(basename ${FILENAME})"
					mkdir -p "${PDESTDIR}"
					vecho "\tHASH=${HASH}\n"
					vecho "\tFILENAME=${FILENAME}\n"
					vecho "\tPDESTDIR=${PDESTDIR}\n"
					vecho "\tBASENAME=${BASENAME}\n"
					if [ "${VERBOSE}" = "NO" ] ; then
						echo "Fetching ${FILENAME}"
					fi


					RETVAL="$(fetch_full_file "${HASH}" "${FILENAME}" "${PDESTDIR}" "${BASENAME}")" 2>&1

					if [ "${RETVAL}" != "0" ] ; then
						unset RETVAL
						echo "File corrupted in transit, bailing out"
						exit 65
					else
						unset RETVAL
					fi
				done
			else
				for filespec in ${DEST_TRACKFILE}
				do

					unset RETVAL
					cd "${DESTDIR}/evoke/"
					# let's see if HASH matches any already existing file.

					HASH="$(echo "${filespec}" | cut -d ":" -f 3)"
					FILENAME="$(echo "${filespec}" | cut -d ":" -f 2)"
					PDESTDIR="${STAGEDIR}/$(dirname ${FILENAME})"
					BASENAME="$(basename ${FILENAME})"
					PPATCHDIR="${PATCHDIR}/${HASH}"
					if [ "${VERBOSE}" = "NO" ] ; then
						echo "Fetching ${FILENAME}"
					fi
					mkdir -p "${PPATCHDIR}"
					mkdir -p "${PDESTDIR}"
					vecho "Starting ${FILENAME} \{\n"
					vecho "\tChecking existing files \{\n"

					for version in ${VERSIONLIST}
					do
						MATCHED_LINE="$(grep -a ^F: "${DESTDIR}/evoke/${version}/trackfile" | grep ${HASH})"
						if [ "${MATCHED_LINE}" != "" ] ; then
							SFILENAME="$(echo ${MATCHED_LINE} | cut -d ":" -f 2)"
							FILEPATH="${DESTDIR}/evoke/${version}/${SFILENAME}"
							vecho "\t\t${FILEPATH} {\n"
							cp "${FILEPATH}" "${STAGEDIR}/${FILENAME}"
							sh -c "cd ${STAGEDIR} && TRACKFILE="${TEMPDIR}/trackfile" OPTIONS="quiet" verify "${FILENAME}""
							RETVAL=$?
							if [ "${RETVAL}" = "0" ] ; then
								vecho "\t\t\t$Verification passed\n\t\t}\n"
								break
							else
								vecho "\t\t\tVerification failed\n\t\t}\n"
	
							fi
						fi
					done
	
					vecho "\t}\n"
					if [ "${RETVAL}" = "0" ] ; then
						unset RETVAL
						vecho "}\n"
						continue
					else
						unset RETVAL
					fi

					vecho "\tGrabbing patches {\n"
					HASHLIST="$(for version in ${VERSIONLIST}
					do
						FILEHASH="$(grep -a ^F: ${DESTDIR}/evoke/${version}/trackfile | cut -d : -f 3)"
						if [ "${FILEHASH}" != "" ] ; then
							for filehash in ${FILEHASH}
							do
								echo "evoke/misc/BIN-UPDATES/${VERSION}/${HASH}/${filehash}" 
							done
						fi
					done)"
					if [ "${HASHLIST}" != "" ] ; then
						cd "${PPATCHDIR}"
						for hash in ${HASHLIST}
						do
							realhash="$(basename ${hash})"
							vecho "\t\tFetching ${realhash} {\n"
							getfile ${hash} 2>${DEVICES}/null
							if [ -f "${realhash}" ] ; then
								vecho "\t\t\tFile exists: ${realhash}\n"
								FILE="$(grep -Ha ^F: ${DESTDIR}/evoke/*/*/trackfile | grep ${realhash} | awk -F : '{ FILENAME=$3; "dirname " $1 | getline; print $0 "/" FILENAME; }' | head -n 1)"
								RETVAL="$(apply_patch "${realhash}" "${FILE}" "${PDESTDIR}/${BASENAME}" "${realhash}" "${HASH}")"
								if [ "${RETVAL}" = "0" ] ; then
									vecho "\t\t\tPatch applied successfully: ${realhash}\n"
									vecho "\t\t}\n"
									break
								else
									vecho "\t\t\tPatch did not apply: ${realhash}\n"
									vecho "\t\t}\n"
								fi
							else
								vecho "\t\t\tFile doesn't exist: ${realhash}\n"
								vecho "\t\t}\n"
							fi
						done
					fi

					vecho "\t}\n"
					if [ "${RETVAL}" = "0" ] ; then
						unset RETVAL
						vecho "}\n"
						continue
					else
						unset RETVAL
					fi

					vecho "\tGrabbing full file {\n"
					# Ok, fall back on grabbing the file.
					RETVAL="$(fetch_full_file "${HASH}" "${FILENAME}" "${PDESTDIR}" "${BASENAME}")"
	
					vecho "\t}\n"
					if [ "${RETVAL}" != "0" ] ; then
						unset RETVAL
						echo "File corrupted in transit, bailing out"
						exit 65
					else
						unset RETVAL
					fi
					vecho "}\n"
				done
			fi
			cd "${STAGEDIR}"

			FILELIST="$(echo ${DEST_TRACKFILE} | cut -d : -f 2)"
			mv "${TEMPDIR}/trackfile" "${STAGEDIR}/"
			TRACKFILE="${STAGEDIR}/trackfile" OPTIONS="quiet" verify ${FILELIST}
			RETVAL=$?
			if [ "${RETVAL}" != "0" ] ; then
				unset RETVAL
				echo "The trackfile is incomplete"
				exit 65
			else
				unset RETVAL
			fi
			mkdir -p "${DESTDIR}/evoke/${VERSION}"
			tar -cf - * | tar -xpf - -C "${DESTDIR}/evoke/${VERSION}" 2>${DEVICES}/null
			# run verify, but this time, let it write the extended attribute out.
			cd "${DESTDIR}/evoke/${VERSION}"
			unset TRACKFILE
			OPTIONS="write" verify *
			PATCHSIZE="$(du -hd 0 ${PATCHDIR} | awk '{ print $1 }')"
			DOWNLOADSIZE="$(du -hd 0 ${SCRATCHDIR}/download | awk '{ print $1 }')"
			echo "Size of complete files downloaded: ${DOWNLOADSIZE}"
			echo "Size of patch files downloaded: ${PATCHSIZE}"
			echo "Total Size of the release: ${MB}M"
			rm -r ${SCRATCHDIR}/download
			rm -r ${PATCHDIR}
		;;
	esac
}

fetch_full_file() {
	local HASH="${1}"
	local FILENAME="${2}"
	local PDESTDIR="${3}"
	local BASENAME="${4}"
	
	local PDOWNDIR="${DOWNDIR}/${HASH}"
	mkdir -p "${PDOWNDIR}"

	cd "${PDOWNDIR}"
	vecho "\t\tFetching ${FILENAME} {\n" 1>&2
	getfile "evoke/${VERSION}/${FILENAME}" 2>${DEVICES}/null

	cp "${BASENAME}" "${PDESTDIR}/"
	cd "${STAGEDIR}"

	TRACKFILE="${TEMPDIR}/trackfile" OPTIONS="quiet" verify "${FILENAME}"
	local ERRORCODE="$?"
	if [ "${ERRORCODE}" = "0" ] ; then
		vecho "\t\t\tFile fetched successfully\n" 1>&2
	else
		vecho "\t\t\tError! file not found.\n" 1>&2
	fi
	vecho "\t\t}\n" 1>&2

	echo "${ERRORCODE}"
}


find_mirror() {
	FILENAME="${1}"
	OUTFILENAME="${2}"
	cd ${TEMPDIR}

	unset RETVAL

	for mirrorurl in $(sed -e 's/#.*$//g' ${TEMPDIR}/mirrorlist)
	do
		server="$(echo "${mirrorurl}" | sed 's_http://__g' | cut -d "/" -f 1)"
		filespec="/$(echo "${mirrorurl}" | sed 's_http://__g' | cut -d "/" -f 2-200)"
		rfilespec="${filespec}/${FILENAME}"
		phttpget "${server}" "${rfilespec}" 2>${DEVICES}/null
		file="$(basename "${rfilespec}")"
		if [ -r "${file}" ] ; then
			RETVAL="0"
			SERVER="${server}"
			FILESPEC="${filespec}"
			break
		else
			RETVAL="65"
		fi
	done
	if [ "${RETVAL}" = "0" ] ; then
		if [ "${TEMPDIR}/${file}" != "${OUTFILENAME}" ] ; then
			mv "${file}" "${OUTFILENAME}"
		fi
	else
		echo "No usable mirrors found. Bailing out."
		exit 65
	fi
	unset RETVAL
}

vecho() {
	if [ "${VERBOSE}" = "YES" ] ; then
		printf "$@"
	fi
}

# Wrapper, as our main mirror doesn't support wdfs, so we have to fall back to phttpget

getfile() {
	phttpget "${SERVER}" "${FILESPEC}/${1}" 2>${DEVICES}/null
}

activater() {
	local PREVDIR="$(pwd)"
	local PDESTDIR="${1}"
	local LDESTDIR="${1}/evoke"
	if [ -f "${LDESTDIR}/${2}/trackfile" ] ; then
		local VERSION="${2}"
	fi

	if [ ! -d "${LDESTDIR}" ] ; then
		echo "No evoke directory found"
		return 65
	fi

	while [ 1 != 2 ]
	do
		cd "${LDESTDIR}"
		VERSIONLIST="$(for version in $(echo */*)
		do
			case "${version}" in 
				misc*)
				;;
				*)
					echo ${version}
				;;
			esac
		done | sort -r)"
		if [ "${VERSIONLIST}" = "*/*" -o "${VERSIONLIST}" = "" ] ; then
			echo "No versions found"
			return 65
		else
			if [ "${VERSION}" = "" ] ; then
				VERSION="$(menu "Available Versions" "${VERSIONLIST}" "b:Back")"
			fi
			if [ "${VERSION}" != "" ] ; then
				case "${VERSION}" in
					Back)
						break
					;;
					*)
						if [ -f "${LDESTDIR}/${VERSION}/trackfile" ] ; then
							cd "${LDESTDIR}/${VERSION}"
							KERNELS="$(for name in FreeBSD/*/*/loader OpenBSD/*/* Darwin/*/* NetBSD/*/* DragonFly/*/* Haiku/*/*
									do
										case "${name}" in
											*/\*/\*/loader)
											;;
											*/\*/\*)
											;;
											*)
												echo "${name}"
											;;
										esac
									done | awk -F "/" '{ print $1 " " $2 "/" $3; }')"
							if [ "${KERNELS}" != "" ] ; then
								NUMKERN="$(echo "${KERNELS}" | wc -l | awk '{ print $1; }')"
								if [ "${NUMKERN}" = "1" ] ; then
									KERNEL="${KERNELS}"
								else
									KERNEL="$(menu "Kernels" "${KERNELS}" "b:Back")"
								fi
								if [ "${KERNEL}" != "" ] ; then
									case "${KERNEL}" in
										Back)
										;;
										FreeBSD*)
											BOOTFILE="$(echo "${KERNEL}/loader" | sed 's@\ @/@g')"
										;;
									esac
									BOOTFILE="/evoke/${VERSION}/${BOOTFILE}"
									echo "${BOOTFILE}" >${PDESTDIR}/boot.config
									echo ""
									echo "${VERSION} Activated."
									echo ""
									read -p "Press any key to continue " PROMPT
									break
								fi
							fi
						fi
					;;
				esac
			fi
		fi
	done
	cd "${PREVDIR}"
}

update_menu() {
	if [ "${1}" != "" ] ; then
		local DESTDIR="${1}"
	fi

	if [ ! -d "${DESTDIR}" ] ; then
		BOOTFS="$(mounter search tag=boot | cut -d : -f 2-100)"
		if [ "${BOOTFS}" != "" ] ; then
			local DESTDIR="${EVOKE_MNTDIR}/$(dd if=/dev/random bs=4m ocunt=1 2>/dev/null | sha256 -q)"
			mkdir -p "${DESTDIR}"

			local CHOICE=$(menu "Boot filesystem" "${BOOTFS}" "q:Quit")
			if [ "${CHOICE}" != "" ] ; then
				case "${CHOICE}" in
					Quit)
						echo "No destination directory specified!"
						GLOBAL_ERRORCODE="65"
						return

					;;
					*)
						mounter "boot-ufs:${CHOICE}" "${DESTDIR}"
					;;
				esac
			else
				echo "No destination directory specified!"
				GLOBAL_ERRORCODE="65"
				return
			fi
		else
			echo "Bootable filesystems not found."
			GLOBAL_ERRORCODE="65"
			return
		fi
	fi

	. $(command -v menu)
	find_mirror "evoke/misc/versionlist" "${TEMPDIR}/versionlist"

	if [ -f "${TEMPDIR}/versionlist" ] ; then
		while [ 1 != 2 ]
		do
			unset BRANCH
			unset RESULT
			unset REVISIONS
			unset REVISION
			BRANCH=$(menu "Branch" "$(cut -d "/" -f 1 ${TEMPDIR}/versionlist | sort -r | uniq | grep -v ^$)" "$(printf "a:Activate\nq:Quit")")
			if [ "${BRANCH}" != "" ] ; then
				case "${BRANCH}" in
					Quit)
						break
					;;
					Activate)
						activater "${DESTDIR}"
					;;
					*)
						while [ 1 != 2 ]
						do
							unset RESULT
							unset REVISIONS
							unset REVISION

							REVISIONS="$(awk -F "/" -v branch="${BRANCH}" '{ if ($1 == branch) { print $2; }; }' ${TEMPDIR}/versionlist | sort -r | grep -v ^$)"
							REVISION=$(menu "Revision" "${REVISIONS}" "$(printf "a:Activate\nb:Back\nq:Quit")")
							if [ "${REVISION}" != "" ] ; then
								case "${REVISION}" in
									Quit)
										break 2
									;;
									Activate)
										activater "${DESTDIR}"
										break
									;;
									Back)
										break
									;;
									*)
										VERSION="${BRANCH}/${REVISION}"
										real_update "${DESTDIR}" "${VERSION}"
									;;
								esac
							else
								echo "Revision not found! - Press any key to continue" 
								read RESULT
							fi
						done
					;;
				esac
			else
				echo "Branch not found! - Press any key to continue" 
				read RESULT
			fi
		done
		if [ "${CHOICE}" != "" ] ; then
			mounter umount "${DESTDIR}"
		fi
	fi
}

update() {
	SCRATCHDIR="${TMPDIR}/update/$(dd if=/dev/random bs=4m count=1 2>${DEVICES}/null | sha256 -q)"
	mkdir -p "${SCRATCHDIR}"
	TEMPDIR="${SCRATCHDIR}/tmp"
	mkdir -p "${TEMPDIR}"
	STAGEDIR="${SCRATCHDIR}/stage"
	mkdir -p "${STAGEDIR}"
	PATCHDIR="${SCRATCHDIR}/patch"
	mkdir -p "${PATCHDIR}"
	DOWNDIR="${SCRATCHDIR}/download"
	mkdir -p "${DOWNDIR}"

	cd "${TEMPDIR}"

	if [ "${EVOKE_UPDATE_MIRROR}" = "" ] ; then
		MOUNTER_EVOKE_LIST="$(mounter search tag=evoke)"
		if [ "${MOUNTER_EVOKE_LIST}" = "" ] ; then
			phttpget evoke.googlecode.com /svn/info/mirrorlist 2>${DEVICES}/null
			if [ ! -f mirrorlist ] ; then
				echo "Unable to fetch mirrorlist, Network connection down?"
				exit 65
			fi
		else
			echo "${MOUNTER_EVOKE_LIST}" >${TEMPDIR}/mirrorlist
		fi
	else
		echo "${EVOKE_UPDATE_MIRROR}" >${TEMPDIR}/mirrorlist
	fi

	VERBOSE="NO"

	if [ "${OPTIONS}" != "" ] ; then
		for option in ${OPTIONS}
		do
			case "${option}" in
				verbose)
					VERBOSE="YES"
				;;
				quiet)
					VERBOSE="NO"
				;;
			esac
		done
	fi

	case "${1}" in
		[iI][nN][sS][tT][aA][lL][lL])
			if [ "${3}" != "" ] ; then
				real_update "${2}" "${3}" 2>&1
			fi
		;;
		[aA][cC][tT][iI][vV][aA][tT][eE])
			if [ -d "${2}" ] ; then
				activater "${2}" "${3}"
				GLOBAL_ERRORCODE="${?}"
			else
				echo "Destination directory does not exist"
				exit 65
			fi
		;;
		[mM][eE][nN][uU])
			update_menu "${2}"
		;;
		*)
			update_menu "${2}"
		;;
	esac
	cd "${PREVDIR}"
	rm -r ${SCRATCHDIR}
	exit "${GLOBAL_ERRORCODE}"
}

update $@

