#!/bin/sh
# Copyright 2007-2008 Dylan Cochran
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


# $Id$

# We pass options via environment variables, as it makes parsing things
# simpler. Plus, spaces can be used explicitly.
#
# Also, force noatime mounting, it's unnecessary.

if [ ! -c "${DEVICES}/null" ] ; then
	if [ -c "/dev/null" ] ; then
		DEVICES=/dev
	else
		echo "Error, no device nodes found"
		exit 1
	fi
fi


# mexit is our wrapper for exit. prints a standard error message.

mexit () {
	case "${1}" in
		1)
			# Use if ${M_HOST} is empty or unusable.
			echo "No route to host"
			exit 85
		;;
		2)
			# Use if ${M_FILE} is empty or unusable.
			echo "No such file or directory"
			exit 2
		;;
		3)
			# Use if ${M_DESTINATION} isn't set, or isn't a directory.
			echo "Destination directory required"
			exit 2
		;;
		4)
			# Use if filesystem type isn't found.
			echo "Inappropriate file type or format"
			exit 79
		;;
		5)
			# Use if argument list is empty
			echo "Invalid Argument"
			exit 22
		;;
		6)
			# A command we ran external to this utility failed, abort.
			echo "External command terminated abnormally"
			exit 255
		;;
		7)
			# Host is empty, but required. abort
			echo "No route to host"
			exit 65
		;;
		8)
			#
			echo "Operation not supported"
			exit 45
		;;
		*)
			echo "General Error" >&2
			exit 255
		;;
	esac
}


# Echo configuration parameters if DEBUG is set.

echo_config () {
	if [ "${DEBUG}" != "" ] ; then
		echo "proto=${M_PROTO}"
		echo "prototype=${M_PTYPE}"
		echo "transport=${M_TRANSPORT}"
		echo "type=${M_STYPE}"
		echo "username=${M_USERNAME}"
		echo "password=${M_PASSWORD}"
		echo "host=${M_HOST}"
		echo "port=${M_PORT}"
		echo "file=${M_FILE}"
		echo "mountpoint=${M_DESTINATION}"
	fi
}

old_mounter () {
	if [ "${MOPTIONS}" != "" ] ; then
		MOPTIONS="-o noatime,${MOPTIONS}"
	else
		MOPTIONS="-o noatime"
	fi

	case "${1}" in
		[fF][tT][pP])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					curlftpfs ${MOPTIONS} ${2} ${3}
				fi
			fi
		;;
		[sS][sS][hH])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					sshfs ${MOPTIONS} -C ${2} ${3}
				fi
			fi
		;;
		[wW][eE][bB][dD][aA][vV])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					wdfs ${MOPTIONS} -o accept_sslcert -o svn_mode ${2} ${3}
				fi
			fi
		;;
		[nN][tT][fF][sS])
			if [ -c "${DEVICES}/${2}" ] ; then
				if [ -d "${3}" ] ; then
					ntfs-3g ${MOPTIONS} ${DEVICES}/${2} ${3}
				fi
			fi
		;;
	
		[sS][wW][aA][pP])
			if [ "${2}" != "" ] ; then
				if [ "${3}" = "enc" ] ; then
					geom eli onetime -d ${DEVICES}/${2}
					swapon ${DEVICES}/${2}.eli
				else 
					swapon ${DEVICES}/${2}
				fi
			fi
		;;
	
		[dD][uU][mM][pP])
			if [ "${2}" != "" ] ; then
				dumpon ${DEVICES}/${2}
			fi
		;;
	
		[eE][nN][tT][rR][oO][pP][yY])
			if [ "${2}" != "" ] ; then
				if [ "${3}" = "save" ] ; then
					dd if=${DEVICES}/random of=${DEVICES}/${2} bs=2048 count=1 2>${DEVICES}/null
				else 
					dd of=${DEVICES}/random if=${DEVICES}/${2} bs=2048 count=1 2>${DEVICES}/null
				fi
			fi
		;;
		[uU][nN][mM][oO][uU][nN][tT])
			mount | awk -v MOUNTPOINT=$2 '{
				mount=$3
				devicenode=$1
				if (mount == MOUNTPOINT) {
					if (devicenode ~ /fuse/) {
						system("umount " devicenode);
						close("umount " devicenode);
					} else {
						system("umount " mount);
						close ("umount " mount);
					}
				}
			}'
		;;
	  	[lL][iI][sS][tT])
	
		# We silently drop if someone types 'mounter list', however, 
		# if the third argument is a directory, we assume the user 
		# wants to automount volumes into that directory. For example, 
		# mounter list ufs /media will mount all ufs partitions into 
		# /media named after their geom name. ie, /media/da0s1a, etc.
			case "${2}" in
				[Ff][sS])
					lsvfs | awk '{ 
						if (NR > 2) 
						{
							if ($3 != "synthetic" && $3 != "loopback" && $1 != "tmpfs") {
								print $1 
							}
						}
					}'
					echo "boot-ufs"
					for fuse in wdfs sshfs curlftpfs ntfs-3g
					do
						command -v ${fuse} >${DEVICES}/null 
						if [ "$?" != "127" ] ; then
							case "${fuse}" in
								sshfs) echo ssh ;;
								ntfs-3g) echo ntfs ;;
								curlftpfs) echo ftp ;;
								wdfs) echo webdav ;;
							esac
						fi
					done
					
				;;

				*)
					if [ "${2}" != "" ] ; then
						for i in $(lsvol | grep ^${2}:)
						do
							DEVNODE=$(echo ${i} | cut -d : -f 2)
							if [ -d "${3}" ] ; then
								mkdir -p ${3}/${i}
								mounter ${2} ${DEVNODE} ${3}/${DEVNODE}
							else
								echo ${DEVNODE}
							fi
						done
					fi
				;;
			esac
		;;
		*)
			if [ -c ${DEVICES}/"${2}" ] ; then
				if [ -d "${3}" ] ; then
					mount -t ${1} ${MOPTIONS} ${DEVICES}/${2} ${3}
				fi
			fi
		;;
	esac
}

new_mounter () {
	if [ "${1}" != "" ] ; then
		# if a : is in the first argument, we treat it as a proto:source, rather then a command
		if [ "$( echo ${1} | grep :)" != "" ] ; then

			M_PROTO="$(echo "${1}" | cut -d : -f 1)"
			M_SOURCE="$(echo "${1}" | cut -d : -f 2-60)"

			# shift it so that it is easier to deal with spaces in a destination directory.
			shift

			# If it's in the form proto+transport, set M_TRANSPORT first, then M_PROTO to the 'real' protocol.
			
			if [ "$( echo ${M_PROTO} | grep +)" != "" ] ; then
				M_TRANSPORT="$(echo "${M_PROTO}" | cut -d + -f 2)"
				M_PROTO="$(echo "${M_PROTO}" | cut -d + -f 1)"
			fi

			# Bail out if there is no mountpoint specified.
			# XXX helio swap and dump are 'special', may need to move it into the actual 'mount' routines
			if [ "${*}" != "" ] ; then
				if [ -d "${*}" ] ; then
					M_DESTINATION="${*}"
				else
					mexit 3
				fi
			else
				mexit 3
			fi

			# We handle four specifications:
			# 	proto://URI
			#	proto:/file/name
			#	proto:geomname
			#	proto:all

			case "${M_SOURCE}" in
				//*)
					M_SOURCE="$(echo ${M_SOURCE} | cut -b 3-400 )"
					M_STYPE="URI"

					# Everything after the first / is treated as a file specification.
					# This does cause things to blow up, particularly if your password contains 
					# a /. Unfortunately, there is no way to handle this, yet.

					if [ "$( echo ${M_SOURCE} | grep /)" != "" ] ; then
						M_FILE="/$(echo ${M_SOURCE} | cut -d / -f 2-400)"
						M_SOURCE="$(echo ${M_SOURCE} | cut -d / -f 1)"
					fi

					# Everything after the first @ is considered a host, before it, part of the 
					# auth. This also breaks unusual passwords. Sorry.

					if [ "$( echo ${M_SOURCE} | grep @)" != "" ] ; then
						M_AUTH="$(echo ${M_SOURCE} | cut -d @ -f 1)"
						if [ "$( echo ${M_AUTH} | grep :)" != "" ] ; then
							M_USERNAME="$( echo ${M_AUTH} | cut -d : -f 1)"
							M_PASSWORD="$( echo ${M_AUTH} | cut -d : -f 2)"
						else
							M_USERNAME="${M_AUTH}"
						fi
						unset M_AUTH
						M_SOURCE="$(echo ${M_SOURCE} | cut -d @ -f 2)"
					fi

					# We need to check if it's an ipv6 address, or a hostname/ipv4 address, as 
					# it changes how M_PORT is used (due to ipv6 notation using the : character)
					# 
					# ipv6 addresses use a [host]:port notation, everything else uses
					# host:port

					if [ "$( echo ${M_SOURCE} | cut -b 1)" = "[" ] ; then
						M_HOST="$( echo ${M_SOURCE} | cut -d [ -f 2 | cut -d ] -f 1)"
						M_PORT="$( echo ${M_SOURCE} | cut -d [ -f 2 | cut -d ] -f 2 | cut -d : -f 2 )"
					else
						if [ "$( echo ${M_SOURCE} | grep :)" != "" ] ; then
							M_HOST="$( echo ${M_SOURCE} | cut -d : -f 1)"
							M_PORT="$( echo ${M_SOURCE} | cut -d : -f 2)"
						else
							M_HOST="${M_SOURCE}"
						fi
					fi
					unset M_SOURCE
				;;
				/*)
					TYPE=$( stat -f "%HT" ${M_SOURCE})
					case "${TYPE}" in
						Directory)
							M_STYPE="DIRECTORY"
							M_FILE="${M_SOURCE}"
						;;
						Character*)
						# XXX helio this needs to be filled out, we change the M_STYPE but not the M_FILE
							M_STYPE="GEOM"
						;;
						*)
							M_STYPE="FILE"
							M_FILE="${M_SOURCE}"
						;;
					esac
				;;
				[aA][lL][lL])
					M_STYPE="ALL"
				;;
				*)
					M_STYPE="GEOM"
					M_FILE="${M_SOURCE}"
				;;
			esac
			mount_proto
		else
			mounter_command $*
		fi 
	else
		mexit 5
	fi
}


# Mount protocol wrapper; here we special case fuse and swap.
# We also detect if a filesystem is 'native' via lsvfs
# Only two MPTYPEs: NET and DEV

mount_proto () {
	# XXX helio Protocols in need of special handling:
	# XXX helio procfs
	# XXX helio devfs
	# XXX helio nfs4
	# XXX helio nfs
	# XXX helio nullfs
	# XXX helio smbfs
	# XXX helio zfs
	# XXX helio portalfs

	case "${M_PROTO}" in
		http*)
			if list_proto | grep http >/dev/null ; then
				M_PTYPE="NET"
				prep_transport
				webdav_mount
			else
				mexit 4
			fi
		;;
		ftp*)
			if list_proto | grep http >/dev/null ; then
				M_PTYPE="NET"
				prep_transport
				ftp_mount
			else
				mexit 4
			fi
		;;
		ssh)
			if list_proto | grep http >/dev/null ; then
				M_PTYPE="NET"
				prep_transport
				ssh_mount
			else
				mexit 4
			fi
		;;
		*)
			if [ "$(mounter_command list fs | grep "^${M_PROTO}")" != "" ] ; then
				M_PTYPE="DEV"
				prep_transport
				nativefs_mount
			else
				mexit 4
			fi
		;;
	esac
}


# The transport prep routine. Always set M_PTYPE before calling.
# Note: if the M_PTYPE is NET, then nothing happens. We don't support
# tunneling as of yet.

prep_transport () {
	echo_config
	case "${M_PTYPE}" in
		DEV)
			case "${M_STYPE}" in
				URI)
					case "${M_TRANSPORT}" in
						[gG][gG][aA][tT][eE])
							ggate_handler
						;;
						*)
							ggate_handler
						;;
					esac
				;;
				FILE)
					mdconfig_handler
				;;
			esac
		;;
	esac
}

# mdconfig wrapper, trap errors, and terminate if necessary.

mdconfig_handler () {
	local MD_DEV=$(mdconfig -af "${M_FILE}" 2>/dev/null)
	local ERROR=$?
	# XXX helio someone needs to fill out the error codes mdconfig can return.
	case "${ERROR}" in
		0)
		;;
		*)
			mexit 6
		;;
	esac
	M_STYPE="GEOM"
	M_FILE="${MD_DEV}"
}

# ggate wrapper, push options into the ggatec command line, then catch errors ggatec can return.

ggate_handler () {
	if [ "${M_PORT}" != "" ] ; then
		local GOPTS="-p ${M_PORT}"
	fi
	if [ "${M_HOST}" = "" ] ; then
		mexit 1
	fi
	if [ "${M_FILE}" = "" ] ; then
		mexit 2
	fi
	local GATEDEV=$(ggatec create ${GOPTS} ${M_HOST} ${M_FILE})
	local ERROR=$?
	# XXX helio someone needs to fill out the error codes ggatec can return.
	case "${ERROR}" in
		0)
		;;
		*)
			mexit 6
		;;
	esac
	M_STYPE="GEOM"
	M_FILE="${GATEDEV}"
}


# Native filesystem mounter. For filesystems that can be used via nmount.

nativefs_mount () {
	echo_config
	if [ "${M_STYPE}" = "GEOM" ] ; then
		if [ -c "${DEVICES}/${M_FILE}" ] ; then
			mount -t ${M_PROTO} ${DEVICES}/${M_FILE} ${M_DESTINATION}
		fi
	fi
}


# WebDAV filesystem wrapper; supports both http and https

webdav_mount () {
	if [ "${M_STYPE}" = "URI" ] ; then
		local WDFS_OPTIONS="-o locking"
		if [ "${M_PROTO}" = "https" ] ; then
			local WDFS_OPTIONS="${WDFS_OPTIONS} -o accept_sslcert "
		fi
		if [ "${M_USERNAME}" != "" ]; then
			local WDFS_OPTIONS="${WDFS_OPTIONS} -o username=${M_USERNAME}"
			if [ "${M_PASSWORD}" != "" ]; then
				local WDFS_OPTIONS="${WDFS_OPTIONS} -o password=${M_PASSWORD}"
			fi
		fi
		if [ "${M_HOST}" != "" ] ; then
			local HOST=${M_HOST}
			if [ "${M_PORT}" != "" ] ; then
				local HOST="${HOST}:${M_PORT}"
			fi
			if [ "${M_FILE}" != "" ] ; then
				local HOST="${HOST}${M_FILE}"
			fi
			wdfs ${WDFS_OPTIONS} ${M_PROTO}://${HOST} ${M_DESTINATION}
		else
			mexit 7
		fi
	else
		mexit 8
	fi
}


# FTP filesystem wrapper; supports ftp and ftps.

ftp_mount () {
	if [ "${M_STYPE}" = "URI" ] ; then
		local FTPFS_OPTIONS="-o transform_symlinks"
		if [ "${M_PROTO}" = "ftps" ] ; then
			local FTPFS_OPTIONS="${FTPFS_OPTIONS} -o ssl -o no_verify_hostname -o no_verify_peer"
		else
			local FTPFS_OPTIONS="${FTPFS_OPTIONS} -o ssl_try"
		fi
		if [ "${M_USERNAME}" != "" ]; then
			local USER=${M_USERNAME}
			if [ "${M_PASSWORD}" != "" ]; then
				local USER=${USER}:${M_PASSWORD}
			fi
			local FTPFS_OPTIONS="${FTPFS_OPTIONS} -o user=${USER}"
		fi
		if [ "${M_HOST}" != "" ] ; then
			HOST=${M_HOST}
			if [ "${M_PORT}" != "" ] ; then
				HOST="${HOST}:${M_PORT}"
			fi
			if [ "${M_FILE}" != "" ] ; then
				HOST="${HOST}${M_FILE}"
			fi
			curlftpfs ${FTPFS_OPTIONS} ${M_PROTO}://${HOST} ${M_DESTINATION}
		else
			mexit 7
		fi
	else
		mexit 8
	fi
}


# SFTP filesystem support. 
# XXX helio needs filling out.

ssh_mount () {
	if [ "${M_STYPE}" = "URI" ] ; then
		local SSHFS_OPTIONS="-o workaround=all -o idmap=user -o transform_symlinks"
		local SSHFS_OPTIONS="${SSHFS_OPTIONS} -o follow_symlinks -o compression=yes"
		if [ "${M_PORT}" != "" ] ; then
			local SSHFS_OPTIONS="${SSHFS_OPTIONS} -o port=${M_PORT}"
		fi
		if [ "${M_HOST}" != "" ] ; then
			local HOST=${M_HOST}:
			if [ "${M_USERNAME}" != "" ] ; then
				local HOST="${M_USERNAME}@${HOST}"
			fi
			if [ "${M_FILE}" != "" ] ; then
				local HOST="${HOST}${M_FILE}"
			fi
			sshfs ${SSHFS_OPTIONS} ${HOST} ${M_DESTINATION}
		else
			mexit 7
		fi
	else
		mexit 8
	fi
}


unmount_handler () {
	mount | awk -v MOUNTPOINT=$1 -v DEVICES=${DEVICES} '
	function unmount(spec) {
		system("umount " spec);
		close("umount " spec);			
	}

	{
		mount=$3
		devicenode=$1
		if (mount == MOUNTPOINT) {
			if (devicenode ~ /fuse/) {
				unmount(devicenode);
			} else {
				umount(mount);
				if (devicenode ~ /md/) {
					# This strips ${DEVICES} and md from the node name, so mdconfig -d -u # will work
					sub(DEVICES"/md","",devicenode)
					system("mdconfig -d -u " devicenode " 2>/dev/null >/dev/null");
					close("mdconfig -d -u " devicenode " 2>/dev/null >/dev/null");

				}
				if (devicenode ~ /ggate/) {
					# same as md
					sub(DEVICES"/ggate","",devicenode)
					system("ggatec destroy -u " devicenode " 2>/dev/null >/dev/null");
					close("ggatec destroy -u " devicenode " 2>/dev/null >/dev/null");
				}
			}
					
		}
	}'
}

# List available protocols to stdout in newline deliminated form.

list_proto () {
	lsvfs | awk '{ 
		if (NR > 2) 
		{
			if ($1 != "tmpfs" && $1 != "fusefs") {
				print $1 
			}
	}
	}'
	echo "boot-ufs"
	for fuse in wdfs sshfs curlftpfs ntfs-3g
	do
		command -v ${fuse} >${DEVICES}/null 
		if [ "$?" != "127" ] ; then
			case "${fuse}" in
				sshfs) echo ssh ;;
				ntfs-3g) echo ntfs ;;
				curlftpfs) 
					echo ftp 
					echo ftps
				;;
				wdfs) 
					echo http
					echo https
				;;
			esac
		fi
	done
}

# The main command parsing portion.
# It's static, and could be shared, but isn't for other reasons.

mounter_command () {
	case "${1}" in
		[uU][nN][mM][oO][uU][nN][tT])
			unmount_handler "${2}"
		;;
		# For compat purposes
		[uU][mM][oO][uU][nN][tT])
			unmount_handler "${2}"
		;;
	  	[lL][iI][sS][tT])
	
		# We silently drop if someone types 'mounter list', however, 
		# if the third argument is a directory, we assume the user 
		# wants to automount volumes into that directory. For example, 
		# mounter list ufs /media will mount all ufs partitions into 
		# /media named after their geom name. ie, /media/da0s1a, etc.
			case "${2}" in
				[pP][rR][oO][tT][oO])
					list_proto					
				;;
				[fF][sS])
					list_proto					
				;;

				*)
					if [ "${2}" != "" ] ; then
						for i in $(lsvol | grep ^${2}:)
						do
							DEVNODE=$(echo ${i} | cut -d : -f 2)
#							if [ -d "${3}" ] ; then
#								mkdir -p ${3}/${i}
#								mounter ${2} ${DEVNODE} ${3}/${DEVNODE}
#							else
								echo ${DEVNODE}
#							fi
						done
					fi
				;;
			esac
		;;
		*)
			echo "usage:"
		;;
	esac
}
new_mounter $*


