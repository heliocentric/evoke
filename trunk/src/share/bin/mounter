#!/bin/sh
# Copyright 2007-2008 Dylan Cochran
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


# $Id$

# We pass options via environment variables, as it makes parsing things
# simpler. Plus, spaces can be used explicitly.
#
# Also, force noatime mounting, it's unnecessary.
old_mounter () {
	if [ "${MOPTIONS}" != "" ] ; then
		MOPTIONS="-o noatime,${MOPTIONS}"
	else
		MOPTIONS="-o noatime"
	fi

	if [ ! -c "${DEVICES}/null" ] ; then
		if [ -c "/dev/null" ] ; then
			DEVICES=/dev
		else
			echo "Error, no device nodes found"
			exit 1
		fi
	fi
	case "${1}" in
		[fF][tT][pP])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					curlftpfs ${MOPTIONS} ${2} ${3}
				fi
			fi
		;;
		[sS][sS][hH])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					sshfs ${MOPTIONS} -C ${2} ${3}
				fi
			fi
		;;
		[wW][eE][bB][dD][aA][vV])
			if [ "${2}" != "" ] ; then
				if [ -d "${3}" ] ; then
					wdfs ${MOPTIONS} -o accept_sslcert -o svn_mode ${2} ${3}
				fi
			fi
		;;
		[nN][tT][fF][sS])
			if [ -c "${DEVICES}/${2}" ] ; then
				if [ -d "${3}" ] ; then
					ntfs-3g ${MOPTIONS} ${DEVICES}/${2} ${3}
				fi
			fi
		;;
	
		[sS][wW][aA][pP])
			if [ "${2}" != "" ] ; then
				if [ "${3}" = "enc" ] ; then
					geom eli onetime -d ${DEVICES}/${2}
					swapon ${DEVICES}/${2}.eli
				else 
					swapon ${DEVICES}/${2}
				fi
			fi
		;;
	
		[dD][uU][mM][pP])
			if [ "${2}" != "" ] ; then
				dumpon ${DEVICES}/${2}
			fi
		;;
	
		[eE][nN][tT][rR][oO][pP][yY])
			if [ "${2}" != "" ] ; then
				if [ "${3}" = "save" ] ; then
					dd if=${DEVICES}/random of=${DEVICES}/${2} bs=2048 count=1 2>${DEVICES}/null
				else 
					dd of=${DEVICES}/random if=${DEVICES}/${2} bs=2048 count=1 2>${DEVICES}/null
				fi
			fi
		;;
		[uU][nN][mM][oO][uU][nN][tT])
			mount | awk -v MOUNTPOINT=$2 '{
				mount=$3
				devicenode=$1
				if (mount == MOUNTPOINT) {
					if (devicenode ~ /fuse/) {
						system("umount " devicenode);
						close("umount " devicenode);
					} else {
						system("umount " mount);
						close ("umount " mount);
					}
				}
			}'
		;;
	  	[lL][iI][sS][tT])
	
		# We silently drop if someone types 'mounter list', however, 
		# if the third argument is a directory, we assume the user 
		# wants to automount volumes into that directory. For example, 
		# mounter list ufs /media will mount all ufs partitions into 
		# /media named after their geom name. ie, /media/da0s1a, etc.
			case "${2}" in
				[Ff][sS])
					lsvfs | awk '{ 
						if (NR > 2) 
						{
							if ($3 != "synthetic" && $3 != "loopback" && $1 != "tmpfs") {
								print $1 
							}
						}
					}'
					echo "boot-ufs"
					for fuse in wdfs sshfs curlftpfs ntfs-3g
					do
						command -v ${fuse} >${DEVICES}/null 
						if [ "$?" != "127" ] ; then
							case "${fuse}" in
								sshfs) echo ssh ;;
								ntfs-3g) echo ntfs ;;
								curlftpfs) echo ftp ;;
								wdfs) echo webdav ;;
							esac
						fi
					done
					
				;;

				*)
					if [ "${2}" != "" ] ; then
						for i in $(lsvol | grep ^${2}:)
						do
							DEVNODE=$(echo ${i} | cut -d : -f 2)
							if [ -d "${3}" ] ; then
								mkdir -p ${3}/${i}
								mounter ${2} ${DEVNODE} ${3}/${DEVNODE}
							else
								echo ${DEVNODE}
							fi
						done
					fi
				;;
			esac
		;;
		*)
			if [ -c ${DEVICES}/"${2}" ] ; then
				if [ -d "${3}" ] ; then
					mount -t ${1} ${MOPTIONS} ${DEVICES}/${2} ${3}
				fi
			fi
		;;
	esac
}

new_mounter () {
	if [ "${1}" != "" ] ; then
		if [ "$( echo ${1} | grep :)" != "" ] ; then
			# Since a : is in the first argument, we treat it as a proto:source, rather then a command

			M_PROTO="$(echo "${1}" | cut -d : -f 1)"
			M_SOURCE="$(echo "${1}" | cut -d : -f 2-60)"
			if [ "$( echo ${M_PROTO} | grep +)" != "" ] ; then
				# Since it's in the form proto+transport, set M_TRANSPORT first, then M_PROTO to the 'real' protocol.
				M_TRANSPORT="$(echo "${M_PROTO}" | cut -d + -f 2)"
				M_PROTO="$(echo "${M_PROTO}" | cut -d + -f 1)"
			fi
			case "${M_SOURCE}" in
				//*)
					M_SOURCE="$(echo ${M_SOURCE} | cut -b 3-400 )"
					M_STYPE="URI"

					# Everything after the first / is treated as a file specification.
					# This does cause things to blow up, particularly if your password contains 
					# a /. Unfortunately, there is no way to handle this, yet.

					if [ "$( echo ${M_SOURCE} | grep /)" != "" ] ; then
						M_FILE="/$(echo ${M_SOURCE} | cut -d / -f 2-400)"
						M_SOURCE="$(echo ${M_SOURCE} | cut -d / -f 1)"
					fi

					# Everything after the first @ is considered a host, before it, part of the 
					# auth. This also breaks unusual passwords. Sorry.

					if [ "$( echo ${M_SOURCE} | grep @)" != "" ] ; then
						M_AUTH="$(echo ${M_SOURCE} | cut -d @ -f 1)"
						if [ "$( echo ${M_AUTH} | grep :)" != "" ] ; then
							M_USERNAME="$( echo ${M_AUTH} | cut -d : -f 1)"
							M_PASSWORD="$( echo ${M_AUTH} | cut -d : -f 2)"
						else
							M_USERNAME="${M_AUTH}"
						fi
						unset M_AUTH
						M_SOURCE="$(echo ${M_SOURCE} | cut -d @ -f 2)"
					fi

					# We need to check if it's an ipv6 address, or a hostname/ipv4 address, as 
					# it changes how M_PORT is used (due to ipv6 notation using the : character)
					# 
					# ipv6 addresses use a [host]:port notation, everything else uses
					# host:port

					if [ "$( echo ${M_SOURCE} | cut -b 1)" = "[" ] ; then
						M_HOST="$( echo ${M_SOURCE} | cut -d [ -f 2 | cut -d ] -f 1)"
						M_PORT="$( echo ${M_SOURCE} | cut -d [ -f 2 | cut -d ] -f 2 | cut -d : -f 2 )"
					else
						if [ "$( echo ${M_SOURCE} | grep :)" != "" ] ; then
							M_HOST="$( echo ${M_SOURCE} | cut -d : -f 1)"
							M_PORT="$( echo ${M_SOURCE} | cut -d : -f 2)"
						else
							M_HOST="${M_SOURCE}"
						fi
					fi
					unset M_SOURCE
				;;
				/*)
					TYPE=$( stat -f "%HT" ${M_SOURCE})
					case "${TYPE}" in
						Character*)
							
						;;
						*)
							M_STYPE="FILE"						
						;;
					esac
					
				;;
				[aA][lL][lL])
					M_STYPE="ALL"
				;;
				*)
					M_STYPE="GEOM"
				;;
			esac
			shift
			mount_proto $*
		else
			mounter_command $*
		fi 
	fi
}
mount_proto () {
	case "${M_PROTO}" in
		ufs)
			M_PTYPE="FS"
			prep_transport
		;;
	esac
	
			echo "proto=${M_PROTO}"
			echo "prototype=${M_PTYPE}"
			echo "transport=${M_TRANSPORT}"
			echo "type=${M_STYPE}"
			echo "username=${M_USERNAME}"
			echo "password=${M_PASSWORD}"
			echo "host=${M_HOST}"
			echo "port=${M_PORT}"
			echo "file=${M_FILE}"
			echo "mountpoint=$*"
}


# The transport prep routine. Always set M_PTYPE before calling.
# Note: if the M_PTYPE is NET, then nothing happens. We don't support
# tunneling as of yet.

prep_transport () {
	case "${M_PTYPE}" in
		FS)
			if [ "${M_STYPE}" = "URI" ] ; then
				case "${M_TRANSPORT}" in
					[gG][gG][aA][tT][eE])
						ggate_handler
					;;
					*)
						ggate_handler
					;;
				esac
			fi
		;;
	esac
}
ggate_handler () {
	if [ "${M_PORT}" != "" ] ; then
		GOPTS="-p ${M_PORT}"
	fi
	if [ "${M_HOST}" = "" ] ; then
		mexit 1
	fi
	if [ "${M_FILE}" = "" ] ; then
		mexit 2
	fi
	echo "ggatec create ${GOPTS} ${M_HOST} ${M_FILE}"
	# Need to catch ggatec connect errors here.
	M_STYPE="GEOM"
	M_FILE="${GATEDEV}"
}

# mexit is our wrapper for exit. prints a standard error message.

mexit () {
	case "${1}" in
		1)
			# Use if ${M_HOST} is empty or unusable.
			echo "No route to host"
			exit 85
		;;
		2)
			# Use if ${M_FILE} is empty or unusable.
			echo "No such file or directory"
			exit 2
		;;
		*)
			echo "General Error" >&2
			exit 255
		;;
	esac
}


# The main command parsing portion.
# It's static, and could be shared, but isn't for other reasons.

mounter_command () {
	case "${1}" in
		[uU][nN][mM][oO][uU][nN][tT])
			mount | awk -v MOUNTPOINT=$2 '{
				mount=$3
				devicenode=$1
				if (mount == MOUNTPOINT) {
					if (devicenode ~ /fuse/) {
						system("umount " devicenode);
						close("umount " devicenode);
					} else {
						system("umount " mount);
						close ("umount " mount);
					}
				}
			}'
		;;
	  	[lL][iI][sS][tT])
	
		# We silently drop if someone types 'mounter list', however, 
		# if the third argument is a directory, we assume the user 
		# wants to automount volumes into that directory. For example, 
		# mounter list ufs /media will mount all ufs partitions into 
		# /media named after their geom name. ie, /media/da0s1a, etc.
			case "${2}" in
				[Ff][sS])
					lsvfs | awk '{ 
						if (NR > 2) 
						{
							if ($3 != "synthetic" && $3 != "loopback" && $1 != "tmpfs") {
								print $1 
							}
						}
					}'
					echo "boot-ufs"
					for fuse in wdfs sshfs curlftpfs ntfs-3g
					do
						command -v ${fuse} >${DEVICES}/null 
						if [ "$?" != "127" ] ; then
							case "${fuse}" in
								sshfs) echo ssh ;;
								ntfs-3g) echo ntfs ;;
								curlftpfs) echo ftp ;;
								wdfs) echo webdav ;;
							esac
						fi
					done
					
				;;

				*)
					if [ "${2}" != "" ] ; then
						for i in $(lsvol | grep ^${2}:)
						do
							DEVNODE=$(echo ${i} | cut -d : -f 2)
#							if [ -d "${3}" ] ; then
#								mkdir -p ${3}/${i}
#								mounter ${2} ${DEVNODE} ${3}/${DEVNODE}
#							else
								echo ${DEVNODE}
#							fi
						done
					fi
				;;
			esac
		;;
		*)
			echo "usage:"
		;;
	esac
}
new_mounter $*


