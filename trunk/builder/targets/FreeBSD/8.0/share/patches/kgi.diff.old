diff -x CVS -x .svn -aurpN sys/conf/files sys/conf/files
--- sys/conf/files	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/files	2009-10-01 10:41:59.000000000 +0800
@@ -1109,6 +1109,42 @@ dev/joy/joy.c			optional joy
 dev/joy/joy_isa.c		optional joy isa
 dev/joy/joy_pccard.c		optional joy pccard
 dev/kbdmux/kbdmux.c		optional kbdmux
+dev/kgc/kgc_emudumb.c		optional kgc kgi
+dev/kgc/kgc_emuxterm.c		optional kgc kgi
+dev/kgc/kgc_textbuf.c		optional kgc kgi
+dev/kgc/kgc_gfbdflt.c		optional kgc kgi
+dev/kgc/kgc_gfbrndr.c		optional kgc kgi
+dev/kgc/kgc_kgirndr.c		optional kgc kgi
+dev/kgc/kgc_mapper.c		optional kgc kgi
+dev/kgc/kgc_render.c		optional kgc kgi
+dev/kgc/kgc_backgnd.c		optional kgc kgi
+dev/kgc/kgc_bgndpcx.c		optional kgc kgi
+dev/kgc/kgc_daemon.c		optional kgc kgi
+dev/kgc/kgc_scroller.c		optional kgc kgi
+dev/kgc/kgc_textscroller.c	optional kgc kgi
+dev/kgc/render_if.m		optional kgc kgi
+dev/kgc/scroller_if.m		optional kgc kgi
+dev/kgi/kgi_core.c		optional kgi
+dev/kgi/kgi_daemon.c		optional kgi
+dev/kgi/kgi_dpynull.c		optional kgi
+dev/kgi/kgi_syspci.c		optional kgi
+dev/kgi/kgi_sysatomic.c		optional kgi
+dev/kgi/kgi_sysmem.c		optional kgi
+dev/kgi/kgi_sysmutex.c		optional kgi
+dev/kgi/kgu_graphic.c		optional kgu kgi
+dev/kgi/kgu_resource.c		optional kgu kgi
+dev/kgi/kgu_command.c		optional kgu kgi
+dev/kgi/kgu_map.c		optional kgu kgi
+dev/kgi/kgu_accel.c		optional kgu kgi
+dev/kgi/kgu_mmio.c		optional kgu kgi
+dev/kii/kii_core.c		optional kgi
+dev/kii/kii_action.c		optional kgi
+dev/kii/kiu_event.c		optional kiu kgi
+dev/kip/kip_defaults.c		optional kip kgi
+dev/kip/kip_kbdriver.c		optional kip kgi
+dev/kip/kip_keymap.c		optional kip kgi
+dev/kip/kip_modifiers.c		optional kip kgi
+dev/kip/kip_symbols.c		optional kip kgi
 dev/ksyms/ksyms.c		optional ksyms
 dev/le/am7990.c			optional le
 dev/le/am79900.c		optional le
@@ -1384,6 +1420,10 @@ dev/scc/scc_dev_z8530.c		optional scc
 dev/scd/scd.c			optional scd isa
 dev/scd/scd_isa.c		optional scd isa
 dev/sdhci/sdhci.c		optional sdhci pci
+dev/sce/sce_bootconsole.c	optional sce kgc kgi
+dev/sce/sce_vtconsole.c	optional sce kgc kgi
+dev/sce/sce_sysmouse.c	optional sce kgc kgi
+dev/sce/sce_scmouse.c	optional sce kgc kgi
 dev/sf/if_sf.c			optional sf pci
 dev/si/si.c			optional si
 dev/si/si2_z280.c		optional si
@@ -2636,6 +2676,7 @@ ufs/ufs/ufs_vfsops.c		optional ffs
 ufs/ufs/ufs_vnops.c		optional ffs
 vm/default_pager.c		standard
 vm/device_pager.c		standard
+vm/kgi_pager.c			standard
 vm/phys_pager.c			standard
 vm/redzone.c			optional DEBUG_REDZONE
 vm/sg_pager.c			standard
diff -x CVS -x .svn -aurpN sys/conf/files.i386 sys/conf/files.i386
--- sys/conf/files.i386	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/files.i386	2009-10-01 10:41:59.000000000 +0800
@@ -196,7 +196,12 @@ dev/ipmi/ipmi_smbios.c		optional ipmi
 dev/ipmi/ipmi_ssif.c		optional ipmi smbus
 dev/ipmi/ipmi_pci.c		optional ipmi pci
 dev/ipmi/ipmi_linux.c		optional ipmi compat_linux
-dev/kbd/kbd.c			optional atkbd | sc | ukbd | usb2_input_kbd
+dev/kbd/kbd.c			optional atkbd | sc | ukbd | usb2_input_kbd | kgi
+dev/kgy/kgy_disp.c		optional kgy kgi
+dev/kgy/kgy_mode.c		optional kgy kgi
+dev/kgy/kgy_text16.c		optional kgy kgi
+dev/kgy/kgy_splash.c		optional kgy kgi
+dev/kgim/kgim.c		optional kgim kgi
 dev/le/if_le_isa.c		optional le isa
 dev/mem/memutil.c		optional mem
 dev/mse/mse.c			optional mse
diff -x CVS -x .svn -aurpN sys/conf/kern.mk sys/conf/kern.mk
--- sys/conf/kern.mk	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/kern.mk	2009-10-01 10:41:59.000000000 +0800
@@ -12,7 +12,7 @@ CWARNFLAGS=
 .else
 CWARNFLAGS?=	-Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes \
 		-Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual \
-		${_wundef} ${_Wno_pointer_sign} -fformat-extensions
+		${_wundef} ${_Wno_pointer_sign} -fformat-extensions -fgnu89-inline
 .if !defined(WITH_GCC3)
 _Wno_pointer_sign=-Wno-pointer-sign
 .endif
diff -x CVS -x .svn -aurpN sys/conf/kmod.mk sys/conf/kmod.mk
--- sys/conf/kmod.mk	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/kmod.mk	2009-10-01 10:41:59.000000000 +0800
@@ -334,7 +334,7 @@ MFILES?= dev/acpica/acpi_if.m dev/acpi_s
 	kern/bus_if.m kern/clock_if.m \
 	kern/cpufreq_if.m kern/device_if.m kern/serdev_if.m \
 	libkern/iconv_converter_if.m opencrypto/cryptodev_if.m \
-	pc98/pc98/canbus_if.m
+	pc98/pc98/canbus_if.m dev/kgc/scroller_if.m dev/kgc/render_if.m
 
 .for _srcsrc in ${MFILES}
 .for _ext in c h
diff -x CVS -x .svn -aurpN sys/conf/options sys/conf/options
--- sys/conf/options	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/options	2009-10-01 10:41:59.000000000 +0800
@@ -534,6 +534,21 @@ LOCKF_DEBUG		opt_debug_lockf.h
 NETATALKDEBUG		opt_atalk.h
 SI_DEBUG		opt_debug_si.h
 
+# KGI options
+KGI_COMPAT		opt_kgi.h
+KGI_DBG_LEVEL		opt_kgi.h
+KGC_DEFAULT_FONT	opt_kgi.h
+KGI_IGNORE_VGAPCI       opt_kgi.h
+KGC_RENDER_BACKGROUND	opt_kgi.h
+KGC_RENDER_1280x1024	opt_kgi.h
+KGC_RENDER_1024x768	opt_kgi.h 
+KGC_RENDER_800x600	opt_kgi.h 
+KGC_RENDER_640x480	opt_kgi.h 
+KGC_RENDER_640x400	opt_kgi.h 
+KGC_RENDER_320x240	opt_kgi.h 
+KGC_RENDER_320x200	opt_kgi.h 
+KGC_RENDER_16BITS	opt_kgi.h
+
 # Fb options
 FB_DEBUG		opt_fb.h
 FB_INSTALL_CDEV		opt_fb.h
diff -x CVS -x .svn -aurpN sys/conf/options.i386 sys/conf/options.i386
--- sys/conf/options.i386	2009-08-22 13:06:21.000000000 +0800
+++ sys/conf/options.i386	2009-10-01 10:41:59.000000000 +0800
@@ -91,6 +91,10 @@ VESA_DEBUG		opt_vesa.h
 # AGP debugging support
 AGP_DEBUG		opt_agp.h
 
+KGI_NOSPLASH		opt_kgi.h
+CONFIG_FB_ATY_GX	opt_kgi.h
+CONFIG_FB_ATY_CT	opt_kgi.h
+
 PSM_DEBUG		opt_psm.h
 PSM_HOOKRESUME		opt_psm.h
 PSM_RESETAFTERSUSPEND	opt_psm.h
diff -x CVS -x .svn -aurpN sys/dev/fb/fb.c sys/dev/fb/fb.c
--- sys/dev/fb/fb.c	2009-08-22 13:07:08.000000000 +0800
+++ sys/dev/fb/fb.c	2009-10-01 10:41:59.000000000 +0800
@@ -533,6 +533,7 @@ static char
 	{ KD_VGA,	"VGA" },
 	{ KD_PC98,	"PC-98x1" },
 	{ KD_TGA,	"TGA" },
+	{ KD_KGI,	"KGI" },
 	{ -1,		"Unknown" },
     };
     int i;
@@ -608,6 +609,7 @@ fb_type(int adp_type)
 		{ FBTYPE_VGA,		KD_VGA },
 		{ FBTYPE_PC98,		KD_PC98 },
 		{ FBTYPE_TGA,		KD_TGA },
+		{ FBTYPE_KGI,		KD_KGI },
 	};
 	int i;
 
diff -x CVS -x .svn -aurpN sys/dev/fb/kgia.c sys/dev/fb/kgia.c
--- sys/dev/fb/kgia.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/fb/kgia.c	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,561 @@
+/*-
+ * Copyright (C) 2002 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+ 
+/*
+ * KGI vidsw emulation driver
+ */
+
+/*
+ * XXX
+ * Currently this is only a complementary video_switch like VESA.
+ * Later, it should be a true adapter/video driver like TGA/GFB coupled with
+ * a syscons renderer.
+ * XXX
+ */
+
+#include <kgi/maintainers.h>
+#define	MAINTAINER	Nicholas_Souchu
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/fbio.h>
+
+#include <dev/fb/fbreg.h>
+#include <dev/fb/vgareg.h>
+
+#define	DEBUG_LEVEL	2
+
+#define	KGI_SYS_NEED_IO
+#include <kgi/system.h>
+#include <kgi/debug.h>
+
+#include <kgi/kgii.h>
+#include <kgi/kgi.h>
+
+static int kgia_init_done = 0;
+
+static video_switch_t *prevvidsw;
+static video_adapter_t *kgia_adp = NULL;
+
+struct kgia_data
+{
+#ifdef kii_used
+	kii_device_t		kii;
+#endif
+	kgi_device_t		kgi;
+	kgi_mode_t		kgimode;
+
+	kgi_mmio_region_t	*mmio;
+	kgi_text16_t		*text16;
+	kgi_ilut_t		*ilut;
+	kgi_tlut_t		*tlut;
+	kgi_marker_t		*cur;
+	kgi_marker_t		*ptr;
+	kgi_font_t		*font;
+
+	kgi_ucoord_t		visible; /* visible size of buffer	*/
+} kgia;
+
+static int
+kgia_error(void)
+{
+
+	return (1);
+}
+
+static int
+kgia_probe(int unit, video_adapter_t **adpp, void *arg, int flags)
+{
+
+	return ((*prevvidsw->probe)(unit, adpp, arg, flags));
+}
+
+static int
+kgia_init(int unit, video_adapter_t *adp, int flags)
+{
+
+	return ((*prevvidsw->init)(unit, adp, flags));
+}
+
+static int
+kgia_get_info(video_adapter_t *adp, int mode, video_info_t *info)
+{
+	/* 
+	 * XXX Bypass the KGI framework to provide directly the mode info XXX
+	 */
+	return ((*prevvidsw->get_info)(adp, mode, info));
+}
+
+static int
+kgia_query_mode(video_adapter_t *adp, video_info_t *info)
+{
+	kgi_device_t k;
+	kgi_mode_t m;
+
+	memset(&m.img[0], 0, sizeof(info));
+	m.images = 1;
+
+	if (!(info->vi_flags & V_INFO_GRAPHICS))
+		goto (error);
+
+	m.img[0].fam |= KGI_AM_COLORS;
+
+	switch (info->vi_depth) {
+	case 16:			/* XXX only 16 bit modes */
+	default:
+		m.img[0].bpfa[0] = 5;
+		m.img[0].bpfa[1] = 6;
+		m.img[0].bpfa[2] = 5;
+		break;
+	}
+	m.img[0].size.x = m.img[0].virt.x = info->vi_width;
+	m.img[0].size.y = m.img[0].virt.y = info->vi_height;	
+	
+	k.mode = &m;
+
+	if (kgi_register_device(&k, 0) != KGI_EOK)
+		goto (error);
+
+	kgi_unregister_device(&k);
+
+	return (0);
+
+ error:
+	return (ENODEV);
+}
+
+static int
+kgia_set_mode(video_adapter_t *adp, int mode)
+{
+	kgi_image_mode_t kgi_mode;
+
+	/* XXX refuse other modes than 640x480x4 */
+	if (mode != M_CG640x480)
+		return (EINVAL);
+
+	if (kgia.kgi.flags & KGI_DF_FOCUSED)
+		kgi_unmap_device(kgia.kgi.id);
+
+	/* XXX search mode according to mode index */
+	memset(&kgi_mode, 0, sizeof(kgi_mode));
+	kgi_mode.fam |= KGI_AM_COLORS;
+	kgi_mode.cam |= KGI_AM_COLOR_INDEX;
+	kgi_mode.bpfa[0] = 4;
+	kgi_mode.bpfa[1] = 0;
+	kgi_mode.size.x = kgi_mode.virt.x = 640;
+	kgi_mode.size.y = kgi_mode.virt.y = 480;
+
+	kgia.kgi.mode->img[0] = kgi_mode;
+
+	kgi_map_device(kgia.kgi.id);
+
+	return (0);
+}
+
+static int
+kgia_save_font(video_adapter_t *adp, int page, int fontsize, u_char *data,
+	       int ch, int count)
+{
+
+	if (!kgia.font)
+		return (EINVAL);
+
+	kgia.font->Save(kgia.font, page, fontsize, data, ch, count);
+
+	return (0);
+}
+
+static int
+kgia_load_font(video_adapter_t *adp, int page, int fontsize, u_char *data,
+	       int ch, int count)
+{
+
+	if (!kgia.font)
+		return (EINVAL);
+
+	kgia.font->Load(kgia.font, page, fontsize, data, ch, count);
+
+	return (0);
+}
+
+static int
+kgia_show_font(video_adapter_t *adp, int page)
+{
+
+	if (!kgia.font)
+		return (EINVAL);
+
+	kgia.font->Show(kgia.font, page);
+
+	return (0);
+}
+
+static int
+kgia_save_palette(video_adapter_t *adp, u_char *palette)
+{
+
+	return (1);
+}
+
+static int
+kgia_load_palette(video_adapter_t *adp, u_char *palette)
+{
+
+	return (1);
+}
+
+static int
+kgia_set_border(video_adapter_t *adp, int color)
+{
+
+	return ((*prevvidsw->set_border)(adp, color));
+}
+
+static int
+kgia_save_state(video_adapter_t *adp, void *p, size_t size)
+{
+
+	return ((*prevvidsw->save_state)(adp, p, size));
+}
+
+static int
+kgia_load_state(video_adapter_t *adp, void *p)
+{
+
+	return ((*prevvidsw->load_state)(adp, p));
+}
+
+static int
+kgia_set_origin(video_adapter_t *adp, off_t offset)
+{
+
+	if (!kgia.mmio)
+		return (EINVAL);
+
+	kgia.mmio->SetOffset(kgia.mmio, (kgi_size_t)offset);
+
+	return (0);
+}
+
+static int
+kgia_read_hw_cursor(video_adapter_t *adp, int *col, int *row)
+{
+
+	return (1);
+}
+
+static int
+kgia_set_hw_cursor(video_adapter_t *adp, int col, int row)
+{
+
+	return (1);
+}
+
+static int
+kgia_set_hw_cursor_shape(video_adapter_t *adp, int base, int height,
+			 int celsize, int blink)
+{
+
+	return (1);
+}
+
+static int
+kgia_blank_display(video_adapter_t *adp, int mode) 
+{
+
+	return ((*prevvidsw->blank_display)(adp, mode));
+}
+
+static int
+kgia_mmap(video_adapter_t *adp, vm_offset_t offset, int prot)
+{
+
+	return (1);
+}
+
+static int
+kgia_clear(video_adapter_t *adp)
+{
+
+	return (1);
+}
+
+static int
+kgia_fill_rect(video_adapter_t *adp, int val, int x, int y, int cx, int cy)
+{
+
+	return (1);
+}
+
+static int
+kgia_bitblt(video_adapter_t *adp,...)
+{
+
+	return (1);
+}
+
+static int
+kgia_ioctl(video_adapter_t *adp, u_long cmd, caddr_t arg)
+{
+
+	return (1);
+} 
+
+static int
+kgia_diag(video_adapter_t *adp, int level)
+{
+
+	return (1);
+}
+
+static video_switch_t kgividsw = {
+	kgia_probe,
+	kgia_init,
+	kgia_get_info,
+	kgia_query_mode,
+	kgia_set_mode,
+	kgia_save_font,
+	kgia_load_font,
+	kgia_show_font,
+	kgia_save_palette,
+	kgia_load_palette,
+	kgia_set_border,
+	kgia_save_state,
+	kgia_load_state,
+	kgia_set_origin,
+	kgia_read_hw_cursor,
+	kgia_set_hw_cursor,
+	kgia_set_hw_cursor_shape,
+	kgia_blank_display,
+	kgia_mmap,
+	kgia_ioctl,
+	kgia_clear,
+	kgia_fill_rect,
+	kgia_bitblt,
+	kgia_error,
+	kgia_error,
+	kgia_diag,
+};
+
+static int
+kgia_configure(int flags)
+{
+	int error = 0;
+	int i;
+	video_adapter_t *adp;
+
+	kgi_u_t	index = 0;
+	kgi_resource_t *resource;
+	kgi_marker_t *marker;
+
+	/*
+	 * If the kgia module has already been loaded, abort loading 
+	 * the module this time.
+	 */
+	for (i = 0; (adp = vid_get_adapter(i)) != NULL; ++i) {
+		if (adp->va_flags & V_ADP_KGI)
+			return (ENXIO);
+		if (adp->va_type == KD_VGA)
+			break;
+	}
+
+	/*
+	 * The VGA adapter is not found.  This is because either 
+	 * 1) the VGA driver has not been initialized, or 2) the VGA card
+	 * is not present.  If 1) is the case, we shall defer
+	 * initialization for now and try again later.
+	 */
+
+	/* XXX may collide with VESA */
+	if (adp == NULL) {
+		vga_sub_configure = kgia_configure;
+		return (ENODEV);
+	}
+
+	kgia_adp = adp;
+	kgia_adp->va_flags |= V_ADP_KGI;
+
+	/* Check that a kgi display is registered */
+	if (kgi_display_registered(0) != KGI_EOK) {
+		error = (ENODEV);
+		goto end;
+	}
+
+	/* Register the adapter as a KGI device */
+	if ((error = kgi_register_device(&(kgia.kgi), 0)) != KGI_EOK) 
+		goto end;
+
+	while ((index < __KGI_MAX_NR_IMAGE_RESOURCES) &&
+	       (resource = kgia.kgi.mode->img[0].resource[index])) {		
+		switch (resource->type) {			
+		case KGI_RT_MMIO_FRAME_BUFFER:
+			KRN_DEBUG(2, "mmio: %s", resource->name);
+			kgia.mmio = (kgi_mmio_region_t *) resource;
+			break;			
+		case KGI_RT_TEXT16_CONTROL:
+			KRN_DEBUG(2, "text16: %s", resource->name);
+			kgia.text16 = (kgi_text16_t *) resource;
+			break;			
+		case KGI_RT_CURSOR_CONTROL:
+			marker = (kgi_marker_t *) resource;
+			if ((NULL == kgia.cur) ||
+			    (kgia.cur->Undo && (NULL == marker->Undo))) {				
+				KRN_DEBUG(2, "cursor: %s", resource->name);
+				kgia.cur = marker;
+			}
+			break;			
+		case KGI_RT_POINTER_CONTROL:
+			marker = (kgi_marker_t *) resource;
+			if ((NULL == kgia.ptr) ||
+			    (kgia.ptr->Undo && (NULL == marker->Undo))) {				
+				KRN_DEBUG(2, "pointer: %s", resource->name);
+				kgia.ptr = marker;
+			}
+			break;			
+		case KGI_RT_TLUT_CONTROL:
+			KRN_DEBUG(2, "tlut: %s", resource->name);
+			kgia.tlut = (kgi_tlut_t *) resource;
+			break;			
+		case KGI_RT_ILUT_CONTROL:
+			KRN_DEBUG(2, "ilut: %s", resource->name);
+			kgia.ilut = (kgi_ilut_t *) resource;
+			break;
+		case KGI_RT_FONT_CONTROL:
+			KRN_DEBUG(2, "font: %s", resource->name);
+			kgia.font = (kgi_font_t *) resource;
+			break;
+		default:
+			break;
+		}
+		index++;
+	}
+	
+	if (! (kgia.text16)) {
+		KRN_DEBUG(1, "could not get text16 resource "
+			  "(text16 %p, cur %p, ptr %p)",
+			  kgia.text16, kgia.cur, kgia.ptr);
+		return (EINVAL);
+	}
+
+	kgia.visible.x = kgia.text16->size.x;
+	kgia.visible.y = kgia.text16->size.y;
+
+	kgia.kgimode.images = 1;
+	kgia.kgimode.img[0].flags |= KGI_IF_TEXT16;
+
+	kgia.kgi.mode = &(kgia.kgimode);
+	kgia.kgi.flags |= KGI_DF_CONSOLE;
+	kgia.kgi.priv.priv_ptr = &kgia;
+	
+#ifdef kii_used
+	kgia.kii.tty = current->tty;
+	kgia.kii.flags |= KII_DF_CONSOLE;
+	kgia.kii.priv.priv_ptr = kgia;
+#endif
+	kgia.kgi.MapDevice = NULL;
+	kgia.kgi.UnmapDevice = NULL;
+	kgia.kgi.HandleEvent = NULL;
+
+	if (!kgi_current_focus(kgia.kgi.dpy_id)) {
+		kgi_map_device(kgia.kgi.id);
+#ifdef kii_used
+		if (! kii_current_focus(kgia.kgi.kii.focus_id))
+			kii_map_device(kgia.kgi.kii.id);
+#endif
+	}
+
+ end:
+	if (error) {
+		kgia_adp = NULL;
+		return (error);
+	}
+
+	prevvidsw = vidsw[kgia_adp->va_index];
+	vidsw[kgia_adp->va_index] = &kgividsw;
+	kgia_init_done = TRUE;
+
+	return (0);
+}
+
+static int
+kgia_load(void)
+{
+	int error = 0;
+	int s;
+
+	if (kgia_init_done)
+		return (0);
+
+	/* locate a VGA adapter */
+	s = spltty();
+	kgia_adp = NULL;
+	error = kgia_configure(0);
+	splx(s);
+
+	return (error);
+}
+
+static int
+kgia_unload(void)
+{
+	int error = 0;
+	int s;
+
+	s = spltty();
+	if (kgia_adp != NULL) {
+#ifdef kii_used
+		if (kgia.kii.flags & KII_DF_FOCUSED) 
+			kii_unmap_device(kgia.kii.id);
+#endif
+		if (kgia.kgi.flags & KGI_DF_FOCUSED) 
+			kgi_unmap_device(kgia.kgi.id);
+#ifdef kii_used
+		kii_unregister_device(&(kgia.kii));
+#endif
+		kgi_unregister_device(&(kgia.kgi));
+
+		kgia_adp->va_flags &= ~V_ADP_KGI;
+		vidsw[kgia_adp->va_index] = prevvidsw;
+	}
+	splx(s);
+
+	return (error);
+}
+
+static int
+kgia_mod_event(module_t mod, int type, void *data)
+{
+	switch (type) {
+	case MOD_LOAD:
+		return (kgia_load());
+	case MOD_UNLOAD:
+		return (kgia_unload());
+	default:
+		break;
+	}
+	return (0);
+}
+
+static moduledata_t kgia_mod = {
+	"kgia",
+	kgia_mod_event,
+	NULL,
+};
+
+DECLARE_MODULE(kgia, kgia_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);
+MODULE_VERSION(kgia, 1);
+
+#include <kgi/kgi_version.h>
+MODULE_DEPEND(kgia, kgi, KGI_MINVER, KGI_PREFVER, KGI_MAXVER);
+MODULE_DEPEND(kgia, dpysw, 1, 1, 1);
\ No newline at end of file
diff -x CVS -x .svn -aurpN sys/dev/kbd/kbd.c sys/dev/kbd/kbd.c
--- sys/dev/kbd/kbd.c	2009-08-22 13:07:02.000000000 +0800
+++ sys/dev/kbd/kbd.c	2009-10-01 10:42:00.000000000 +0800
@@ -87,6 +87,8 @@ SYSCTL_INT(_hw_kbd, OID_AUTO, keymap_res
 
 #define ARRAY_DELTA	4
 
+void kip_kbd_register(keyboard_t *kbd, int index);
+
 static int
 kbd_realloc_array(void)
 {
@@ -227,7 +229,7 @@ kbd_register(keyboard_t *kbd)
 				kbdd_ioctl(mux, KBADDKBD, (caddr_t) &ki);
 			}
 
-			return (index);
+			goto found;
 		}
 	}
 	SET_FOREACH(list, kbddriver_set) {
@@ -244,11 +246,15 @@ kbd_register(keyboard_t *kbd)
 				kbdd_ioctl(mux, KBADDKBD, (caddr_t) &ki);
 			}
 
-			return (index);
+			goto found;
 		}
 	}
 
 	return (-1);
+
+found:
+	kip_kbd_register(kbd, index); /* XXX hardwired. */
+	return (index);
 }
 
 int
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-color sys/dev/kgc/default-color
--- sys/dev/kgc/default-color	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-color	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,25 @@
+/* 
+ * Default ANSI textmode palette.
+ */
+#define	I(x)	((0xFFFF * (x))/100)
+
+const kgi_u16_t default_color_text16_ilut[3*16] =
+{
+	I(  0), I(  0), I(  0),		/* black		*/
+	I(  0), I(  0), I( 66),		/* blue			*/
+	I(  0), I( 66), I(  0),		/* green		*/
+	I(  0), I( 66), I( 66),		/* cyan			*/
+	I( 66), I(  0), I(  0),		/* red			*/
+	I( 66), I(  0), I( 66),		/* magenta		*/
+	I( 66), I( 66), I(  0),		/* brown		*/
+	I( 66), I( 66), I( 66),		/* light gray		*/
+	I( 33), I( 33), I( 33),		/* dark gray		*/
+	I( 33), I( 33), I(100),		/* light blue		*/
+	I( 33), I(100), I( 33),		/* light green		*/
+	I( 33), I(100), I(100),		/* light cyan		*/
+	I(100), I( 33), I( 33),		/* light red		*/
+	I(100), I( 33), I(100),		/* light magenta	*/
+	I(100), I(100), I( 33),		/* yellow		*/
+	I(100), I(100), I(100)		/* white		*/
+};
+#undef	I
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-font-ibm437 sys/dev/kgc/default-font-ibm437
--- sys/dev/kgc/default-font-ibm437	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-font-ibm437	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,210 @@
+/*
+ * Mapping info to map iso10646 characters to IBM codepage 437
+ */
+
+#define	NONE	0x00
+
+static kgi_u8_t default_font_ibm437_info_00[256] =
+{	0x00, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0xff, 0xad, 0x9b, 0x9c, NONE, 0x9d, NONE, 0x15,
+	NONE, NONE, 0xa6, 0xae, 0xaa, NONE, NONE, NONE,
+	0xf8, 0xf1, 0xfd, NONE, NONE, 0xe6, 0x14, 0xfa,
+	NONE, NONE, 0xa7, 0xaf, 0xac, 0xab, NONE, 0xa8,
+	NONE, NONE, NONE, NONE, 0x8e, 0x8f, 0x92, 0x80,
+	NONE, 0x90, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, 0xa5, NONE, NONE, NONE, NONE, 0x99, NONE,
+	NONE, NONE, NONE, NONE, 0x9a, NONE, NONE, 0xe1,
+	0x85, 0xa0, 0x83, NONE, 0x84, 0x86, 0x91, 0x87,
+	0x8a, 0x82, 0x88, 0x89, 0x8d, 0xa1, 0x8c, 0x8b,
+	NONE, 0xa4, 0x95, 0xa2, 0x93, NONE, 0x94, 0xf6,
+	NONE, 0x97, 0xa3, 0x96, 0x81, NONE, NONE, 0x98
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_01[] =
+{	{ 0x0192, 1 },
+	{ 0x0192, 0x9f }
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_03[] =
+{	{ 0x03c6, 12 },
+	{ 0x0393, 0xe2 }, { 0x0398, 0xe9 }, { 0x03a3, 0xe4 }, { 0x03a6, 0xe8 },
+	{ 0x03a9, 0xea }, { 0x03b1, 0xe0 }, { 0x03b4, 0xeb }, { 0x03b5, 0xee },
+	{ 0x03c0, 0xe3 }, { 0x03c3, 0xe5 }, { 0x03c4, 0xe7 }, { 0x03c6, 0xed }
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_20[] =
+{	{ 0x20a7, 4 },
+	{ 0x2022, 0x07 }, { 0x203c, 0x13 }, { 0x207f, 0xfc }, { 0x20a7, 0x9e }
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_21[] =
+{	{ 0x21a8, 7 },
+	{ 0x2190, 0x1b }, { 0x2191, 0x18 }, { 0x2192, 0x1a }, { 0x2193, 0x19 },
+	{ 0x2194, 0x1d }, { 0x2195, 0x12 }, { 0x21a8, 0x17 }
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_22[] =
+{	{ 0x2265, 9 },
+	{ 0x2219, 0xf9 }, { 0x221a, 0xfb }, { 0x221e, 0xec }, { 0x221f, 0x1c },
+	{ 0x2229, 0xef }, { 0x2248, 0xf7 }, { 0x2261, 0xf0 }, { 0x2264, 0xf3 },
+	{ 0x2265, 0xf2 }
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_23[] =
+{	{ 0x2321, 4 },
+	{ 0x2302, 0x7f }, { 0x2310, 0xa9 }, { 0x2320, 0xf4 }, { 0x2321, 0xf5 }
+};
+
+static kgi_u8_t default_font_ibm437_info_25[256] =
+{	0xc4, NONE, 0xb3, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0xda, NONE, NONE, NONE,
+	0xbf, NONE, NONE, NONE, 0xc0, NONE, NONE, NONE,
+	0xd9, NONE, NONE, NONE, 0xc3, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0xb4, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0xc2, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0xc1, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0xc5, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0xcd, 0xba, 0xd5, 0xd6, 0xc9, 0xb8, 0xb7, 0xbb,
+	0xd4, 0xd3, 0xc8, 0xbe, 0xbd, 0xbc, 0xc6, 0xc7,
+	0xcc, 0xb5, 0xb6, 0xb9, 0xd1, 0xd2, 0xcb, 0xcf,
+	0xd0, 0xca, 0xd8, 0xd7, 0xce, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0xdf, NONE, NONE, NONE, 0xdc, NONE, NONE, NONE,
+	0xdb, NONE, NONE, NONE, 0xdd, NONE, NONE, NONE,
+	0xde, 0xb0, 0xb1, 0xb2, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0xfe, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, 0x16, NONE, NONE, NONE,
+	NONE, NONE, 0x1e, NONE, NONE, NONE, 0x10, NONE,
+	NONE, NONE, NONE, NONE, 0x1f, NONE, NONE, NONE,
+	0x11, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, 0x09, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	0x08, 0x0a, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
+	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE
+};
+
+static kgi_console_font_cellinfo_t default_font_ibm437_info_26[] =
+{	{ 0x266b, 11 },
+	{ 0x263a, 0x01 }, { 0x263b, 0x02 }, { 0x263c, 0x0f }, { 0x2640, 0x0c },
+	{ 0x2642, 0x0b }, { 0x2660, 0x06 }, { 0x2663, 0x05 }, { 0x2665, 0x03 },
+	{ 0x2666, 0x04 }, { 0x266a, 0x0d }, { 0x266b, 0x0e }
+};
+
+#define	I(x)	default_font_ibm437_info_##x
+static kgi_console_font_info_t default_font_ibm437_info =
+{
+	256,		/* number font positions	*/
+	'?' /* NONE */,		/* default font position	*/
+	{	0x00000001, 0x00000020, 0x00000000, 0x00000000,
+		0x00000000, 0x00000000, 0x00000000, 0x00000000
+	},
+	{	I(00),I(01),NULL, I(03),NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		I(20),I(21),I(22),I(23),NULL, I(25),I(26),NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+	},
+	{	0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
+		0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
+		0x25b6, 0x25c0, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
+		0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
+		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+		0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
+		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+		0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
+		0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+		0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
+		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+		0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
+		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+		0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
+		0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
+		0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
+		0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
+		0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
+		0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
+		0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
+		0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
+		0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
+		0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
+		0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
+		0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
+		0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
+		0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
+		0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
+		0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
+		0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
+	}
+};
+#undef	I
+
+#ifdef CONFIG_ISO_FONT_9x16
+#	include <kgc/default-font-ibm437-09x16>
+#	undef	CONFIG_ISO_FONT_9x16
+#	define	CONFIG_ISO_FONT_9x16	&default_font_ibm437_9x16,
+#endif
+#ifdef CONFIG_ISO_FONT_8x14
+#	include <kgc/default-font-ibm437-08x14>
+#	undef	CONFIG_ISO_FONT_8x14
+#	define	CONFIG_ISO_FONT_8x14	&default_font_ibm437_8x14,
+#endif
+#ifdef CONFIG_ISO_FONT_8x8
+#	include <kgc/default-font-ibm437-08x08>
+#	undef	CONFIG_ISO_FONT_8x8
+#	define	CONFIG_ISO_FONT_8x8	&default_font_ibm437_8x8,
+#endif
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-font-ibm437-08x08 sys/dev/kgc/default-font-ibm437-08x08
--- sys/dev/kgc/default-font-ibm437-08x08	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-font-ibm437-08x08	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,273 @@
+/*
+ * 8x8 standard VGA font (IBM codepage 437)
+ */
+
+static kgi_u8_t default_font_ibm437_data_8x8[] =
+{
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
+	0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,
+	0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
+	0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00,
+	0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x92, 0x10, 0x7C,
+	0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C,
+	0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
+	0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,
+	0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
+	0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,
+	0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
+	0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
+	0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
+	0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,
+	0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
+	0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,
+	0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
+	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,
+	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
+	0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00,
+	0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0x86, 0xFC,
+	0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,
+	0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
+	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
+	0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00,
+	0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
+	0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00,
+	0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
+	0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,
+	0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,
+	0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
+	0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
+	0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
+	0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
+	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
+	0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
+	0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
+	0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
+	0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
+	0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
+	0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
+	0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00,
+	0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00,
+	0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
+	0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
+	0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00,
+	0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
+	0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00,
+	0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00,
+	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
+	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
+	0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00,
+	0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
+	0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
+	0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
+	0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
+	0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,
+	0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,
+	0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
+	0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
+	0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
+	0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
+	0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00,
+	0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
+	0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
+	0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
+	0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,
+	0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
+	0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
+	0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
+	0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
+	0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00,
+	0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
+	0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00,
+	0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00,
+	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00,
+	0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
+	0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
+	0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
+	0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
+	0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
+	0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
+	0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
+	0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
+	0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00,
+	0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00,
+	0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
+	0x38, 0x6C, 0x64, 0xF0, 0x60, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
+	0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00,
+	0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78,
+	0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
+	0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xD6, 0x00,
+	0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
+	0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0,
+	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
+	0x00, 0x00, 0xDC, 0x76, 0x62, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x7C, 0xC0, 0x70, 0x1C, 0xF8, 0x00,
+	0x10, 0x30, 0xFC, 0x30, 0x30, 0x34, 0x18, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
+	0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
+	0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00,
+	0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00,
+	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
+	0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
+	0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
+	0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x0C, 0x06, 0x7C,
+	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
+	0x7E, 0x81, 0x3C, 0x06, 0x3E, 0x66, 0x3B, 0x00,
+	0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
+	0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
+	0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC0, 0x78, 0x0C, 0x38,
+	0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,
+	0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
+	0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
+	0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0x7C, 0x82, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
+	0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0xC6, 0x10, 0x7C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
+	0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00,
+	0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00,
+	0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
+	0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00,
+	0x78, 0x84, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
+	0x78, 0x84, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
+	0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,
+	0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
+	0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18,
+	0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00,
+	0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x30, 0xFC, 0x30,
+	0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC3,
+	0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
+	0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
+	0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
+	0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0xF8, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0x00,
+	0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00,
+	0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00,
+	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
+	0x18, 0x00, 0x18, 0x18, 0x30, 0x66, 0x3C, 0x00,
+	0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00,
+	0xC6, 0xCC, 0xD8, 0x36, 0x6B, 0xC2, 0x84, 0x0F,
+	0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6D, 0xCF, 0x03,
+	0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,
+	0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,
+	0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,
+	0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
+	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
+	0xDB, 0xF6, 0xDB, 0x6F, 0xDB, 0x7E, 0xD7, 0xED,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36,
+	0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
+	0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
+	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00,
+	0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
+	0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
+	0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
+	0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00,
+	0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
+	0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0,
+	0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
+	0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC,
+	0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
+	0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00,
+	0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,
+	0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
+	0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00,
+	0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
+	0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,
+	0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,
+	0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00,
+	0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
+	0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
+	0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,
+	0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
+	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
+	0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
+	0x58, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
+	0x70, 0x98, 0x30, 0x60, 0xF8, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static kgi_console_font_t default_font_ibm437_8x8 =
+{
+	{ 8, 8 },	/* character cell	*/
+	{ 8, 8 },	/* bitmap size		*/
+	6,		/* base line		*/
+
+	&default_font_ibm437_info,
+	 default_font_ibm437_data_8x8
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-font-ibm437-08x14 sys/dev/kgc/default-font-ibm437-08x14
--- sys/dev/kgc/default-font-ibm437-08x14	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-font-ibm437-08x14	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,465 @@
+/*
+ * 8x14 standard VGA font (IBM codepage 437)
+ */
+
+static kgi_u8_t default_font_ibm437_data_8x14[] =
+{
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81,
+	0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xFF,
+	0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE,
+	0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C,
+	0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x99, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,
+	0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+	0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3,
+	0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFF, 0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32,
+	0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18,
+	0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x70, 0xF0,
+	0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x63,
+	0x7F, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C,
+	0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF8, 0xFE, 0xF8,
+	0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x02, 0x06, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x06,
+	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,
+	0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B,
+	0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x7C,
+	0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38,
+	0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18,
+	0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60,
+	0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0,
+	0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x28, 0x6C, 0xFE, 0x6C, 0x28, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
+	0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C,
+	0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66,
+	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C,
+	0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06,
+	0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x66,
+	0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6C,
+	0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30,
+	0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18,
+	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
+	0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18,
+	0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6,
+	0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6,
+	0x06, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06,
+	0x3C, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
+	0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFE, 0xC0, 0xC0, 0xFC, 0x0E, 0x06, 0x06, 0xC6,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x60,
+	0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0xC6, 0x06, 0x0C,
+	0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
+	0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x0C,
+	0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+	0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30,
+	0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30,
+	0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C,
+	0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE,
+	0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6,
+	0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x66,
+	0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0,
+	0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66,
+	0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x66,
+	0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0,
+	0xC0, 0xDE, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x0C,
+	0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xE6, 0x66, 0x6C, 0x6C,
+	0x78, 0x6C, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
+	0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xE6,
+	0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
+	0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C,
+	0x0C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x66,
+	0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0xE6, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60,
+	0x38, 0x0C, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xD6, 0xD6, 0xFE, 0x7C, 0x6C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x38,
+	0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC6,
+	0x8C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x3C, 0x30, 0x30, 0x30,
+	0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C,
+	0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x3C, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
+	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC,
+	0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x60,
+	0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0xDC, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,
+	0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
+	0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6C,
+	0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76,
+	0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
+	0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
+	0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06,
+	0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66,
+	0x3C, 0x00, 0x00, 0x00, 0xE0, 0x60, 0x60, 0x66,
+	0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6,
+	0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
+	0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0x7C,
+	0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xDC, 0x76, 0x62, 0x60, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,
+	0xC6, 0x70, 0x1C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
+	0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+	0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6,
+	0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
+	0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E,
+	0x06, 0x0C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xFE, 0xCC, 0x18, 0x30, 0x66, 0xFE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x0E, 0x18, 0x18, 0x18,
+	0x70, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
+	0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18,
+	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38,
+	0x6C, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC2,
+	0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00, 0x00,
+	0xCC, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
+	0x76, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x18, 0x30,
+	0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0x00, 0x78,
+	0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x60,
+	0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC,
+	0x76, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6C, 0x38,
+	0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66,
+	0x60, 0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00,
+	0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xCC, 0xCC, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18,
+	0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x00, 0x38,
+	0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x60,
+	0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x10,
+	0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
+	0x00, 0x00, 0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C,
+	0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x00, 0x00,
+	0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C,
+	0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xCC, 0x76, 0x36, 0x7E, 0xD8, 0xD8,
+	0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x6C,
+	0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCE, 0x00,
+	0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x60,
+	0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0xCC,
+	0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
+	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x00, 0xCC,
+	0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6,
+	0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00, 0x00, 0xC6,
+	0xC6, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C,
+	0x38, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x00,
+	0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC0,
+	0xC0, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60,
+	0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xCC, 0xCC,
+	0xF8, 0xC4, 0xCC, 0xDE, 0xCC, 0xCC, 0xC6, 0x00,
+	0x00, 0x00, 0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18,
+	0x7E, 0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00,
+	0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x0C,
+	0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
+	0x3C, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x60,
+	0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x30, 0x60, 0x00, 0xCC,
+	0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x76, 0xDC,
+	0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6,
+	0xC6, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x6C, 0x6C,
+	0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00,
+	0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60,
+	0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC6, 0xCC, 0xD8,
+	0x30, 0x60, 0xCE, 0x93, 0x06, 0x0C, 0x1F, 0x00,
+	0x00, 0xC0, 0xC0, 0xC6, 0xCC, 0xD8, 0x30, 0x66,
+	0xCE, 0x9A, 0x3F, 0x06, 0x0F, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x3C,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x66,
+	0x33, 0x66, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
+	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x55, 0xAA,
+	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
+	0x55, 0xAA, 0x55, 0xAA, 0xDD, 0x77, 0xDD, 0x77,
+	0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
+	0xDD, 0x77, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
+	0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF,
+	0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
+	0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8,
+	0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC,
+	0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFE, 0xC6,
+	0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
+	0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18, 0x30,
+	0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8,
+	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66, 0x66,
+	0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x6C,
+	0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6C,
+	0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x6C, 0xEE, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C,
+	0x3E, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB,
+	0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x03, 0x06, 0x7E, 0xCF, 0xDB, 0xF3, 0x7E, 0x60,
+	0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x30,
+	0x60, 0x60, 0x7C, 0x60, 0x60, 0x30, 0x1C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00,
+	0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
+	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18,
+	0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60,
+	0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8,
+	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+	0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC,
+	0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0C, 0xEC, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00,
+	0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	0x98, 0x30, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static kgi_console_font_t default_font_ibm437_8x14 =
+{
+	{ 8, 14 },		/* character cell	*/
+	{ 8, 14 },		/* bitmap size		*/
+	10,			/* base line		*/
+
+	&default_font_ibm437_info,
+	 default_font_ibm437_data_8x14
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-font-ibm437-09x16 sys/dev/kgc/default-font-ibm437-09x16
--- sys/dev/kgc/default-font-ibm437-09x16	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-font-ibm437-09x16	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,529 @@
+/*
+ * 9x16 standard VGA font (IBM codepage 437) 
+ */
+
+static kgi_u8_t default_font_ibm437_data_9x16[] =
+{
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD,
+	0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3,
+	0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE,
+	0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE,
+	0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7,
+	0xE7, 0x99, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF,
+	0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,
+	0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3,
+	0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42,
+	0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD,
+	0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C,
+	0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30,
+	0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63,
+	0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7,
+	0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8,
+	0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E,
+	0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
+	0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B,
+	0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6,
+	0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
+	0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE,
+	0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE,
+	0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0,
+	0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE,
+	0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C,
+	0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C,
+	0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
+	0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C,
+	0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06,
+	0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18,
+	0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30,
+	0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF,
+	0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E,
+	0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18,
+	0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xD6, 0xD6,
+	0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30,
+	0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06,
+	0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
+	0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x0E,
+	0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18,
+	0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06,
+	0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60,
+	0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00,
+	0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06,
+	0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18,
+	0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE,
+	0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66,
+	0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
+	0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
+	0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
+	0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE,
+	0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xE6, 0x66, 0x6C, 0x6C, 0x78, 0x78,
+	0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
+	0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
+	0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
+	0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C,
+	0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C,
+	0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6,
+	0xD6, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x6C, 0x38, 0x38,
+	0x6C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30,
+	0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30,
+	0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38,
+	0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+	0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
+	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66,
+	0x66, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60,
+	0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
+	0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
+	0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06,
+	0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
+	0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78,
+	0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6,
+	0xD6, 0xD6, 0xD6, 0xD6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x62,
+	0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60,
+	0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
+	0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
+	0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
+	0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18,
+	0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18,
+	0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18,
+	0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
+	0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
+	0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0x00, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xCC, 0xCC, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60,
+	0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE,
+	0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x66, 0x66, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xC6, 0xC6, 0x10, 0x38, 0x6C, 0xC6, 0xC6,
+	0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6,
+	0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C,
+	0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36,
+	0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC,
+	0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
+	0x00, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x60,
+	0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60,
+	0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
+	0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE,
+	0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,
+	0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC,
+	0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
+	0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE,
+	0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60,
+	0xC0, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0,
+	0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06,
+	0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30,
+	0x60, 0xCE, 0x93, 0x06, 0x0C, 0x1F, 0x00, 0x00,
+	0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30,
+	0x66, 0xCE, 0x9A, 0x3F, 0x06, 0x0F, 0x00, 0x00,
+	0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18,
+	0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x66, 0xCC,
+	0x66, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33,
+	0x66, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
+	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
+	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
+	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
+	0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
+	0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF,
+	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
+	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8,
+	0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC6, 0xFC,
+	0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
+	0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0,
+	0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x80, 0xFE, 0x6C, 0x6C,
+	0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18,
+	0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8,
+	0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66,
+	0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
+	0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C,
+	0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66,
+	0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB,
+	0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x03, 0x06, 0x7E, 0xCF, 0xDB,
+	0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60,
+	0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6,
+	0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE,
+	0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18,
+	0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C,
+	0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30,
+	0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E,
+	0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00,
+	0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC,
+	0x6C, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x70, 0x98, 0x30, 0x60, 0xC8, 0xF8, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C,
+	0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static kgi_console_font_t default_font_ibm437_9x16 =
+{
+	{ 9, 16 },		/* character cell	*/
+	{ 8, 16 },		/* bitmap size		*/
+	11,			/* baseline		*/
+ 
+	&default_font_ibm437_info,
+	 default_font_ibm437_data_9x16
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/default-ptr sys/dev/kgc/default-ptr
--- sys/dev/kgc/default-ptr	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/default-ptr	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,159 @@
+#define	I(x)	((0xFFFF * (x))/100)
+const kgi_rgb_color_t default_ptr_color[3] =
+{
+	{ I(  0), I(  0), I(  0) },
+	{ I(100), I(100), I(100) },
+	{ I(100), I(  0), I(  0) }
+};
+#undef	I
+
+const kgi_u8_t default_ptr_64x64[1024] = 
+{
+	/*	AND mask
+	*/
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x07, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x07, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x03, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	/*	XOR mask
+	*/
+	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x41, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x40, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x23, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x24, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x14, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x14, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x0a, 0x4e, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x0a, 0x91, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x05, 0x20, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x04, 0x48, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x02, 0x44, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x02, 0x49, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x01, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x01, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x88, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x83, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x44, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x44, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x28, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x28, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x10, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x10, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_backgnd.c sys/dev/kgc/kgc_backgnd.c
--- sys/dev/kgc/kgc_backgnd.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_backgnd.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,265 @@
+/*-
+ * Copyright (c) 1999 Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+ * Copyright (c) 2003 Nicholas Souchu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer as
+ *    the first lines of this file unmodified.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * From FreeBSD: src/sys/dev/fb/splash.c,v 1.14 2004/05/30 20:08:31 phk Exp
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/linker.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_backgnd.h>
+
+/* decoder candidates */
+#define MAX_NR_DECODERS 4
+static backgnd_decoder_t *decoder_set[MAX_NR_DECODERS];
+
+static backgnd_decoder_t *backgnd_decoders[KGI_MAX_NR_DEVICES];
+static backgnd_callback_t backgnd_callbacks[KGI_MAX_NR_DEVICES];
+static void *backgnd_args[KGI_MAX_NR_DEVICES];
+
+static void
+kgc_backgnd_init(void) 
+{
+
+	bzero(decoder_set, sizeof(decoder_set));
+	bzero(backgnd_decoders, sizeof(backgnd_decoders));
+	bzero(backgnd_callbacks, sizeof(backgnd_callbacks));
+	bzero(backgnd_args, sizeof(backgnd_args));
+}
+
+SYSINIT(backgnd, SI_SUB_KGI, SI_ORDER_ANY, kgc_backgnd_init, NULL);
+
+static int
+backgnd_find_data(backgnd_decoder_t *decoder)
+{
+	caddr_t image_module;
+	caddr_t p;
+
+	if (decoder->data_type == NULL)
+		return 0;
+	image_module = preload_search_by_type(decoder->data_type);
+	if (image_module == NULL)
+		return (ENOENT);
+	p = preload_search_info(image_module, MODINFO_ADDR);
+	if (p == NULL)
+		return (ENOENT);
+	decoder->data = *(void **)p;
+	p = preload_search_info(image_module, MODINFO_SIZE);
+	if (p == NULL)
+		return (ENOENT);
+	decoder->data_size = *(kgi_u32_t *)p;
+	KRN_BOOT("backgnd: image@%p, size:%lu\n",
+		 (void *)decoder->data, (long)decoder->data_size);
+	return (0);
+}
+
+static int
+backgnd_test(backgnd_decoder_t *decoder, kgi_u_t devid)
+{
+	render_t r;
+
+	if (!(r = kgc_get_render(devid)))
+		return (EINVAL);
+
+	decoder->data = NULL;
+	decoder->data_size = 0;
+
+	/* 
+	 * Let the decoder provide its own defaults if backgnd
+	 * data not found.
+	 */
+	backgnd_find_data(decoder);
+
+	if (*decoder->init && (*decoder->init)(r)) {
+		decoder->data = NULL;
+		decoder->data_size = 0;
+		return (ENODEV);	/* XXX */
+	}
+	if (bootverbose)
+		printf("backgnd: image decoder found: %s\n", decoder->name);
+	return (0);
+}
+
+static void
+backgnd_new(backgnd_decoder_t *decoder, kgi_u_t devid)
+{
+	render_t r;
+
+	if (!(r = kgc_get_render(devid)))
+		return;
+
+	backgnd_decoders[devid] = decoder;
+	if (backgnd_callbacks[devid] != NULL)
+		(*backgnd_callbacks[devid])(r, BACKGND_INIT, backgnd_args[devid]);
+}
+
+int
+backgnd_register(backgnd_decoder_t *decoder)
+{
+	int i, error = ENOMEM;
+	kgi_u_t devid;
+
+	/* register the decoder for later use */
+	for (i = 0; i < MAX_NR_DECODERS; ++i) {
+		if (decoder_set[i] == NULL) {
+			decoder_set[i] = decoder;
+			error = 0;
+			break;
+		}
+	}
+
+	/* 
+	 * Parse the devids to find any render that would
+	 * have not decoder.
+	 */
+	for (devid=0; KGI_VALID_DEVICE_ID(devid); devid++) {
+		if (backgnd_callbacks[devid] && !backgnd_decoders[devid]) {
+			if (backgnd_test(decoder, devid) == 0) {
+				backgnd_new(decoder, devid);
+			}
+		}
+	}
+
+	return (error);
+}
+
+int
+backgnd_unregister(backgnd_decoder_t *decoder)
+{
+	int error;
+	kgi_u_t i, j;
+	render_t r;
+
+	if (!decoder)
+		return (0);
+
+	for (j = 0; j < MAX_NR_DECODERS; j++) {
+		if (decoder_set[j] == decoder)
+			break;
+	}	
+
+	if (j >= MAX_NR_DECODERS)
+		return (EINVAL);
+
+	for (i = 0; KGI_VALID_DEVICE_ID(i); i++) {
+		if (backgnd_decoders[i] == decoder) {
+			if (!(r = kgc_get_render(i)))
+				continue;
+			if ((error = backgnd_term(i)) != 0) {
+				KRN_ERROR("Can't terminate backgnd %d (%d)", i, error);
+			}
+		}
+	}
+	decoder_set[i] = NULL;
+
+	return (0);
+}
+
+int
+backgnd_init(kgi_u_t devid, backgnd_callback_t callback, void *arg)
+{
+	int i, error = ENODEV;
+
+	if (!KGI_VALID_DEVICE_ID(devid))
+		return (EINVAL);
+
+	backgnd_callbacks[devid] = callback;
+	backgnd_args[devid] = arg;
+
+	backgnd_decoders[devid] = NULL;
+
+	/* Scan the decoders to find one */
+	for (i = 0; i < MAX_NR_DECODERS; ++i) {
+		if (decoder_set[i] == NULL)
+			continue;
+		if (backgnd_test(decoder_set[i], devid) == 0) {
+			backgnd_new(decoder_set[i], devid);
+			error = 0;
+			break;
+		}
+	}
+	return (error);
+}
+
+int
+backgnd_term(kgi_u_t devid)
+{
+	int error = 0;
+	render_t r;
+
+	if (!KGI_VALID_DEVICE_ID(devid) || !(r = kgc_get_render(devid)))
+		return (EINVAL);
+
+	if (backgnd_decoders[devid] != NULL) {
+		if (backgnd_callbacks[devid] != NULL)
+			error = (*backgnd_callbacks[devid])(r, BACKGND_TERM,
+							backgnd_args[devid]);
+		if (error == 0 && backgnd_decoders[devid]->term)
+			error = (*backgnd_decoders[devid]->term)(r);
+	}
+
+	/* XXX Free decoder and callback entries anyway */
+	backgnd_decoders[devid] = NULL;
+	backgnd_callbacks[devid] = NULL;
+	backgnd_args[devid] = NULL;
+	
+	return (error);
+}
+
+int
+backgnd_draw(kgi_u_t devid, unsigned char *mem, kgi_u16_t *pal)
+{
+	render_t r;
+
+	if (!KGI_VALID_DEVICE_ID(devid) || !(r = kgc_get_render(devid)))
+		return (EINVAL);
+
+	if (backgnd_decoders[devid] != NULL)
+		return ((*backgnd_decoders[devid]->draw)(r, mem, pal));
+
+	return (ENODEV);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_backgnd.h sys/dev/kgc/kgc_backgnd.h
--- sys/dev/kgc/kgc_backgnd.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_backgnd.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,87 @@
+/*-
+ * Copyright (c) 1999 Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+ * Copyright (c) 2003 Nicholas Souchu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer as
+ *    the first lines of this file unmodified.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * From FreeBSD: src/sys/dev/fb/splashreg.h,v 1.6 2004/07/15 08:26:01 phk Exp
+ *
+ * $FreeBSD$
+ *
+ */
+
+#ifndef _kgc_backgnd_h
+#define	_kgc_backgnd_h
+
+#define BACKGND_IMAGE	"splash_image_data"
+
+struct render_t;
+
+struct backgnd_decoder {
+	char		*name;
+	int		(*init)(render_t r);
+	int		(*term)(render_t r);
+	int		(*draw)(render_t r, unsigned char *mem, kgi_u16_t *pal);
+	char		*data_type;
+	void		*data;
+	size_t		data_size;
+};
+
+typedef struct backgnd_decoder	backgnd_decoder_t;
+
+typedef int (*backgnd_callback_t)(render_t, int, void *);
+
+#define BACKGND_DECODER(name, sw)				\
+	static int name##_modevent(module_t mod, int type, void *data) \
+	{							\
+		switch ((modeventtype_t)type) {			\
+		case MOD_LOAD:					\
+			return backgnd_register(&sw);		\
+		case MOD_UNLOAD:				\
+			return backgnd_unregister(&sw);		\
+		default:					\
+			break;					\
+		}						\
+		return 0;					\
+	}							\
+	static moduledata_t name##_mod = {			\
+		#name, 						\
+		name##_modevent,				\
+		NULL						\
+	};							\
+	DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_ANY);
+
+/* entry point for the splash image decoder */
+extern int	backgnd_register(backgnd_decoder_t *decoder);
+extern int	backgnd_unregister(backgnd_decoder_t *decoder);
+
+/* entry points for the render */
+extern int	backgnd_init(kgi_u_t, backgnd_callback_t, void *arg);
+extern int	backgnd_term(kgi_u_t devid);
+extern int	backgnd_draw(kgi_u_t devid, unsigned char *mem, kgi_u16_t *pal);
+
+/* event types for the callback function */
+#define BACKGND_INIT	0
+#define BACKGND_TERM	1
+
+#endif /* !_kgc_backgnd_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_bgndpcx.c sys/dev/kgc/kgc_bgndpcx.c
--- sys/dev/kgc/kgc_bgndpcx.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_bgndpcx.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,237 @@
+/*-
+ * Copyright (c) 1999 Michael Smith <msmith@freebsd.org>
+ * Copyright (c) 1999 Kazutaka YOKOTA <yokota@freebsd.org>
+ * Copyright (c) 1999 Dag-Erling Codan Smrgrav
+ * Copyright (c) 2003 Nicholas Souchu
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * From FreeBSD: src/sys/modules/backgnd/pcx/backgnd_pcx.c,v 1.5 2002/11/11 10:28:44 mux Exp
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/linker.h>
+#include <sys/module.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_kgirndr.h>
+#include <dev/kgc/kgc_backgnd.h>
+
+#define FADE_TIMEOUT	300	/* sec */
+
+static int pcx_start(render_t r);
+static int pcx_end(render_t r);
+static int pcx_init(char *data, int sdepth);
+static int pcx_draw(render_t r, unsigned char *vidmem, kgi_u16_t *pal);
+
+static backgnd_decoder_t pcx_decoder = {
+    "backgnd_pcx", pcx_start, pcx_end, pcx_draw, BACKGND_IMAGE,
+};
+
+BACKGND_DECODER(backgnd_pcx, pcx_decoder);
+
+static struct
+{
+    int		  width, height, bpsl;
+    int		  bpp, zlen;
+    const u_char *zdata;
+    u_char	 *palette;
+} pcx_info;
+
+extern const char daemon_pcx[];
+
+static int 
+pcx_start(render_t r)
+{
+    kgirndr_meta *render = kgc_render_meta(r);
+    kgi_image_mode_t *img = &render->mode.img[0];
+    int	depth;
+
+    /* Use the nebula daemon by default */
+    if (pcx_decoder.data == NULL || pcx_decoder.data_size <= 0) {
+	    pcx_decoder.data = daemon_pcx;
+	    pcx_decoder.data_size = 40386;
+    }
+
+    if (pcx_init((u_char *)pcx_decoder.data, pcx_decoder.data_size))
+	return (ENODEV);
+
+    if (bootverbose)
+	printf("backgnd_pcx: image good:\n"
+	       "  width = %d\n"
+	       "  height = %d\n"
+	       "  depth = %d\n",
+	       pcx_info.width, pcx_info.height,
+	       pcx_info.bpp);
+
+    depth = kgi_attr_bits(img->bpfa);
+    
+    if (bootverbose)
+	    printf("backgnd_pcx: considering mode:\n"
+		   "  width = %d\n"
+		   "  height = %d\n"
+		   "  depth = %d\n",
+		   img->size.y, img->size.x, depth);
+
+    if (img->size.x < pcx_info.width || img->size.y < pcx_info.height
+		|| depth != pcx_info.bpp)
+	    return (ENODEV);
+
+    return (0);
+}
+
+static int
+pcx_end(render_t r)
+{
+    /* nothing to do */
+    return (0);
+}
+
+struct pcxheader {
+    u_char manufactor;
+    u_char version;
+    u_char encoding;
+    u_char bpp;
+    u_short xmin, ymin, xmax, ymax;
+    u_short hres, vres;
+    u_char colormap[48];
+    u_char rsvd;
+    u_char nplanes;
+    u_short bpsl;
+    u_short palinfo;
+    u_short hsize, vsize;
+};
+
+#define MAXSCANLINE 1024
+
+static int
+pcx_init(char *data, int size)
+{
+    const struct pcxheader *hdr;
+
+    hdr = (const struct pcxheader *)data;
+
+    if (size < 128 + 1 + 1 + 768
+	|| hdr->manufactor != 10
+	|| hdr->version != 5
+	|| hdr->encoding != 1
+	|| hdr->nplanes != 1
+	|| hdr->bpp != 8
+	|| hdr->bpsl > MAXSCANLINE
+	|| data[size-769] != 12) {
+	printf("backgnd_pcx: invalid PCX image\n");
+	return (1);
+    }
+    pcx_info.width =  hdr->xmax - hdr->xmin + 1;
+    pcx_info.height =  hdr->ymax - hdr->ymin + 1;
+    pcx_info.bpsl = hdr->bpsl;
+    pcx_info.bpp = hdr->bpp;
+    pcx_info.zlen = size - (128 + 1 + 768);
+    pcx_info.zdata = data + 128;
+    pcx_info.palette = data + size - 768;
+    return (0);
+}
+
+static int
+pcx_draw(render_t r, unsigned char *vidmem, kgi_u16_t *pal)
+{
+    kgirndr_meta *render = kgc_render_meta(r);
+    kgi_image_mode_t *img = &render->mode.img[0];
+    int swidth, sheight, sbpsl, sdepth;
+    int c, i, j, pos, scan, x, y;
+    u_char line[MAXSCANLINE];
+    kgi_u16_t clut[256*3], *pclut;
+    
+    if (pcx_info.zlen < 1)
+	return (1);
+
+    pclut = (pal)?pal:clut;
+    
+    /* Copy the palette
+     * XXX What to do if palette was not 256 bytes long?
+     * Convert 8bits to 16bits palette. What for?
+     */
+    for (i=0; i<256*3; i+=3) {
+	    pclut[i]   = pcx_info.palette[i]   << 8;
+	    pclut[i+1] = pcx_info.palette[i+1] << 8;
+	    pclut[i+2] = pcx_info.palette[i+2] << 8;
+    }
+    if (!pal && render->ilut->Set)
+	    /* Set directly the palette with the display resource */
+	    (render->ilut->Set)(render->ilut, 0, 0, 256, KGI_AM_COLORS,
+				pclut);
+      
+    swidth = img->size.x;
+    sheight = img->size.y;
+    sdepth = kgi_attr_bits(img->bpfa);
+
+    /* Add 1 for the case of 15bits mode */
+    sbpsl = swidth * ((sdepth + 1) / 8);
+    
+    bzero(vidmem, sheight*sbpsl);
+    
+    x = (swidth - pcx_info.width) / 2;
+    y = (sheight - pcx_info.height) / 2;
+    pos = y * sbpsl + x;
+    
+    for (scan = i = 0; scan < pcx_info.height; ++scan, ++y, pos += sbpsl) {
+		for (j = 0; j < pcx_info.bpsl && i < pcx_info.zlen; ++i) {
+			if ((pcx_info.zdata[i] & 0xc0) == 0xc0) {
+				c = pcx_info.zdata[i++] & 0x3f;
+				if (i >= pcx_info.zlen)
+					return (1);
+			} else {
+				c = 1;
+			}
+			if (j + c > pcx_info.bpsl)
+				return (1);
+			while (c--)
+				line[j++] = pcx_info.zdata[i];
+		}
+		bcopy(line, vidmem + pos, pcx_info.width);
+    }
+
+    return (0);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_console.h sys/dev/kgc/kgc_console.h
--- sys/dev/kgc/kgc_console.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_console.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,183 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI console implementation specific definitions
+ */
+
+#ifndef _kgc_console_h
+#define	_kgc_console_h
+
+/* extern struct tasklet_struct keyboard_tasklet, console_tasklet; */
+
+typedef struct {
+	unsigned char	kbmeta;
+	unsigned char	mode;
+	unsigned char	kbmode;
+#define	VC_RAW		0
+#define	VC_XLATE	1
+#define	VC_MEDIUMRAW	2
+#define	VC_UNICODE	3
+
+	unsigned char	kbled;
+	unsigned char	led;
+} kgi_console_kd_t;
+
+typedef enum {
+	KGI_CM_SMOOTH_SCROLL,	/* smooth(slow) scroll		*/
+	KGI_CM_REVERSE_VIDEO,	/* black on white		*/
+	KGI_CM_ORIGIN,		/* cursor origin mode		*/
+	KGI_CM_AUTO_WRAP,	/* automatic line wrap		*/
+	KGI_CM_AUTO_REPEAT,	/* repeat chars automatically	*/
+	KGI_CM_REVERSE_WRAP,	/* allow reverse wrapping	*/
+	KGI_CM_ALT_SCREEN,	/* use alternate screen		*/
+	KGI_CM_SHOW_CURSOR,	/* show/hide cursor mark	*/
+	KGI_CM_SHOW_POINTER,	/* show/hide pointer mark	*/
+
+	KGI_CM_LAST /* NOTE: there *must* not be more than 32 modes! */
+} kgi_console_mode_t;
+
+#define	CONSOLE_CLEAR_MODE(cons, m)	((cons)->mode &= ~(1 << (m)))
+#define	CONSOLE_SET_MODE(cons, m)	((cons)->mode |=  (1 << (m)))
+#define	CONSOLE_MODE(cons, m)		((cons)->mode &   (1 << (m)))
+
+typedef enum {
+#define	KGI_CA_COLOR(fg,bg)	(((bg) & 0xFF) | (((fg) & 0xFF) << 8))
+	KGI_CA_FG_COLOR	= 0x0000FF00,
+	KGI_CA_BG_COLOR = 0x000000FF,
+	KGI_CA_NORMAL	= 0x00000000,
+	KGI_CA_HALF	= 0x00010000,
+	KGI_CA_BRIGHT	= 0x00020000,
+	KGI_CA_INTENSITY= 0x00030000,
+	KGI_CA_UNDERLINE= 0x00040000,
+	KGI_CA_BOLD	= 0x00080000,
+	KGI_CA_ITALIC	= 0x00100000,
+	KGI_CA_REVERSE	= 0x00200000,
+	KGI_CA_BLINK	= 0x00400000,
+	KGI_CA_ALPHA	= 0x00800000
+} kgi_console_attributes_t;
+
+typedef enum {
+	KGI_CF_NEED_WRAP	= 0x00000001,
+	KGI_CF_SCROLLED		= 0x00000002,
+
+	KGI_CF_NO_HARDSCROLL	= 0x00000004,
+	KGI_CF_SPLITLINE	= 0x00000008,
+
+	KGI_CF_CURSOR_SHOWN	= 0x00000010,
+	KGI_CF_CURSOR_TO_SHOW	= 0x00000020,
+	KGI_CF_POINTER_SHOWN	= 0x00000040,
+	KGI_CF_POINTER_TO_SHOW	= 0x00000080
+} kgi_console_flags_t;
+
+typedef struct kgi_console_s kgi_console_t;
+
+#define MAX_IO_BUF_SIZE			32
+
+struct kgi_console_s {
+	kgi_u_t	refcnt;
+
+	kii_device_t	kii;
+	int	(*DoWrite)(kgi_console_t *, const char *, int);
+
+	void		*meta_console;
+
+	/* input handling variables (mostly for cn) */
+#define EMPTY 0x0
+#define FULL 0x1
+#define HAS_DATA 0x2
+	int		status;
+	int		head, tail, size;
+	int		buffer[MAX_IO_BUF_SIZE];
+
+	kgi_console_flags_t	flags;
+	kgi_console_mode_t	mode;
+
+	/*
+	 * scroller and render are defined void* to avoid
+	 * .h dependencies
+	 */
+	void		*parser;
+	void		*scroller;
+	void		*render;
+};
+
+enum kgi_console_color_e {
+	KGI_CC_BLACK=0,
+	KGI_CC_BLUE,
+	KGI_CC_GREEN,
+	KGI_CC_CYAN,
+	KGI_CC_RED,
+	KGI_CC_MAGENTA,
+	KGI_CC_BROWN,
+	KGI_CC_LIGHTGRAY,
+	KGI_CC_DARKGRAY,
+	KGI_CC_LIGHTBLUE,
+	KGI_CC_LIGHTGREEN,
+	KGI_CC_LIGHTCYAN,
+	KGI_CC_LIGHTRED,
+	KGI_CC_LIGHTMAGENTA,
+	KGI_CC_YELLOW,
+	KGI_CC_WHITE
+};
+
+
+/* ASCII control code definitions */
+
+#define	ASCII_NUL	0	/* null (end of string) */
+#define	ASCII_SOH	1	/* start of heading	*/
+#define	ASCII_STX	2	/* start of text	*/
+#define	ASCII_ETX	3	/* end of text		*/
+#define	ASCII_EOT	4	/* end of transmission	*/
+#define	ASCII_ENQ	5	/* enquiry		*/
+#define	ASCII_ACK	6	/* acknowledge		*/
+#define	ASCII_BEL	7	/* bell			*/
+#define	ASCII_BS	8	/* backspace		*/
+#define	ASCII_HT	9	/* horizontal tab	*/
+#define	ASCII_TAB	9	/* horizontal tab	*/
+
+#define	ASCII_LF	10	/* line feed	        */
+#define	ASCII_VT	11	/* vertical tab		*/
+#define	ASCII_FF	12	/* form feed		*/
+#define	ASCII_CR	13	/* carriage return	*/
+#define	ASCII_SO	14	/* shift out		*/
+#define	ASCII_SI	15	/* shift in		*/
+#define	ASCII_DLE	16	/* data line escape	*/
+#define	ASCII_DC1	17	/* dev-ctrl 1 (X-ON)	*/
+#define	ASCII_DC2	18	/* dev-ctrl 2       	*/
+#define	ASCII_DC3	19	/* dev-ctrl 3 (X-OFF)	*/
+
+#define	ASCII_DC4	20	/* dev-ctrl 4       	*/
+#define	ASCII_NAK	21	/* negative acknowledge	*/
+#define	ASCII_SYN	22	/* synchronous idle	*/
+#define	ASCII_ETB	23	/* end of transmit block*/
+#define	ASCII_CAN	24	/* cancel		*/
+#define	ASCII_EM	25	/* end of medium	*/
+#define	ASCII_SUB	26	/* substitute		*/
+#define	ASCII_ESC	27	/* escape		*/
+#define	ASCII_FS	28	/* file separator	*/
+#define	ASCII_GS	29	/* group separator	*/
+
+#define	ASCII_RS	30	/* record separator	*/
+#define	ASCII_US	31	/* unit separator	*/
+
+extern const kgi_u16_t			default_color_text16_ilut[16*3];
+extern const kgi_rgb_color_t		default_ptr_color[3];
+extern const kgi_u8_t			default_ptr_64x64[1024];
+
+extern void kgc_map_kgi(kgi_device_t *dev);
+extern kgi_s_t kgc_unmap_kgi(kgi_device_t *dev);
+
+extern void kgc_map_kii(kii_device_t *dev);
+extern kii_s_t kgc_unmap_kii(kii_device_t *dev);
+
+#endif	/* !_kgc_console_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_daemon.c sys/dev/kgc/kgc_daemon.c
--- sys/dev/kgc/kgc_daemon.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_daemon.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,1792 @@
+extern const char daemon_pcx[];
+const char daemon_pcx[] = {
+10,5,1,8,0,0,0,0,23,1,199,0,44,1,44,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,24,1,
+1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,230,0,1,194,0,195,1,2,197,
+1,3,194,4,195,3,5,3,6,0,8,194,0,197,9,10,195,11,197,13,15,13,11,15,11,15,
+194,18,15,194,18,194,17,196,20,194,28,195,24,196,26,196,24,194,26,32,30,
+196,32,33,32,33,57,58,196,57,196,58,196,33,199,58,33,34,33,31,35,34,35,
+200,31,34,33,32,33,195,58,194,32,194,30,31,30,198,29,23,29,197,23,197,22,
+194,20,17,20,195,17,195,18,194,15,194,11,194,14,9,198,14,194,8,195,0,8,
+195,0,194,8,194,12,195,5,3,195,4,3,196,2,195,1,194,0,1,233,0,230,0,1,0,
+1,0,2,1,2,1,194,0,2,1,194,2,194,1,194,4,6,3,5,0,8,9,0,10,0,195,9,10,194,
+13,11,13,15,21,15,13,195,21,15,195,21,25,15,194,18,194,20,195,28,194,24,
+28,194,26,24,196,26,200,32,195,33,32,33,32,194,33,32,33,32,198,33,195,58,
+199,33,194,58,195,34,36,196,34,194,36,39,36,39,31,35,194,34,194,33,32,58,
+57,194,33,30,194,31,194,37,199,29,194,22,24,195,22,24,196,20,17,194,20,
+195,17,16,18,15,21,196,19,11,196,14,8,14,9,14,9,0,10,9,197,0,5,12,195,5,
+196,3,195,4,1,2,196,1,0,194,1,232,0,231,0,198,1,2,194,1,196,4,6,194,4,6,
+4,6,8,195,0,194,9,10,9,10,9,11,195,13,15,13,196,15,18,15,18,195,15,194,
+18,22,198,20,194,28,197,26,195,32,194,26,57,195,32,58,194,32,57,195,32,
+194,33,58,194,33,199,58,195,33,199,58,194,33,195,38,194,34,195,36,198,34,
+38,194,33,34,194,33,32,33,57,194,33,196,31,37,30,31,29,30,194,29,31,30,
+23,194,30,194,24,26,28,20,26,197,20,18,22,15,197,21,194,19,195,11,9,11,
+194,9,194,10,13,196,9,194,0,8,0,5,3,196,5,3,4,196,3,1,194,2,195,1,234,0,
+230,0,1,0,2,194,1,2,196,1,197,3,194,4,196,5,194,0,10,0,11,10,9,196,13,15,
+13,15,16,197,15,21,194,18,27,18,27,17,194,22,195,28,195,26,24,195,26,197,
+32,58,194,32,33,194,32,58,57,32,197,58,33,194,58,198,33,38,58,38,58,197,
+33,194,58,38,195,58,34,38,36,195,34,38,34,194,38,34,39,34,36,39,194,34,
+58,33,58,33,58,33,196,34,197,31,30,32,194,30,194,32,195,26,194,24,26,20,
+26,28,196,20,194,18,25,195,21,19,194,21,194,19,14,197,11,194,13,194,10,
+9,0,10,9,0,194,8,0,5,196,3,5,194,3,194,4,3,200,1,232,0,229,0,1,0,195,1,
+2,4,195,3,1,194,4,3,5,6,194,5,195,6,8,194,9,0,194,10,195,11,196,13,194,
+15,13,194,15,18,15,194,18,15,25,195,18,22,194,20,195,24,195,26,199,32,26,
+196,32,57,33,194,32,199,33,58,194,33,194,38,194,58,194,38,33,194,38,34,
+195,38,194,58,194,34,195,38,34,199,38,39,36,194,39,34,39,38,34,194,38,33,
+58,33,58,33,58,194,33,194,31,34,35,194,31,35,33,194,30,33,194,30,194,32,
+30,196,26,20,24,26,195,22,18,195,25,19,194,25,21,19,195,21,15,13,15,195,
+13,194,11,9,13,11,9,196,0,5,12,196,5,3,194,5,197,3,2,196,1,0,1,231,0,229,
+0,1,2,1,2,4,2,195,4,2,194,1,194,4,5,194,6,195,5,12,194,0,9,11,9,194,13,
+10,11,21,15,16,15,16,18,16,194,15,18,15,18,194,22,18,195,22,23,28,20,195,
+26,194,30,194,26,194,32,26,194,32,58,57,32,58,33,32,57,201,58,34,194,58,
+38,58,194,34,194,58,38,194,34,200,38,195,34,194,38,34,58,195,38,39,194,
+38,34,194,39,36,194,39,196,38,58,34,58,194,38,34,194,38,36,34,36,194,33,
+194,35,33,31,58,57,194,32,26,32,194,26,24,32,195,24,20,194,22,194,27,25,
+27,194,25,194,21,198,15,194,16,15,196,13,10,194,9,194,0,196,8,194,0,5,12,
+196,5,3,5,4,3,194,2,195,1,0,1,231,0,228,0,197,1,2,4,194,3,1,194,4,3,195,
+5,194,3,195,6,14,0,9,194,10,194,13,9,11,194,13,194,15,16,15,16,200,18,197,
+20,195,24,26,24,194,26,196,32,33,32,58,194,32,33,32,58,199,33,38,33,195,
+58,38,58,194,34,194,58,194,34,202,38,39,38,195,39,194,38,39,194,38,34,38,
+194,39,47,36,42,40,194,42,195,39,194,34,38,194,34,194,39,194,36,195,34,
+36,34,196,33,198,32,30,194,32,24,30,24,195,23,22,195,27,194,25,194,18,20,
+194,18,17,15,16,195,15,13,16,194,13,194,11,194,10,9,8,194,0,5,0,194,8,0,
+5,12,5,3,194,5,194,3,194,4,1,2,197,1,230,0,226,0,1,0,194,1,194,2,1,196,
+3,4,3,194,4,6,3,5,6,194,5,8,6,8,195,9,194,11,195,13,196,15,17,194,15,17,
+194,18,25,194,18,17,23,194,22,24,32,24,26,32,26,195,32,26,196,32,57,194,
+32,33,58,194,33,197,58,38,58,34,38,194,34,38,194,34,58,196,38,194,39,194,
+38,194,39,194,38,194,39,198,38,39,197,38,196,39,47,40,42,44,40,194,42,36,
+194,39,194,38,194,39,195,36,40,194,36,34,36,34,39,34,33,34,194,33,194,58,
+32,57,32,194,30,32,195,30,24,196,23,24,22,23,22,18,194,20,194,17,18,17,
+16,15,16,15,16,15,194,13,194,11,194,9,0,9,0,8,0,12,8,0,8,195,12,195,5,195,
+3,4,2,3,195,1,231,0,227,0,1,0,194,1,4,197,3,196,4,194,5,8,5,194,6,195,8,
+9,11,196,13,15,21,194,13,16,17,16,195,17,22,18,20,195,22,194,20,195,24,
+194,30,26,32,194,26,32,33,194,32,194,57,33,32,194,58,33,194,58,194,33,34,
+33,34,38,33,199,38,197,39,194,38,194,39,194,38,194,39,194,38,198,39,38,
+198,39,40,47,44,40,42,44,194,42,44,40,44,194,40,42,40,42,36,195,40,36,42,
+196,36,195,34,58,34,33,194,32,58,195,33,32,30,32,194,30,29,195,24,23,20,
+196,28,20,17,20,194,17,16,18,17,18,16,194,15,194,13,11,195,9,11,8,9,194,
+0,8,0,9,0,194,8,194,5,3,5,196,3,4,1,3,196,1,229,0,224,0,196,1,2,194,1,196,
+3,5,3,1,195,4,194,5,8,5,196,8,9,10,11,196,13,15,21,194,15,16,18,194,17,
+194,18,20,194,18,20,24,22,24,26,194,24,26,24,196,32,194,57,195,32,33,32,
+58,194,33,58,194,33,194,58,197,38,58,197,38,39,197,38,194,39,38,202,39,
+195,38,194,39,38,197,39,194,40,48,59,44,194,48,44,45,46,194,42,44,46,194,
+44,194,42,46,197,42,40,36,39,38,34,38,58,200,33,194,31,30,32,194,30,194,
+24,30,24,195,20,28,197,20,194,17,16,18,194,16,15,195,11,19,11,14,11,194,
+9,8,9,198,0,8,5,12,195,5,195,3,1,2,194,1,0,1,229,0,224,0,198,1,2,3,4,194,
+5,194,3,4,3,5,194,6,8,194,5,8,6,194,8,0,11,195,13,198,15,18,195,17,20,194,
+17,22,20,194,22,26,194,24,26,32,30,32,26,32,194,57,194,32,194,58,33,194,
+58,33,194,58,33,38,58,195,38,58,38,34,38,39,34,38,201,39,38,194,39,38,211,
+39,47,44,47,44,46,195,48,45,196,48,194,44,194,46,48,194,46,45,46,196,42,
+40,36,34,38,33,194,58,33,58,194,33,194,34,32,195,33,194,30,194,32,195,26,
+32,194,26,20,26,28,194,20,17,20,195,17,196,15,13,11,13,14,10,195,9,10,195,
+9,195,0,8,12,0,5,12,5,3,5,195,3,4,2,194,1,0,194,1,227,0,223,0,195,1,2,1,
+2,1,4,195,3,5,194,3,194,4,195,5,0,195,8,6,194,14,194,9,194,13,15,13,196,
+15,16,17,18,17,194,20,22,20,22,20,24,23,26,195,24,26,194,32,26,195,33,195,
+32,58,194,33,58,194,33,195,58,34,33,58,34,197,38,39,198,38,39,40,47,194,
+39,194,44,40,198,44,40,195,47,44,40,39,44,39,40,47,40,44,47,48,59,51,197,
+50,49,50,49,52,49,194,48,46,48,194,46,45,43,45,46,194,42,194,40,39,38,34,
+33,38,33,194,38,194,33,34,195,33,32,58,197,32,196,26,28,20,194,28,20,28,
+20,22,17,22,18,194,21,11,21,11,13,197,11,195,10,194,9,197,0,5,12,195,5,
+3,4,2,4,195,1,230,0,224,0,198,1,195,3,196,5,194,6,4,194,6,5,8,6,8,14,8,
+194,14,13,11,13,194,15,16,194,15,194,18,194,17,20,194,17,194,20,24,194,
+23,194,24,196,32,26,32,33,195,32,196,33,194,58,33,195,38,194,34,194,38,
+34,38,34,38,39,38,39,38,194,39,40,194,44,48,44,59,48,51,199,50,196,53,195,
+50,51,50,51,48,194,50,48,51,59,195,50,194,53,194,50,53,195,52,197,49,52,
+194,49,52,49,195,45,44,194,42,39,38,39,199,38,34,33,34,33,32,58,196,32,
+26,194,32,26,30,26,24,194,26,194,20,22,194,17,194,18,21,194,25,21,13,196,
+11,13,196,11,9,10,194,9,0,9,194,8,0,194,5,12,5,194,3,4,2,199,1,226,0,221,
+0,195,1,2,1,2,1,2,1,194,4,3,195,5,4,196,5,194,8,14,194,8,195,14,11,13,15,
+194,16,197,15,18,17,197,20,22,194,24,26,30,24,30,32,26,32,33,194,32,194,
+57,196,58,194,33,194,38,58,38,58,195,38,194,39,38,39,38,194,39,194,40,44,
+194,48,194,50,53,197,52,53,196,55,200,60,194,55,56,194,54,56,53,55,194,
+54,194,55,194,52,55,52,55,194,53,197,52,53,52,197,49,45,194,48,40,194,39,
+196,38,39,194,34,194,38,34,38,58,196,33,58,32,33,195,32,26,32,194,26,194,
+24,26,24,195,22,25,18,25,194,21,19,25,194,21,13,21,197,13,11,195,10,195,
+0,8,194,0,196,5,3,4,3,1,197,0,1,226,0,221,0,196,1,3,4,1,4,195,3,195,5,6,
+5,4,195,6,8,14,194,8,194,14,8,9,11,196,15,194,16,194,18,20,18,197,20,24,
+26,23,24,29,24,30,32,30,32,58,32,33,58,198,33,58,194,38,33,38,34,195,38,
+39,38,194,39,38,39,40,47,44,48,194,50,52,53,194,52,195,55,53,194,60,61,
+52,201,60,198,61,197,60,61,52,194,60,52,194,60,61,52,55,196,53,194,52,53,
+194,52,194,49,50,46,194,44,40,194,39,38,194,39,38,194,39,194,36,38,194,
+33,196,58,32,58,195,57,194,32,30,32,195,30,23,195,22,27,22,196,25,18,15,
+21,15,21,194,15,13,15,195,13,194,11,194,9,10,196,0,8,12,194,5,194,3,202,
+1,224,0,220,0,194,1,2,194,1,2,3,195,4,3,194,5,12,5,6,196,5,6,194,8,197,
+14,9,11,13,15,17,194,15,194,18,15,22,194,17,196,20,24,26,194,24,194,32,
+30,195,32,194,57,194,33,196,58,38,33,195,38,34,38,194,39,194,38,195,39,
+40,194,44,46,194,50,194,52,53,52,55,53,52,55,52,194,60,52,60,62,201,61,
+60,61,62,63,194,61,194,63,60,194,61,60,61,60,195,61,194,60,62,60,52,61,
+60,52,55,53,197,52,194,50,45,194,59,40,39,40,195,39,40,39,197,38,196,33,
+58,195,33,32,195,33,31,194,30,24,29,23,27,23,22,194,27,18,196,25,15,21,
+196,15,194,13,21,196,13,10,9,194,10,0,8,0,5,8,194,5,6,3,4,197,1,228,0,219,
+0,1,0,196,1,194,4,3,4,2,3,195,5,12,5,195,6,195,8,9,195,8,194,14,19,11,15,
+16,15,194,17,195,18,17,22,20,195,28,32,30,24,196,30,32,197,33,194,58,196,
+33,58,38,194,33,197,38,196,39,194,47,48,50,53,194,52,194,55,52,196,60,61,
+62,197,61,194,63,194,61,64,63,62,194,64,63,64,63,61,194,63,194,61,196,63,
+64,194,63,64,194,63,198,61,62,52,194,60,195,55,50,194,53,51,48,44,48,44,
+40,44,40,44,196,39,194,38,58,194,38,194,58,33,194,58,33,34,33,34,194,31,
+30,196,29,194,23,27,194,22,27,22,195,25,195,18,195,15,18,194,16,195,13,
+194,11,13,195,9,195,0,194,12,194,5,4,3,194,4,194,1,0,196,1,224,0,219,0,
+195,1,195,2,3,1,2,4,6,3,12,198,5,6,8,14,9,196,14,195,11,194,15,16,15,195,
+17,25,18,17,22,20,196,24,30,26,33,194,32,30,32,198,33,194,58,199,38,39,
+194,38,196,39,47,46,194,50,53,55,53,194,55,194,60,52,60,61,194,60,195,61,
+64,63,195,61,194,63,61,211,64,61,62,195,61,63,64,197,61,195,60,55,60,56,
+53,195,50,195,59,194,48,194,44,47,40,39,194,38,34,195,38,58,38,33,194,38,
+34,36,195,35,195,37,196,29,23,194,27,23,194,27,22,194,18,25,194,15,18,15,
+16,194,15,13,15,195,13,11,10,194,9,10,0,194,8,194,5,3,5,4,3,194,4,196,1,
+227,0,218,0,194,1,2,195,1,4,1,3,4,195,3,194,5,8,5,194,6,5,195,8,194,9,197,
+14,13,15,16,15,17,18,17,18,195,22,196,24,194,26,32,195,30,31,33,31,34,33,
+34,195,58,34,33,58,38,34,194,38,194,39,38,194,39,38,39,40,47,48,50,53,52,
+55,194,52,60,194,52,60,61,194,60,194,63,194,61,63,61,64,195,63,61,202,64,
+69,206,64,63,194,61,194,63,61,62,195,60,194,55,56,53,54,55,54,196,53,194,
+50,45,48,40,47,197,39,38,194,34,38,39,194,34,36,35,41,194,37,35,196,37,
+194,29,194,37,29,27,196,22,25,18,194,22,195,17,196,16,196,13,11,194,10,
+194,9,195,0,194,8,4,6,4,2,1,195,4,196,1,224,0,219,0,1,2,1,197,3,194,4,6,
+3,194,12,0,12,5,6,8,6,14,8,194,9,14,196,19,194,15,18,16,17,18,20,18,25,
+194,22,20,30,26,24,26,195,32,194,33,31,34,33,34,33,34,33,58,197,38,34,38,
+39,38,197,39,40,48,50,53,52,53,55,60,61,52,62,195,61,194,63,194,62,194,
+63,194,64,65,62,194,65,195,62,65,62,196,65,62,67,65,196,67,62,66,67,62,
+67,62,64,62,69,62,64,62,64,62,65,62,65,62,196,65,55,56,60,56,197,53,50,
+53,194,50,44,40,194,39,38,39,196,38,36,194,39,40,42,43,35,195,41,195,35,
+195,37,195,29,37,27,23,27,23,24,22,197,17,195,18,15,18,16,196,13,11,9,194,
+10,9,8,194,0,8,5,4,6,197,3,4,227,0,217,0,194,1,0,1,2,1,4,3,4,195,3,194,
+5,199,8,14,8,195,9,8,9,194,14,194,21,15,17,18,194,20,18,17,195,22,23,26,
+30,194,32,26,32,194,30,195,33,34,33,34,194,38,34,38,58,194,34,194,38,39,
+38,39,38,39,38,40,44,59,50,53,194,55,60,52,60,195,61,195,64,194,61,194,
+64,65,62,194,65,66,56,65,195,66,56,66,196,56,54,66,56,66,196,56,66,65,56,
+66,65,194,66,62,65,62,66,62,66,67,195,62,65,194,66,194,56,194,65,56,60,
+195,65,60,55,65,194,53,194,59,44,47,199,39,194,40,46,194,42,43,194,42,195,
+41,195,35,31,194,37,195,29,37,29,194,23,22,20,22,20,22,20,195,17,195,16,
+13,15,194,13,11,194,13,194,9,195,0,5,12,194,5,4,6,197,4,195,1,224,0,218,
+0,1,0,1,2,198,3,195,5,194,0,8,5,8,6,194,8,14,19,194,11,19,194,11,19,11,
+15,18,20,194,17,20,195,22,23,24,23,24,194,26,32,194,26,58,33,194,34,33,
+195,34,38,39,38,39,195,38,39,38,198,39,40,48,50,53,55,194,52,62,61,60,197,
+61,63,194,64,65,62,194,66,195,56,54,198,51,196,54,195,51,195,54,200,56,
+194,66,56,65,66,65,56,66,56,65,66,196,65,66,56,65,56,194,65,195,60,55,56,
+194,54,50,47,40,198,39,47,39,46,44,45,43,46,194,43,42,43,195,41,35,37,41,
+194,31,37,195,29,30,194,24,23,24,20,17,195,20,194,17,18,17,18,196,16,197,
+13,10,0,9,196,8,3,5,194,3,194,2,4,227,0,217,0,1,0,196,1,4,3,4,195,3,5,195,
+0,12,14,8,14,8,14,196,9,194,14,19,194,21,18,194,17,18,20,17,20,22,195,23,
+24,26,30,194,32,194,33,32,195,33,34,39,34,194,39,38,36,34,39,38,196,39,
+38,194,39,40,47,59,51,50,194,60,62,195,61,63,64,63,64,63,64,67,62,56,65,
+56,194,54,51,54,198,51,48,194,51,48,51,48,194,51,50,195,51,54,51,197,54,
+195,56,66,194,56,194,66,56,194,66,194,65,66,195,56,195,65,196,62,194,65,
+194,55,53,47,194,44,39,40,39,40,39,47,40,194,48,45,43,49,43,45,196,43,41,
+35,194,41,35,194,37,194,31,30,29,195,30,194,24,20,28,197,20,17,15,16,18,
+196,15,194,13,11,9,11,9,0,9,0,5,12,194,6,197,4,196,1,223,0,217,0,196,1,
+196,3,4,6,5,12,194,8,194,0,5,8,5,8,14,8,9,195,11,19,11,19,194,21,15,22,
+195,20,22,20,196,23,29,194,30,32,194,57,194,33,196,34,36,38,34,42,198,39,
+38,197,39,44,48,51,55,194,60,194,61,194,63,62,61,195,64,194,62,65,66,56,
+194,54,51,54,194,51,59,50,194,48,59,51,194,48,51,59,51,50,59,51,48,53,54,
+51,195,54,51,198,54,196,56,66,54,198,56,65,66,65,67,194,65,62,65,194,62,
+65,56,54,53,59,47,44,39,47,39,194,40,44,47,44,194,48,49,196,45,42,196,43,
+195,41,35,194,37,194,31,195,30,194,32,30,24,28,20,194,28,17,194,20,17,16,
+17,196,15,21,197,13,10,8,0,194,8,195,5,194,3,2,4,1,226,0,219,0,194,1,195,
+4,194,3,194,5,8,194,0,194,8,0,8,14,194,8,14,194,9,11,19,11,19,21,19,18,
+22,18,194,17,194,20,23,24,27,23,29,30,194,33,194,32,33,32,33,194,58,195,
+38,36,40,39,36,47,39,194,40,196,39,194,40,47,59,51,55,56,60,194,61,64,61,
+62,196,64,62,67,56,66,56,194,54,50,53,194,59,51,50,59,194,51,50,48,195,
+51,50,48,59,50,48,54,51,195,50,51,199,54,56,54,197,56,54,194,66,56,195,
+66,65,67,195,62,65,194,62,194,56,54,51,59,48,40,194,47,40,47,44,47,59,48,
+195,50,195,49,45,194,43,46,195,43,42,35,195,41,194,34,33,31,32,194,30,24,
+194,26,24,26,195,20,194,17,20,17,15,195,16,13,16,195,13,11,194,9,10,194,
+0,12,194,0,6,5,3,6,4,196,1,223,0,219,0,194,1,196,3,196,5,194,0,194,9,14,
+8,195,14,19,9,195,11,21,19,25,21,15,17,20,22,194,20,26,23,24,27,195,29,
+30,194,33,32,194,58,194,33,194,34,39,40,36,42,40,42,40,47,40,47,44,39,40,
+39,47,44,48,51,54,60,194,61,63,61,63,194,64,68,194,64,69,62,66,194,56,195,
+54,59,194,50,48,59,50,51,50,59,194,51,54,50,194,54,53,51,54,51,202,54,195,
+56,54,66,54,66,54,56,65,194,56,66,194,65,56,66,62,195,67,62,67,195,65,66,
+54,51,59,44,195,40,44,47,44,48,51,196,50,52,194,49,52,194,45,46,45,42,194,
+43,41,43,34,194,35,31,34,31,57,195,32,30,26,28,26,20,26,194,20,17,194,20,
+194,17,15,16,15,16,15,196,13,9,11,9,194,8,5,12,194,5,6,3,4,194,1,225,0,
+217,0,197,1,3,194,4,3,5,12,195,0,10,0,9,194,8,194,14,9,11,13,15,194,19,
+194,21,19,25,22,18,17,20,24,23,20,23,195,29,195,31,196,33,58,194,38,194,
+39,36,194,40,46,40,44,40,47,194,40,44,40,47,44,59,51,54,60,65,61,63,61,
+194,64,68,70,68,194,64,65,66,194,56,54,195,51,54,195,51,50,51,50,54,53,
+50,53,51,198,54,205,56,54,66,196,56,194,66,56,66,65,195,67,62,66,65,69,
+62,67,62,194,66,56,54,51,59,194,47,194,44,194,47,44,194,59,194,51,50,194,
+53,197,49,46,45,46,45,195,42,34,36,39,194,34,195,33,194,32,195,26,30,194,
+26,20,26,28,20,195,17,18,17,18,16,15,16,195,13,11,194,10,194,9,0,194,8,
+194,5,195,3,4,194,1,224,0,219,0,194,1,4,194,3,195,5,0,8,194,0,195,9,194,
+14,8,14,195,11,15,21,19,194,25,27,18,194,20,28,26,24,23,24,196,29,37,31,
+33,34,33,58,194,33,196,38,36,42,195,47,48,45,48,59,195,47,59,50,51,53,56,
+60,64,62,194,64,71,194,70,71,195,69,65,194,56,195,54,196,51,200,54,56,54,
+56,194,54,196,56,195,66,65,56,65,197,66,65,196,56,66,194,65,66,62,67,194,
+65,62,67,62,67,65,66,62,66,65,194,56,51,54,194,48,44,194,47,40,44,47,195,
+48,51,194,54,196,53,194,49,52,194,45,43,45,195,42,36,34,36,38,34,195,33,
+58,32,58,32,196,26,28,197,20,194,17,16,18,16,194,15,16,194,13,11,13,194,
+10,194,0,5,8,5,8,6,4,6,4,195,1,223,0,217,0,195,1,2,194,3,196,5,194,0,9,
+0,10,0,14,194,8,194,14,19,11,195,21,25,19,21,25,18,17,194,20,24,26,194,
+30,31,29,37,194,31,194,35,33,34,38,196,58,38,39,47,39,42,195,44,194,47,
+194,44,194,48,51,54,55,65,60,63,194,64,71,70,68,194,70,68,64,67,194,66,
+56,66,199,54,196,56,54,66,194,65,56,66,56,194,66,65,66,67,62,195,65,194,
+67,66,197,65,195,67,195,62,66,67,62,66,65,195,67,62,67,62,66,65,66,194,
+56,195,54,195,59,47,194,44,47,40,44,47,59,51,53,194,54,53,194,50,53,49,
+194,50,48,45,48,194,46,40,42,40,42,38,34,194,38,33,58,194,32,26,195,32,
+194,26,24,195,26,28,20,28,195,17,18,194,16,13,15,194,13,11,13,194,9,194,
+0,5,8,5,3,5,195,3,195,1,222,0,217,0,1,0,194,1,4,194,5,3,12,8,194,0,9,0,
+9,10,9,194,14,19,9,194,11,21,11,21,25,21,194,25,22,23,194,20,194,24,23,
+30,31,29,194,37,196,35,34,194,38,195,34,194,38,194,39,194,44,48,194,50,
+196,51,50,54,56,55,62,195,64,195,70,194,68,194,71,194,64,62,66,196,54,198,
+56,65,66,67,65,66,67,194,62,67,194,62,67,65,62,194,67,194,69,194,67,194,
+69,195,67,69,67,194,62,66,194,67,194,62,67,62,67,194,62,65,66,65,66,65,
+194,56,195,54,51,195,50,44,48,59,47,48,194,47,48,59,48,59,51,53,56,194,
+55,195,53,195,50,45,48,44,42,44,42,39,40,39,34,194,38,194,33,58,33,194,
+57,26,194,32,194,26,28,198,20,194,17,195,18,194,15,16,13,11,194,13,194,
+9,0,12,0,194,8,5,3,4,3,195,1,222,0,218,0,195,1,3,6,3,5,8,0,9,0,194,9,11,
+9,196,14,194,19,194,15,25,194,21,195,25,22,20,24,30,24,196,30,31,37,35,
+37,35,41,194,36,39,34,196,38,39,38,47,40,44,194,59,194,50,51,194,54,194,
+56,65,62,194,64,68,194,70,68,195,70,68,71,69,66,67,56,65,195,56,195,65,
+194,62,195,67,62,194,69,67,194,69,64,194,69,62,199,69,71,194,69,194,64,
+69,67,62,194,67,69,196,67,65,67,62,194,67,62,65,66,54,194,66,197,54,195,
+59,194,51,44,48,59,194,48,44,48,59,198,54,56,54,53,195,50,44,48,44,59,42,
+40,42,36,34,39,194,38,194,58,33,32,195,33,32,26,32,24,30,195,26,195,20,
+195,17,196,16,15,16,195,13,11,194,9,8,5,12,5,195,3,4,196,1,221,0,218,0,
+195,1,4,195,5,8,194,0,10,9,10,9,11,9,14,11,194,14,19,11,15,18,21,195,25,
+27,22,24,26,195,24,29,30,31,194,37,41,37,194,41,35,36,40,196,39,38,194,
+39,194,47,48,50,194,51,53,55,194,56,60,65,62,194,64,68,196,70,194,72,73,
+68,71,64,62,194,67,194,66,65,56,66,62,67,195,69,198,71,69,71,69,195,71,
+69,197,71,69,195,71,196,69,64,69,62,64,194,62,65,67,62,67,194,65,66,62,
+56,65,56,54,56,194,54,194,51,54,51,50,194,48,194,51,44,59,194,47,59,47,
+59,195,51,194,54,53,194,54,194,50,59,51,44,48,44,47,44,194,40,194,39,34,
+195,38,195,58,195,32,33,194,32,195,26,194,28,196,20,196,17,194,15,13,16,
+15,195,13,194,9,0,195,8,194,5,195,3,1,223,0,217,0,194,1,2,3,5,6,194,5,194,
+0,9,0,10,9,13,9,195,14,19,197,21,195,25,194,27,22,23,24,32,26,32,33,29,
+194,31,194,35,194,41,35,43,42,194,36,39,194,38,194,39,38,39,40,47,59,51,
+54,194,56,60,62,65,62,194,64,194,70,194,68,72,74,70,75,72,194,71,194,69,
+194,67,194,62,67,195,69,71,69,71,194,73,76,73,76,73,76,73,77,194,73,76,
+196,73,194,71,194,73,195,71,73,196,71,64,71,196,69,62,66,65,194,67,62,65,
+66,56,65,56,195,54,194,53,50,53,51,54,51,194,48,194,51,194,48,44,48,44,
+59,196,54,51,54,194,51,54,50,48,51,47,44,48,40,47,39,47,194,39,36,194,34,
+38,197,33,197,32,24,30,24,28,197,20,194,18,194,16,18,15,195,13,194,11,9,
+14,0,12,194,5,195,3,196,1,221,0,219,0,1,4,194,3,195,5,0,194,9,10,9,194,
+13,9,19,9,194,19,194,15,194,18,194,25,27,22,27,194,23,24,30,31,30,33,194,
+31,37,194,35,194,41,194,43,42,44,42,47,194,39,38,194,39,40,194,44,50,194,
+54,55,56,60,62,194,64,194,68,195,70,196,75,194,70,73,76,69,71,199,69,71,
+76,73,76,73,72,78,72,78,196,72,78,72,73,72,78,72,194,76,71,195,73,76,71,
+194,73,195,71,69,71,69,194,64,69,64,69,196,62,194,65,56,54,196,56,195,54,
+194,51,194,54,51,50,48,195,51,194,59,48,59,194,51,197,54,195,51,194,48,
+59,44,48,40,47,40,196,39,38,36,38,194,58,195,33,58,194,57,30,32,26,30,24,
+26,28,194,20,195,17,18,17,16,15,18,15,11,13,10,195,9,14,0,5,0,195,5,3,4,
+194,1,221,0,216,0,196,1,4,3,5,12,194,0,10,9,10,11,13,11,9,19,14,19,11,21,
+19,21,15,18,27,25,18,25,194,22,194,24,195,30,194,31,34,195,41,35,43,42,
+43,194,42,40,42,196,39,40,39,40,47,59,50,53,65,60,62,65,64,71,196,70,74,
+194,70,75,74,194,75,72,71,76,69,71,194,69,194,71,73,76,78,72,78,195,79,
+75,194,80,78,196,79,78,79,78,72,78,194,72,196,78,73,76,73,71,70,73,194,
+71,69,71,69,71,62,69,62,194,67,62,65,62,56,65,195,56,54,56,54,56,54,194,
+53,50,51,54,195,51,196,48,194,59,194,51,194,54,194,51,59,48,59,194,51,59,
+48,59,47,48,44,40,47,196,39,38,39,196,38,34,33,194,31,194,32,30,26,195,
+24,28,195,20,194,17,18,17,194,16,15,16,194,13,11,9,14,9,8,0,195,5,195,3,
+194,1,221,0,216,0,196,1,194,3,194,5,194,8,10,9,10,9,196,13,195,19,21,25,
+18,25,194,18,195,27,194,23,29,30,195,32,194,31,33,35,194,41,42,195,43,194,
+46,44,48,44,47,194,39,47,39,194,44,59,51,54,194,65,194,64,68,194,70,72,
+195,75,74,81,74,81,74,75,79,72,194,73,196,76,78,194,72,194,79,72,80,79,
+82,194,80,83,196,80,83,194,80,194,79,80,78,195,75,195,72,78,72,194,76,195,
+73,68,71,69,71,195,64,62,67,62,65,62,60,65,194,56,65,54,56,54,195,56,194,
+54,53,54,194,50,195,51,59,194,51,48,51,50,194,51,194,54,194,51,194,48,194,
+59,48,44,194,47,194,40,47,196,39,38,36,194,34,38,194,34,33,34,194,31,32,
+31,33,30,194,24,28,20,17,194,20,17,18,17,15,16,195,15,13,194,10,194,9,194,
+8,194,0,5,195,3,194,1,221,0,217,0,194,1,2,4,194,5,8,195,0,194,9,194,13,
+195,11,9,194,21,194,19,21,194,18,194,22,27,23,194,27,29,194,30,194,33,194,
+34,35,34,41,196,43,196,45,194,44,194,40,194,39,195,47,59,51,54,56,62,67,
+195,68,72,70,195,75,74,75,81,83,80,79,75,72,78,198,72,194,79,194,80,82,
+195,83,82,194,83,82,84,82,194,83,196,80,79,194,80,78,196,79,72,78,194,72,
+71,194,73,71,68,70,68,71,195,69,62,65,62,65,62,65,62,65,56,194,65,56,54,
+56,54,56,55,197,54,194,50,54,194,48,59,48,195,51,194,59,51,48,195,59,48,
+194,59,194,44,47,44,40,197,39,38,194,39,34,38,34,36,31,33,194,31,30,29,
+195,24,30,20,28,195,20,17,18,17,15,17,194,15,13,194,11,10,0,9,0,197,5,4,
+195,1,220,0,215,0,1,0,194,1,3,4,195,5,12,0,194,10,196,13,194,11,194,19,
+21,195,25,194,18,194,22,195,23,194,29,194,30,31,30,31,36,35,34,42,194,43,
+42,43,45,43,52,49,45,48,59,47,44,194,40,194,44,59,54,56,66,194,64,68,70,
+72,194,75,70,74,75,197,81,194,80,74,197,79,196,80,194,83,194,84,194,85,
+86,84,87,195,85,82,84,82,194,83,84,83,82,80,194,79,194,80,78,194,79,195,
+78,72,73,76,195,71,64,68,194,64,69,62,64,67,62,65,194,62,196,65,195,56,
+54,195,56,196,54,50,54,51,50,59,48,59,195,51,196,59,48,197,59,44,196,47,
+194,39,40,195,39,40,194,36,194,34,35,33,194,31,194,30,31,30,195,24,194,
+28,194,20,195,17,15,194,16,194,15,9,194,11,195,9,194,8,5,195,3,195,1,220,
+0,216,0,1,0,194,1,5,194,3,194,8,9,196,11,194,13,194,15,11,21,19,194,21,
+25,27,194,22,23,27,23,195,29,30,31,33,195,34,194,36,194,42,46,43,45,43,
+52,195,49,194,50,51,59,47,44,40,47,59,51,194,56,65,69,71,73,70,74,70,194,
+74,194,81,194,74,88,83,81,194,80,79,80,194,79,194,80,195,83,84,87,85,194,
+86,89,84,86,194,84,86,84,194,85,87,194,84,194,85,83,82,194,83,197,80,194,
+75,79,78,194,72,76,73,71,73,195,69,64,69,67,194,62,64,62,65,194,62,196,
+65,194,56,195,54,56,53,195,54,51,50,51,50,51,50,48,50,200,59,194,48,44,
+47,44,194,40,39,194,40,39,194,40,42,36,40,42,36,195,41,37,195,31,29,30,
+29,26,194,24,20,194,17,20,195,17,195,15,194,13,11,9,10,9,14,0,12,195,5,
+194,3,195,1,219,0,216,0,1,0,4,1,6,194,5,0,8,0,194,10,194,13,194,15,13,195,
+21,25,21,194,25,18,194,22,24,194,23,195,29,37,194,31,33,194,34,194,36,194,
+42,195,45,195,49,194,52,194,53,51,48,194,59,195,48,51,54,66,62,64,71,72,
+194,75,81,74,195,83,195,88,194,85,194,83,80,194,83,194,82,83,82,84,85,84,
+89,194,87,86,89,90,198,89,86,89,90,195,84,85,195,84,195,83,195,80,72,75,
+194,79,195,72,194,73,194,68,69,196,64,67,194,64,197,62,65,62,195,65,56,
+54,194,56,53,54,53,195,54,195,51,59,50,196,48,194,59,44,195,59,48,195,47,
+44,194,47,40,47,195,40,42,40,194,42,195,41,37,35,194,31,29,30,29,30,194,
+24,28,195,20,18,20,194,17,18,15,21,194,13,11,194,9,195,8,195,5,194,3,1,
+221,0,215,0,1,0,1,4,3,194,5,12,8,0,194,9,11,195,13,16,194,15,21,25,19,195,
+25,194,22,20,23,24,195,29,194,37,31,196,34,36,195,42,195,45,195,49,53,194,
+52,194,53,54,194,59,194,51,194,54,56,65,194,69,70,75,70,75,80,194,81,74,
+88,194,85,87,88,87,85,84,196,83,85,84,87,84,89,90,89,194,91,92,93,194,91,
+93,197,91,197,89,194,86,194,85,87,84,83,80,82,83,194,80,79,75,78,72,194,
+70,194,73,71,68,71,68,71,69,64,194,67,69,195,62,65,62,195,65,56,194,65,
+195,56,54,56,54,53,51,50,51,48,50,59,51,59,47,194,59,48,197,59,48,194,44,
+47,40,44,47,194,40,47,46,44,194,42,194,43,35,194,41,35,195,31,194,30,196,
+24,28,195,20,194,17,15,16,194,15,11,21,13,11,195,9,12,194,5,194,3,4,195,
+1,219,0,215,0,195,1,194,4,194,5,12,0,9,0,195,13,197,15,21,25,19,194,25,
+27,22,23,24,194,30,194,29,37,31,37,35,194,36,34,38,34,40,194,42,194,46,
+52,49,194,52,194,53,194,60,55,56,54,195,51,194,54,66,65,194,69,68,72,75,
+74,81,74,197,88,90,87,90,87,85,87,84,85,83,194,85,87,196,89,195,91,199,
+93,91,93,195,91,194,89,90,86,89,84,194,86,84,83,80,82,83,80,79,80,79,80,
+78,195,70,71,68,71,68,64,71,68,194,64,69,194,64,69,62,64,195,62,194,65,
+196,56,54,56,197,54,51,50,194,48,50,44,48,59,48,194,59,194,48,194,59,47,
+44,194,47,194,44,48,44,47,42,194,46,194,42,43,42,35,41,37,35,195,31,30,
+32,26,195,24,22,20,22,20,17,18,195,15,13,11,194,13,195,9,0,12,194,5,194,
+3,4,1,220,0,218,0,4,3,4,5,194,8,14,194,9,11,13,15,13,195,16,15,21,27,194,
+25,27,22,24,195,23,30,29,31,37,35,37,35,34,194,39,40,194,42,194,44,45,49,
+45,195,52,194,60,61,65,55,194,56,195,54,194,56,67,62,71,76,72,75,74,80,
+195,88,87,196,90,194,87,86,194,84,87,194,86,194,89,90,89,91,93,91,94,93,
+95,96,94,195,96,194,94,194,93,91,84,80,194,89,91,194,89,87,89,87,86,194,
+85,82,194,83,194,74,194,75,79,196,73,70,71,73,68,195,71,64,194,69,62,69,
+195,62,65,62,65,62,65,56,65,196,56,54,53,194,54,51,194,54,59,51,195,59,
+48,59,51,194,59,194,48,59,195,48,59,47,48,45,48,44,46,194,42,194,43,195,
+41,35,195,31,33,31,194,30,194,24,20,22,17,194,18,15,18,197,15,9,11,194,
+14,0,196,5,194,3,194,1,219,0,215,0,195,1,4,3,6,12,194,0,194,9,10,194,13,
+195,15,195,18,15,194,25,195,27,23,24,194,30,31,194,37,35,41,35,41,194,34,
+36,39,40,42,46,44,195,49,52,50,55,52,65,195,60,194,65,56,195,66,56,67,64,
+68,73,72,75,74,83,85,87,88,90,87,91,194,92,91,194,89,90,86,195,89,194,86,
+195,91,94,93,195,96,194,97,98,194,96,97,194,95,85,194,70,194,73,91,93,91,
+93,194,89,90,89,84,85,84,85,194,83,81,80,75,74,75,70,194,72,196,73,194,
+68,71,68,64,71,64,195,69,64,194,62,65,62,195,65,197,56,53,194,54,194,51,
+54,51,194,48,194,59,50,194,59,196,51,195,59,194,50,195,48,45,44,46,43,45,
+195,43,194,41,36,35,33,31,194,30,32,30,26,23,24,20,22,18,22,195,18,194,
+15,11,15,11,13,194,9,194,0,12,0,5,4,3,194,1,219,0,216,0,194,1,2,194,3,5,
+194,0,9,194,11,194,13,16,15,194,16,194,17,18,25,194,18,27,22,23,194,30,
+31,29,31,37,194,35,194,41,36,42,39,194,42,44,194,48,50,49,194,53,194,52,
+62,61,63,64,194,62,56,66,194,56,65,67,62,71,194,73,79,74,83,81,88,87,201,
+90,194,89,87,194,86,196,91,194,93,194,96,97,98,97,98,97,194,98,97,94,194,
+75,74,75,72,102,95,105,91,105,194,91,194,89,90,89,87,194,84,83,82,194,80,
+79,194,72,70,72,194,70,72,70,194,73,70,194,71,68,69,195,64,62,64,62,64,
+65,62,195,65,195,56,54,56,194,53,194,54,194,50,194,51,48,194,51,195,54,
+194,51,50,54,195,51,59,50,59,46,50,45,44,195,45,42,43,42,41,35,36,35,31,
+33,194,30,26,29,30,194,23,194,22,18,20,15,18,195,15,194,13,11,9,19,194,
+0,5,8,5,3,196,1,218,0,215,0,1,0,1,4,3,194,5,194,0,194,9,11,21,11,16,18,
+15,16,18,194,22,25,27,25,27,23,29,24,194,30,194,31,37,194,35,194,41,43,
+42,39,40,194,42,46,48,50,53,52,60,61,52,195,61,62,64,69,62,195,67,62,67,
+194,69,73,72,78,74,83,81,85,87,90,91,92,91,93,92,91,92,89,92,195,91,89,
+196,91,93,94,194,95,98,95,195,99,100,98,84,75,74,72,194,75,94,98,194,95,
+194,96,194,94,194,91,194,89,90,85,87,83,84,83,81,194,74,80,72,75,72,73,
+55,65,196,73,71,70,71,197,69,67,64,67,195,62,65,62,56,65,195,56,55,53,195,
+54,50,54,197,51,195,54,51,54,53,195,54,53,195,50,194,48,43,194,45,42,195,
+43,35,34,194,31,194,33,30,32,194,24,20,23,194,22,25,22,195,18,16,195,15,
+11,9,19,0,9,0,194,12,5,3,1,220,0,214,0,1,0,194,1,3,194,5,194,0,14,9,194,
+11,13,194,15,194,16,18,17,194,18,194,27,22,23,194,27,37,30,195,31,35,37,
+41,35,43,42,40,42,36,47,194,48,195,50,52,194,60,61,63,197,64,69,195,62,
+194,67,69,71,76,73,75,80,74,85,194,87,89,194,90,194,92,96,92,93,194,91,
+195,89,93,195,91,194,94,196,96,99,97,194,100,101,195,74,75,194,74,97,100,
+98,97,98,195,95,96,95,94,194,91,194,89,194,86,194,83,195,80,75,194,74,75,
+62,194,53,50,56,195,70,73,194,70,194,68,195,64,67,64,194,62,65,62,65,62,
+196,56,196,54,50,54,194,51,53,194,54,56,194,54,66,196,56,55,53,54,194,53,
+194,50,49,48,45,43,45,194,42,43,34,35,194,34,194,31,195,30,196,23,194,22,
+194,17,195,18,16,15,195,11,194,9,194,0,8,5,3,4,194,1,219,0,214,0,195,1,
+194,4,194,5,8,0,194,10,195,13,194,15,18,195,17,194,18,22,27,195,23,194,
+29,30,195,31,196,41,194,43,42,44,42,40,44,46,48,53,50,52,55,61,60,61,63,
+64,70,68,64,194,71,69,67,194,69,194,71,76,72,79,83,194,85,194,90,92,91,
+197,93,194,92,195,93,195,91,195,93,194,96,95,98,196,99,95,83,81,74,83,194,
+81,89,99,100,99,100,98,95,96,95,194,96,95,194,94,194,91,90,89,194,87,85,
+194,74,75,79,80,79,73,194,55,52,53,67,72,196,73,194,71,73,71,68,195,69,
+64,194,62,65,62,65,197,56,53,194,54,50,194,51,194,54,56,66,194,56,66,56,
+66,197,56,50,194,53,50,52,46,45,43,45,194,42,43,194,41,35,36,194,33,195,
+31,29,22,194,23,195,22,18,17,15,18,194,16,194,15,194,11,9,8,9,0,5,194,3,
+194,1,219,0,216,0,194,1,194,3,8,0,194,9,196,11,194,15,16,17,195,20,194,
+22,27,194,23,195,29,194,31,33,34,35,194,41,195,43,194,42,40,194,44,48,50,
+53,55,60,194,61,194,63,64,68,70,68,71,68,69,64,71,69,71,77,73,72,194,79,
+80,83,85,87,90,195,92,196,93,194,95,194,91,92,91,197,93,94,96,195,98,194,
+100,94,74,81,74,83,194,81,74,194,103,194,104,103,194,104,194,99,98,95,97,
+96,194,93,91,89,90,87,85,87,85,83,81,195,74,80,196,55,52,71,70,195,73,70,
+73,194,68,71,68,64,62,67,69,62,64,65,62,195,65,196,56,194,54,53,194,54,
+195,56,66,56,194,65,195,56,60,194,55,56,53,50,53,50,49,48,194,45,196,42,
+194,34,194,35,31,33,194,30,194,29,23,27,23,22,194,17,18,17,18,195,15,13,
+194,11,194,9,0,8,194,12,194,3,194,1,218,0,214,0,195,1,194,3,194,5,194,0,
+9,10,195,11,195,15,18,194,17,194,20,22,27,194,23,195,29,196,31,35,41,195,
+43,45,42,46,194,47,48,51,50,53,55,60,195,61,194,64,68,194,70,73,70,73,69,
+195,71,77,76,78,79,80,83,194,85,87,91,194,93,194,92,97,92,96,93,95,93,95,
+93,195,94,93,94,96,95,97,98,99,98,99,93,83,74,195,81,80,83,81,104,107,106,
+195,104,195,99,103,98,95,98,95,96,194,94,194,92,87,194,85,194,83,74,81,
+194,74,75,60,195,55,60,194,72,70,72,70,194,73,68,195,71,68,194,64,67,69,
+194,62,194,65,196,56,54,56,195,54,194,56,66,56,196,67,195,62,194,65,194,
+55,52,53,50,49,50,49,46,44,196,42,194,36,194,34,35,33,194,31,194,29,23,
+22,23,194,22,194,20,196,17,15,195,13,11,194,9,0,194,5,4,3,1,219,0,215,0,
+194,1,4,6,12,8,0,194,9,194,11,194,15,21,15,18,17,22,20,194,22,24,23,27,
+195,29,37,194,31,194,34,41,35,195,42,46,45,48,44,48,44,48,50,53,194,52,
+60,195,64,196,70,194,73,71,73,68,69,70,73,194,72,75,80,83,85,90,89,90,194,
+92,196,97,195,96,197,93,91,94,96,94,95,98,96,98,99,94,195,81,83,81,74,195,
+85,106,108,194,104,106,104,194,99,103,95,101,99,194,98,95,96,194,91,195,
+90,87,194,81,83,74,83,81,83,61,194,60,195,55,194,75,195,72,194,73,194,70,
+68,69,71,69,64,62,67,195,62,194,65,56,54,194,56,54,53,50,194,66,65,67,198,
+62,67,62,60,62,56,194,55,194,53,194,50,48,46,48,44,194,42,36,194,34,35,
+33,194,31,37,195,29,195,23,24,22,17,18,194,17,195,15,194,11,10,9,0,8,0,
+5,3,4,194,1,218,0,213,0,1,0,194,1,3,4,12,5,9,11,9,13,194,11,15,21,18,15,
+17,195,20,22,24,194,23,195,29,37,194,31,41,34,41,195,43,45,43,194,45,194,
+44,59,48,51,54,65,62,61,194,64,68,195,70,72,73,72,195,73,77,194,73,78,79,
+194,80,83,85,90,92,93,194,96,93,96,195,97,196,96,194,93,94,93,94,96,194,
+95,98,97,98,93,74,81,83,81,74,85,195,81,88,106,107,106,91,85,194,83,74,
+83,74,80,194,75,83,102,194,95,94,91,194,89,194,87,194,85,88,83,81,80,61,
+196,60,55,64,194,75,70,195,72,194,73,70,194,68,194,71,64,69,67,194,62,65,
+62,194,65,54,195,56,53,54,66,62,67,69,67,64,69,194,64,62,64,65,60,61,195,
+55,194,53,50,52,44,46,44,194,42,40,194,36,35,36,194,31,37,196,29,24,22,
+20,23,20,194,22,194,17,194,15,194,11,13,9,10,8,0,12,194,3,194,1,218,0,214,
+0,195,1,4,5,8,0,194,9,11,194,13,195,15,18,22,194,20,28,20,24,194,23,195,
+29,194,37,31,194,34,35,41,196,43,45,43,44,48,59,48,51,53,55,194,60,63,64,
+68,194,70,68,74,70,194,72,73,78,76,73,76,78,72,78,80,82,84,87,86,89,92,
+194,93,96,97,96,195,97,98,194,96,194,95,96,95,96,94,96,95,194,98,99,83,
+194,80,81,80,85,83,194,85,87,194,85,194,88,85,83,81,83,85,81,83,81,74,80,
+79,75,74,70,87,94,91,90,89,87,88,195,85,83,88,73,194,61,196,60,78,75,74,
+75,70,72,196,73,71,68,64,69,194,64,67,194,62,194,65,56,65,195,56,54,194,
+56,195,67,194,69,64,194,69,195,64,63,65,61,52,194,55,53,48,50,45,44,45,
+44,194,42,195,36,35,36,35,194,37,195,29,23,24,23,20,22,195,17,18,15,21,
+13,11,9,13,9,194,0,5,3,4,194,1,218,0,216,0,1,5,3,194,8,194,10,11,15,13,
+196,15,18,17,20,28,20,24,23,27,195,29,31,194,37,35,34,36,34,194,43,196,
+45,44,46,47,48,51,54,56,194,61,194,64,70,68,70,72,194,75,70,75,195,72,73,
+72,78,79,194,80,83,85,86,92,91,93,92,194,97,99,97,98,97,98,97,195,95,94,
+96,195,95,96,98,95,98,95,74,81,80,194,81,85,83,194,85,87,88,195,87,194,
+85,88,197,83,81,194,74,195,75,72,70,85,89,92,90,196,87,194,85,72,195,61,
+195,60,73,79,75,80,72,194,70,194,72,194,73,71,68,194,69,64,69,62,69,194,
+62,65,194,56,54,194,56,65,56,62,67,69,68,71,64,194,71,69,194,64,195,62,
+60,52,55,53,194,50,45,44,46,194,42,40,39,194,36,195,35,194,37,194,29,30,
+29,24,23,196,20,17,18,15,21,15,11,9,11,10,0,8,12,194,3,194,1,218,0,213,
+0,195,1,4,6,8,12,14,9,194,11,194,15,21,194,15,194,18,22,17,194,20,28,24,
+195,29,194,37,35,41,36,41,34,195,42,194,45,194,49,50,51,48,59,51,54,55,
+60,194,64,71,68,70,194,72,74,70,75,196,78,72,78,72,75,79,80,83,85,87,89,
+194,92,194,97,96,195,97,95,97,194,98,195,96,194,95,96,194,95,96,194,99,
+102,80,194,81,194,83,81,85,197,87,85,87,88,195,87,85,195,88,74,194,81,194,
+74,75,70,72,70,75,194,89,90,196,87,88,73,64,195,61,65,61,60,194,74,75,74,
+80,75,195,70,73,70,73,70,68,69,64,69,195,62,65,62,194,65,195,56,62,66,62,
+195,69,71,68,64,194,68,194,64,63,60,65,60,55,53,194,50,195,48,44,40,194,
+42,36,34,41,195,35,31,37,194,30,194,24,20,23,194,20,17,20,17,18,15,21,15,
+13,10,9,14,0,194,5,3,194,1,218,0,214,0,1,0,1,5,8,0,194,9,13,11,194,15,21,
+195,18,17,195,20,194,24,30,195,29,194,37,194,35,34,194,36,42,43,46,43,45,
+52,49,50,51,50,48,51,54,56,60,61,64,195,70,75,70,194,74,75,74,75,79,78,
+195,79,194,80,82,84,86,89,91,93,94,96,194,97,98,195,100,95,195,98,197,95,
+196,98,99,81,80,83,81,194,85,196,88,194,87,90,88,90,87,85,194,88,87,195,
+85,194,83,81,80,74,80,75,194,72,194,70,86,92,196,90,79,64,63,64,194,63,
+194,61,60,78,194,74,75,74,80,75,72,70,72,70,73,71,68,69,195,64,62,64,195,
+65,196,56,62,69,62,69,195,71,73,194,71,69,194,64,62,194,60,56,194,53,195,
+50,48,195,46,40,39,42,34,194,41,35,195,37,30,31,30,29,24,26,28,20,17,20,
+17,18,194,15,21,11,13,10,194,0,12,5,3,194,1,218,0,213,0,195,1,5,3,5,8,14,
+194,9,11,21,194,15,21,15,17,195,20,28,195,24,194,29,31,37,194,35,37,35,
+36,194,42,43,194,45,195,49,194,50,59,51,50,56,60,62,63,196,70,194,75,74,
+75,74,195,75,79,72,194,79,194,80,83,194,85,86,92,93,92,194,97,194,100,97,
+195,99,98,196,95,97,98,96,95,194,98,99,103,80,194,81,80,194,83,194,85,194,
+87,90,88,87,199,90,87,195,85,194,83,194,81,74,194,75,72,73,194,70,86,194,
+92,84,73,68,195,64,62,61,64,60,61,68,194,83,74,80,75,74,75,194,72,194,73,
+70,73,70,71,194,69,64,195,62,195,65,54,194,65,194,67,194,69,194,71,195,
+68,70,195,64,62,65,60,65,56,53,194,50,46,48,44,40,196,42,194,41,37,41,35,
+31,29,30,24,26,24,195,20,28,20,17,194,18,195,15,11,194,9,8,194,5,3,2,1,
+218,0,213,0,194,1,4,6,5,8,0,10,195,13,195,15,196,18,194,20,28,26,30,24,
+194,29,31,194,37,194,41,194,36,194,42,43,46,45,49,52,49,194,50,194,51,50,
+56,55,62,64,70,68,72,195,75,74,194,80,74,79,75,194,79,194,80,82,80,83,86,
+87,86,91,95,96,97,98,97,99,194,97,194,100,99,194,98,97,195,98,97,98,97,
+194,98,99,74,80,194,81,194,85,196,87,194,90,194,87,194,90,89,198,87,88,
+85,88,194,74,81,74,72,75,197,70,196,68,71,68,195,64,63,64,194,61,194,83,
+74,81,80,75,74,75,72,73,72,70,73,194,68,64,194,69,64,67,194,62,194,65,56,
+194,65,67,69,71,69,195,71,194,73,71,68,195,64,194,65,55,56,194,50,51,194,
+48,46,44,46,194,42,194,43,41,195,35,194,31,194,30,24,30,24,26,194,20,17,
+18,15,18,194,15,194,13,194,10,0,5,3,4,194,1,218,0,212,0,1,0,194,1,3,5,12,
+0,194,11,9,21,194,15,18,15,18,17,20,17,20,24,20,24,30,29,195,37,41,35,194,
+34,36,194,42,46,45,195,49,52,53,194,50,51,194,54,194,62,194,68,70,75,194,
+70,75,195,81,196,80,72,80,79,80,83,82,84,89,194,91,93,96,98,97,194,100,
+196,99,98,99,97,99,95,97,196,98,194,99,104,80,81,194,83,88,194,85,195,87,
+89,90,89,196,90,89,194,87,90,87,88,87,88,83,85,81,83,194,74,194,75,72,198,
+70,196,68,195,64,61,64,63,88,194,85,83,74,80,79,194,75,70,72,195,73,194,
+71,194,64,69,64,195,62,194,65,56,194,62,67,69,71,77,71,70,71,73,70,194,
+69,64,194,65,55,56,53,54,51,50,48,45,48,46,40,44,42,194,43,41,43,37,35,
+197,31,24,20,194,24,28,194,20,18,194,15,195,13,11,9,194,0,5,3,2,1,218,0,
+212,0,195,1,4,3,5,194,0,10,13,10,195,15,25,21,18,17,20,28,20,26,194,30,
+31,29,37,31,194,35,41,36,34,36,194,42,43,45,195,49,52,53,51,59,51,194,54,
+65,64,68,194,70,196,74,81,195,74,198,80,82,80,85,84,86,194,91,93,96,100,
+98,99,196,100,194,99,194,98,99,194,98,95,194,99,98,104,99,104,85,194,81,
+83,81,88,85,195,87,90,92,89,90,89,90,92,90,92,197,90,87,194,85,81,74,81,
+74,194,75,72,194,73,197,70,68,194,70,194,68,196,64,196,85,88,194,81,75,
+80,75,72,70,72,195,73,71,64,69,64,195,62,65,62,56,65,67,62,69,71,76,71,
+73,68,71,194,68,195,64,62,65,56,55,54,51,50,59,194,48,45,46,45,46,43,42,
+43,194,41,36,31,33,194,30,194,32,24,28,196,20,195,18,15,195,13,9,0,8,5,
+3,2,1,218,0,214,0,2,1,6,0,8,9,194,11,15,13,15,21,15,194,18,195,20,26,24,
+26,24,30,29,194,37,194,35,41,194,36,40,42,46,194,45,52,49,194,52,53,194,
+54,51,54,56,62,64,194,70,194,72,194,75,195,81,194,83,74,194,82,195,80,83,
+85,84,86,90,91,93,95,98,97,194,100,197,99,100,194,99,98,99,98,99,194,98,
+195,99,104,105,74,85,88,85,195,87,90,92,194,90,92,91,194,92,90,92,90,89,
+90,195,87,85,87,195,83,81,74,195,75,197,72,197,70,68,71,68,194,64,73,195,
+87,194,85,194,83,81,195,75,72,195,70,73,68,69,68,67,69,194,67,62,195,65,
+62,194,69,195,71,73,71,68,73,194,71,64,194,62,56,60,54,194,53,51,50,48,
+194,44,48,43,45,42,43,42,194,41,35,33,194,31,194,30,24,32,194,24,194,20,
+195,18,15,16,15,13,11,194,9,0,12,194,4,1,218,0,212,0,194,1,194,2,6,12,0,
+9,10,13,15,13,15,196,18,194,20,28,194,26,195,30,29,195,37,41,35,194,36,
+194,42,194,45,195,49,52,50,55,53,194,51,54,56,65,69,68,72,75,72,74,75,80,
+83,81,88,194,83,80,195,82,80,82,194,85,194,89,194,93,96,98,194,99,194,100,
+104,100,104,194,99,100,99,98,99,98,194,99,194,100,99,194,104,103,81,83,
+85,87,88,90,194,87,91,196,90,89,90,194,89,194,90,89,90,194,87,88,87,194,
+88,83,194,81,75,70,196,75,73,72,70,72,194,68,196,70,194,68,80,194,87,90,
+85,194,87,194,85,81,75,74,75,194,72,70,73,70,71,68,195,64,196,62,65,62,
+67,69,194,71,76,194,71,68,71,195,69,194,62,56,65,56,194,54,51,194,50,195,
+48,195,45,43,42,35,34,41,195,33,194,31,194,30,26,24,194,20,18,17,22,15,
+194,16,194,13,9,0,8,12,194,3,1,218,0,213,0,1,4,3,5,8,0,10,11,13,11,196,
+15,18,20,194,28,20,28,30,26,30,29,31,37,195,41,194,36,194,40,42,46,43,194,
+49,52,53,194,52,54,51,194,54,66,64,68,194,70,74,70,194,74,195,81,80,194,
+83,195,80,195,83,194,84,89,194,91,93,96,194,98,100,104,103,100,104,103,
+194,100,103,99,103,98,104,194,100,194,99,104,106,194,104,195,85,194,87,
+85,87,194,90,89,194,90,91,92,91,195,92,89,90,194,89,194,90,88,87,194,85,
+83,195,74,195,75,70,74,70,196,72,70,68,70,68,70,71,87,90,89,87,90,87,194,
+85,81,83,81,79,74,75,194,72,194,73,68,194,71,194,69,67,62,195,65,66,195,
+69,71,69,194,73,194,71,194,68,62,67,65,66,56,194,54,53,51,54,195,50,194,
+45,197,43,36,34,194,35,194,31,194,32,194,26,28,20,23,20,22,194,18,194,15,
+194,13,10,14,0,5,3,4,194,1,217,0,212,0,194,1,4,3,12,8,0,10,11,194,13,15,
+21,195,18,194,20,194,26,28,32,194,30,29,31,37,194,35,195,34,36,40,44,48,
+52,45,49,52,194,55,56,53,50,194,54,66,67,71,194,70,195,74,81,74,85,194,
+88,195,85,194,83,82,195,85,84,86,194,91,94,96,97,98,194,100,194,103,104,
+106,103,104,99,104,196,99,194,100,103,104,106,107,106,83,194,88,87,90,194,
+87,90,92,89,91,90,89,92,89,91,89,196,92,90,87,90,87,85,88,81,85,194,81,
+74,75,194,74,195,75,70,75,70,72,195,70,194,68,73,91,194,90,196,89,194,87,
+85,81,80,195,75,70,72,194,73,194,68,194,64,194,69,195,62,194,65,194,69,
+71,69,194,71,69,71,69,194,64,194,62,56,65,195,54,194,51,195,50,49,52,45,
+46,43,194,42,36,195,34,194,31,196,30,24,28,22,196,17,16,15,194,13,10,9,
+8,5,194,3,1,218,0,211,0,1,0,2,194,3,5,194,0,11,194,13,195,15,21,195,17,
+194,20,24,32,194,24,194,31,37,195,35,195,36,39,194,42,46,45,52,49,194,52,
+60,55,196,54,56,64,68,72,194,75,194,74,194,81,194,88,196,85,194,83,85,84,
+82,84,87,194,89,93,96,194,98,100,99,199,104,106,99,104,103,99,100,99,198,
+104,88,85,195,87,90,92,194,90,194,92,91,92,91,196,92,91,92,195,90,87,194,
+90,194,85,88,81,83,81,195,74,75,74,195,75,74,70,194,72,195,70,89,90,194,
+91,92,194,90,194,89,87,194,85,74,80,74,75,72,70,72,70,71,73,71,69,196,62,
+65,62,67,62,194,69,71,69,194,71,69,64,69,194,67,195,66,194,56,53,194,54,
+194,53,195,49,46,194,45,194,42,34,36,34,31,194,33,30,32,195,26,30,20,22,
+18,22,16,18,15,21,13,194,9,0,5,3,4,194,1,217,0,211,0,1,0,1,3,5,12,194,0,
+9,194,13,194,15,194,18,22,20,196,28,26,32,30,196,37,34,35,34,38,194,39,
+194,40,45,194,49,52,50,55,60,65,54,51,54,56,66,64,73,194,72,194,74,75,83,
+194,88,196,85,84,82,83,195,85,84,89,194,91,105,96,95,99,100,195,104,106,
+200,104,99,104,106,104,194,106,194,107,106,85,196,87,89,91,90,92,89,92,
+93,92,93,195,91,92,194,91,194,89,90,194,87,194,88,87,83,81,74,196,81,196,
+74,72,194,75,195,72,70,86,93,194,92,195,93,90,195,89,84,87,85,194,80,74,
+75,70,72,194,70,194,68,194,71,69,194,62,194,65,62,65,64,67,197,69,64,67,
+194,62,65,194,56,66,56,54,55,54,194,53,194,49,52,49,46,45,194,42,34,194,
+36,35,31,194,33,195,32,195,24,23,194,22,17,194,16,21,13,194,9,0,5,194,3,
+1,218,0,212,0,194,1,3,5,194,8,9,10,194,13,195,15,18,17,195,20,26,24,32,
+24,194,30,194,31,34,35,34,195,39,36,42,45,46,194,49,53,194,52,60,55,195,
+54,194,56,69,68,74,70,75,74,83,81,88,85,194,87,85,83,194,85,196,84,89,90,
+89,91,194,93,98,194,99,194,104,107,104,195,106,104,103,106,195,104,99,104,
+106,104,108,104,107,104,87,85,194,87,195,90,194,91,92,91,92,91,196,92,89,
+92,90,194,92,91,90,87,194,90,194,85,88,194,81,74,196,81,197,74,195,75,105,
+96,92,196,93,92,194,93,90,194,89,84,87,85,81,79,194,75,194,72,195,73,194,
+64,62,69,195,62,65,67,66,194,69,62,195,69,197,67,66,194,56,54,56,54,195,
+53,52,195,49,45,46,194,42,196,36,34,194,31,30,195,26,30,26,20,194,17,22,
+17,15,195,13,10,8,12,5,4,194,1,217,0,212,0,194,1,3,5,194,0,9,194,13,21,
+15,195,18,196,20,26,20,194,32,30,195,31,34,41,34,38,34,39,194,40,46,45,
+49,194,52,60,52,61,56,54,51,54,56,65,69,70,75,81,74,81,74,85,194,88,85,
+194,87,86,84,87,195,85,84,86,89,194,91,93,194,96,194,99,106,104,106,195,
+104,106,194,104,196,106,194,104,107,106,107,108,106,95,195,87,195,90,92,
+90,91,92,91,92,195,93,91,92,91,93,194,91,90,194,92,89,87,194,90,85,87,85,
+87,197,85,194,81,84,85,81,74,86,95,96,194,97,96,194,93,95,94,195,93,194,
+91,90,86,87,81,83,74,75,72,73,72,70,195,71,64,69,195,62,65,62,65,62,194,
+67,69,194,67,64,67,195,62,66,56,65,56,194,65,56,196,52,194,49,45,43,44,
+42,40,194,34,35,34,195,33,32,194,26,194,24,22,24,17,18,20,16,15,13,11,10,
+9,12,194,3,1,218,0,211,0,1,2,3,4,12,8,0,9,194,11,13,21,194,18,195,20,26,
+28,26,32,26,194,30,194,31,194,35,38,34,36,39,38,39,46,48,194,49,194,52,
+55,61,60,55,195,54,66,67,64,73,194,75,83,194,81,194,88,85,195,87,84,85,
+84,195,86,90,89,86,91,93,94,95,194,98,100,196,104,106,107,104,194,106,196,
+104,196,106,194,107,109,91,88,90,87,194,92,91,90,91,92,93,92,93,194,92,
+96,92,93,198,92,90,92,194,90,87,90,86,194,89,87,90,84,195,85,84,87,74,81,
+105,99,98,97,196,96,95,194,96,94,93,195,91,89,90,85,87,85,80,75,194,72,
+70,194,73,68,64,71,64,69,64,65,62,65,62,194,67,62,65,67,62,66,62,66,67,
+66,194,65,66,65,56,55,60,55,53,194,52,194,49,45,48,46,40,195,36,34,31,35,
+33,57,26,32,26,24,20,24,194,22,20,194,18,195,13,194,0,194,5,4,194,1,217,
+0,211,0,1,0,2,3,12,194,0,10,194,13,194,15,18,194,17,194,20,24,20,28,194,
+24,196,31,34,35,194,34,38,36,194,39,42,48,194,49,53,55,60,52,61,56,54,51,
+54,56,67,69,72,70,81,74,83,195,88,195,87,90,86,90,195,84,86,196,89,194,
+91,95,194,98,100,194,104,106,194,104,106,194,108,195,106,107,196,108,194,
+107,194,109,90,87,90,194,89,92,91,92,93,92,194,93,194,96,92,93,92,195,93,
+92,91,89,92,90,91,194,90,194,87,194,88,85,88,87,85,87,85,87,194,85,83,94,
+194,99,100,99,95,194,98,97,96,97,194,96,95,96,194,93,89,91,89,194,85,83,
+74,194,75,73,70,72,73,68,69,64,67,69,194,62,195,65,194,67,62,67,62,66,62,
+65,62,66,67,65,67,62,194,65,195,60,53,52,194,49,48,44,194,42,40,194,36,
+194,34,33,31,33,196,32,20,24,20,194,17,18,17,15,194,13,9,0,12,5,3,1,218,
+0,212,0,1,4,3,5,194,0,194,9,11,13,21,194,17,195,20,28,194,26,195,32,194,
+31,33,31,34,39,34,39,38,39,42,44,48,49,195,52,60,62,65,56,195,54,56,62,
+73,70,75,74,83,81,88,194,87,195,90,86,84,85,89,195,86,194,90,89,194,91,
+194,95,97,99,98,194,106,104,194,106,195,107,108,107,108,107,106,195,107,
+108,194,109,110,194,87,194,90,92,89,92,91,92,96,194,92,93,92,194,93,96,
+195,92,91,194,92,91,92,196,90,88,90,85,88,85,197,88,83,81,87,101,106,100,
+99,194,100,97,194,100,99,195,98,96,95,93,94,93,91,194,90,194,85,83,74,75,
+194,72,194,73,71,70,71,64,62,64,197,62,65,67,65,67,62,195,67,62,65,194,
+62,65,62,60,62,52,60,195,52,49,194,46,44,40,194,42,194,36,194,34,33,195,
+32,26,194,24,194,22,23,20,17,194,16,13,11,9,0,8,3,4,194,1,217,0,211,0,1,
+2,4,3,5,194,0,11,13,15,13,15,194,17,20,17,20,28,24,26,195,30,32,31,195,
+34,38,34,39,38,39,40,46,48,49,52,53,194,52,61,65,56,54,51,54,56,67,73,72,
+75,81,74,85,195,88,87,195,90,89,194,90,87,89,86,89,194,91,194,93,96,95,
+98,99,100,99,195,104,194,108,104,194,108,107,108,107,104,107,110,195,109,
+111,95,196,90,92,93,92,199,93,92,93,96,194,93,92,93,91,92,91,92,91,92,194,
+90,87,195,90,194,87,195,85,88,85,89,196,104,106,99,104,106,99,100,99,100,
+99,196,98,95,96,94,91,90,194,87,85,80,74,75,194,70,73,71,68,194,71,67,62,
+67,195,65,62,56,194,62,67,195,62,67,69,67,62,69,195,62,194,61,60,55,194,
+52,49,194,48,46,194,40,195,36,34,195,33,26,195,32,30,24,20,195,22,15,195,
+13,10,194,0,5,3,1,218,0,211,0,194,1,194,4,5,8,0,9,194,11,15,13,18,194,17,
+28,194,20,195,26,32,30,195,31,33,34,195,38,36,39,40,44,48,45,194,52,60,
+194,61,60,56,195,54,66,67,68,72,74,194,81,194,88,87,194,90,194,89,87,89,
+194,86,89,90,195,89,194,91,105,94,194,95,97,99,104,106,107,106,195,107,
+194,106,110,109,108,107,196,109,111,98,87,194,90,92,194,91,92,93,194,92,
+96,194,92,93,194,96,92,194,93,92,96,93,92,93,92,194,90,89,91,89,195,87,
+88,90,88,90,195,88,194,104,194,108,107,195,104,106,104,99,106,194,104,99,
+100,194,99,97,96,94,93,105,91,89,87,85,81,74,75,194,72,70,73,71,68,194,
+64,69,64,62,194,65,56,65,194,66,65,66,67,66,69,194,67,194,62,69,64,194,
+61,194,60,55,52,194,50,48,46,40,194,42,40,194,36,194,34,33,32,33,26,32,
+24,26,194,23,20,17,18,17,194,16,13,11,0,8,3,4,195,1,216,0,211,0,1,2,194,
+3,5,8,0,10,194,13,194,16,17,194,20,195,28,24,30,24,32,30,31,33,35,194,34,
+58,34,38,194,39,40,44,50,53,52,53,195,60,194,56,195,54,65,67,73,70,74,83,
+74,194,88,87,195,90,91,90,200,89,91,195,93,96,98,194,99,195,104,107,106,
+195,107,108,200,109,106,87,90,194,91,90,92,91,92,93,96,92,195,96,92,195,
+96,93,96,93,92,96,92,194,93,197,92,90,92,91,87,90,87,90,195,87,109,194,
+107,108,107,195,108,194,107,104,194,106,104,106,194,104,195,99,95,96,95,
+93,92,89,86,85,83,194,75,72,194,70,195,71,64,196,62,65,56,194,54,56,65,
+56,62,65,194,67,69,71,196,64,63,61,194,60,55,53,50,48,45,44,40,42,36,34,
+36,38,34,33,32,33,26,32,24,32,20,23,194,20,194,18,194,15,13,9,194,0,5,3,
+1,218,0,211,0,195,1,6,5,194,0,11,9,13,194,15,194,17,194,20,194,24,194,26,
+30,195,31,35,33,194,34,196,38,47,44,45,50,194,52,55,60,61,194,65,194,54,
+194,51,66,69,73,75,74,81,88,85,194,87,90,92,89,90,91,198,89,195,91,194,
+94,194,95,98,99,195,104,106,195,107,108,107,200,109,112,87,195,90,92,194,
+93,92,93,92,93,96,93,194,96,97,196,96,194,93,96,194,93,194,92,194,93,91,
+195,92,197,90,87,90,194,87,202,109,107,108,106,109,197,104,194,99,98,96,
+93,91,89,86,85,88,80,75,194,72,73,70,68,64,195,69,195,62,194,65,196,56,
+66,67,62,195,64,71,69,194,64,195,61,60,52,53,50,194,48,194,46,195,40,36,
+34,194,33,58,196,32,24,23,24,23,22,17,18,15,195,13,0,8,194,3,195,1,216,
+0,212,0,1,2,5,3,8,0,11,13,15,17,15,17,195,20,28,20,24,32,24,30,194,33,35,
+33,194,34,196,38,39,47,48,50,53,194,52,60,61,60,56,196,54,62,69,73,72,75,
+83,195,88,87,90,194,92,90,194,92,89,194,91,89,195,91,93,91,93,95,194,98,
+99,196,104,194,108,107,108,198,109,112,194,111,104,92,91,92,89,194,92,93,
+92,96,92,93,96,92,97,203,96,194,93,194,92,93,195,91,194,92,91,194,90,196,
+87,205,109,107,109,195,106,194,104,99,101,99,95,96,93,91,86,87,83,74,75,
+194,72,73,71,70,195,64,62,195,65,194,56,54,56,53,194,56,194,66,67,64,68,
+195,64,63,61,194,60,55,194,50,194,48,44,46,194,42,39,36,194,34,33,194,32,
+26,32,30,24,23,195,24,195,17,195,13,194,0,5,3,1,218,0,211,0,1,2,194,4,5,
+0,9,195,13,15,194,17,194,20,28,20,30,194,24,194,32,194,31,33,34,195,38,
+34,38,194,39,40,194,48,52,55,194,60,61,194,65,195,54,56,67,64,73,74,194,
+81,88,87,194,90,89,194,90,92,91,89,92,89,91,194,89,91,89,105,94,95,194,
+96,98,100,103,194,106,108,107,194,106,194,109,103,110,195,109,111,113,109,
+104,89,90,91,92,91,93,92,96,93,96,93,96,97,208,96,196,92,91,196,92,90,194,
+92,90,111,109,112,111,114,111,109,111,109,111,198,109,194,104,106,104,106,
+104,103,99,95,194,93,91,84,85,80,75,194,72,194,73,71,195,69,67,64,62,194,
+65,194,56,194,54,53,194,56,62,67,194,69,71,194,64,62,194,61,65,54,53,50,
+194,44,47,40,44,36,42,38,39,58,33,194,58,33,195,32,26,195,22,194,18,13,
+15,13,9,0,8,5,3,195,1,216,0,211,0,194,1,3,194,5,194,8,11,13,16,15,195,17,
+20,28,20,26,195,30,32,33,31,33,194,36,34,194,39,36,39,40,44,48,50,52,53,
+195,60,65,56,195,54,56,67,68,73,75,81,194,88,194,87,90,92,194,91,194,92,
+194,91,89,194,91,89,196,93,94,95,98,195,99,104,106,107,108,107,110,109,
+107,87,90,99,107,111,109,113,114,93,194,92,93,194,92,196,93,198,96,97,96,
+97,200,96,195,93,194,96,93,92,91,92,194,91,194,92,90,194,92,113,194,111,
+195,114,109,111,109,114,111,199,109,107,108,106,194,104,99,98,95,94,93,
+89,86,85,74,72,196,70,68,194,64,67,194,62,195,65,194,56,195,54,56,194,65,
+194,62,69,71,194,64,61,194,60,55,53,194,50,45,44,42,44,40,42,34,194,38,
+33,32,57,194,32,30,24,30,194,24,20,194,18,16,195,13,0,8,5,3,1,218,0,211,
+0,1,2,4,6,5,12,9,10,194,13,16,194,17,195,20,26,24,26,24,32,194,31,33,35,
+34,195,38,34,194,38,39,44,45,48,52,55,52,194,61,65,56,195,54,56,62,69,73,
+80,74,85,88,87,88,92,89,194,92,91,194,93,91,93,194,91,93,194,91,194,94,
+96,95,97,98,194,99,195,104,107,108,195,109,107,194,87,91,109,113,194,114,
+93,194,91,92,195,93,194,92,198,96,197,97,96,97,92,196,96,97,92,96,195,93,
+96,194,93,194,92,194,91,93,91,98,194,114,113,111,195,113,114,113,194,114,
+194,111,114,111,196,109,107,104,107,194,106,194,99,97,93,91,90,85,83,74,
+75,72,73,71,73,69,194,64,69,194,62,65,194,56,54,56,195,54,56,66,67,69,195,
+64,194,62,65,56,54,51,50,59,194,48,44,194,42,194,39,36,38,58,33,196,32,
+30,24,194,22,23,194,17,18,17,13,9,0,12,5,3,195,1,216,0,211,0,194,1,3,194,
+5,0,9,194,13,194,15,17,20,17,194,20,194,24,196,30,31,194,33,35,194,34,196,
+39,194,47,48,50,52,196,60,56,54,194,51,54,56,67,69,73,194,74,85,88,90,87,
+90,92,90,195,92,93,91,194,93,194,91,93,91,93,94,194,95,98,194,99,195,106,
+104,107,106,196,109,103,90,91,99,106,114,111,99,92,93,195,92,96,194,97,
+195,96,201,97,100,195,97,194,96,97,196,96,92,97,92,194,96,92,96,194,92,
+91,107,200,113,111,194,113,197,114,194,111,194,109,108,106,104,106,104,
+103,99,95,94,93,89,85,80,74,72,195,70,194,69,196,62,65,195,56,197,54,56,
+66,194,67,64,69,62,60,194,55,194,53,48,194,47,44,48,40,42,39,38,194,34,
+58,194,33,195,32,194,30,24,194,20,22,18,15,16,194,13,9,0,5,3,1,218,0,211,
+0,1,2,1,3,194,8,195,11,15,16,17,197,20,24,26,194,30,32,31,194,35,34,194,
+39,194,38,194,39,40,44,50,53,52,60,52,61,194,65,195,54,51,66,62,71,72,74,
+81,88,194,87,195,90,194,93,194,96,91,93,194,91,93,194,91,194,94,93,96,95,
+97,98,103,99,194,104,194,107,108,196,109,107,94,90,89,90,107,113,112,93,
+92,194,93,96,93,197,96,201,97,96,196,97,92,96,194,97,96,194,97,92,96,194,
+93,96,92,93,96,92,118,115,195,113,111,195,113,115,111,194,113,111,195,114,
+111,112,111,114,195,109,107,106,194,104,100,95,93,91,86,84,80,75,72,73,
+71,194,68,69,64,62,65,62,194,65,194,56,53,54,51,54,56,65,62,194,67,194,
+65,62,65,56,54,194,51,194,48,44,40,46,39,36,39,38,58,33,195,58,32,30,26,
+24,195,23,22,17,18,15,13,9,0,8,5,4,195,1,216,0,211,0,194,1,4,195,5,9,13,
+11,194,15,18,194,17,20,28,195,24,32,30,194,31,33,41,35,36,194,39,38,194,
+39,40,45,194,50,52,60,65,60,65,66,196,54,56,67,71,78,80,194,88,87,90,92,
+89,90,92,91,194,93,91,93,94,91,93,94,194,93,196,95,194,99,196,104,108,107,
+106,107,194,109,114,111,96,90,92,91,107,111,113,98,196,93,195,96,197,97,
+98,97,98,100,197,97,96,97,100,97,92,194,97,194,96,194,97,199,96,107,196,
+115,116,195,115,113,116,113,111,115,113,111,113,114,113,109,111,112,111,
+195,109,107,106,104,194,99,95,93,89,86,85,79,72,73,194,71,64,194,69,64,
+195,65,195,56,53,54,50,51,54,66,56,65,62,67,65,194,56,194,54,194,51,48,
+44,48,47,44,40,36,39,194,38,196,33,32,195,30,26,20,194,22,18,15,16,13,11,
+194,0,12,3,1,218,0,212,0,2,3,4,12,0,10,11,13,11,194,18,194,22,194,23,26,
+24,32,196,31,37,197,34,195,39,194,44,50,53,52,61,52,60,55,56,194,54,194,
+51,66,69,71,72,74,88,87,88,87,89,90,92,93,92,93,92,93,94,91,94,195,93,95,
+93,95,97,195,98,99,106,107,194,106,107,104,85,94,106,111,109,112,92,91,
+92,99,107,115,113,194,92,93,92,194,96,195,97,96,197,97,98,100,97,100,196,
+97,98,195,97,92,194,97,194,96,97,198,96,116,197,115,113,115,113,116,194,
+115,194,113,115,113,111,113,114,113,195,111,114,195,109,108,107,104,103,
+98,95,93,91,84,83,74,194,70,68,71,64,62,67,194,62,194,65,56,54,56,53,196,
+54,56,194,66,65,66,65,54,53,51,50,48,59,48,194,44,194,42,39,195,38,194,
+58,32,57,194,32,33,24,29,23,24,22,17,18,15,13,10,194,0,5,3,195,1,216,0,
+211,0,194,1,3,6,194,5,9,14,194,13,194,18,194,17,20,22,30,194,24,194,30,
+31,35,37,194,41,36,39,34,194,39,47,44,48,194,50,55,61,65,62,56,54,51,196,
+54,62,77,78,83,88,87,88,87,92,89,92,93,92,96,95,195,93,195,94,93,95,96,
+194,95,98,99,98,99,195,104,107,106,104,87,90,87,92,104,114,92,91,92,93,
+106,113,116,197,96,196,97,194,98,97,98,194,100,98,100,98,195,100,197,97,
+100,196,97,194,96,194,97,195,96,114,195,116,194,115,116,195,115,113,195,
+115,113,115,194,113,111,194,113,195,111,109,111,195,109,107,108,104,194,
+99,96,93,91,86,84,80,72,68,69,194,64,195,62,65,196,56,194,54,51,53,54,198,
+56,195,54,51,48,51,48,44,47,39,40,39,36,194,38,33,58,194,33,31,30,31,24,
+30,22,20,22,17,18,16,194,13,194,0,5,3,1,218,0,211,0,194,1,194,4,5,0,8,9,
+11,21,16,15,194,20,22,24,20,24,29,194,30,194,31,41,35,34,36,194,39,38,40,
+39,47,44,50,53,52,60,61,194,56,195,54,194,51,56,67,71,72,74,194,88,90,92,
+90,92,90,92,96,195,93,94,195,93,96,95,93,194,95,97,194,98,194,99,104,107,
+106,108,112,109,96,194,87,89,90,91,90,92,93,92,93,99,113,114,92,195,96,
+97,194,96,196,97,100,194,97,100,98,100,195,97,99,194,100,98,200,97,96,195,
+97,104,194,115,116,115,194,116,115,194,116,195,115,116,194,115,116,115,
+111,196,113,114,109,111,109,111,195,109,107,108,104,99,98,95,105,89,85,
+82,79,72,68,69,67,64,194,62,195,65,194,56,54,53,54,51,54,195,56,66,194,
+56,194,54,51,54,51,44,59,44,40,39,194,36,38,194,34,58,196,33,195,30,194,
+24,23,22,18,194,15,13,11,9,8,5,3,195,1,216,0,212,0,1,3,194,6,0,9,11,10,
+21,17,194,18,20,22,23,24,26,194,29,31,194,37,35,41,35,36,194,40,194,39,
+40,48,44,194,50,55,194,60,55,56,197,54,56,62,71,72,74,195,87,89,90,195,
+91,195,93,195,96,93,94,93,196,95,96,97,98,99,103,194,104,106,104,194,109,
+104,194,87,89,90,92,91,92,93,92,93,96,115,116,115,114,194,96,196,97,100,
+99,97,99,100,97,100,97,195,99,195,97,194,100,98,100,97,100,197,97,194,96,
+104,194,116,117,115,116,196,115,195,116,115,116,115,113,194,116,115,113,
+111,113,111,195,113,111,114,195,109,194,107,104,103,100,98,95,94,90,87,
+83,79,72,68,67,69,194,62,65,194,56,195,54,53,51,194,54,56,66,56,66,56,66,
+56,54,195,51,44,59,44,47,195,39,195,38,58,194,33,32,33,31,30,29,30,23,24,
+194,22,17,15,13,9,194,0,5,3,1,218,0,211,0,194,1,4,194,5,8,9,11,13,16,15,
+18,20,23,20,24,194,23,24,31,30,37,31,194,35,41,195,36,42,40,194,44,48,50,
+53,52,55,56,65,56,194,54,194,51,54,56,67,76,79,80,88,87,88,90,198,92,94,
+197,96,195,95,96,195,98,99,101,194,104,106,104,195,109,110,99,93,96,194,
+91,92,91,92,96,93,96,116,194,115,116,194,115,100,197,97,100,97,98,100,97,
+100,195,97,100,194,99,97,98,100,98,99,98,194,97,194,100,97,194,100,116,
+197,117,115,116,117,115,117,196,115,116,115,194,113,116,115,113,111,115,
+195,113,112,195,111,194,109,107,108,194,104,99,96,93,89,86,85,80,75,73,
+68,64,67,62,195,65,194,56,196,54,196,56,54,66,194,56,54,53,50,48,59,44,
+40,39,47,195,39,38,33,38,194,34,33,32,194,30,24,23,20,24,20,194,17,15,194,
+13,0,8,5,4,195,1,216,0,212,0,194,1,6,12,5,9,11,21,16,17,18,17,194,22,194,
+24,30,24,194,30,194,37,194,41,35,194,42,39,42,40,44,45,48,194,50,56,194,
+55,194,56,195,54,51,54,56,65,71,79,74,88,87,90,89,194,92,194,93,96,92,97,
+196,96,93,96,93,194,95,194,98,194,99,95,89,105,194,106,107,197,109,113,
+99,91,92,93,195,92,113,115,116,115,116,115,117,194,116,98,99,100,98,194,
+100,98,100,98,195,100,195,97,194,100,97,100,97,100,99,100,98,97,99,97,104,
+115,194,117,115,117,115,194,117,115,116,115,195,116,200,115,194,113,111,
+115,113,195,111,114,111,195,109,108,107,104,194,99,95,94,91,89,84,194,79,
+76,68,195,62,194,65,194,56,54,56,54,56,66,54,66,65,56,54,56,195,54,51,50,
+194,59,44,40,195,39,194,38,34,38,58,34,194,33,194,31,194,30,24,26,195,17,
+195,13,194,0,5,3,1,218,0,211,0,194,1,3,5,8,0,11,194,13,15,16,17,20,22,20,
+194,23,24,30,29,194,37,41,37,194,41,43,40,42,44,46,47,48,194,50,194,53,
+65,56,54,56,51,54,195,51,54,67,71,72,80,88,87,88,194,92,93,92,194,93,195,
+96,199,95,96,98,95,98,194,99,83,81,85,89,94,89,104,109,111,194,114,113,
+98,93,92,93,194,96,113,194,115,118,113,112,109,115,117,100,194,97,100,194,
+97,100,98,100,195,97,99,194,100,98,97,100,97,100,194,97,98,100,99,97,110,
+205,117,115,196,116,195,115,113,116,115,113,115,194,111,113,111,114,197,
+109,107,104,106,104,99,98,96,91,89,86,84,79,72,194,71,64,67,62,197,65,56,
+54,194,56,54,66,194,56,194,54,195,51,59,48,44,47,40,194,39,38,36,39,194,
+38,34,33,35,194,31,194,30,194,24,194,20,18,17,16,13,11,0,8,3,4,195,1,216,
+0,212,0,194,1,6,8,0,9,11,15,25,194,18,17,22,20,24,194,23,194,30,194,37,
+41,35,194,41,43,194,42,40,42,44,48,194,50,194,53,55,56,194,54,51,194,54,
+51,194,54,66,71,73,80,85,90,87,89,90,93,92,96,93,195,96,196,95,98,194,95,
+96,97,99,194,98,104,99,87,81,88,83,85,91,109,111,109,194,114,98,196,93,
+96,98,116,109,198,97,100,99,97,99,100,99,100,196,99,195,97,194,100,98,100,
+97,195,100,194,97,194,100,194,117,115,201,117,115,117,115,117,115,117,194,
+116,115,116,113,116,115,195,113,115,112,114,196,111,194,109,107,194,108,
+104,100,98,95,93,91,86,84,82,80,78,76,68,194,69,194,67,194,65,194,66,56,
+66,65,56,194,66,194,56,194,54,51,194,59,194,44,194,47,194,39,195,38,34,
+194,38,33,34,33,195,30,26,30,24,20,17,18,194,15,13,194,0,194,3,1,218,0,
+211,0,194,1,194,3,5,194,9,10,21,15,21,18,25,195,22,24,30,24,195,31,194,
+35,41,35,43,194,42,46,194,48,44,194,50,53,194,56,55,196,54,195,51,54,65,
+69,78,74,81,194,87,90,194,92,96,92,197,96,95,98,95,96,97,194,98,99,98,194,
+99,195,103,105,85,194,88,89,101,104,99,93,96,91,194,92,194,93,92,97,92,
+96,197,97,100,194,97,100,97,98,100,99,97,196,100,194,99,97,98,100,98,99,
+98,194,97,194,100,97,109,115,196,117,115,117,115,117,115,196,117,115,116,
+194,115,116,115,116,194,115,113,115,196,113,195,111,114,195,109,194,108,
+104,106,104,194,99,98,93,194,91,87,85,82,79,78,72,73,68,71,195,69,194,62,
+67,56,194,66,195,56,194,54,51,59,194,48,47,194,40,196,39,36,39,194,38,33,
+34,194,31,30,31,29,24,20,24,194,20,17,18,13,11,0,8,6,4,195,1,216,0,211,
+0,194,1,3,5,8,194,9,10,11,15,21,195,22,24,23,24,30,23,29,194,31,194,37,
+194,41,196,42,46,45,49,195,50,53,199,54,51,50,51,56,64,76,80,85,90,87,89,
+194,92,93,92,96,93,195,96,194,97,196,98,95,99,98,99,100,99,194,104,106,
+95,90,85,87,194,90,92,89,92,91,93,194,92,96,92,100,97,96,194,97,96,97,98,
+99,100,98,194,100,98,100,197,99,196,100,97,100,97,100,99,100,98,97,99,98,
+112,194,117,115,203,117,115,117,115,116,199,115,194,113,194,111,109,112,
+111,112,195,109,194,107,108,106,104,194,100,98,93,194,91,86,85,194,83,80,
+79,78,72,73,71,194,69,195,67,194,65,66,56,66,196,54,51,194,59,47,194,40,
+196,39,34,38,34,36,194,34,33,31,195,30,32,28,26,20,194,17,16,13,11,0,8,
+3,194,1,218,0,211,0,194,1,3,5,12,194,9,11,13,21,15,18,25,194,22,20,194,
+23,194,30,194,31,35,195,41,43,195,42,45,46,52,50,194,53,54,194,53,194,54,
+198,51,66,67,71,74,81,88,90,92,89,93,92,97,92,97,195,96,95,97,194,98,97,
+195,98,99,98,99,104,99,194,104,107,103,91,88,194,87,89,194,92,96,104,119,
+116,93,196,96,196,97,100,194,97,100,194,97,100,98,197,100,195,99,100,99,
+196,100,99,100,99,97,100,109,202,117,115,195,117,115,116,115,194,116,194,
+115,116,115,119,115,111,115,113,196,111,196,109,194,107,195,104,99,194,
+98,95,93,194,89,84,85,80,82,80,79,194,72,76,73,71,194,69,67,194,66,65,66,
+194,56,54,51,194,59,47,48,44,195,47,198,39,194,38,33,35,31,195,30,194,24,
+20,17,20,17,194,15,10,0,12,194,4,195,1,216,0,211,0,1,4,3,194,5,0,11,19,
+13,194,21,18,25,22,23,24,32,30,32,30,194,31,33,35,34,41,195,42,46,45,195,
+49,194,53,56,194,54,51,54,194,51,54,194,51,50,54,69,71,79,194,85,87,194,
+92,194,93,96,92,97,96,195,97,96,194,95,96,194,99,98,99,103,194,99,195,106,
+108,107,109,103,95,93,95,94,110,113,111,113,195,115,194,97,194,96,194,98,
+97,100,99,97,99,195,100,197,99,195,100,99,100,196,99,194,100,97,100,99,
+194,100,115,117,115,117,115,117,115,117,115,195,117,115,194,117,115,117,
+115,194,116,115,116,113,194,115,111,115,113,114,111,197,109,107,108,107,
+194,106,104,99,97,96,95,94,91,194,89,86,83,195,80,78,72,194,76,73,71,68,
+69,67,66,65,195,56,194,54,194,51,194,59,194,44,194,40,196,39,38,197,34,
+194,31,32,195,30,24,17,18,17,16,21,11,14,0,5,194,1,218,0,211,0,1,194,3,
+5,8,0,9,11,19,11,25,194,18,22,20,194,24,26,194,30,194,31,35,34,35,36,195,
+42,45,46,194,49,194,52,194,53,195,54,196,51,54,194,51,54,65,71,75,83,88,
+195,90,194,92,97,194,96,194,97,98,95,98,99,196,98,100,194,99,103,106,195,
+104,106,108,107,194,109,111,112,114,111,113,116,194,115,116,115,92,96,199,
+97,100,97,194,98,99,194,97,195,100,195,99,100,99,196,100,194,99,100,99,
+100,194,99,111,200,117,115,197,117,115,116,115,194,116,195,115,119,194,
+116,194,113,114,109,114,111,195,109,108,107,195,104,100,99,194,95,195,93,
+91,89,84,85,84,83,79,80,79,72,73,77,71,69,67,194,62,194,66,194,56,194,54,
+194,51,59,48,194,47,40,39,47,39,42,39,36,39,194,36,35,195,31,30,32,195,
+24,194,20,17,15,13,194,9,5,6,4,195,1,216,0,212,0,1,4,5,8,14,8,14,19,11,
+25,22,18,22,20,24,30,197,32,35,196,34,194,42,194,45,194,49,194,52,194,55,
+196,54,197,51,194,54,66,69,72,83,87,90,92,91,194,93,96,92,100,197,97,194,
+99,98,99,98,197,99,196,106,107,195,109,194,111,194,113,111,115,116,113,
+116,99,92,100,195,97,98,99,100,98,196,100,197,99,195,100,99,100,196,99,
+194,100,99,100,99,194,100,104,100,194,117,115,117,115,117,115,195,117,115,
+195,117,115,117,115,117,196,115,194,113,115,113,111,113,195,111,194,109,
+110,194,108,106,104,99,195,98,95,94,194,91,194,89,84,85,83,82,194,80,194,
+78,72,195,71,69,67,65,62,194,66,56,194,54,194,51,59,194,44,194,47,40,47,
+196,39,38,194,34,36,34,194,31,30,32,26,194,24,17,22,17,16,15,194,9,12,5,
+194,1,218,0,211,0,1,194,4,194,6,8,195,14,19,21,194,18,195,20,194,26,32,
+26,195,33,194,34,194,36,194,42,43,46,52,45,52,53,55,194,54,53,51,59,50,
+59,196,51,54,56,71,72,74,85,194,89,195,92,196,96,97,99,98,95,97,195,98,
+99,98,106,194,99,196,104,194,107,195,109,194,111,114,111,113,119,195,115,
+201,97,100,195,97,98,197,100,195,99,100,99,196,100,194,99,100,99,100,194,
+99,194,100,194,115,200,117,115,195,117,116,115,116,115,116,115,116,196,
+115,111,113,114,111,196,109,195,106,104,99,100,99,98,194,95,194,93,91,89,
+90,86,194,84,83,82,194,79,72,78,73,76,194,71,67,69,66,195,56,194,54,51,
+50,194,59,47,194,44,40,39,47,40,42,196,36,35,196,31,194,30,194,26,20,194,
+17,18,194,13,14,8,6,4,195,1,216,0,211,0,1,194,3,5,194,6,194,11,19,11,21,
+18,22,20,28,26,24,26,32,26,32,58,33,34,33,34,38,42,46,43,45,194,49,194,
+52,194,55,54,53,54,59,50,59,195,51,48,194,54,67,76,74,88,87,92,91,93,92,
+96,92,100,195,97,100,197,99,194,100,194,99,195,106,107,104,108,107,195,
+109,112,114,194,113,111,196,115,194,96,97,194,98,194,97,99,97,99,195,100,
+197,99,195,100,99,100,196,99,194,100,99,100,99,194,100,99,104,99,109,196,
+117,115,194,117,115,197,117,115,117,115,194,116,197,115,116,194,113,195,
+114,195,109,106,195,104,99,98,97,194,96,95,94,194,91,89,86,84,194,85,194,
+83,80,79,75,78,72,73,77,71,67,69,67,65,194,56,194,54,51,48,59,48,59,44,
+47,44,40,194,39,40,36,39,34,36,194,34,194,31,32,194,30,194,24,20,17,16,
+18,13,10,0,194,5,194,1,218,0,211,0,1,194,4,6,196,14,11,19,21,22,17,28,24,
+195,26,194,32,57,194,32,33,194,38,194,39,42,45,46,52,45,195,52,65,56,54,
+51,50,59,50,194,51,59,51,50,56,67,73,79,83,87,90,194,92,96,97,96,194,97,
+96,195,99,195,98,194,99,98,106,103,99,195,104,106,107,104,107,194,109,111,
+109,196,113,116,194,115,104,92,96,197,97,100,97,194,98,195,97,195,100,195,
+99,100,99,196,100,194,99,100,99,100,194,99,196,100,117,115,198,117,115,
+117,115,194,117,115,116,115,194,116,115,194,116,194,119,115,194,113,114,
+194,111,194,109,194,108,194,106,99,97,99,194,95,94,196,91,86,90,87,194,
+84,83,80,83,194,79,72,194,73,195,71,194,62,67,194,66,194,54,195,51,59,48,
+194,44,47,44,40,194,42,40,42,36,34,41,196,31,32,26,24,26,194,20,17,16,13,
+11,8,0,6,4,195,1,216,0,212,0,195,4,5,6,19,14,11,21,15,22,17,194,20,195,
+26,194,32,194,33,58,33,58,38,34,39,40,194,46,194,49,194,53,194,52,56,54,
+51,48,194,59,50,51,48,59,51,53,66,69,79,81,85,92,194,91,92,96,92,197,97,
+194,100,195,99,100,195,99,196,104,106,195,107,195,109,112,195,113,111,116,
+194,115,118,100,194,97,194,98,97,98,195,100,99,100,99,98,194,99,195,100,
+99,100,196,99,194,100,99,100,99,194,100,196,99,100,196,117,115,199,117,
+194,115,117,115,117,197,115,113,111,115,113,109,111,114,194,109,107,194,
+104,194,99,194,98,95,96,94,93,194,89,91,89,194,86,85,83,194,82,195,79,194,
+78,73,71,194,69,67,194,65,56,65,56,194,54,194,51,194,59,48,195,44,47,40,
+42,39,194,36,34,36,35,194,31,194,30,32,194,24,194,17,18,194,15,13,8,194,
+5,194,1,218,0,211,0,194,1,4,5,8,14,8,19,11,15,25,17,20,194,28,26,194,24,
+194,32,26,194,32,195,33,38,39,42,40,44,52,194,49,52,194,55,54,53,51,59,
+194,44,59,194,51,50,194,51,56,71,72,80,87,90,194,92,93,195,96,194,97,195,
+100,99,100,98,100,195,99,194,104,106,194,107,104,109,104,107,195,109,111,
+197,113,194,116,115,116,100,203,97,195,100,195,99,100,99,196,100,194,99,
+100,99,100,194,99,197,100,115,196,117,115,195,117,115,194,117,115,117,115,
+116,196,115,113,195,115,111,113,111,109,111,194,109,107,106,104,103,98,
+97,194,95,105,93,194,91,89,86,194,89,85,194,84,83,194,80,194,79,72,73,76,
+73,71,195,69,67,66,195,56,54,53,51,194,50,47,44,47,44,42,46,40,42,36,34,
+194,35,194,33,195,32,194,24,28,194,20,17,16,13,11,194,0,6,3,194,1,217,0,
+211,0,194,1,4,6,5,8,14,11,21,15,17,20,17,194,20,195,26,195,32,57,32,194,
+58,194,33,38,39,42,44,195,49,52,53,52,56,54,51,194,59,44,194,48,59,48,51,
+53,56,69,76,80,85,87,195,92,96,93,96,97,195,98,100,99,100,99,100,99,104,
+103,106,99,194,104,106,104,195,107,196,109,196,113,194,115,116,115,194,
+116,100,97,98,97,98,195,100,99,100,99,98,99,195,100,99,100,196,99,194,100,
+99,100,99,194,100,196,99,194,100,115,117,115,196,117,115,196,117,194,115,
+117,115,194,116,195,115,116,194,113,111,194,113,109,114,194,109,107,106,
+104,106,98,97,194,96,194,93,195,91,86,194,89,86,85,194,83,195,80,79,78,
+72,76,73,76,71,67,64,194,62,66,56,66,51,53,194,51,50,51,45,48,44,40,42,
+194,40,194,36,34,35,194,31,194,30,32,195,24,20,17,18,15,194,13,8,5,6,195,
+1,217,0,211,0,194,1,4,5,8,14,0,11,13,16,17,195,20,28,196,26,32,26,32,57,
+194,33,194,58,38,39,40,46,48,194,49,53,60,61,60,54,51,59,48,59,47,51,50,
+51,48,51,54,67,73,78,85,90,194,91,93,97,92,96,98,195,100,98,97,99,100,99,
+100,103,196,104,106,104,106,109,104,196,109,111,113,111,115,111,194,113,
+196,115,116,99,195,97,194,98,196,97,100,97,194,98,99,100,99,196,100,194,
+99,100,99,100,194,99,196,100,99,100,115,204,117,115,116,115,116,194,115,
+116,119,113,116,113,115,113,109,194,111,194,109,108,107,106,194,99,98,194,
+95,93,194,91,194,89,194,90,89,85,84,85,83,82,80,194,79,75,78,72,76,68,69,
+71,69,194,67,65,66,194,56,194,54,194,51,194,48,44,48,46,44,194,42,194,36,
+35,194,34,33,31,32,30,26,194,24,194,20,17,16,13,11,194,0,5,3,195,1,216,
+0,211,0,194,1,4,194,5,194,9,13,195,15,17,195,20,194,26,30,194,32,194,33,
+194,58,195,33,34,36,40,42,45,194,49,52,53,60,55,194,54,59,44,194,48,59,
+48,194,51,194,54,66,71,79,83,87,195,92,96,97,96,194,97,98,100,99,97,98,
+100,99,100,99,194,104,106,99,195,104,194,107,196,109,111,194,114,113,197,
+115,116,195,115,116,113,109,97,99,100,99,100,97,99,195,100,98,100,196,99,
+194,100,99,100,99,194,100,195,99,98,100,99,100,115,117,115,194,117,115,
+194,117,115,117,115,117,115,117,115,117,115,116,197,115,196,113,109,114,
+194,109,194,108,104,106,194,98,95,194,94,194,91,194,89,194,86,89,87,194,
+84,195,83,80,79,75,72,73,76,73,69,64,71,62,67,65,56,65,56,53,194,54,50,
+59,194,48,44,194,46,194,42,34,36,35,194,31,33,31,32,30,24,196,20,18,15,
+194,13,0,12,5,4,1,218,0,211,0,195,1,6,8,14,9,13,15,16,17,195,20,28,20,24,
+194,26,197,32,196,58,38,39,44,48,194,49,52,55,60,56,55,54,59,195,47,59,
+51,48,194,50,51,56,69,78,80,87,90,194,93,96,92,194,97,194,100,99,100,99,
+100,196,99,98,106,194,104,107,194,106,107,108,110,196,109,111,195,113,116,
+113,194,116,115,195,116,115,194,117,115,104,195,97,99,97,100,99,98,100,
+99,196,100,194,99,100,99,100,194,99,196,100,99,194,100,115,196,117,115,
+198,117,194,115,116,115,116,196,115,113,115,111,115,111,115,113,196,109,
+194,106,104,99,194,98,194,96,93,89,194,91,89,90,86,84,194,85,194,83,80,
+194,79,194,78,72,194,73,71,69,194,67,195,62,194,56,54,53,194,54,50,45,48,
+45,44,40,42,39,195,36,194,34,195,30,32,194,26,24,20,17,16,15,13,9,0,8,5,
+2,195,1,216,0,211,0,1,3,4,5,0,9,11,13,15,16,15,17,194,20,26,28,26,197,32,
+196,33,195,38,39,40,194,45,49,194,52,60,194,56,54,59,195,44,48,51,59,54,
+53,51,56,62,76,79,87,194,90,92,96,92,96,98,194,97,98,100,194,99,97,194,
+99,194,100,99,197,104,107,106,198,109,113,194,111,113,115,113,196,115,195,
+116,194,117,116,100,99,97,100,98,97,100,99,100,98,99,98,99,194,100,99,100,
+99,194,100,99,98,194,99,100,99,194,100,115,194,117,115,196,117,115,117,
+115,117,115,117,115,117,194,115,116,194,115,116,113,111,115,195,113,111,
+112,194,109,107,194,104,100,194,98,194,95,93,91,195,89,195,86,194,84,194,
+82,80,194,79,194,78,73,76,73,71,68,69,62,195,66,194,56,54,53,54,194,50,
+46,44,45,46,40,42,40,36,194,34,31,34,33,32,195,30,24,195,20,194,16,13,11,
+0,8,5,3,1,218,0,211,0,1,4,5,194,0,9,194,13,15,18,194,17,195,20,26,28,195,
+26,194,57,32,33,194,58,194,38,194,39,42,44,48,49,195,52,60,54,51,48,194,
+47,59,47,48,50,194,51,53,56,67,73,80,83,90,92,194,93,195,96,195,100,99,
+100,97,99,98,195,99,104,106,104,107,195,106,108,107,196,109,111,114,115,
+194,113,197,115,117,195,115,195,117,110,97,100,97,194,100,194,97,99,196,
+100,99,98,100,99,100,194,99,97,195,100,98,195,100,203,117,115,116,115,116,
+194,115,116,115,119,116,196,113,115,111,113,194,111,194,109,108,107,104,
+99,100,194,95,93,94,195,91,89,90,195,84,85,83,80,83,80,79,75,194,72,73,
+77,71,69,64,67,194,62,65,194,56,194,54,194,50,59,194,48,44,40,42,40,36,
+34,36,194,34,31,32,31,194,32,195,26,20,194,17,194,15,13,9,0,5,196,1,216,
+0,211,0,1,4,194,5,0,9,195,13,16,194,17,20,28,20,194,24,26,194,32,33,58,
+198,33,38,39,40,194,44,194,50,55,52,194,60,54,50,194,44,48,194,59,48,195,
+51,54,66,71,79,83,87,194,92,93,96,92,196,97,98,196,99,98,100,103,99,106,
+99,195,104,106,108,107,196,109,111,109,195,113,115,116,115,116,115,194,
+116,117,115,117,115,117,115,100,99,194,97,99,100,97,195,99,98,97,100,99,
+100,99,97,100,194,99,194,98,100,97,99,100,108,117,115,194,117,115,194,117,
+115,117,115,117,115,117,115,116,196,115,113,194,115,113,194,111,113,111,
+113,111,114,194,109,108,106,104,99,100,96,95,93,96,194,91,194,89,90,86,
+87,194,84,83,194,80,75,194,79,78,76,73,69,64,195,67,65,66,195,56,194,54,
+194,50,51,194,48,46,40,42,194,40,196,34,31,33,31,195,30,24,28,20,194,17,
+15,13,10,194,0,12,3,1,218,0,211,0,2,194,3,12,0,194,9,13,16,18,194,17,194,
+20,195,28,194,26,32,26,32,33,34,194,58,194,38,34,38,40,42,48,44,50,52,60,
+52,56,54,59,194,47,59,48,44,51,48,51,54,53,54,62,78,82,87,92,93,194,92,
+194,96,98,196,97,195,98,99,98,195,99,195,104,106,104,107,108,196,109,111,
+114,113,111,195,113,116,197,115,116,115,194,117,116,98,97,100,99,97,98,
+100,195,97,100,194,99,100,99,100,194,99,198,100,97,100,115,202,117,195,
+115,195,116,198,115,113,115,113,115,113,112,109,111,194,109,107,104,194,
+106,194,99,98,95,94,194,93,91,194,89,87,84,86,85,83,82,80,78,79,194,72,
+71,68,71,69,64,195,62,194,56,197,54,50,44,45,194,44,46,40,194,36,38,39,
+34,194,33,195,32,195,26,24,28,20,18,16,13,11,194,0,5,194,3,194,1,216,0,
+211,0,1,4,3,12,0,9,195,13,15,194,17,195,20,195,26,24,32,30,32,33,34,33,
+58,38,58,38,34,194,40,194,48,194,50,194,55,56,54,50,194,44,47,59,48,51,
+50,48,51,53,56,62,73,80,82,92,93,96,97,194,96,196,98,97,96,98,97,195,99,
+100,103,99,103,104,194,106,195,107,195,109,111,109,114,111,115,194,113,
+115,116,194,115,117,115,117,115,194,117,115,97,98,97,194,100,97,197,100,
+97,98,97,98,100,97,194,98,100,97,194,98,195,100,115,117,115,194,117,115,
+194,117,194,115,117,115,117,115,117,194,115,116,194,115,119,116,111,197,
+113,114,109,111,194,109,107,194,104,100,103,194,98,93,105,194,91,194,89,
+91,89,194,84,82,83,194,80,78,79,78,73,76,194,71,69,67,194,66,65,66,56,195,
+54,51,59,51,47,194,44,47,42,40,39,36,34,33,34,194,33,32,26,32,26,24,28,
+20,194,17,18,15,194,13,9,0,5,4,1,218,0,211,0,1,3,194,5,0,10,9,13,194,16,
+15,17,196,20,24,194,26,30,32,33,194,31,194,34,194,38,36,194,39,42,194,44,
+50,53,55,56,55,53,59,44,47,194,48,59,48,59,51,194,54,56,67,71,78,85,87,
+194,92,93,96,196,97,96,97,95,98,95,97,195,98,99,106,196,104,103,194,107,
+196,109,114,111,194,113,111,113,195,115,116,115,116,115,116,115,117,109,
+194,97,100,194,97,99,97,195,98,97,196,100,98,195,100,98,99,194,100,194,
+97,100,115,117,115,198,117,194,115,117,115,116,196,115,119,116,113,115,
+194,113,115,111,113,114,194,111,114,194,109,194,108,106,194,99,98,96,95,
+96,194,93,91,195,89,194,87,85,194,83,80,75,78,72,76,73,71,194,67,69,62,
+65,66,54,56,54,194,50,51,50,194,48,194,44,194,40,194,36,38,194,34,194,33,
+58,194,32,26,24,194,26,195,20,17,194,13,11,0,8,5,194,3,194,1,216,0,211,
+0,1,4,194,5,8,9,11,13,15,194,16,17,195,20,28,194,30,32,30,31,30,194,31,
+33,34,195,38,194,39,195,44,48,50,53,54,56,54,59,44,195,47,59,50,48,195,
+51,54,66,71,72,83,87,91,195,92,196,97,195,96,194,95,98,97,98,99,98,194,
+104,106,104,108,104,108,107,196,109,111,112,194,113,115,194,113,116,199,
+115,116,107,194,97,98,100,97,99,195,100,99,98,97,98,97,100,98,194,97,100,
+195,97,194,99,194,100,109,195,117,115,197,117,194,115,117,115,116,195,115,
+113,115,194,113,194,111,113,115,194,111,114,196,109,108,194,104,194,100,
+99,98,194,95,194,93,194,91,90,89,195,84,82,194,80,72,78,72,73,194,71,195,
+67,66,54,56,195,54,51,50,194,59,47,194,59,44,194,40,194,39,34,58,38,33,
+197,32,195,26,20,195,17,16,13,11,9,0,5,4,1,218,0,211,0,2,194,3,12,0,9,13,
+11,194,15,18,195,17,28,194,20,26,24,31,194,30,31,34,41,194,34,194,38,34,
+194,39,44,194,48,50,53,55,53,54,59,47,194,44,194,48,59,51,50,194,54,53,
+56,64,76,80,84,90,93,96,97,92,196,96,95,96,194,95,96,194,98,95,100,99,103,
+99,106,103,194,106,108,107,195,109,195,111,113,111,194,113,115,113,116,
+115,116,117,194,116,115,110,97,98,97,98,198,97,196,100,97,195,100,97,195,
+100,194,97,98,194,100,197,117,115,117,194,115,194,116,115,116,115,116,198,
+115,113,115,113,111,113,111,109,111,194,109,107,106,107,106,104,99,98,97,
+95,93,105,194,91,194,89,194,86,87,85,80,82,80,79,72,73,77,71,69,64,194,
+62,195,56,194,54,194,51,54,50,194,48,194,44,194,40,194,39,38,39,38,194,
+58,33,58,196,32,24,26,194,20,194,17,15,13,10,0,8,12,2,3,194,1,216,0,211,
+0,1,194,3,12,8,0,194,13,15,194,16,17,195,20,28,195,24,29,30,31,37,31,34,
+194,38,36,38,195,39,40,44,194,48,194,53,55,53,48,196,47,48,44,51,48,50,
+51,54,56,64,76,75,83,87,92,91,198,96,94,194,93,95,94,95,97,194,98,194,99,
+100,195,104,103,104,194,107,196,109,111,113,111,115,194,113,115,116,196,
+115,116,115,112,199,97,194,100,97,98,97,98,100,97,194,98,100,97,194,98,
+195,100,97,194,100,115,197,117,115,117,115,117,115,117,194,115,116,194,
+115,194,116,111,197,113,114,194,111,195,109,108,195,104,194,99,95,98,94,
+93,94,91,93,91,89,86,89,87,85,83,82,194,79,78,73,194,71,67,195,66,195,56,
+195,54,194,51,194,59,48,44,47,40,194,39,36,194,38,34,33,58,196,32,194,26,
+24,26,194,20,17,15,194,13,10,0,194,5,4,1,218,0,211,0,2,194,3,8,0,9,11,195,
+13,194,18,17,18,195,20,23,29,30,29,194,37,31,41,194,34,38,39,38,39,194,
+40,194,44,59,50,53,194,54,59,44,40,44,48,194,59,48,194,51,194,54,56,66,
+69,78,83,85,86,92,93,194,92,93,194,94,194,93,94,91,96,93,194,95,98,96,98,
+194,99,104,106,108,106,194,107,108,195,109,194,114,113,194,111,113,115,
+113,197,115,116,114,195,97,98,97,195,98,97,196,100,98,195,100,98,99,194,
+100,195,97,98,194,97,108,117,115,194,117,115,117,195,115,116,196,115,116,
+119,194,113,115,194,113,111,194,113,109,111,112,194,109,107,108,194,104,
+99,100,194,98,195,96,194,93,91,194,89,90,86,84,86,194,83,80,78,72,71,77,
+69,67,62,65,194,56,195,54,51,50,51,59,50,48,47,44,40,47,194,39,194,38,34,
+194,58,33,32,57,32,26,30,32,194,28,26,20,18,17,15,13,9,194,0,5,3,195,1,
+216,0,211,0,1,194,3,12,0,10,9,194,13,16,15,194,17,22,20,196,24,195,29,194,
+37,194,35,34,196,38,194,39,194,44,47,50,51,54,51,59,194,44,47,44,48,59,
+194,48,194,51,54,56,62,69,76,80,83,84,90,93,96,198,93,94,91,94,194,93,194,
+95,98,95,194,98,99,103,195,104,107,106,107,195,109,114,194,113,115,194,
+113,195,115,194,116,194,115,116,99,194,97,98,195,97,194,98,97,98,194,97,
+98,194,97,100,195,97,194,98,196,97,194,100,115,194,117,194,115,117,115,
+117,115,194,116,195,115,113,194,115,113,111,115,113,115,113,111,114,111,
+194,109,104,108,194,106,100,194,99,98,194,95,194,96,93,94,93,91,89,91,90,
+84,87,194,83,80,79,72,73,71,69,67,195,66,194,54,51,54,195,51,194,59,48,
+47,44,40,195,39,36,58,38,33,58,194,33,194,32,194,26,32,24,20,17,20,194,
+17,15,13,10,194,0,5,3,1,218,0,211,0,1,4,3,5,8,0,194,9,15,11,15,194,18,17,
+18,195,22,23,195,29,37,31,37,196,34,194,39,38,47,40,44,48,47,50,194,51,
+59,194,47,44,47,59,48,194,51,50,53,51,54,66,64,73,79,82,85,86,90,89,194,
+92,194,91,93,197,91,94,93,95,96,95,194,98,99,194,100,194,104,106,107,108,
+195,109,111,112,113,195,111,113,118,116,195,115,116,115,114,213,97,98,197,
+97,108,117,115,117,194,115,117,115,116,199,115,195,113,111,113,109,194,
+111,195,109,194,107,106,194,104,194,99,98,97,95,93,194,94,105,93,91,92,
+91,90,89,86,84,83,82,80,78,76,71,69,67,62,65,56,196,54,196,51,50,48,47,
+44,40,194,39,196,38,33,58,33,57,196,32,195,24,28,20,17,22,194,15,13,11,
+9,8,12,3,195,1,216,0,211,0,1,4,3,12,8,0,11,9,194,15,11,196,18,22,24,20,
+23,24,194,29,37,35,41,34,195,38,34,196,39,40,48,59,50,53,194,50,44,47,194,
+44,47,44,59,54,195,51,54,66,67,71,73,80,83,84,87,89,91,89,91,89,194,91,
+89,91,89,195,91,94,194,93,96,95,194,98,99,195,104,106,107,104,195,109,111,
+114,113,194,115,194,111,194,115,116,115,116,115,116,96,198,97,98,97,98,
+194,97,194,98,194,97,194,98,202,97,109,115,117,195,115,117,115,116,115,
+116,113,115,116,115,111,115,113,195,111,112,195,109,194,107,104,106,104,
+100,194,98,195,95,96,195,93,94,93,92,91,89,90,89,87,85,194,80,72,76,71,
+69,194,66,54,56,197,54,195,51,59,48,44,47,44,194,39,197,38,58,195,33,30,
+194,32,195,24,20,22,194,17,16,15,13,9,0,194,5,3,1,218,0,211,0,2,195,3,12,
+194,0,11,9,11,21,194,15,194,18,194,22,23,24,23,24,29,194,37,31,35,34,36,
+34,39,194,38,39,194,47,44,48,59,51,54,59,47,194,44,47,48,59,197,54,56,65,
+194,69,73,78,79,83,194,84,86,89,86,91,89,90,89,87,197,89,194,93,105,93,
+95,194,98,194,100,106,104,108,107,108,195,109,111,194,114,113,115,113,197,
+115,116,194,115,96,194,97,96,197,97,98,195,97,194,98,97,96,194,97,194,96,
+194,97,96,194,97,96,100,194,115,117,194,116,195,115,116,113,194,116,197,
+113,195,111,195,109,107,108,104,106,104,99,195,98,95,96,95,94,93,94,93,
+92,194,91,194,92,89,90,85,194,83,80,78,73,69,194,62,194,56,194,54,51,54,
+194,51,194,50,59,44,47,44,40,195,39,194,38,34,38,34,196,33,32,194,30,32,
+24,23,22,20,194,18,194,15,11,9,194,0,5,3,195,1,216,0,211,0,194,1,4,5,8,
+0,194,9,10,11,21,25,194,18,17,22,20,23,24,23,24,194,30,194,31,35,38,33,
+58,38,36,38,194,39,194,47,48,194,59,54,51,59,47,40,47,48,51,197,56,54,56,
+62,69,71,73,194,79,194,83,85,86,194,84,89,84,194,86,85,89,90,194,89,91,
+93,194,91,94,194,95,98,100,194,104,195,106,108,195,109,111,197,113,115,
+116,194,115,194,116,115,107,195,96,194,97,98,194,97,98,199,97,200,96,92,
+195,97,113,199,115,197,113,194,114,111,114,112,195,109,107,194,106,194,
+104,194,99,98,195,95,194,93,94,93,194,94,195,93,91,92,194,89,87,85,83,75,
+78,73,69,67,194,66,56,194,54,198,51,59,48,47,40,47,194,39,194,36,194,38,
+194,58,34,33,32,31,32,30,23,195,24,194,22,15,18,15,13,194,10,8,194,5,3,
+1,218,0,211,0,194,1,3,5,12,8,0,14,19,13,15,21,15,194,18,17,23,24,23,194,
+30,31,29,31,195,33,194,38,34,38,194,39,194,40,44,59,48,195,50,194,59,48,
+59,51,54,66,67,194,62,194,66,65,194,67,69,76,73,72,79,82,194,83,194,85,
+84,85,84,85,84,85,86,87,84,194,86,91,195,93,95,98,95,98,103,194,104,108,
+194,107,194,109,112,109,114,197,113,196,115,116,106,197,96,200,97,196,96,
+194,97,194,96,97,92,97,96,93,96,194,93,96,198,115,113,115,111,194,113,111,
+109,112,195,109,108,194,107,106,104,195,99,194,95,93,96,93,94,195,93,91,
+93,91,194,93,92,91,90,92,194,85,83,79,72,73,69,62,65,56,194,54,51,54,194,
+51,54,51,194,48,47,40,195,39,196,38,34,38,34,33,34,195,31,194,30,29,194,
+23,22,18,22,195,15,11,19,0,8,194,4,194,1,217,0,211,0,194,1,194,4,3,5,14,
+9,14,11,194,21,15,194,18,17,22,20,24,194,23,195,30,195,33,34,195,38,34,
+39,42,44,45,48,194,50,54,194,50,195,51,54,56,65,67,69,62,194,67,65,195,
+62,69,194,73,72,79,194,80,84,194,83,85,82,83,82,83,82,85,194,87,86,87,90,
+92,194,91,95,98,99,100,104,103,195,106,107,194,109,194,111,113,114,195,
+113,116,196,115,112,194,97,202,96,97,92,97,96,92,194,96,194,92,97,92,96,
+195,92,96,93,96,98,114,195,113,194,111,113,114,109,111,114,195,109,108,
+107,108,195,104,99,98,194,95,96,95,194,94,93,194,91,198,93,96,194,92,90,
+92,87,194,81,79,78,77,69,67,194,56,194,54,51,194,54,195,51,59,48,44,47,
+40,195,39,38,195,39,34,36,31,34,195,31,30,195,24,20,22,194,18,21,194,11,
+10,8,194,12,194,3,194,1,217,0,211,0,194,1,2,3,5,194,8,14,194,11,13,15,194,
+18,22,194,20,22,23,24,196,30,195,33,194,58,38,36,194,39,194,40,44,48,194,
+50,51,194,54,51,54,194,56,65,69,71,194,73,71,194,69,197,67,194,71,78,196,
+79,82,194,80,83,80,82,83,85,83,195,85,86,89,92,195,93,96,98,99,195,104,
+108,107,194,109,194,111,194,114,113,111,113,111,196,115,114,93,194,96,97,
+92,197,96,97,92,96,100,194,92,194,96,93,194,96,194,93,194,96,194,93,195,
+92,93,91,98,114,194,113,194,114,194,111,195,109,194,108,107,106,103,104,
+99,106,99,98,194,96,105,93,199,91,194,93,194,92,195,93,92,90,87,85,80,79,
+73,71,69,194,56,195,54,197,51,48,59,194,47,40,197,39,34,38,194,34,35,34,
+194,31,30,29,24,30,24,195,22,25,21,18,21,11,14,9,8,5,6,4,195,1,216,0,211,
+0,194,1,2,4,3,12,5,8,9,11,13,15,195,18,195,20,23,194,24,30,31,30,197,33,
+58,38,39,42,46,48,46,44,194,50,53,51,54,53,194,56,65,62,69,70,72,70,73,
+194,69,67,65,194,62,67,194,69,71,76,72,79,72,79,194,80,75,79,74,75,194,
+80,74,81,195,85,86,91,93,94,194,95,98,100,103,106,104,108,107,195,109,111,
+114,194,113,115,113,116,195,115,111,93,196,96,97,92,197,97,194,96,97,96,
+194,92,93,91,194,93,92,91,194,92,195,91,90,195,92,90,94,99,109,111,195,
+109,108,194,107,195,104,106,103,98,95,98,95,94,93,195,91,194,89,197,91,
+194,96,195,92,91,89,90,87,83,74,79,73,194,69,66,195,54,51,54,196,51,48,
+194,44,40,47,38,199,39,34,35,34,194,31,30,37,194,24,32,24,23,194,20,18,
+15,13,21,9,0,194,5,2,4,219,0,212,0,194,1,3,6,5,0,195,9,11,21,196,18,194,
+22,20,23,29,24,195,32,194,57,195,58,38,36,194,40,46,44,52,49,53,50,53,55,
+54,56,65,62,64,68,70,73,74,70,73,71,69,67,195,65,66,62,69,71,73,72,78,194,
+72,194,79,75,80,75,78,75,194,80,194,81,85,87,86,89,194,91,93,96,98,100,
+104,106,107,108,106,110,109,111,109,114,195,113,111,113,103,194,96,93,96,
+92,96,97,92,195,96,92,97,194,92,195,93,194,96,196,92,91,92,194,91,194,92,
+90,92,196,90,88,87,85,89,106,107,108,107,106,196,104,98,99,97,98,195,93,
+91,200,89,194,91,194,93,96,93,91,92,90,194,87,88,80,72,73,71,66,194,56,
+194,51,54,194,51,54,51,194,59,194,47,196,39,38,194,39,42,36,34,35,34,195,
+31,30,32,194,30,196,20,195,18,21,19,11,194,8,6,4,2,194,1,217,0,211,0,195,
+1,4,6,5,8,14,11,9,13,21,15,194,18,17,18,194,22,24,194,23,24,194,32,33,194,
+32,194,33,194,38,194,42,45,46,194,49,52,50,53,56,55,194,65,62,64,68,70,
+72,75,74,70,73,71,194,67,56,65,56,194,65,69,64,70,77,76,73,72,78,72,194,
+78,75,70,74,79,75,74,81,88,85,87,91,93,94,95,194,98,100,104,103,104,95,
+94,110,109,103,194,98,99,103,99,97,93,91,194,92,96,194,93,194,96,194,92,
+97,93,195,96,93,92,93,91,195,93,91,92,91,194,90,112,95,90,87,90,198,87,
+83,81,195,83,85,101,99,103,98,99,97,95,93,95,94,194,91,194,89,90,85,196,
+89,194,91,195,93,194,92,90,92,91,87,85,74,80,78,77,64,62,56,194,54,51,194,
+54,194,51,50,59,44,40,47,200,39,194,36,35,194,34,31,33,30,32,26,194,24,
+195,20,17,15,18,13,14,9,14,194,5,4,194,1,218,0,212,0,194,1,3,4,194,5,8,
+9,13,21,13,15,194,18,25,196,22,24,30,29,30,33,32,194,33,194,58,38,36,40,
+42,43,45,195,49,53,50,53,56,55,60,61,64,195,70,75,70,194,75,73,69,62,66,
+55,194,56,194,65,67,69,71,70,73,194,72,73,72,70,194,72,194,75,195,80,83,
+81,194,87,90,91,93,94,105,86,74,81,83,88,85,87,85,194,87,90,89,197,92,195,
+93,96,92,93,195,96,93,92,194,93,194,92,93,90,195,92,195,90,194,92,195,111,
+112,103,91,87,195,85,194,83,81,83,81,195,74,195,75,80,85,194,102,94,195,
+91,89,84,87,84,86,85,84,89,90,89,194,91,92,195,93,92,90,88,90,88,83,75,
+72,71,67,194,66,194,54,196,51,194,59,44,47,40,199,39,42,194,36,34,36,194,
+31,33,30,194,26,24,194,26,194,20,17,22,18,21,194,11,9,8,6,4,194,1,0,1,217,
+0,214,0,194,3,5,12,8,14,9,11,13,15,196,18,25,27,22,23,24,194,30,32,194,
+57,195,33,38,34,39,46,42,45,195,49,52,53,55,65,60,62,63,64,194,68,70,72,
+75,70,75,72,71,194,67,56,194,54,194,56,65,62,69,194,71,73,76,194,72,70,
+72,73,72,70,195,74,83,74,83,195,85,83,73,196,75,83,85,88,197,87,92,194,
+90,194,91,196,92,93,194,92,93,91,92,93,194,92,91,93,92,194,91,89,90,92,
+90,91,195,87,112,196,109,194,107,98,89,194,81,83,194,81,74,197,75,70,194,
+72,194,73,71,68,73,82,85,194,84,85,84,85,194,84,194,89,92,96,195,92,91,
+89,91,88,87,88,80,78,71,69,65,194,56,54,197,51,194,59,44,47,40,47,196,39,
+36,39,195,36,35,36,33,197,32,26,195,28,20,17,194,18,15,11,19,194,14,194,
+6,4,1,219,0,211,0,195,1,194,4,5,194,8,11,9,13,21,11,195,21,194,25,194,27,
+22,23,24,195,30,194,32,195,58,34,42,39,42,194,46,195,49,195,52,56,55,60,
+63,64,70,68,70,196,75,77,71,62,65,195,56,194,65,194,62,69,68,69,73,70,194,
+73,72,194,70,72,194,75,79,74,194,81,82,73,64,71,70,72,70,79,194,74,81,83,
+85,194,88,87,90,87,89,91,194,92,194,91,93,91,92,194,93,194,92,93,92,91,
+93,194,92,91,92,90,92,89,87,90,88,195,87,194,110,107,106,107,104,108,106,
+194,104,101,91,80,75,74,70,195,72,70,72,195,70,194,68,194,64,194,62,73,
+80,82,194,85,87,86,194,89,91,93,96,93,91,194,92,87,90,88,81,74,72,73,69,
+66,56,54,51,54,51,194,50,194,59,44,47,198,39,194,40,194,42,34,36,34,31,
+34,33,194,32,194,26,195,24,195,20,17,15,21,11,9,14,194,5,3,4,195,1,217,
+0,212,0,194,1,194,3,5,194,12,9,14,10,11,21,11,19,196,25,27,22,27,24,195,
+30,58,33,32,33,194,38,36,194,42,194,45,195,49,53,50,53,195,56,65,64,68,
+70,68,72,70,75,70,72,69,194,67,195,56,65,56,65,62,67,71,68,71,194,73,70,
+196,72,194,75,79,74,80,74,64,60,63,64,68,72,70,194,75,80,81,74,194,85,87,
+85,87,90,87,194,90,196,92,91,194,92,194,93,92,91,194,92,91,196,90,198,87,
+85,83,81,104,194,108,194,106,194,104,106,99,100,99,97,98,96,94,91,80,72,
+70,197,68,195,64,195,62,60,194,62,82,83,84,195,89,90,91,194,92,195,90,194,
+87,88,74,80,72,69,67,66,56,54,194,51,59,194,51,48,59,44,40,39,40,39,47,
+194,39,42,40,194,42,36,35,34,194,33,194,57,32,26,32,26,28,20,28,20,22,18,
+194,15,11,19,14,8,6,194,4,194,1,218,0,214,0,1,194,4,194,8,14,9,195,11,19,
+25,19,194,25,195,27,29,27,24,30,33,30,194,33,34,195,38,34,194,42,46,45,
+48,194,49,195,53,194,55,56,65,64,68,194,70,75,70,194,72,73,71,62,65,56,
+54,56,195,65,194,62,71,69,71,195,73,194,72,194,73,194,75,79,74,79,195,61,
+64,68,70,75,70,194,75,74,81,80,85,88,197,87,92,196,90,92,91,92,90,92,91,
+92,194,89,92,91,92,89,90,87,88,87,194,85,81,88,81,83,194,106,194,104,100,
+194,99,194,97,98,97,95,94,96,94,91,194,92,89,92,89,84,83,194,80,73,62,194,
+60,65,194,60,194,65,76,87,85,194,89,93,92,93,194,92,194,90,194,87,85,81,
+75,76,71,62,56,54,194,51,59,51,59,48,47,44,47,39,47,195,39,194,47,40,194,
+42,36,34,39,34,194,33,195,32,197,26,20,194,17,22,18,13,11,194,14,6,194,
+5,4,1,0,1,217,0,212,0,1,0,1,194,3,5,12,14,9,194,14,195,21,25,21,194,25,
+22,25,23,27,30,29,194,31,196,33,34,36,39,194,40,42,44,194,48,194,50,194,
+53,54,53,194,54,66,62,64,68,70,72,70,73,77,69,67,194,56,194,54,195,65,62,
+65,71,70,71,195,73,70,194,72,70,72,70,194,74,75,62,195,61,64,68,194,70,
+74,75,74,81,74,80,81,85,88,196,87,91,89,91,194,90,89,92,194,90,89,92,90,
+87,90,87,90,87,88,87,195,88,85,194,81,194,74,98,99,100,99,194,100,97,98,
+194,96,93,92,93,92,93,91,90,194,89,196,87,195,85,83,82,71,65,60,194,61,
+65,67,79,194,90,92,93,92,93,91,89,194,90,195,88,74,73,71,67,66,56,54,196,
+51,194,59,47,40,47,194,39,47,194,39,40,196,42,36,195,34,197,32,194,26,196,
+20,18,17,18,21,15,13,9,14,194,6,194,4,1,219,0,213,0,1,2,4,6,5,194,8,14,
+197,19,194,21,194,25,27,22,194,23,27,29,194,30,31,33,35,194,34,194,38,36,
+42,40,194,46,194,48,50,53,50,195,54,194,51,54,65,69,71,68,73,71,68,71,69,
+67,65,55,56,54,56,194,65,62,65,69,70,76,194,78,79,194,72,80,70,194,75,79,
+80,78,60,61,194,64,71,70,72,70,75,194,74,80,81,194,83,85,88,198,87,91,194,
+90,194,89,194,92,196,87,85,88,194,87,194,85,81,83,81,194,83,74,81,99,100,
+98,97,195,96,197,93,92,91,194,90,194,87,85,87,85,194,83,85,83,196,74,80,
+195,65,195,62,84,89,91,92,93,194,90,92,87,88,87,88,83,79,72,64,62,65,54,
+51,50,48,51,48,59,48,44,47,39,47,194,39,194,40,42,40,194,42,194,36,194,
+34,32,33,194,32,194,26,194,24,26,28,20,22,194,18,194,15,194,11,19,14,8,
+194,5,4,195,1,217,0,212,0,1,0,1,194,3,194,5,195,8,9,14,21,194,19,195,25,
+195,27,194,23,194,29,30,195,31,34,35,34,36,38,36,39,194,40,195,44,194,50,
+53,50,51,194,48,59,51,56,67,62,194,69,196,67,66,197,56,65,194,62,69,68,
+73,72,78,194,79,78,80,74,75,70,194,75,80,73,64,61,194,64,68,194,73,72,75,
+74,196,81,195,85,87,88,90,194,88,90,203,87,195,83,74,83,81,195,75,74,91,
+97,195,96,196,93,196,92,89,92,194,87,90,88,85,83,88,81,68,60,75,83,74,197,
+75,55,60,62,67,64,78,92,91,195,92,195,90,195,88,81,78,76,69,194,66,195,
+51,194,59,48,59,47,194,40,39,47,39,194,47,40,46,195,42,36,34,194,33,57,
+197,32,194,26,194,20,17,20,195,18,15,11,9,14,8,194,6,4,1,220,0,213,0,1,
+2,194,4,3,0,194,8,14,19,9,19,196,21,194,25,27,22,23,22,23,194,29,37,194,
+31,35,34,36,34,39,38,34,194,39,47,194,48,50,53,50,54,51,59,194,47,48,51,
+56,66,194,65,194,62,65,195,56,55,56,54,195,65,194,62,71,73,72,75,194,79,
+194,75,79,74,80,74,80,74,80,74,82,72,195,78,80,74,75,74,79,80,194,83,194,
+81,194,85,87,88,90,87,85,90,88,197,87,194,88,194,83,88,194,81,83,74,75,
+81,70,89,95,194,96,196,93,92,93,92,194,91,194,90,194,87,90,194,85,87,88,
+81,80,71,62,194,65,195,75,79,75,80,78,65,62,65,194,64,80,89,92,93,91,194,
+90,194,87,194,85,81,74,72,64,62,65,54,194,51,59,48,194,59,194,44,40,196,
+39,194,40,46,40,194,42,36,194,34,58,33,32,58,195,32,194,26,24,28,194,20,
+194,17,18,194,15,13,9,194,14,194,5,3,4,195,1,217,0,213,0,194,1,2,3,6,5,
+6,194,8,19,11,195,19,194,21,194,25,196,27,23,195,29,37,31,194,37,36,34,
+36,39,36,194,39,38,40,59,48,50,194,53,51,48,40,47,44,59,50,54,56,66,54,
+196,56,194,54,197,56,65,62,69,76,78,72,79,195,80,79,80,79,74,80,81,83,81,
+85,194,87,92,91,105,93,95,194,97,85,74,194,83,81,88,83,194,85,194,87,88,
+87,88,87,195,88,194,85,194,81,194,83,81,74,75,81,89,194,97,194,96,195,93,
+194,92,91,90,91,194,90,194,89,196,87,85,195,83,73,60,52,60,194,55,76,78,
+70,74,72,65,55,60,61,194,62,68,89,91,194,92,194,89,88,87,194,88,194,74,
+72,71,67,66,56,54,51,50,196,59,195,47,39,40,47,40,44,40,46,194,42,194,36,
+38,34,194,33,196,32,194,26,28,24,194,28,194,20,17,194,15,194,11,9,194,8,
+194,6,194,4,220,0,214,0,2,1,4,3,6,5,8,6,8,14,19,21,25,194,19,21,195,25,
+27,194,23,27,194,29,31,37,35,41,35,41,36,195,38,194,39,40,44,45,53,52,55,
+53,51,47,40,47,40,59,51,194,54,66,198,54,55,194,54,56,65,194,62,64,71,72,
+79,75,79,82,80,83,74,83,194,80,194,83,82,83,85,84,86,89,93,194,94,194,98,
+194,99,94,89,83,80,194,85,81,83,81,195,85,194,83,85,83,80,81,83,81,74,83,
+102,93,194,97,96,196,93,91,194,92,93,91,194,92,90,92,90,194,87,90,87,85,
+88,85,83,73,195,60,61,52,194,55,195,53,194,55,196,65,62,71,78,195,92,90,
+92,194,90,195,88,83,74,76,71,67,56,54,51,195,59,194,48,194,44,40,39,194,
+47,40,194,44,46,40,42,194,40,194,34,33,58,194,32,57,194,26,195,24,28,194,
+20,22,195,18,15,21,194,9,14,8,194,5,3,4,194,1,218,0,214,0,194,1,194,4,194,
+6,14,8,14,9,14,19,21,25,19,195,25,22,194,27,23,22,195,29,195,37,194,35,
+195,36,34,195,39,47,44,49,52,53,55,53,51,195,44,47,59,197,54,51,54,53,194,
+54,55,56,54,194,56,194,62,194,71,78,194,79,80,82,83,195,82,197,83,194,87,
+194,89,91,93,94,95,195,98,194,99,104,194,99,103,94,102,194,89,194,85,87,
+86,102,94,101,99,103,194,99,194,98,95,93,94,93,200,92,194,90,92,194,87,
+194,90,88,195,85,81,70,196,60,194,55,194,52,195,53,194,50,53,55,60,194,
+62,64,79,90,93,89,92,194,90,194,87,194,88,81,80,73,68,62,56,194,54,51,196,
+59,47,40,47,194,39,194,40,47,194,44,46,194,42,36,38,34,38,33,58,32,33,195,
+32,194,26,195,20,195,17,18,195,15,11,9,14,8,194,5,194,4,0,1,218,0,213,0,
+195,1,4,194,3,5,8,6,8,194,14,11,194,19,25,21,195,25,194,22,23,27,195,29,
+37,31,194,35,194,41,36,40,39,36,195,40,48,49,194,52,194,55,51,59,194,47,
+44,59,194,51,194,54,51,50,48,194,51,194,54,195,56,194,65,62,67,70,73,79,
+195,80,82,198,83,82,84,83,85,194,90,194,91,194,93,95,98,195,99,104,99,196,
+104,106,104,106,195,104,100,99,100,98,195,97,194,96,93,91,194,92,91,92,
+91,92,91,89,196,90,194,87,90,194,88,85,88,85,78,194,65,195,60,52,195,55,
+53,194,50,194,53,55,56,195,65,76,84,90,91,194,92,89,90,194,87,88,85,83,
+81,74,73,69,194,66,54,51,50,59,48,194,59,40,47,40,39,194,40,47,44,194,46,
+40,194,42,39,38,194,58,33,32,58,26,32,24,26,32,26,28,20,17,20,22,194,18,
+194,15,21,13,194,11,0,8,5,3,4,195,1,217,0,214,0,1,2,1,4,194,6,195,8,9,19,
+11,21,11,19,21,195,25,194,27,194,23,27,195,29,194,37,196,35,36,40,36,40,
+42,46,44,194,49,195,52,53,50,44,40,44,48,51,196,54,194,51,50,53,51,54,53,
+56,54,56,65,62,67,194,71,72,79,194,80,195,83,194,82,85,83,85,196,84,87,
+89,91,94,93,96,194,95,99,98,104,103,196,99,194,104,194,103,104,194,99,95,
+98,194,95,194,96,92,93,92,195,90,89,90,89,194,90,87,90,196,87,85,87,194,
+85,83,72,60,61,195,60,194,55,52,55,196,53,50,194,53,60,62,73,194,83,87,
+89,92,91,194,92,89,90,88,90,194,88,74,75,72,69,62,56,54,51,59,48,59,48,
+194,44,194,40,47,40,47,194,44,47,48,46,42,40,194,36,38,33,58,33,32,33,194,
+32,194,26,20,24,28,20,194,17,18,194,15,21,15,11,195,9,0,5,194,3,4,1,219,
+0,213,0,196,1,4,3,5,8,6,196,14,194,19,21,19,21,19,25,195,27,194,23,195,
+29,194,37,35,37,195,41,43,194,42,194,40,194,48,49,52,53,194,55,54,59,195,
+47,51,197,54,50,54,51,54,50,194,54,56,194,54,65,62,69,194,73,78,79,80,195,
+82,194,83,82,196,85,84,86,194,89,194,91,94,95,96,95,195,98,195,99,106,99,
+103,98,99,98,95,97,98,95,96,94,93,92,194,91,92,91,90,91,194,90,200,87,195,
+85,194,83,72,61,62,61,195,60,194,52,194,55,53,50,194,53,50,52,53,71,194,
+79,194,82,84,86,90,91,92,195,90,88,87,194,88,81,83,72,71,69,66,54,51,50,
+196,59,194,47,40,47,40,47,40,194,44,45,46,194,42,36,39,38,33,58,33,195,
+32,26,32,194,24,30,24,195,22,194,18,25,21,194,15,194,11,10,9,0,8,5,3,2,
+0,194,1,217,0,216,0,1,4,194,6,195,8,14,19,11,194,19,21,19,25,19,25,18,22,
+25,195,23,195,29,37,195,35,194,41,197,42,40,48,49,195,52,55,56,54,195,48,
+59,194,54,194,56,54,194,51,50,51,54,53,54,196,56,194,65,69,73,72,78,79,
+80,83,82,84,83,194,84,196,85,86,87,194,89,194,91,94,96,194,95,98,96,197,
+98,99,194,97,98,95,194,96,95,93,194,91,90,89,194,87,90,87,90,194,87,90,
+87,90,194,87,195,85,83,88,85,81,80,69,194,60,62,61,62,69,194,55,50,73,76,
+77,195,71,69,76,78,194,79,83,194,86,89,92,90,89,90,87,90,87,85,88,74,81,
+75,73,67,62,56,54,51,50,59,194,48,44,197,40,44,48,45,48,44,40,42,40,38,
+34,38,33,194,58,33,196,32,26,194,24,20,22,194,18,195,15,18,15,194,13,195,
+9,12,8,3,4,194,1,219,0,213,0,196,1,194,4,5,8,194,6,8,194,14,11,21,19,15,
+21,195,18,25,22,23,27,22,195,29,194,37,35,37,194,35,41,194,42,194,40,194,
+46,195,49,53,194,52,53,51,59,47,50,194,54,66,56,66,54,50,195,51,54,53,54,
+56,54,194,56,62,69,71,73,72,75,194,80,194,83,84,194,85,82,84,85,195,84,
+194,90,89,194,91,94,91,93,96,95,194,98,97,98,97,195,95,96,194,94,194,91,
+92,89,90,194,87,85,87,85,88,85,88,87,88,87,196,85,83,85,81,83,74,83,81,
+195,74,194,75,79,194,75,194,72,73,194,70,73,194,68,70,72,79,80,85,84,87,
+89,92,90,194,92,90,88,87,194,88,194,83,74,73,71,62,66,54,51,59,47,194,59,
+47,44,40,47,194,40,47,194,44,48,44,194,46,40,39,36,194,38,58,33,32,57,26,
+32,194,26,30,26,20,194,22,196,18,194,15,21,15,9,11,9,194,8,5,6,4,195,1,
+218,0,214,0,195,1,3,194,4,8,198,14,11,19,194,21,195,18,194,22,23,194,27,
+23,195,29,37,35,37,194,41,35,43,194,42,39,40,44,43,194,49,52,53,194,55,
+54,51,194,59,50,51,66,54,56,66,194,51,50,59,54,50,195,53,195,54,65,67,71,
+76,72,79,83,80,194,83,82,194,85,84,82,85,86,194,84,194,90,194,89,93,194,
+94,95,94,196,95,96,194,95,94,93,195,91,194,89,194,87,196,85,87,85,87,88,
+83,194,81,83,197,81,74,83,81,194,80,74,75,79,195,75,72,73,194,72,194,73,
+68,73,194,71,76,72,194,80,85,194,87,194,92,89,90,87,90,87,194,88,194,81,
+75,72,71,67,56,54,51,50,194,48,59,44,47,195,40,47,44,194,59,48,46,48,40,
+42,36,194,38,58,38,58,33,32,58,194,32,30,26,194,23,22,27,194,25,194,21,
+25,11,13,195,11,194,9,8,5,3,4,194,1,0,1,218,0,213,0,1,0,194,1,194,4,5,6,
+194,5,8,194,14,11,19,194,21,15,194,21,22,25,194,22,194,23,22,195,29,194,
+37,35,194,37,194,41,43,40,42,36,46,44,52,194,49,194,52,194,55,50,195,59,
+54,56,54,66,194,56,51,59,50,51,54,51,194,54,196,56,62,69,71,76,72,78,80,
+83,82,83,82,84,196,85,194,86,84,194,89,91,89,91,196,93,94,96,194,94,96,
+91,194,93,91,89,86,84,194,85,83,81,85,81,85,83,81,74,83,81,194,83,81,83,
+74,81,74,83,194,74,194,75,74,194,79,194,75,194,72,196,70,73,71,73,68,70,
+73,72,79,80,82,84,86,91,194,89,90,195,87,194,88,74,194,81,75,68,62,65,56,
+51,53,195,59,44,47,40,47,40,47,40,47,46,45,44,48,194,42,39,38,36,33,34,
+33,196,32,26,32,24,29,24,23,27,22,194,25,197,21,194,11,13,9,194,0,194,6,
+3,1,0,1,219,0,214,0,194,1,0,3,4,3,6,195,8,194,14,11,21,13,21,15,18,15,18,
+25,18,22,194,27,194,23,195,29,37,35,41,37,35,41,35,36,40,39,42,40,45,195,
+49,52,53,55,54,194,59,48,59,54,197,56,51,48,194,51,196,54,55,54,194,56,
+62,64,77,72,194,79,80,196,83,84,82,84,194,85,194,84,85,87,89,90,194,89,
+195,91,105,194,93,91,93,91,89,91,89,90,194,87,83,81,83,81,83,80,83,81,83,
+81,83,194,81,83,81,83,194,80,194,74,75,194,74,195,75,70,72,194,70,75,72,
+194,73,70,194,68,194,69,70,76,79,80,83,85,86,90,194,92,90,87,90,85,88,85,
+83,74,75,70,72,69,66,56,54,59,50,194,59,47,194,44,195,40,47,44,59,48,45,
+46,194,44,42,39,194,38,194,58,33,58,33,194,32,30,32,24,27,23,194,27,194,
+25,21,18,15,194,21,13,15,195,9,194,0,5,6,4,195,1,219,0,215,0,194,1,195,
+4,5,6,8,14,8,14,9,194,11,13,194,15,18,15,194,18,196,22,23,195,29,195,37,
+194,41,35,194,36,34,38,39,42,46,195,49,194,52,55,53,54,51,59,195,51,66,
+194,65,194,56,54,50,54,51,194,50,194,54,55,54,194,56,67,69,76,72,194,79,
+82,194,83,82,195,83,82,84,194,85,84,194,86,195,89,91,89,91,93,195,91,196,
+89,85,87,194,85,81,194,74,80,195,81,83,198,74,75,74,75,74,194,79,80,194,
+79,75,72,70,196,72,194,73,196,71,69,194,68,71,72,79,82,85,86,90,92,196,
+90,195,88,194,81,83,74,73,69,62,56,54,194,51,194,59,194,44,194,47,40,47,
+40,194,44,46,44,48,44,46,42,194,39,195,38,194,33,32,57,32,194,30,23,22,
+23,198,25,194,21,195,15,194,13,195,9,8,194,5,4,1,194,0,1,218,0,215,0,194,
+1,194,4,6,195,5,194,14,19,9,195,11,194,21,196,18,25,195,27,22,23,195,29,
+31,194,37,194,35,34,38,196,39,42,46,195,49,195,52,54,51,50,59,50,51,56,
+65,194,66,54,51,48,50,51,54,53,51,194,54,55,56,54,65,62,69,73,194,72,80,
+82,80,83,194,82,194,83,194,82,85,84,85,194,84,87,86,89,194,87,197,89,90,
+85,86,194,85,81,194,80,75,74,79,74,195,75,79,75,195,79,80,196,75,74,70,
+194,75,194,70,75,72,70,72,194,73,68,194,70,195,64,194,69,73,78,75,80,194,
+84,194,90,92,90,195,87,88,85,195,81,72,73,69,67,56,194,54,48,59,48,194,
+59,44,195,40,194,47,48,59,194,48,46,194,40,39,34,39,38,33,34,57,194,32,
+58,194,32,30,27,194,23,22,27,194,25,194,21,197,15,21,194,13,9,0,8,194,5,
+194,4,1,220,0,214,0,195,1,194,3,4,195,6,8,14,0,9,195,11,196,15,21,194,25,
+194,27,23,27,23,22,194,29,37,31,194,37,36,34,36,34,195,38,39,44,45,195,
+49,194,53,50,53,195,59,54,51,66,194,56,194,66,54,59,195,51,53,51,194,54,
+195,56,65,69,77,73,194,78,79,80,82,195,83,82,194,83,82,83,84,194,85,84,
+87,195,86,85,86,84,87,86,194,84,194,85,81,80,74,75,79,195,75,194,74,80,
+75,79,200,75,72,75,194,70,194,72,194,73,72,73,194,68,194,71,69,194,71,69,
+64,68,73,72,82,83,85,90,194,91,89,90,196,88,74,81,74,75,70,71,62,56,54,
+51,194,59,48,194,59,44,47,40,47,194,40,44,47,48,45,46,44,46,36,194,39,34,
+33,38,196,33,194,30,29,195,23,195,27,194,25,195,21,194,15,11,15,13,11,194,
+9,194,0,5,194,3,4,194,1,219,0,216,0,194,1,3,4,6,8,6,8,194,14,9,11,13,11,
+13,194,15,18,15,18,195,25,22,194,27,23,195,29,31,35,31,35,194,34,194,58,
+194,38,39,40,44,195,49,194,52,195,53,59,48,194,51,54,56,65,195,56,50,48,
+59,51,54,53,51,194,54,53,56,54,62,67,194,73,72,79,80,83,194,82,80,195,83,
+80,83,194,82,85,84,83,194,84,86,84,86,84,83,85,194,83,194,80,194,75,78,
+70,195,75,194,72,70,197,75,70,194,72,73,194,70,73,195,72,194,73,70,73,68,
+194,71,68,64,68,64,62,64,67,71,73,78,79,83,87,195,90,195,87,90,194,85,81,
+80,83,75,73,69,67,56,54,194,51,196,59,47,40,47,40,47,195,44,45,48,44,46,
+194,40,39,195,38,194,33,32,57,33,32,194,31,29,23,195,27,22,195,25,194,18,
+195,15,11,15,13,11,194,9,194,0,194,5,194,3,194,1,219,0,214,0,196,1,194,
+4,5,4,5,8,14,195,9,194,11,194,15,21,15,25,21,195,25,194,27,194,23,22,195,
+29,37,194,31,33,194,34,194,33,38,58,39,194,46,49,52,49,194,52,53,51,195,
+59,48,194,54,195,66,56,54,51,50,59,50,51,53,50,53,194,54,194,56,67,69,76,
+78,79,72,194,79,194,80,79,82,80,82,80,194,83,82,83,82,200,83,194,80,194,
+79,194,74,70,194,72,70,195,72,75,197,70,194,72,70,195,72,197,73,70,73,68,
+71,194,68,194,71,67,194,69,62,68,71,78,80,83,84,85,195,90,88,87,195,88,
+195,81,75,72,71,69,56,194,54,51,196,59,48,194,44,195,40,194,47,48,194,44,
+46,44,42,36,39,36,194,38,58,196,33,31,30,29,22,194,23,22,196,25,18,196,
+15,13,15,195,13,9,10,0,12,194,5,3,4,195,1,218,0,216,0,194,1,2,4,194,6,5,
+194,8,195,9,10,194,11,194,13,196,21,194,25,194,27,25,27,23,195,29,37,194,
+31,33,34,194,58,38,34,33,38,39,44,43,195,49,52,194,50,59,44,59,48,194,51,
+195,56,66,56,54,48,59,51,59,51,194,54,51,194,54,55,56,62,194,71,78,79,75,
+195,80,194,79,195,80,79,197,80,82,194,83,80,83,79,80,79,194,75,78,195,72,
+70,75,73,72,70,194,72,194,75,72,75,72,73,72,70,194,73,194,70,73,68,70,71,
+68,69,68,194,69,64,62,194,64,62,67,65,71,73,79,80,83,87,89,87,88,90,88,
+194,85,88,81,83,81,75,70,71,62,66,54,194,51,59,50,59,48,59,194,47,196,40,
+44,45,195,48,42,194,40,42,195,38,58,195,33,32,195,30,29,27,23,25,22,195,
+25,21,18,196,15,13,196,11,14,9,8,0,194,5,194,3,1,220,0,215,0,195,1,194,
+4,3,4,6,5,8,14,9,19,196,11,194,21,11,19,21,195,25,22,27,23,194,27,194,29,
+194,30,31,35,196,33,194,38,58,194,39,48,45,195,49,53,194,50,196,59,51,54,
+56,65,194,56,54,51,194,48,50,48,59,50,53,195,54,56,66,62,71,73,72,79,78,
+80,79,195,80,79,199,80,79,80,79,80,196,79,194,72,195,73,194,72,73,194,70,
+72,199,73,70,194,73,70,68,194,73,68,73,69,64,69,68,69,194,64,67,69,62,67,
+64,62,69,73,78,79,83,87,90,88,90,87,88,87,88,74,194,81,74,75,70,71,62,66,
+56,54,51,59,50,59,48,59,195,44,40,194,47,195,44,48,45,46,44,42,36,39,194,
+34,195,33,57,32,31,32,194,29,27,194,23,194,27,22,25,194,18,21,194,15,21,
+15,11,13,195,10,9,194,0,8,12,194,3,1,0,1,219,0,217,0,195,1,194,3,6,5,6,
+8,0,194,9,195,11,13,15,21,19,25,21,194,25,194,27,22,23,27,23,194,29,194,
+31,32,33,196,58,33,195,38,42,44,52,195,49,194,50,194,44,47,48,59,51,194,
+56,66,194,56,54,59,47,51,50,59,51,194,50,51,53,54,56,67,69,77,76,72,194,
+79,75,194,79,80,78,79,194,78,79,80,79,75,196,79,78,79,194,78,72,73,70,194,
+68,71,68,73,194,71,68,70,194,68,70,194,68,71,68,194,71,73,68,64,71,194,
+64,71,195,64,194,67,64,62,69,62,65,194,62,69,73,75,82,83,85,90,194,87,85,
+194,88,81,83,80,74,75,72,73,67,194,56,54,51,194,59,50,51,59,196,47,39,40,
+47,59,48,45,48,44,42,194,40,36,39,194,38,34,195,33,32,30,31,29,194,23,195,
+27,194,22,18,15,18,194,21,15,11,13,195,11,194,9,194,0,12,194,5,4,3,194,
+1,220,0,215,0,196,1,194,4,6,5,6,8,14,9,14,194,9,195,11,194,19,21,19,25,
+21,194,25,22,194,27,23,194,27,29,194,30,198,33,194,58,34,36,40,42,46,194,
+49,52,50,194,59,47,44,47,48,59,51,195,56,66,56,51,48,44,59,50,59,194,51,
+53,51,50,54,56,62,194,71,76,72,198,79,194,75,79,72,195,79,78,79,72,78,72,
+73,72,73,68,70,71,194,69,64,69,64,194,68,196,71,194,69,71,68,69,68,194,
+64,194,69,64,194,69,62,194,69,67,194,64,194,62,65,195,62,68,76,78,79,83,
+85,194,87,195,88,74,194,81,194,74,75,70,73,67,66,56,194,51,59,48,50,51,
+194,48,194,44,194,40,44,40,194,44,48,194,44,46,44,194,36,39,194,34,38,34,
+195,33,194,31,30,29,24,194,23,194,22,25,196,18,195,15,13,11,194,13,194,
+9,10,8,196,5,3,195,1,220,0,217,0,194,1,195,4,3,5,6,194,8,9,11,195,9,194,
+11,19,21,19,21,19,195,25,22,27,195,23,29,194,30,194,33,194,32,58,194,33,
+194,38,33,39,42,40,45,194,49,50,45,195,44,47,44,59,194,51,194,56,66,56,
+54,59,48,59,50,194,51,59,194,51,54,53,194,56,69,71,77,72,78,72,75,78,75,
+78,79,75,194,78,72,78,194,72,78,194,72,76,194,73,71,69,64,194,68,71,68,
+195,69,68,64,196,68,64,69,68,69,71,69,194,64,69,64,62,69,64,62,64,197,62,
+194,65,60,66,71,73,78,80,85,88,85,195,88,81,194,83,81,74,70,75,68,62,65,
+56,54,51,50,197,59,195,47,194,40,195,44,45,194,46,44,42,40,39,194,34,194,
+38,33,57,32,33,30,29,194,30,23,27,23,194,22,196,18,196,15,21,11,9,11,13,
+9,0,10,0,12,8,5,195,3,194,1,220,0,215,0,198,1,195,6,5,194,8,9,0,194,11,
+14,196,19,21,19,197,25,22,27,23,22,27,30,31,30,194,57,58,33,196,58,194,
+38,39,194,46,194,44,194,48,59,47,194,40,47,48,59,195,54,194,56,54,51,195,
+59,44,48,50,48,54,195,51,56,65,69,194,71,73,194,78,75,196,78,194,72,78,
+72,78,72,194,73,71,73,69,196,71,67,194,62,67,195,64,194,69,196,67,69,64,
+67,64,62,64,194,69,194,62,64,62,67,62,65,195,62,197,65,69,71,78,79,83,196,
+88,83,81,83,81,75,81,70,72,71,69,67,56,54,51,195,59,48,194,59,48,44,194,
+40,39,194,47,44,48,195,44,195,42,194,36,39,34,196,33,195,30,29,23,194,24,
+22,20,22,194,20,22,18,195,15,11,13,15,13,10,11,13,9,14,0,8,195,5,4,195,
+1,220,0,218,0,194,1,195,4,194,6,0,8,14,194,0,9,14,8,11,194,19,21,11,21,
+19,195,25,22,194,27,194,23,24,194,30,195,32,196,33,58,194,34,39,42,195,
+46,196,44,195,40,44,59,51,195,54,56,54,51,194,44,194,59,47,51,194,48,194,
+51,194,54,65,62,71,195,73,78,196,72,78,73,72,76,73,76,73,194,76,68,71,194,
+69,195,64,67,194,64,194,67,194,62,197,64,62,67,64,194,62,67,195,62,69,195,
+62,65,62,198,65,56,194,65,71,73,72,79,80,194,88,83,81,83,81,195,74,75,74,
+68,64,62,66,194,51,195,59,51,50,59,195,47,40,47,39,40,47,44,48,194,45,44,
+42,194,40,36,195,34,196,33,32,195,30,195,23,22,20,17,18,17,194,18,196,15,
+13,21,11,13,9,194,10,14,194,0,194,5,194,3,2,194,1,220,0,216,0,194,1,0,194,
+1,4,195,5,4,6,8,195,14,8,194,14,9,196,19,25,19,195,25,194,27,23,24,30,26,
+198,32,194,58,33,58,194,38,194,39,194,44,46,44,40,39,47,39,194,47,44,59,
+50,54,56,194,54,51,59,47,196,48,59,51,194,48,51,194,54,66,62,69,71,76,73,
+196,78,73,78,76,73,76,71,76,68,195,71,194,64,194,67,194,62,194,65,64,62,
+69,62,197,67,195,62,67,197,62,65,194,62,65,62,65,62,194,56,65,196,56,67,
+69,73,78,74,81,83,194,81,194,74,75,81,70,72,75,73,71,194,66,54,51,194,59,
+194,48,194,59,48,194,44,40,194,39,40,44,40,44,46,44,196,42,194,36,194,34,
+196,33,30,31,33,196,24,20,22,18,22,195,18,15,21,195,15,21,194,13,9,10,11,
+0,9,194,8,0,5,3,4,194,1,0,1,219,0,217,0,194,1,0,1,195,4,194,5,194,6,14,
+8,195,14,19,9,11,195,21,194,25,19,194,25,194,27,194,22,23,194,24,194,32,
+57,194,32,33,58,33,194,58,34,39,194,36,194,40,47,197,39,194,44,59,50,194,
+54,56,54,51,48,194,47,194,59,194,48,59,51,194,48,51,53,194,66,69,71,77,
+71,194,72,73,76,194,73,76,195,73,195,71,69,71,69,64,62,67,65,194,62,65,
+62,65,205,62,194,65,62,197,65,56,194,65,194,56,54,194,56,65,194,69,73,78,
+80,81,83,74,81,195,74,75,74,75,70,64,65,56,194,51,59,48,194,59,48,194,59,
+194,47,40,47,194,39,40,44,46,48,194,46,195,42,36,197,34,33,197,30,24,195,
+23,194,24,17,20,17,15,18,195,15,197,13,11,10,194,9,0,12,194,5,194,3,4,194,
+1,221,0,218,0,195,1,194,4,195,6,194,8,6,14,8,195,14,194,19,14,194,19,21,
+19,25,19,194,25,27,22,195,24,32,26,197,32,33,58,194,33,38,34,38,39,36,197,
+39,38,194,39,40,47,59,51,54,194,53,51,59,196,44,194,47,194,48,59,51,48,
+59,54,65,66,67,71,194,73,194,71,73,194,76,194,73,76,194,77,71,69,64,194,
+62,67,62,196,65,62,65,62,206,65,62,194,56,194,65,202,56,66,62,71,73,75,
+74,194,81,195,74,75,72,75,194,70,69,62,66,54,194,51,48,197,59,194,44,40,
+195,39,194,47,194,44,46,197,42,34,36,39,195,33,31,33,194,32,194,24,30,24,
+194,20,22,17,20,17,194,18,197,15,196,13,10,194,9,194,0,194,8,3,5,3,194,
+2,1,221,0,218,0,1,194,0,2,3,4,5,4,196,5,195,8,14,8,19,11,194,19,194,21,
+25,21,25,194,18,194,22,24,20,24,26,195,32,57,194,32,194,33,58,33,38,36,
+39,38,34,194,39,38,196,39,44,194,48,194,51,194,54,51,59,195,47,194,44,59,
+47,48,44,59,194,48,50,56,194,65,67,69,197,73,71,76,73,71,73,194,71,195,
+69,62,66,65,62,194,65,56,65,56,200,65,56,65,195,56,65,56,194,65,197,56,
+194,54,195,56,195,54,67,69,77,76,78,194,75,194,74,75,70,74,75,72,75,68,
+69,65,56,54,198,59,48,194,47,40,47,40,47,194,39,47,42,44,196,42,43,41,196,
+34,195,33,194,30,32,194,26,24,23,22,20,22,196,17,195,15,194,16,15,13,194,
+11,9,195,10,195,0,8,194,3,4,196,1,220,0,218,0,196,1,4,3,4,5,194,6,8,6,5,
+8,14,8,195,14,9,14,194,19,11,21,25,18,25,18,24,20,24,194,26,24,196,32,58,
+57,194,33,38,34,58,38,34,195,38,39,38,196,39,40,47,48,51,54,53,54,50,48,
+40,44,194,47,194,44,194,59,48,47,194,59,54,56,66,194,67,194,69,71,73,77,
+73,71,73,71,195,69,71,64,194,67,62,195,65,196,56,194,54,205,56,54,194,56,
+54,194,56,54,194,56,194,53,54,53,54,56,65,69,71,75,70,75,74,194,75,70,75,
+195,70,68,64,62,56,51,194,48,59,195,48,44,59,194,44,47,197,39,194,40,46,
+195,42,194,43,36,41,35,194,33,194,32,30,194,32,194,30,194,24,195,20,17,
+194,22,17,16,195,15,197,13,194,10,9,194,0,9,0,195,5,4,3,195,1,221,0,218,
+0,196,1,194,4,6,194,5,6,8,6,194,8,196,14,19,194,11,21,19,21,15,194,18,22,
+18,22,194,20,24,195,26,194,32,26,32,196,33,199,38,34,194,38,195,39,44,47,
+194,48,51,50,51,194,59,194,40,44,47,195,44,47,196,48,59,54,56,65,67,69,
+64,69,70,77,73,71,194,73,194,71,194,69,196,67,194,65,66,56,54,195,56,54,
+198,56,54,195,56,54,194,56,54,197,56,196,54,53,54,51,54,56,66,194,69,73,
+194,75,72,194,75,72,75,195,70,68,62,66,54,51,59,44,47,195,59,44,194,47,
+40,198,39,46,195,42,43,42,194,41,195,34,35,194,33,32,194,30,26,195,24,20,
+23,17,20,195,17,18,197,15,195,13,194,11,195,9,195,0,195,5,194,3,195,1,221,
+0,220,0,195,1,3,194,4,6,5,6,8,194,6,194,8,194,14,8,195,19,196,21,15,17,
+196,20,28,20,194,26,24,196,32,194,33,195,34,38,33,195,58,38,34,194,38,194,
+39,40,44,194,59,50,51,50,51,48,47,40,44,40,195,47,44,194,47,59,47,48,51,
+54,66,56,65,62,194,69,71,69,198,71,194,69,194,62,194,65,56,65,56,55,54,
+206,56,54,55,56,54,53,198,54,194,51,54,53,50,66,65,67,71,72,70,74,70,194,
+72,70,68,195,70,64,65,54,51,194,59,47,48,195,59,47,44,195,40,195,39,195,
+40,194,42,194,43,41,196,35,31,32,195,30,32,26,30,194,24,28,24,17,22,194,
+20,17,18,16,197,15,13,11,13,195,10,9,196,0,12,5,3,4,1,2,0,194,1,220,0,221,
+0,194,1,3,4,3,6,5,6,8,14,6,195,8,14,194,9,11,194,13,195,15,18,17,20,17,
+194,20,28,20,24,194,26,195,30,31,30,196,33,58,195,33,197,38,194,39,40,194,
+44,48,51,50,48,194,59,194,47,196,40,47,44,40,194,44,47,194,44,59,54,56,
+66,67,194,62,197,71,69,194,71,194,69,67,69,62,66,56,66,54,56,54,197,53,
+195,54,53,54,53,194,54,53,194,54,53,194,54,53,50,53,54,50,194,54,195,51,
+50,66,65,67,69,72,70,72,197,70,194,68,64,62,56,54,51,194,44,47,195,48,44,
+47,44,40,197,39,198,42,195,41,34,33,34,194,33,31,32,194,30,26,194,28,195,
+20,196,17,16,18,16,195,15,195,13,194,11,194,9,10,194,0,8,0,8,3,5,194,3,
+194,1,223,0,219,0,196,1,197,4,5,6,5,8,6,8,194,14,194,9,194,11,21,194,15,
+17,15,194,17,196,20,28,196,24,196,32,30,196,33,195,58,33,197,38,194,39,
+40,44,47,45,44,51,50,48,44,39,47,194,40,44,40,47,44,194,47,44,194,47,48,
+51,54,194,56,66,194,67,69,64,194,69,194,71,196,69,194,67,62,65,56,66,54,
+194,51,197,54,53,199,54,51,50,51,54,50,51,54,51,50,54,48,51,50,59,48,51,
+54,66,69,194,68,198,70,71,194,64,65,194,56,51,59,194,47,44,47,195,59,44,
+40,195,39,38,39,38,40,39,194,42,194,43,35,41,194,35,194,31,194,30,32,30,
+32,26,195,24,20,194,22,194,20,17,18,17,16,194,15,11,197,13,194,10,9,196,
+0,8,194,5,195,3,2,194,1,222,0,221,0,195,1,194,4,5,4,3,4,5,195,8,0,14,194,
+9,194,13,11,15,13,194,15,16,195,17,20,18,194,20,24,26,23,29,23,37,32,30,
+194,33,57,32,194,33,58,194,33,38,34,58,194,38,39,47,40,47,48,45,48,47,59,
+44,40,47,40,47,194,40,47,40,44,47,194,44,195,47,59,51,54,56,194,65,67,196,
+69,68,71,69,62,67,62,194,67,66,194,56,195,54,195,51,50,194,51,54,194,51,
+194,50,51,53,194,54,195,51,59,196,51,50,51,50,194,51,50,54,56,66,69,71,
+195,70,194,68,194,64,62,63,65,56,50,194,48,44,47,197,44,194,47,195,39,38,
+39,38,42,39,42,36,195,41,36,33,35,33,194,31,30,32,24,30,194,26,28,194,20,
+194,17,194,18,16,197,15,196,13,194,9,11,0,195,9,195,0,194,5,3,194,4,195,
+1,222,0,220,0,1,0,194,1,4,3,4,194,6,5,6,194,5,0,14,10,9,13,11,194,13,194,
+15,194,16,194,18,17,194,18,20,18,20,22,23,20,195,24,29,30,33,57,195,33,
+58,33,194,58,34,38,34,38,39,38,36,194,40,46,194,44,45,48,47,40,194,39,40,
+47,195,40,44,40,44,47,44,40,194,44,59,50,194,54,194,56,66,67,194,64,69,
+194,64,71,62,67,195,65,194,56,54,51,48,194,50,194,54,51,50,51,50,195,51,
+50,59,194,51,50,51,194,50,48,51,194,48,59,48,59,44,51,194,54,66,194,62,
+194,64,70,68,194,64,61,194,63,194,60,53,51,59,194,47,44,47,194,48,44,47,
+40,194,39,195,38,195,39,195,36,35,194,34,31,35,194,31,33,32,30,24,32,194,
+24,28,20,28,20,194,22,18,195,17,16,15,194,13,15,13,194,11,13,10,0,10,196,
+0,8,5,12,5,4,194,3,2,1,223,0,220,0,1,0,196,1,3,194,4,5,195,8,0,195,9,10,
+196,13,11,196,15,196,18,25,195,22,194,23,194,24,196,30,32,57,33,57,194,
+33,195,58,34,38,194,39,40,42,194,44,45,194,48,45,47,44,47,194,39,195,40,
+47,40,47,44,40,194,47,194,44,194,47,59,194,54,56,65,194,67,62,67,69,64,
+71,194,69,67,194,66,194,56,54,51,194,59,48,59,50,51,48,51,50,194,48,59,
+194,50,48,51,48,194,59,51,48,194,51,48,59,48,59,48,51,54,56,194,66,194,
+62,195,64,62,63,62,194,61,56,54,51,59,194,44,47,44,194,47,195,44,40,194,
+39,36,39,194,38,34,194,36,194,34,194,35,34,33,195,31,30,32,30,24,26,24,
+20,28,20,18,17,15,20,18,17,15,18,16,194,15,13,11,194,13,9,11,10,194,9,0,
+194,8,0,12,195,5,3,194,4,194,1,223,0,219,0,1,0,1,0,1,194,4,1,3,6,3,12,196,
+0,10,13,9,11,194,13,194,15,21,13,194,21,15,21,15,196,18,194,22,194,23,30,
+194,24,31,194,32,33,57,33,57,58,194,33,194,38,34,194,38,194,39,194,42,40,
+44,46,194,48,194,40,39,40,194,39,47,39,47,195,40,44,40,47,195,44,194,47,
+51,194,54,56,65,67,62,64,67,62,194,67,194,62,56,66,56,194,54,194,50,51,
+50,59,48,51,48,59,194,51,50,194,59,51,48,51,194,48,44,59,48,44,59,48,59,
+50,59,51,194,54,56,194,65,194,62,61,194,63,194,61,60,56,55,54,51,48,47,
+44,40,195,44,59,44,40,195,39,194,38,39,36,40,36,34,194,35,194,34,195,31,
+196,30,26,24,30,28,26,195,20,194,18,15,18,15,194,16,15,13,11,21,13,196,
+10,194,9,196,0,195,5,3,4,3,2,194,1,0,1,222,0,221,0,1,0,1,3,194,4,3,194,
+5,12,194,0,9,194,0,194,10,9,13,11,9,13,11,194,13,196,21,25,21,22,27,18,
+194,22,27,194,23,194,24,32,30,196,32,57,58,33,58,194,38,194,34,194,39,40,
+42,46,194,40,46,59,44,47,199,39,194,47,195,40,47,194,40,194,44,40,44,59,
+51,54,194,56,66,194,67,194,62,194,67,66,194,56,54,194,51,59,44,47,48,59,
+48,59,48,194,44,47,195,48,59,48,195,59,48,47,59,44,47,50,59,196,54,194,
+56,65,56,65,62,194,60,194,61,60,52,54,53,50,59,44,195,47,196,44,195,40,
+195,39,34,38,194,34,36,34,36,35,196,31,30,32,31,24,29,194,24,196,20,17,
+20,194,18,195,15,194,13,15,195,13,194,11,195,9,194,0,9,194,0,194,12,195,
+5,4,194,3,194,1,224,0,220,0,197,1,4,1,3,195,5,8,195,0,195,9,10,195,9,14,
+9,11,19,11,13,11,15,195,21,194,25,18,22,23,195,24,30,24,32,30,194,32,194,
+33,32,194,33,58,34,194,38,34,194,36,194,40,194,46,40,42,47,40,194,47,194,
+39,40,39,40,194,39,40,47,195,40,47,40,195,47,44,194,59,51,194,56,65,194,
+62,67,195,62,194,66,194,54,51,44,59,48,59,48,47,48,195,59,48,195,59,48,
+47,195,48,59,48,44,59,194,51,196,54,56,54,194,56,65,194,56,194,65,60,194,
+52,55,53,50,51,44,47,194,44,194,40,44,42,40,46,40,194,39,38,34,194,39,36,
+41,195,35,33,194,31,37,30,31,29,194,24,28,26,24,26,196,20,194,18,25,197,
+15,197,13,10,13,10,0,9,195,0,8,194,5,12,5,194,3,4,1,2,1,0,1,222,0,221,0,
+195,1,2,194,3,195,5,12,194,5,8,195,0,14,194,0,194,9,11,194,9,196,19,11,
+19,194,21,18,25,194,18,194,22,194,23,195,24,194,30,32,30,197,33,34,38,39,
+38,39,38,36,194,39,46,44,42,46,194,40,47,38,196,39,40,196,39,47,40,47,195,
+40,47,40,44,59,51,194,54,194,56,197,65,194,56,194,54,51,48,59,48,59,48,
+59,195,48,59,195,44,47,44,195,47,44,194,47,48,194,51,54,194,66,54,194,56,
+54,60,54,60,194,55,53,56,54,196,53,48,59,44,194,40,44,194,47,44,46,40,194,
+42,39,42,39,38,195,34,41,195,37,35,31,197,30,32,194,30,28,20,194,28,194,
+20,17,18,199,15,194,13,195,11,194,9,10,0,9,194,8,0,12,196,5,194,3,2,195,
+1,224,0,224,0,1,194,4,3,195,5,194,12,0,5,194,8,0,8,0,194,9,8,14,197,11,
+19,21,19,21,19,21,25,18,25,194,22,20,194,23,30,24,32,30,194,32,33,31,33,
+34,195,33,194,34,195,36,42,40,42,194,40,46,195,39,38,39,38,39,38,47,39,
+47,40,195,39,194,40,44,195,40,194,44,59,51,54,56,196,65,195,56,54,51,48,
+59,44,47,44,47,44,195,47,44,195,47,44,47,195,44,47,44,48,59,54,194,56,54,
+195,55,56,65,56,60,54,56,54,56,50,195,53,194,50,195,48,59,194,44,46,194,
+42,40,42,194,40,39,196,34,36,41,35,41,194,35,31,29,30,31,194,24,194,23,
+24,198,20,17,195,18,25,196,15,196,13,194,10,9,197,0,12,194,5,12,5,194,3,
+5,3,4,1,0,1,224,0,222,0,1,0,194,1,4,2,194,3,197,5,12,5,0,194,8,0,194,9,
+8,9,14,194,19,11,19,21,19,21,25,194,21,25,194,18,194,22,23,20,194,23,194,
+24,29,30,32,31,194,33,194,34,33,34,38,34,39,36,34,36,196,42,194,44,47,196,
+39,38,195,39,197,40,39,40,44,47,40,47,40,47,59,51,194,54,194,56,65,194,
+56,195,54,194,59,40,47,44,47,40,194,44,47,195,44,47,44,47,40,47,44,194,
+47,48,51,54,56,55,65,195,61,55,60,56,55,194,53,50,53,197,50,48,45,44,40,
+47,194,40,44,40,194,42,36,42,196,36,195,35,37,41,194,37,31,194,30,29,30,
+23,24,20,194,24,23,195,20,28,194,17,195,15,21,194,15,195,13,11,13,194,9,
+10,194,9,196,0,194,12,196,5,3,4,3,194,1,0,194,1,223,0,223,0,1,0,195,1,2,
+194,4,194,5,194,12,195,8,0,12,8,0,9,194,14,195,9,19,11,19,21,194,19,194,
+25,18,25,18,196,22,196,23,24,30,29,194,30,31,33,30,34,33,34,38,194,34,194,
+36,39,40,39,40,36,39,36,198,39,38,198,39,47,196,39,194,40,194,44,59,50,
+194,54,56,54,194,56,54,51,59,48,44,47,40,195,44,194,47,44,195,47,194,44,
+40,47,195,40,48,51,194,54,55,61,52,65,195,60,52,194,55,194,53,195,50,48,
+50,44,46,194,44,48,46,42,194,46,196,42,40,34,36,34,38,34,36,35,37,41,195,
+37,194,29,37,24,23,194,24,23,194,22,195,17,20,196,17,195,15,198,13,9,13,
+10,9,194,8,195,0,8,194,5,198,3,4,2,195,1,224,0,223,0,1,194,0,194,1,3,2,
+194,3,195,5,194,12,194,8,12,196,8,14,195,9,19,11,19,21,195,11,19,197,25,
+195,27,195,23,194,29,24,30,32,30,33,31,194,33,34,33,195,34,195,36,42,40,
+42,194,40,195,39,38,195,39,194,38,198,39,40,47,39,40,194,39,44,59,194,50,
+53,56,53,194,54,194,51,59,47,44,40,47,40,47,195,40,44,195,40,47,195,40,
+47,44,59,51,53,56,65,60,61,52,60,52,55,60,196,52,53,50,48,44,48,45,48,45,
+48,42,40,44,40,194,39,195,40,194,36,34,39,34,36,195,35,196,37,196,29,24,
+194,23,24,195,22,18,20,18,195,17,195,15,194,21,11,15,196,13,9,11,0,10,194,
+0,194,8,0,12,196,5,196,3,4,194,1,0,1,224,0,224,0,196,1,4,194,3,197,5,8,
+12,0,8,12,8,195,14,8,194,14,194,19,11,196,19,15,194,21,19,195,25,18,195,
+27,195,23,195,29,30,31,32,33,31,33,34,194,33,39,194,34,195,36,40,42,36,
+40,195,39,195,38,205,39,47,40,44,59,194,51,194,54,53,54,51,48,59,44,194,
+47,40,47,40,194,44,47,40,44,40,47,39,47,195,40,47,59,51,54,196,55,60,55,
+53,195,52,194,53,194,49,194,45,48,196,44,42,44,46,196,42,196,36,196,34,
+31,33,34,37,194,31,197,29,196,23,195,22,18,22,18,17,194,18,15,16,194,15,
+197,13,194,11,9,10,0,9,196,0,12,194,5,12,194,5,194,3,4,3,1,2,195,1,225,
+0,224,0,196,1,194,4,194,3,5,3,197,5,194,8,6,5,8,14,8,14,194,8,14,9,194,
+11,21,195,19,25,195,21,194,25,22,25,194,27,23,27,194,23,29,30,29,30,32,
+30,194,33,34,195,33,194,34,195,36,40,39,36,198,39,194,38,39,38,204,39,44,
+59,48,194,51,50,53,51,48,47,44,194,40,39,199,40,39,40,39,40,47,39,194,44,
+194,51,53,199,52,53,52,45,196,49,44,194,45,46,194,42,44,194,42,195,40,194,
+39,36,194,34,39,36,194,33,194,34,194,31,194,37,196,29,22,23,27,23,22,195,
+27,195,25,194,18,17,16,196,15,196,11,13,10,13,9,194,10,9,0,8,0,8,199,5,
+3,4,2,1,2,194,1,226,0,223,0,1,194,0,1,2,195,3,5,3,196,5,6,5,6,195,5,194,
+8,6,8,195,14,196,19,11,194,21,19,25,194,19,198,25,27,195,23,194,29,197,
+30,194,33,31,195,34,33,196,34,196,36,38,34,194,38,196,39,38,194,39,38,199,
+39,40,47,44,59,195,50,59,48,47,44,194,40,47,194,40,195,39,47,194,39,40,
+39,40,194,39,44,47,51,50,194,53,52,49,52,50,52,199,49,52,49,45,44,194,40,
+44,40,36,194,40,36,42,197,36,39,194,33,34,33,57,194,33,194,30,196,29,194,
+23,27,23,194,22,197,25,194,21,15,16,194,15,194,13,11,9,13,10,13,10,11,9,
+10,9,196,0,5,12,196,5,197,3,196,1,227,0,224,0,1,2,194,1,2,4,198,3,5,6,3,
+4,196,6,197,8,14,8,14,9,195,19,21,19,21,25,19,25,19,27,194,25,196,27,22,
+23,22,23,194,30,33,30,32,195,33,32,195,33,194,36,34,195,36,42,194,39,194,
+38,58,197,38,39,38,198,39,194,38,40,44,47,48,59,50,47,194,48,194,47,40,
+194,39,47,194,39,40,47,194,39,47,39,47,40,47,44,194,48,50,202,49,52,194,
+49,43,45,46,45,196,42,40,194,36,40,39,195,36,38,196,34,195,33,195,32,194,
+30,194,29,27,195,23,27,195,22,195,25,21,19,25,194,21,195,15,21,11,13,9,
+195,11,194,10,194,9,197,0,5,194,12,5,197,3,4,3,2,195,1,227,0,223,0,198,
+1,2,1,4,3,195,4,1,4,194,6,195,5,194,8,6,5,195,8,195,14,19,194,11,14,11,
+19,195,21,25,21,195,25,22,194,25,194,27,195,23,24,23,32,30,32,30,32,195,
+33,35,33,31,195,34,36,194,34,38,36,194,38,194,58,196,38,194,39,194,38,198,
+39,40,194,44,48,44,45,44,47,194,40,195,39,40,194,47,194,40,194,47,194,39,
+194,40,44,48,44,194,50,196,49,52,197,49,43,195,45,46,45,194,43,42,36,40,
+195,36,34,195,36,194,34,198,33,26,196,32,194,24,29,23,195,27,196,22,18,
+194,25,21,25,21,19,15,21,15,11,194,13,11,194,13,194,10,195,9,0,9,8,0,194,
+8,12,196,5,195,3,4,2,195,1,229,0,224,0,198,1,2,1,194,2,1,195,4,3,4,194,
+6,4,6,201,8,194,14,11,19,11,195,19,11,21,198,25,194,22,194,27,194,23,24,
+23,30,24,32,195,30,31,194,33,195,34,35,34,195,36,38,194,34,198,38,34,201,
+38,39,40,194,44,194,48,47,194,44,40,194,47,39,47,194,40,44,195,40,44,47,
+40,59,44,196,48,194,49,52,45,194,49,46,45,43,194,45,43,195,45,43,46,195,
+43,194,42,196,36,195,34,35,34,35,34,32,33,32,33,32,26,32,26,32,30,26,24,
+23,194,22,195,27,195,18,25,19,25,19,21,19,21,11,13,195,11,14,9,194,11,10,
+9,196,0,8,194,0,196,5,3,5,3,1,2,195,1,2,195,1,227,0,227,0,199,1,194,4,2,
+1,195,4,3,194,5,195,6,196,8,195,14,11,19,11,19,11,194,21,194,19,195,21,
+19,195,25,194,27,25,194,27,23,194,24,30,24,197,32,33,32,194,30,33,35,31,
+196,34,195,38,33,195,38,58,198,38,39,36,39,38,194,39,44,46,40,46,44,40,
+47,40,39,47,194,40,195,47,194,44,194,40,48,46,48,195,45,43,194,45,46,45,
+43,194,45,46,196,45,199,43,42,194,43,36,34,194,35,34,194,35,33,31,33,30,
+33,30,32,26,194,32,194,26,24,26,24,23,194,22,27,194,25,18,25,194,18,21,
+25,19,21,19,197,11,9,10,197,9,10,9,196,0,8,196,5,3,5,3,4,3,4,194,2,195,
+1,229,0,227,0,194,1,196,0,194,1,4,3,1,3,194,4,194,6,3,194,5,194,6,196,8,
+14,8,9,14,9,19,14,19,194,21,194,19,11,199,25,195,22,194,23,22,24,30,194,
+24,195,30,32,194,33,31,32,34,35,33,35,38,36,194,34,38,33,197,58,38,34,194,
+38,58,196,38,194,39,40,46,44,40,44,42,40,195,39,47,194,40,46,44,40,194,
+44,46,195,44,46,43,49,43,196,45,43,194,45,195,43,46,195,43,46,43,194,42,
+41,35,41,35,194,41,34,35,34,33,35,195,33,30,32,30,32,30,194,26,24,26,24,
+195,20,22,18,196,25,195,18,194,15,11,21,194,19,194,11,10,13,194,11,194,
+9,196,0,9,8,194,0,195,12,194,3,5,195,3,4,2,194,1,2,0,1,230,0,229,0,197,
+1,2,194,4,3,4,3,4,2,4,195,6,3,5,195,8,196,14,9,11,9,194,11,194,19,194,11,
+19,11,194,21,19,21,195,25,195,27,22,23,24,22,30,24,26,32,26,194,30,32,26,
+33,30,33,31,33,35,31,195,33,58,196,33,38,33,196,38,194,58,194,38,194,39,
+36,40,194,42,36,39,196,40,36,194,42,40,42,46,194,42,40,43,45,46,194,45,
+46,45,43,194,46,43,46,194,43,194,42,46,195,42,36,34,198,41,196,35,197,31,
+194,30,32,30,32,30,26,24,30,26,194,24,20,28,23,22,195,25,195,21,15,18,15,
+21,15,194,11,194,9,13,194,11,194,10,9,195,0,8,195,0,194,8,197,5,194,3,4,
+3,2,197,1,231,0,230,0,194,1,0,194,1,3,4,3,1,3,4,194,3,4,5,194,6,194,4,6,
+194,5,8,194,14,8,194,9,194,14,9,198,19,21,19,11,25,196,21,194,25,27,22,
+20,24,194,20,24,30,26,195,30,32,194,30,194,31,33,31,34,33,31,33,195,58,
+33,57,58,194,33,34,194,33,34,33,38,194,39,36,195,40,196,42,36,40,39,40,
+42,40,198,42,197,43,46,194,43,42,196,43,42,34,39,36,38,34,36,194,34,194,
+35,34,194,35,195,37,31,194,37,194,31,30,32,30,32,30,26,194,30,194,24,26,
+20,28,23,17,22,18,22,25,21,25,21,19,21,195,15,13,194,11,14,9,194,13,11,
+9,10,194,9,195,0,5,195,0,12,196,5,196,3,199,1,231,0,229,0,1,0,194,1,0,194,
+1,4,1,3,1,195,4,3,194,4,3,6,5,4,5,6,195,5,8,194,6,195,9,194,14,9,14,19,
+11,19,21,19,21,196,19,194,21,195,18,194,22,24,20,28,24,20,195,24,26,194,
+24,195,30,194,32,194,33,194,32,33,58,33,32,58,194,57,195,58,38,194,58,34,
+39,34,194,36,39,34,194,39,40,36,42,36,39,42,194,40,195,42,195,43,42,43,
+42,199,43,194,41,194,36,194,34,38,33,197,34,33,194,35,197,37,29,195,30,
+32,24,26,30,28,20,194,24,22,20,23,17,194,18,22,21,25,19,21,19,21,15,21,
+13,11,15,194,11,13,11,194,9,10,13,194,9,0,8,194,5,0,8,12,194,5,194,3,5,
+196,3,4,3,195,2,194,1,0,1,230,0,231,0,194,1,194,0,2,195,1,2,196,1,3,4,3,
+6,5,198,6,8,14,194,8,6,194,14,19,14,9,14,11,194,19,14,19,195,21,194,25,
+21,194,25,195,18,17,22,17,195,20,24,23,30,24,26,194,30,24,194,30,33,30,
+32,26,196,32,196,33,32,195,33,194,58,36,34,36,41,36,35,194,34,195,38,34,
+38,34,194,36,194,42,36,43,42,198,43,41,194,35,41,194,35,41,35,194,34,33,
+35,194,33,32,57,32,194,33,32,33,194,31,197,29,198,24,26,28,20,24,22,17,
+20,22,25,18,194,21,25,19,25,194,19,194,11,15,11,15,13,11,9,194,11,195,9,
+10,9,194,0,8,199,5,194,3,5,194,3,2,196,1,194,0,1,232,0,230,0,1,0,195,1,
+0,196,1,0,197,1,4,1,194,4,3,194,4,194,5,4,5,194,6,8,195,5,8,196,14,9,14,
+9,14,198,19,18,21,25,18,25,195,18,195,20,17,20,24,195,23,29,23,26,24,195,
+32,194,26,198,32,33,57,194,32,194,33,32,196,33,34,33,58,33,196,58,34,33,
+34,35,34,35,34,37,204,35,31,33,35,194,31,198,32,194,26,194,32,30,29,30,
+194,29,195,23,29,32,24,26,194,20,24,28,17,194,20,18,17,18,21,18,195,21,
+19,21,11,21,13,11,194,13,11,194,13,195,9,0,9,194,0,9,194,0,8,5,6,194,3,
+196,5,3,195,4,195,1,0,194,1,233,0,233,0,197,1,0,1,0,196,1,0,1,4,1,194,4,
+3,194,4,5,4,3,5,196,6,8,6,5,194,8,199,14,194,11,19,14,19,13,21,194,13,194,
+18,194,15,18,17,195,18,17,194,22,24,23,24,20,24,20,30,32,197,26,32,26,24,
+26,32,26,32,194,31,33,34,35,195,33,58,194,33,32,33,32,30,35,34,31,33,31,
+34,194,35,37,195,35,195,37,31,196,37,30,196,31,30,197,32,196,26,24,30,24,
+194,23,27,23,22,194,24,26,28,196,20,197,18,195,15,195,21,19,14,19,11,194,
+9,13,194,9,194,10,14,194,0,8,197,0,12,3,6,4,3,4,3,4,194,3,195,2,196,1,235,
+0,238,0,195,1,195,0,195,1,0,195,1,194,4,1,194,4,6,4,3,196,5,8,5,6,8,6,8,
+6,194,8,14,194,8,14,8,196,14,19,195,11,13,21,15,21,15,18,16,196,18,22,17,
+24,20,194,28,194,20,24,20,196,24,26,24,20,26,194,24,26,194,30,32,194,30,
+26,194,24,26,32,194,26,194,32,30,33,196,31,37,35,195,37,35,195,37,31,194,
+30,194,24,30,29,194,30,198,24,32,30,26,195,28,194,20,23,24,20,195,22,17,
+20,194,17,20,195,17,194,15,21,25,194,21,15,13,195,11,14,8,194,11,14,195,
+9,197,0,8,0,194,8,195,5,194,3,1,3,194,2,1,3,4,194,1,2,194,1,236,0,242,0,
+1,0,205,1,196,4,6,4,6,4,3,5,4,8,6,8,5,8,194,6,196,8,14,8,9,14,9,195,11,
+10,11,195,13,15,21,25,15,25,15,195,18,17,195,20,194,17,20,28,20,28,194,
+20,194,28,194,24,194,20,26,195,24,28,194,20,24,194,30,194,24,30,29,194,
+30,24,30,194,23,194,29,27,29,196,23,24,23,29,23,24,199,23,24,22,28,197,
+20,28,17,22,18,22,18,17,22,17,194,20,196,17,18,21,15,11,19,13,21,15,196,
+13,11,194,8,14,194,9,0,14,0,8,0,5,12,194,0,194,12,195,5,194,3,203,1,0,194,
+1,234,0,249,0,1,0,200,1,197,4,3,194,4,3,4,194,5,4,194,5,8,5,6,5,6,5,8,5,
+12,197,0,194,9,14,11,14,13,195,11,196,15,13,15,16,196,17,194,18,22,194,
+20,194,18,20,17,201,20,195,17,20,194,22,20,200,22,23,194,22,194,23,194,
+22,24,194,17,20,17,20,195,22,18,25,195,22,17,22,17,194,20,18,196,17,196,
+18,15,17,18,16,194,15,16,15,11,19,11,194,19,11,9,195,11,195,14,196,8,195,
+0,8,0,8,199,5,194,4,3,196,1,0,195,1,194,0,1,236,0,247,0,1,0,1,0,1,197,0,
+195,1,0,1,0,195,1,194,4,1,4,3,1,194,4,6,4,6,5,4,6,5,6,194,5,3,5,8,5,8,0,
+5,0,8,0,9,0,19,14,11,10,11,13,11,13,21,194,15,197,16,17,16,13,17,16,194,
+15,195,16,15,194,16,196,17,20,201,18,22,194,15,18,15,195,18,15,194,18,15,
+18,15,194,18,15,195,25,194,21,18,21,194,18,194,16,17,16,198,15,16,15,16,
+15,16,15,11,194,13,11,19,194,14,8,9,194,13,11,13,9,6,196,8,195,5,12,8,0,
+194,5,194,3,194,5,195,3,4,3,194,1,0,197,1,194,0,1,236,0,253,0,196,1,194,
+0,194,1,0,199,1,0,197,1,2,195,4,1,194,4,194,1,6,194,3,197,5,12,194,5,8,
+12,14,0,14,9,0,10,9,10,11,9,194,11,194,9,202,13,11,15,11,15,194,11,21,194,
+11,15,194,21,11,21,11,195,21,194,11,15,11,21,11,13,11,195,13,15,13,15,13,
+11,15,194,13,19,194,21,19,13,11,21,195,13,21,198,15,196,13,11,195,13,11,
+10,9,14,8,14,0,8,9,10,0,9,0,5,194,6,196,5,8,5,3,195,5,6,198,3,4,2,195,1,
+195,0,1,239,0,255,0,204,0,194,1,0,194,1,194,0,1,194,0,194,1,0,197,1,194,
+4,1,4,3,194,1,3,4,3,4,3,5,12,5,12,8,198,0,194,9,194,0,14,9,0,9,0,194,9,
+14,195,9,8,10,9,10,9,19,195,14,11,9,11,194,9,0,11,10,194,9,194,10,9,10,
+197,9,0,10,197,9,14,9,194,14,197,9,10,11,194,10,9,11,197,9,194,10,13,11,
+10,14,195,0,8,6,8,5,8,194,0,8,195,5,6,4,6,5,194,3,194,5,3,4,3,2,3,4,3,4,
+1,4,1,2,197,1,241,0,255,0,208,0,198,1,0,194,1,0,196,1,0,194,1,0,196,1,2,
+1,3,4,2,4,3,5,3,197,5,12,196,5,12,196,5,8,5,12,0,12,8,0,8,194,5,8,5,0,8,
+0,195,5,8,5,8,0,8,5,12,5,8,12,194,8,5,0,12,5,0,5,12,196,8,12,8,14,196,8,
+0,194,8,202,0,9,194,8,0,14,0,8,14,5,8,0,196,5,8,194,5,196,4,2,1,4,1,4,3,
+4,194,3,4,1,2,1,2,1,2,1,0,1,0,1,243,0,255,0,255,0,255,0,255,0,220,0,12,
+0,0,0,2,0,1,2,2,2,0,4,3,0,0,2,13,5,3,13,0,2,18,13,14,18,4,2,23,12,14,23,
+18,16,28,12,14,13,13,13,28,17,16,23,4,1,34,17,15,34,27,28,39,26,28,39,16,
+14,28,3,0,44,25,27,34,11,13,44,15,13,49,14,12,49,24,27,39,10,12,49,31,29,
+44,9,11,44,31,29,55,13,11,55,24,26,60,22,25,55,30,28,60,29,27,65,28,26,
+65,21,24,70,27,25,60,12,10,65,38,40,70,37,40,76,36,39,70,20,23,76,26,23,
+76,19,22,81,35,38,86,24,21,81,25,22,81,42,40,86,34,37,92,23,20,92,33,36,
+92,40,37,102,20,18,97,32,34,97,39,36,102,31,33,102,38,35,55,40,42,60,39,
+41,86,41,39,107,30,32,113,28,31,113,35,33,118,27,30,118,34,32,107,36,34,
+107,47,49,113,46,48,123,33,30,118,45,47,128,32,29,123,44,46,134,41,44,128,
+42,45,144,39,41,139,40,43,128,49,47,123,50,48,134,48,46,139,47,44,144,46,
+43,149,38,40,149,55,58,149,45,42,155,54,57,155,43,41,160,53,55,160,42,40,
+155,36,39,165,52,54,165,41,38,170,51,53,170,40,37,176,49,52,176,56,54,181,
+55,53,181,48,51,186,47,49,186,54,51,191,53,50,191,46,48,181,60,53,165,59,
+56,191,58,50,197,51,49,170,58,55,202,61,64,207,60,62,207,49,46,212,59,61,
+207,67,64,223,56,59,212,66,63,228,62,59,223,63,61,239,59,57,244,69,72,255,
+66,69,228,67,59,233,71,74,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_emudumb.c sys/dev/kgc/kgc_emudumb.c
--- sys/dev/kgc/kgc_emudumb.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_emudumb.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,190 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGC dumb emulation.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/cons.h>
+#include <sys/consio.h>
+#include <sys/fbio.h>
+#include <sys/kernel.h>
+#include <sys/tty.h>
+
+#include <dev/fb/fbreg.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+
+#include <dev/kgc/kgc_emudumb.h>
+
+#include "scroller_if.h"
+#include "render_if.h"
+
+/* 
+ * A very dumb console parser to have output even with no parser loaded.
+ */
+
+void 
+dumb_do_reset(kgi_console_t *cons, kgi_u_t do_reset)
+{
+	scroller_t scroll = (scroller_t)cons->scroller;
+		
+#if 0
+	kgi_ucoord_t render_size, scroller_size;
+	struct tty *tp = (struct tty *) cons->kii.tty;
+	
+	int s = spltty();
+	
+	SCROLLER_GET(cons->scroller, &scroller_size, 0, 0, 0);
+	tp->t_winsize.ws_col = scroller_size.x;
+	tp->t_winsize.ws_row = scroller_size.y;
+
+	RENDER_GET(cons->render, &render_size, 0, 0);
+	tp->t_winsize.ws_xpixel = render_size.x;
+	tp->t_winsize.ws_ypixel = render_size.y;
+	
+	splx();
+#endif
+
+	cons->kii.event_mask |= KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT;
+
+	if (do_reset) {
+		SCROLLER_RESET(scroll);
+		
+		SCROLLER_UPDATE_ATTR(scroll);
+		SCROLLER_GOTOXY(scroll, 0, 0);
+		SCROLLER_ERASE_DISPLAY(scroll, 2);
+	}
+		
+	SCROLLER_SYNC(scroll);
+}
+
+
+void 
+dumb_handle_kii_event(kii_device_t *dev, kii_event_t *e)
+{
+	kgi_console_t *cons = (kgi_console_t *) dev->priv.priv_ptr;
+	struct tty *tp = (struct tty *)cons->kii.tty;
+	scroller_t scroll = (scroller_t)cons->scroller;
+	
+	if (((1 << e->any.type) & ~(KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT)) ||
+		(e->key.sym == K_VOID) || !tp) 
+		return;
+	
+	switch (e->key.sym & K_TYPE_MASK) {
+	case K_TYPE_LATIN:
+		/* Ignore non-special events if cursor hidden */
+		if (CONSOLE_MODE(cons, KGI_CM_SHOW_CURSOR)) {
+			tty_lock(tp);
+			ttydisc_rint(tp, (char)e->key.sym, 0);
+			ttydisc_rint_done(tp);
+			tty_unlock(tp);
+		}
+		break;
+	case K_TYPE_SPECIAL:
+		switch (e->key.sym) {
+#ifdef notyet
+		case K_HOLD:
+			tp->stopped ? start_tty(tp) : stop_tty(tp);
+			return;
+#endif
+		case K_ENTER:
+			if (CONSOLE_MODE(cons, KGI_CM_SHOW_CURSOR)) {
+				tty_lock(tp);
+				ttydisc_rint(tp, (char)ASCII_CR, 0);
+				ttydisc_rint_done(tp);
+				tty_unlock(tp);
+			}
+			break;
+		case K_SCROLLFORW:
+			SCROLLER_FORWARD(scroll, 0);
+			SCROLLER_SYNC(scroll);
+			break;
+		case K_SCROLLBACK:
+			SCROLLER_BACKWARD(scroll, 0);
+			SCROLLER_SYNC(scroll);
+			break;
+		default:
+			return;
+		}
+	}
+}
+
+int 
+dumb_do_write(kgi_console_t *cons, char *buf, int count)
+{
+	kgi_u_t cnt = 0;
+	kgi_ascii_t c;
+	scroller_t scroll;
+
+	scroll = (scroller_t)cons->scroller;
+
+	SCROLLER_MARK(scroll);
+
+	while (count) {
+		c = *buf;
+		buf++; cnt++; count--;
+
+		if ((c == ASCII_LF) || (c == ASCII_CR) || 
+		    (cons->flags & KGI_CF_NEED_WRAP)) {
+			if (c != ASCII_CR) {
+				SCROLLER_MODIFIED_MARK(scroll);
+				SCROLLER_LF(scroll);
+				SCROLLER_SYNC(scroll);
+			}
+
+			SCROLLER_CR(scroll);
+			SCROLLER_MARK(scroll);
+
+			if ((c == ASCII_LF) || (c == ASCII_CR))
+				continue;
+		}
+
+		if (c == ASCII_BS) {
+			SCROLLER_MODIFIED_MARK(scroll);
+			SCROLLER_BS(scroll);
+			SCROLLER_MARK(scroll);
+			continue;
+		}
+
+		SCROLLER_WRITE(scroll, c);
+	}
+
+	SCROLLER_MODIFIED_MARK(scroll);
+	SCROLLER_SYNC(scroll);
+
+	return (cnt);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_emudumb.h sys/dev/kgc/kgc_emudumb.h
--- sys/dev/kgc/kgc_emudumb.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_emudumb.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,28 @@
+/*-
+ * Copyright (C) 1996-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * DUMB console parser state
+ */
+
+#ifndef	_KGI_DUMB_H
+#define	_KGI_DUMB_H
+
+typedef struct{
+	kgi_console_t cons;
+} kgi_console_dumb_t;
+
+extern void dumb_do_reset(kgi_console_t *cons, kgi_u_t do_reset);
+extern void dumb_handle_kii_event(kii_device_t *dev, kii_event_t *ev);
+extern int dumb_do_write(kgi_console_t *cons, char *buf, int count);
+
+#endif	/* #ifdef _KGI_DUMB_H */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_emuxterm.c sys/dev/kgc/kgc_emuxterm.c
--- sys/dev/kgc/kgc_emuxterm.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_emuxterm.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,1667 @@
+/*-
+ * Copyright (C) 1996-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * xterm console parser
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/cons.h>
+#include <sys/consio.h>
+#include <sys/fbio.h>
+#include <sys/kernel.h>
+#include <sys/tty.h>
+#include <dev/fb/fbreg.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kii.h>
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+#include <dev/kgc/kgc_emuxterm.h>
+#include "scroller_if.h"
+#include "render_if.h"
+
+#undef	STRICT_XTERM	/* #define to restrict to original XTERM	*/
+#undef	SETEC_ASTRONOMY	/* #define to force display of concealed text	*/
+
+#define TRACE(x)	KRN_TRACE(2,(x))
+
+static kgi_u8_t DEFAULT_COLORS[8] = {
+	KGI_CC_LIGHTGRAY,	KGI_CC_BLACK, /* Normal.	*/
+	KGI_CC_LIGHTRED,	KGI_CC_BLACK, /* Blink.		*/
+	KGI_CC_LIGHTBLUE,	KGI_CC_BLACK, /* Underline.	*/
+};
+
+enum color_index {
+	CI_FG,		 CI_BG,
+	CI_BLINK_FG, CI_BLINK_BG,
+	CI_UL_FG,	 CI_UL_BG
+};
+
+static kgi_u8_t colormap[16] = {
+	KGI_CC_BLACK,		KGI_CC_RED,
+	KGI_CC_GREEN,		KGI_CC_BROWN,
+	KGI_CC_BLUE,		KGI_CC_MAGENTA,
+	KGI_CC_CYAN,		KGI_CC_LIGHTGRAY,
+	KGI_CC_DARKGRAY,	KGI_CC_LIGHTRED,
+	KGI_CC_LIGHTGREEN,	KGI_CC_YELLOW,
+	KGI_CC_LIGHTBLUE,	KGI_CC_LIGHTMAGENTA,
+	KGI_CC_LIGHTCYAN,	KGI_CC_WHITE
+};
+
+#define	DEFAULT_FG	(DEFAULT_COLORS[CI_FG])
+#define	DEFAULT_BG	(DEFAULT_COLORS[CI_BG])
+
+#define CTRL_ACTION 0x0d00ff81	/* chars<32 that invoke special action	*/
+#define	CTRL_ALWAYS 0x0800f581	/* can not be overridden by DISP_CTRL	*/
+
+/*
+ * Forward declaration of the font translation tables. See the end of this
+ * file for the initializer.
+ */
+static kgi_unicode_t translation[4][256];
+
+static void 
+xterm_set_charset(kgi_console_t *cons, kgi_u_t nr, char c)
+{
+	kgi_console_xterm_t *xterm;
+
+ 	xterm = (kgi_console_xterm_t *)cons;
+
+	switch(c) {
+	case 'K':		/* ??? original console code did this?	*/
+	case 'A':		/* United Kingdom/national		*/
+		xterm->g[nr] = USER_MAP;
+		break;
+	case '1':		/* 'alternate ROM standard character'	*/
+	case 'B':		/* US-ASCII (ISO-8859-1 = Latin1)	*/
+		xterm->g[nr] = LAT1_MAP;
+		break;
+	case '2':		/* 'alternate ROM graphics'		*/
+	case '0':		/* VT100 graphics			*/
+		xterm->g[nr] = GRAF_MAP;
+		break;
+	case 'U':		/* ??? original console code did this?	*/
+		xterm->g[nr] = IBMPC_MAP;
+		break;
+	}
+
+	if (xterm->charset == nr) 
+		xterm->translate = translation[xterm->g[nr]];
+}
+
+enum {	
+	cursor, id, status, 
+	mouseup, 
+	mousedown1, mousedown2, mousedown3
+};
+
+static void 
+xterm_do_set_mode(kgi_console_t *cons, kgi_s_t mode, kgi_s_t on)
+{
+	kgi_u_t attrfl, erase;
+
+	if (mode == KGI_CM_AUTO_REPEAT) {
+		if (on)
+			cons->kii.event_mask |= KII_EM_KEY_REPEAT;
+		else 
+			cons->kii.event_mask &= ~KII_EM_KEY_REPEAT;
+	}
+
+	if (mode == KGI_CM_REVERSE_VIDEO) {
+		if (!CONSOLE_MODE(cons, KGI_CM_REVERSE_VIDEO) != !on) {
+/* XXX #warning correct inversion, invert alternate screen too! */
+#if 0
+			fb_invert(FB, 0, cons->fb_size - 1);
+			SCROLLER_MODIFIED(cons->scroller, cons->org,
+				cons->org + cons->fsize);
+#endif
+			SCROLLER_GET(cons->scroller, 0, 0, 0, 0, 0, &attrfl, &erase); 
+			attrfl ^= KGI_CA_REVERSE;
+			SCROLLER_SET(cons->scroller, attrfl, erase); 
+		}
+	}
+
+
+#if 0	/* !!! implement alternate screen	*/
+	if ((mode == alt_screen) && (!MODE(alt_screen) != !on)) {
+
+		int cnt = FB_SIZE_X*SIZE_Y;
+
+		if (CONSOLE_MODE(cons, KGI_CM_ALT_SCREEN)) {
+
+			if (ORG + cnt < FB_SIZE) {
+
+				fb_memcpy_tofb(FB, ALT_SCREEN, ORG, cnt);
+
+           		} else {
+
+				fb_memcpy_tofb(FB, ALT_SCREEN, ORG,
+					FB_SIZE-ORG);
+				fb_memcpy_tofb(FB, ALT_SCREEN+FB_SIZE-ORG,
+					0, ORG+cnt-FB_SIZE);
+			}
+
+		} else {
+
+			if (ORG + cnt < FB_SIZE) {
+
+				fb_memcpy_fromfb(FB, ALT_SCREEN, ORG, cnt);
+
+           		} else {
+
+				fb_memcpy_fromfb(FB, ALT_SCREEN, ORG,
+					FB_SIZE - ORG);
+				fb_memcpy_fromfb(FB, ALT_SCREEN + FB_SIZE-ORG,
+					0, ORG+cnt-FB_SIZE);
+			}
+		}
+	}
+#endif
+
+	/*
+	 * XXX if (mode == column132 && MODE(allow_132mode))
+	 * XXX con_resize(cons, SIZE_Y, on ? 132 : 80);
+	 */
+
+	if ((mode == KGI_CM_XT_X10_MOUSE) || (mode == KGI_CM_XT_REPORT_MOUSE) ||
+			(mode == KGI_CM_XT_TRACK_MOUSE)) {
+		if (on)
+			CONSOLE_SET_MODE(cons, KGI_CM_SHOW_POINTER);
+		else
+			CONSOLE_CLEAR_MODE(cons, KGI_CM_SHOW_POINTER);
+	}
+
+	if (on)
+		CONSOLE_SET_MODE(cons, mode);
+	else 
+		CONSOLE_CLEAR_MODE(cons, mode);
+
+	SCROLLER_UPDATE_ATTR(cons->scroller);
+
+	if (mode == KGI_CM_ORIGIN) 
+		SCROLLER_GOTOXY(cons->scroller, 0, 0);
+}
+
+static int 
+xterm_par_to_mode(register int ques, register int par)
+{
+
+	if (ques) {
+		switch (par) {
+		case 1:
+			return (KGI_CM_XT_CURSOR_KEY);
+		case 3:
+			return (KGI_CM_XT_COLUMN132);
+		case 4:
+			return (KGI_CM_SMOOTH_SCROLL);
+		case 5:
+			return (KGI_CM_REVERSE_VIDEO);
+		case 6:
+			return (KGI_CM_ORIGIN);
+		case 7:
+			return (KGI_CM_AUTO_WRAP);
+		case 8:
+			return (KGI_CM_AUTO_REPEAT);
+		case 9:
+			return (KGI_CM_XT_X10_MOUSE);
+		case 38:
+			return (KGI_CM_XT_TEXTRONIX_MODE);
+		case 40:
+			return (KGI_CM_XT_ALLOW_132MODE);
+		case 41:
+			return (KGI_CM_XT_CURSES_FIX);
+		case 44:
+			return (KGI_CM_XT_MARGIN_BELL);
+		case 45:
+			return (KGI_CM_REVERSE_WRAP);
+		case 46:
+			return (KGI_CM_XT_LOGGING);
+		case 47:
+			return (KGI_CM_ALT_SCREEN);
+		case 1000:
+			return (KGI_CM_XT_REPORT_MOUSE);
+		case 1001:
+			return (KGI_CM_XT_TRACK_MOUSE);
+		}
+	} else {
+		switch (par) {
+		case 3:
+			return (KGI_CM_XT_DISPLAY_CTRL);
+		case 4:
+			return (KGI_CM_XT_INSERT);
+		case 20:
+			return (KGI_CM_XT_NEWLINE);
+		}
+	}
+
+	return (-1);
+}
+
+static void 
+xterm_set_mode(kgi_console_t *cons, int on)
+{
+	kgi_console_xterm_t *xterm;
+	kgi_u_t i;
+	kgi_s_t mode;
+
+	xterm = (kgi_console_xterm_t *)cons;
+
+	for (i = 0; i <= xterm->npar; i++) {
+		if ((mode = xterm_par_to_mode(cons->flags & KGI_CF_XT_QUESTION,
+			xterm->par[i])) >= 0) {
+			xterm_do_set_mode(cons, mode, on);
+		}
+	}
+
+	RENDER_HIDE_GADGETS(cons->render);
+	cons->flags &= ~(KGI_CF_CURSOR_TO_SHOW | KGI_CF_POINTER_TO_SHOW);
+
+	if (CONSOLE_MODE(cons, KGI_CM_SHOW_CURSOR)) 
+		cons->flags |= KGI_CF_CURSOR_TO_SHOW;
+
+	if (CONSOLE_MODE(cons, KGI_CM_XT_REPORT_MOUSE) |
+		CONSOLE_MODE(cons, KGI_CM_XT_X10_MOUSE) |
+		CONSOLE_MODE(cons, KGI_CM_XT_TRACK_MOUSE)) {
+		cons->flags |= KGI_CF_POINTER_TO_SHOW;
+	}
+}
+
+static void 
+xterm_backup_mode(kgi_console_t *cons, int save)
+{
+	kgi_console_xterm_t *xterm;
+	kgi_u_t i;
+	kgi_s_t mode;
+
+	xterm = (kgi_console_xterm_t *)cons;
+
+	for (i = 0; i <= xterm->npar; i++) {
+		if ((mode = xterm_par_to_mode(cons->flags & KGI_CF_XT_QUESTION, 
+			xterm->par[i])) >= 0) {
+			kgi_u_t mask = 1 << mode;
+
+			if (save) {
+				xterm->s_mode &= ~mask;
+				xterm->s_mode |= cons->mode & mask;
+			} else {
+				if ((cons->mode & mask) != (xterm->s_mode & mask))
+					xterm_do_set_mode(cons, mode, xterm->s_mode & mask);
+			}
+		}
+	}
+
+	RENDER_HIDE_GADGETS(cons->render);
+	cons->flags &= ~(KGI_CF_CURSOR_TO_SHOW | KGI_CF_POINTER_TO_SHOW);
+
+	if (CONSOLE_MODE(cons, KGI_CM_SHOW_CURSOR)) 
+		cons->flags |= KGI_CF_CURSOR_TO_SHOW;
+
+	if (CONSOLE_MODE(cons, KGI_CM_XT_REPORT_MOUSE) |
+		CONSOLE_MODE(cons, KGI_CM_XT_X10_MOUSE) |
+		CONSOLE_MODE(cons, KGI_CM_XT_TRACK_MOUSE)) {
+		cons->flags |= KGI_CF_POINTER_TO_SHOW;
+	}
+}
+
+static void 
+xterm_save_cur(kgi_console_t *cons)
+{
+	kgi_console_xterm_t *xterm; 
+	kgi_u_t i;
+
+	xterm = (kgi_console_xterm_t *)cons;
+
+	/*
+	 * XXX
+	 * Warning save reverse_mode too!
+     */
+	SCROLLER_SAVE(cons->scroller);
+
+	xterm->s_charset = xterm->charset;
+
+	for (i = 0; i < sizeof(xterm->s_g); i++) 
+		xterm->s_g[i] = xterm->g[i];
+
+	for (i = 0; i < sizeof(xterm->s_colors); i++) 
+		xterm->s_colors[i] = xterm->colors[i];
+}
+
+
+static void 
+xterm_restore_cur(kgi_console_t *cons)
+{
+	kgi_console_xterm_t *xterm;
+	kgi_u_t i;
+
+	xterm = (kgi_console_xterm_t *)cons;
+	xterm->charset = xterm->s_charset;
+
+	for (i = 0; i < sizeof(xterm->g); i++)
+		xterm->g[i] = xterm->s_g[i];
+
+	for (i = 0; i < sizeof(xterm->colors); i++)
+		xterm->colors[i] = xterm->s_colors[i];
+
+	xterm->translate = translation[xterm->g[xterm->charset]];
+
+	SCROLLER_RESTORE(cons->scroller);
+	SCROLLER_UPDATE_ATTR(cons->scroller);
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+
+static void 
+xterm_set_term(kgi_console_t *cons)
+{
+	kgi_console_xterm_t *xterm;
+
+	xterm = (kgi_console_xterm_t *)cons;
+
+	switch(xterm->par[0]) {
+	case 10:
+		if (xterm->npar >= 1) {
+			xterm->bell.pitch = ((xterm->par[1] < 20) ||
+				(xterm->par[1] > 32767)) ? 0 : xterm->par[1];
+		} else {	
+			xterm->bell.pitch = 750;
+		}
+		break;
+	case 11:
+		if (xterm->npar >= 1)
+			xterm->bell.duration = (xterm->par[1] < 2000) ? xterm->par[1] : 0;
+		else
+			xterm->bell.duration = 125;
+		break;
+	}
+}
+
+static void 
+csi_m(kgi_console_t *cons)
+{
+	kgi_console_xterm_t *xterm;
+	kgi_u_t i, attrfl, erase;
+
+	xterm = (kgi_console_xterm_t *)cons;
+
+	SCROLLER_GET(cons->scroller, 0, 0, 0, 0, 0, &attrfl, &erase); 
+
+	for (i = 0; i <= xterm->npar; i++) {
+		switch (xterm->par[i]) {
+		case 0:
+			attrfl = KGI_CA_NORMAL | KGI_CA_COLOR(DEFAULT_FG, DEFAULT_BG);
+			break;
+		case 1:
+			attrfl &= ~KGI_CA_INTENSITY;
+			attrfl |= KGI_CA_BOLD;
+			break;
+#ifndef STRICT_XTERM
+		case 2:
+			attrfl &= ~KGI_CA_INTENSITY;
+			attrfl |= KGI_CA_HALF;
+			break;
+#endif
+		case 4:
+			attrfl |= KGI_CA_UNDERLINE;
+			break;
+		case 5:
+			attrfl |= KGI_CA_BLINK;
+			break;
+		case 7:
+			if (CONSOLE_MODE(cons, KGI_CM_REVERSE_VIDEO))
+				attrfl &= ~KGI_CA_REVERSE;
+			else
+				attrfl |= KGI_CA_REVERSE;
+			break;
+#ifndef STRICT_XTERM
+#	ifndef SETEC_ASTRONOMY
+		case 8:
+			attrfl &= ~KGI_CA_FG_COLOR;
+			attrfl |= (attrfl << 8) & KGI_CA_FG_COLOR;
+			break;
+#	endif
+		case 10:
+			/*
+			 * ANSI X3.64-1979 (SCO-ish?)
+			 * Select primary font, don't display
+			 * control chars if defined, don't set
+			 * bit 8 on output.
+			 */
+			xterm->translate = translation[xterm->g[xterm->charset]];
+			CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_DISPLAY_CTRL);
+			CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_TOGGLE_META);
+			break;
+		case 11:
+			/*
+			 * ANSI X3.64-1979 (SCO-ish?)
+			 * Select first alternate font, let's
+			 * chars < 32 be displayed as ROM chars.
+			 */
+			xterm->translate = translation[IBMPC_MAP];
+			CONSOLE_SET_MODE(cons, KGI_CM_XT_DISPLAY_CTRL);
+			CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_TOGGLE_META);
+			break;
+		case 12:
+			/*
+			 * ANSI X3.64-1979 (SCO-ish?)
+			 * Select second alternate font, toggle
+			 * high bit before displaying as ROM char.
+			 */
+			xterm->translate = translation[IBMPC_MAP];
+			CONSOLE_SET_MODE(cons, KGI_CM_XT_DISPLAY_CTRL);
+			CONSOLE_SET_MODE(cons, KGI_CM_XT_TOGGLE_META);
+			break;
+#endif
+		case 21: /* Fall thru. */
+		case 22:
+			attrfl &= ~KGI_CA_INTENSITY;
+			attrfl |= KGI_CA_NORMAL;
+			break;
+		case 24:
+			attrfl &= ~KGI_CA_UNDERLINE;
+			break;
+		case 25:
+			attrfl &= ~KGI_CA_BLINK;
+			break;
+		case 27:
+			if (CONSOLE_MODE(cons, KGI_CM_REVERSE_VIDEO))
+				attrfl |= KGI_CA_REVERSE;
+			else 
+				attrfl &= ~KGI_CA_REVERSE;
+			break;
+#ifndef STRICT_XTERM
+		case 38:
+			/*
+			 * ANSI X3.64-1979 (SCO-ish?)
+			 * Enables underscore, white foreground
+			 * with white underscore (Linux - use
+			 * default foreground).
+			 */
+			attrfl |= KGI_CA_UNDERLINE;
+			attrfl &= ~0xFF00;
+			attrfl |= KGI_CC_WHITE << 8;
+			break;
+		case 39:
+			/*
+			 * ANSI X3.64-1979 (SCO-ish?)
+			 * ???	Disable underline option. Reset color
+			 * ???	to default?
+			 * It did this before:
+			 */
+			attrfl &= ~KGI_CA_UNDERLINE;
+			attrfl &= ~KGI_CA_FG_COLOR;
+			attrfl |= DEFAULT_FG << 8;
+			break;	
+		case 49:
+			attrfl &= ~KGI_CA_BG_COLOR;
+			attrfl |= DEFAULT_BG;
+			break;
+#endif
+		default:
+			if ((xterm->par[i] >= 30) && (xterm->par[i] <= 37)) {
+				attrfl &= ~KGI_CA_FG_COLOR;
+				attrfl |= ((unsigned long) colormap[xterm->par[i]-30]) << 8; 
+			} else {
+				if ((xterm->par[i] >= 40) && (xterm->par[i] <= 47)) {	
+					attrfl &= ~KGI_CA_BG_COLOR;
+					attrfl |= ((unsigned long) colormap[xterm->par[i]-40]);
+				}
+			}
+			break;
+		}
+	}
+
+	SCROLLER_SET(cons->scroller, attrfl, erase); 
+	SCROLLER_UPDATE_ATTR(cons->scroller);
+}
+
+
+void 
+xterm_do_reset(kgi_console_t *cons, int do_reset)
+{
+	kgi_u_t attrfl, erase;
+
+#if 0
+	struct tty *tp = (struct tty *) cons->kii.tty;
+	kgi_ucoord_t render_size, scroller_size;
+#endif
+	kgi_console_xterm_t *xterm = (kgi_console_xterm_t *)cons;
+
+#ifdef notyet
+	cons->kii.event_mask = KII_EM_POINTER | KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT;
+#endif
+	cons->kii.event_mask = KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT;
+
+#if 0
+	SCROLLER_GET(cons->scroller, &scroller_size, 0, 0, 0, 0, 0, 0);
+	RENDER_GET(cons->render, &render_size, 0, 0);
+
+	if (tp) {
+
+		tp->t_winsize.ws_col = scroller_size.x;
+		tp->t_winsize.ws_row = scroller_size.y;
+
+		tp->t_winsize.ws_xpixel = render_size.x;
+		tp->t_winsize.ws_ypixel = render_size.y;
+	}
+
+	kiidev_set_pointer_window(&cons->kii,
+		0, scroller_size.x * cons->text16->cell.x,
+		0, scroller_size.y * cons->text16->cell.y);
+#endif
+
+	SCROLLER_GET(cons->scroller, 0, 0, 0, 0, 0, &attrfl, &erase); 
+
+	cons->mode	= 0;
+	CONSOLE_SET_MODE(cons, KGI_CM_SHOW_CURSOR);
+	CONSOLE_SET_MODE(cons, KGI_CM_AUTO_WRAP);
+	CONSOLE_SET_MODE(cons, KGI_CM_XT_META_ESC);
+	xterm->s_mode = cons->mode;
+
+	cons->flags &= ~(KGI_CF_XT_QUESTION | KGI_CF_XT_CAPS_LOCK | 
+		KGI_CF_XT_CAPS_STICKY | KGI_CF_XT_NUM_LOCK);
+
+	xterm->state	= ESnormal;
+	xterm->utf_char	= 0;
+	xterm->utf_count= 0;
+
+	xterm->bell.pitch = 750 /* Hz */;
+	xterm->bell.duration = 125 /* msec */;
+
+	xterm->charset	= 0;
+	xterm->g[0]	= LAT1_MAP;
+	xterm->g[1]	= GRAF_MAP;
+	xterm->g[2]	= IBMPC_MAP; 
+	xterm->g[3]	= USER_MAP;
+
+	xterm->translate = translation[xterm->g[xterm->charset]];
+
+	xterm->npar = 0;
+
+	attrfl = KGI_CA_NORMAL | 
+		KGI_CA_COLOR(KGI_CC_LIGHTGRAY, KGI_CC_BLACK);
+
+	SCROLLER_SET(cons->scroller, attrfl, erase); 
+
+	memcpy(xterm->colors, DEFAULT_COLORS, sizeof(xterm->colors));
+
+	xterm_save_cur(cons);
+
+	if (do_reset) {
+		SCROLLER_RESET(cons->scroller);
+		SCROLLER_UPDATE_ATTR(cons->scroller);
+		SCROLLER_GOTOXY(cons->scroller, 0, 0);
+		SCROLLER_ERASE_DISPLAY(cons->scroller, 2);
+		SCROLLER_SYNC(cons->scroller);
+	}
+}
+
+static inline void 
+xterm_put_char(kgi_console_t *cons, kgi_ascii_t c)
+{
+	struct tty *tp;
+	
+	tp = cons->kii.tty;
+	tty_lock(tp);
+	ttydisc_rint(tp, (char)c, 0);
+	ttydisc_rint_done(tp);
+	tty_unlock(tp);
+}
+
+static inline void 
+xterm_application_key(kgi_console_t *cons, kgi_ascii_t key,	kgi_u_t mode)
+{
+
+	xterm_put_char(cons, ASCII_ESC);
+	xterm_put_char(cons, mode ? 'O' : '[');
+	xterm_put_char(cons, key);
+}
+
+static void 
+xterm_function_key(kgi_console_t *cons, kgi_u_t key)
+{
+	const kgi_ascii_t *s; 
+
+	s = kiidev_get_fnstring(&cons->kii, key);
+	if (s) {
+		while (*s)
+			xterm_put_char(cons, *(s++));
+	}
+}
+
+static const char *cur = "BDCA";
+static const char *pad = "0123456789+-*/\015,.?";
+static const char *app = "pqrstuvwxylSRQMnn?";
+
+static void 
+xterm_numpad_key(kgi_console_t *cons, kgi_u8_t val, kii_u_t shift)
+{
+
+	if (CONSOLE_MODE(cons, KGI_CM_XT_APPLIC_KEY) && !(shift & KII_MM_SHIFT)) {
+		xterm_application_key(cons, app[val], 1);
+		return;
+	}
+
+	if (!(cons->flags & KGI_CF_XT_NUM_LOCK)) {
+		switch(K_SYM(K_TYPE_NUMPAD, val)) {
+		case K_PCOMMA: /* Fall thru. */
+		case K_PDOT:
+			xterm_function_key(cons, K_VALUE(K_REMOVE));
+			return;
+		case K_P0:
+			xterm_function_key(cons, K_VALUE(K_INSERT));
+			return;
+		case K_P1:
+			xterm_function_key(cons, K_VALUE(K_SELECT));
+			return;
+		case K_P2:
+			xterm_application_key(cons, cur[K_VALUE(K_DOWN)], 0);
+			return;
+		case K_P3:
+			xterm_function_key(cons, K_VALUE(K_PGDN));
+			return;
+		case K_P4:
+			xterm_application_key(cons, cur[K_VALUE(K_LEFT)], 0);
+			return;
+		case K_P6:
+			xterm_application_key(cons, cur[K_VALUE(K_RIGHT)], 0);
+			return;
+		case K_P7:
+			xterm_function_key(cons, K_VALUE(K_FIND));
+			return;
+		case K_P8:
+			xterm_application_key(cons, cur[K_VALUE(K_UP)], 0);
+			return;
+		case K_P9:
+			xterm_function_key(cons, K_VALUE(K_PGUP));
+			return;
+		}
+	}
+
+	xterm_put_char(cons, pad[val]);
+	if ((val == K_VALUE(K_PENTER)) && CONSOLE_MODE(cons, KGI_CM_XT_NEWLINE))
+		xterm_put_char(cons, ASCII_LF);	
+}
+
+#if 0
+static void xterm_report(kgi_console_t *cons, kgi_u_t what)
+{
+	char buf[40], *s = buf;
+	char cbutton = ' ';
+#	define VT100ID	"\033[?1;2c"	/* VT100 with advanced video option */
+#	define VT102ID	"\033[?6c"
+
+#	define MOUSEX	('!' + (char)(cons->kii.ptr.x/cons->text16->cell.x))
+#	define MOUSEY	('!' + (char)(cons->kii.ptr.y/cons->text16->cell.y))
+
+	switch (what) {
+
+		case cursor:
+			sprintf(buf, "\033[%hd;%hdR",
+				cons->y + (CONSOLE_MODE(cons, KGI_CM_ORIGIN)
+					? cons->top+1 : 1), cons->x+1);
+			break;
+
+		case id:
+			s = VT102ID;
+			break;
+ 			
+		case status:
+			s = "\033[0n";
+			break;
+
+		case mouseup:
+			sprintf(buf, "\033[M#%c%c", MOUSEX, MOUSEY);
+			break;
+
+		case mousedown3:
+			cbutton++;
+		case mousedown2:
+			cbutton++;
+		case mousedown1:
+			sprintf(buf, "\033[M%c%c%c", cbutton, MOUSEX, MOUSEY);
+			break;
+	}
+
+	while (*s) {
+
+		xterm_put_char(cons, *(s++));
+	}
+	tty_schedule_flip((struct tty_struct *) cons->kii.tty);
+
+#	undef	MOUSEX
+#	undef	MOUSEY
+}
+#endif
+
+void 
+xterm_handle_kii_event(kii_device_t *dev, kii_event_t *ev)
+{
+	kgi_console_t *cons;
+	register kgi_u_t sym;		
+	struct tty *tp;
+
+	cons = dev->priv.priv_ptr;
+#if 0
+	if ((1 << ev->any.type) & KII_EM_POINTER) {
+
+		switch (ev->any.type) {
+
+		case KII_EV_PTR_BUTTON_PRESS:
+
+			if (CONSOLE_MODE(cons, KGI_CM_XT_REPORT_MOUSE) ||
+				CONSOLE_MODE(cons, KGI_CM_XT_X10_MOUSE)) {
+
+				if (ev->pbutton.button & 1) {
+
+					xterm_report(cons, mousedown1);
+				}
+				if (ev->pbutton.button & 4) {
+
+					xterm_report(cons, mousedown2);
+				}
+				if (ev->pbutton.button & 2) {
+
+					xterm_report(cons, mousedown3);
+				}
+			}
+			break;
+
+		case KII_EV_PTR_BUTTON_RELEASE:
+
+			if (CONSOLE_MODE(cons, KGI_CM_XT_REPORT_MOUSE)) {
+
+				xterm_report(cons, mouseup);
+			}
+			break;
+
+		case KII_EV_PTR_RELATIVE:
+		case KII_EV_PTR_ABSOLUTE:
+			RENDER_SHOW_GADGETS(cons->render);
+			break;
+		}
+	}
+#endif
+
+	if ((1 << ev->any.type) & (KII_EM_KEYBOARD)) {	
+		tp = cons->kii.tty;
+		sym = ev->key.sym;
+	
+		if (tp == NULL)
+			return;
+
+		switch(K_TYPE(sym)) {
+		case K_TYPE_META:
+			if (CONSOLE_MODE(cons, KGI_CM_XT_META_ESC)) {
+				xterm_put_char(cons, ASCII_ESC);
+				xterm_put_char(cons, K_VALUE(sym));
+			} else {
+				xterm_put_char(cons, K_VALUE(sym) | 0x80);
+			}
+			break;
+		case K_TYPE_FUNCTION:
+			xterm_function_key(cons, K_VALUE(sym));
+			break;
+		case K_TYPE_SPECIAL:
+			switch (sym) {
+			case K_ENTER:
+				xterm_put_char(cons, ASCII_CR);
+				if (CONSOLE_MODE(cons, KGI_CM_XT_NEWLINE)) 
+					xterm_put_char(cons, ASCII_LF); 
+				break;
+#if 0
+			case K_BREAK:
+				tty_insert_flip_char(tty, 0, TTY_BREAK);
+				break;
+#endif					
+			case K_CAPS:
+				/*
+				 * XXX where to handle LEDs? XXX
+				 * See kii/kii.c
+				 */
+				return;
+			case K_NUM:
+				if (CONSOLE_MODE(cons, KGI_CM_XT_APPLIC_KEY)) {
+					xterm_application_key(cons, 'P', 1);
+				} else {
+					cons->flags ^= KGI_CF_XT_NUM_LOCK;
+					/*
+					 * XXX where to handle LEDs? XXX
+					 * See kii/kii.c
+					 */
+					return;
+				}
+				break;
+#ifdef notyet
+			case K_HOLD:
+				if (tp->stopped) {
+					start_tty(tp);
+				} else {
+					stop_tty(tp);
+				}
+				return;
+#endif
+			case K_SCROLLFORW:
+				SCROLLER_FORWARD(cons->scroller, 0);
+				SCROLLER_SYNC(cons->scroller);
+				return;
+			case K_SCROLLBACK:
+				SCROLLER_BACKWARD(cons->scroller, 0);
+				SCROLLER_SYNC(cons->scroller);
+				return;
+			case K_CAPSON:
+				/*
+				 * XXX handled in kii.c
+				 * XXX where to handle LEDs?
+				 */
+				return;
+			case K_BARENUMLOCK:
+				cons->flags ^= KGI_CF_XT_NUM_LOCK;
+				/* XXX where to handle LEDs? XXX */
+				return;
+			default:
+				return;
+			}
+			break;
+		case K_TYPE_NUMPAD:
+			xterm_numpad_key(cons, K_VALUE(sym), ev->key.normal);
+			break;
+		case K_TYPE_CURSOR:
+			xterm_application_key(cons, cur[K_VALUE(sym)],
+					CONSOLE_MODE(cons, KGI_CM_XT_CURSOR_KEY));
+			break;
+		case K_TYPE_SHIFT: /* Fall thru. */
+		case K_TYPE_CONSOLE: /* Fall thru. */
+		case K_TYPE_ASCII: /* Fall thru. */
+		case K_TYPE_DEAD: /* Fall thru. */
+			return;
+		default:
+			if (CONSOLE_MODE(cons, KGI_CM_XT_UTF8)) {
+				if (sym < 0x80) {
+					xterm_put_char(cons, sym);
+				} else if (sym < 0x800) {
+					xterm_put_char(cons, 0xC0 | (sym >> 6));
+					xterm_put_char(cons, 0x80 | (sym & 0x3F));
+				} else {
+					xterm_put_char(cons, 0xE0 | (sym >> 12));
+					xterm_put_char(cons, 0x80 | (sym >> 6));
+					xterm_put_char(cons, 0x80 | (sym & 0x3F));
+				}
+				/*
+				 * UTF-8 is defined to up to 31 bits,
+				 * but as the keyboard delivers unicode
+				 * chars only we only need 16 bit here.
+				 */
+			} else {
+				if (K_TYPE(sym) == K_TYPE_LATIN)
+					xterm_put_char(cons, K_VALUE(sym));
+			}
+		}
+	}
+}
+
+int 
+xterm_do_write(kgi_console_t *cons, const char *buf, int count)
+{
+	kgi_console_xterm_t *xterm;
+	kgi_u_t n, erase, attrfl, top, bottom;
+	kgi_isochar_t c;  /* 8-bit character to process. */
+	kgi_isochar_t tc; /* Translated character.		 */
+	kgi_u_t printable;
+
+	n = 0;
+ 	xterm = (kgi_console_xterm_t *)cons;
+
+	SCROLLER_MARK(cons->scroller);
+
+	while (count) {
+		c = *buf;
+		c &= 0xff; /* !!! Make positive. */
+		buf++; n++; count--;
+
+		/*
+		 * XXX 
+		 * Shouldn't toggle_meta mode *change* bit 0x80
+		 */
+		tc = xterm->translate[CONSOLE_MODE(cons, KGI_CM_XT_TOGGLE_META)
+			? (c | 0x80) : c];
+
+		printable = (c >= 32) || ((1 << c) & 
+			(CONSOLE_MODE(cons, KGI_CM_XT_DISPLAY_CTRL)
+				? ~CTRL_ALWAYS : ~CTRL_ACTION));
+
+		if (printable && (xterm->state == ESnormal)) {
+			if (cons->flags & KGI_CF_NEED_WRAP) {
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				if (CONSOLE_MODE(cons, KGI_CM_AUTO_WRAP)) 
+					SCROLLER_LF(cons->scroller);
+
+				SCROLLER_CR(cons->scroller);
+				SCROLLER_MARK(cons->scroller);
+			}
+
+			if (CONSOLE_MODE(cons, KGI_CM_XT_INSERT)) {
+				TRACE(printf("<INS>"));
+				SCROLLER_INSERT_CHARS(cons->scroller, 1);
+			}
+
+			TRACE(printf("%.2x %.8x     ", c, cons->mode));
+			SCROLLER_WRITE(cons->scroller, tc);
+			continue;
+		}
+
+		/*
+		 * Control characters can be used in the *middle* of
+		 * an escape sequence.
+		 */
+		switch (c) {
+		case ASCII_BEL:
+			TRACE(printf("<BEL>"));
+			if (xterm->bell.pitch && xterm->bell.duration) {
+				SCROLLER_MKSOUND(cons->scroller, xterm->bell.pitch,
+						xterm->bell.duration);
+			}
+			continue;	
+		case ASCII_BS:
+			TRACE(printf("<BS>"));
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+			SCROLLER_BS(cons->scroller);
+			SCROLLER_MARK(cons->scroller);
+			continue;
+		case ASCII_HT:
+			TRACE(printf("<HT>"));
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+			SCROLLER_HT(cons->scroller);
+			SCROLLER_MARK(cons->scroller);
+			continue;
+		case ASCII_LF: /* Fall thru. */
+		case ASCII_VT: /* Fall thru. */
+		case ASCII_FF: /* Fall thru. */
+			TRACE(printf("<LF>"));
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+			SCROLLER_LF(cons->scroller);
+			SCROLLER_MARK(cons->scroller);	
+			if (!CONSOLE_MODE(cons, KGI_CM_XT_NEWLINE)) 
+				continue;
+		case ASCII_CR:
+			TRACE(printf("<CR>"));
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+			SCROLLER_CR(cons->scroller);
+			SCROLLER_MARK(cons->scroller);
+			continue;
+		case ASCII_SO:
+			TRACE(printf("<S0>"));
+			xterm->charset = 1;
+			xterm->translate = translation[xterm->g[1]];
+			CONSOLE_SET_MODE(cons, KGI_CM_XT_DISPLAY_CTRL);
+			continue;
+	 	case ASCII_SI:
+			TRACE(printf("<SI>"));
+			xterm->charset = 0;
+			xterm->translate = translation[xterm->g[0]];
+			CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_DISPLAY_CTRL);
+			continue;
+		case ASCII_CAN: /* Fall thru. */
+		case ASCII_SUB:
+			TRACE(printf("<CAN>"));
+			xterm->state = ESnormal; /* XXX display checkerboard! */
+			continue;
+		case ASCII_ESC:
+			TRACE(printf("<ESC"));
+			xterm->state = ESesc;
+			continue;
+		case 127:
+			TRACE(printf("<DEL>"));
+			/* XXX SCORLLER_DEL(cons->scroller); */
+			continue;
+		case 128+27:
+			TRACE(printf("<CSI"));	
+			xterm->state = ESsquare;
+			continue;
+		}
+
+		switch(xterm->state) {
+		case ESesc:
+			TRACE(printf("%c", (char) c));
+			xterm->state = ESnormal;
+			/*
+			 * Handle sequences that do not change cursor
+			 * position first.
+			 */
+			switch(c) {
+			case '[':
+				xterm->state = ESsquare;
+				continue;
+			case '>':	/* DECKPNM - numeric keypad */
+				TRACE(printf("= DECKPNM>\n"));
+				CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_APPLIC_KEY);
+				continue;
+			case '=':	/* DECKPAM - appl. keypad */
+				TRACE(printf("= DECKPAM>\n"));
+				CONSOLE_SET_MODE(cons, KGI_CM_XT_APPLIC_KEY);
+			 	continue;
+			case '(':	/* SCS G0 - select character set 0 */
+				TRACE(printf("= SCS0>\n"));
+				xterm->state = ESset;
+				xterm->par[0] = 0;	/* charset to set */
+				continue;
+			case ')':	/* SCS G1 - select character set 1 */
+				TRACE(printf("= SCS1>\n"));
+				xterm->state = ESset;
+				xterm->par[0] = 1;
+				continue;
+			case '*':	/* SCS G2 - select character set 2 */
+				TRACE(printf("= SCS2>\n"));
+				xterm->state = ESset;
+				xterm->par[0] = 2;
+				continue;
+			case '+':	/* SCS G3 - select character set 3 */
+				TRACE(printf("= SCS3>\n"));
+				xterm->state = ESset;
+				xterm->par[0] = 3;
+				continue;
+			case '#':
+				xterm->state = EShash;
+				continue;
+			case 'H':	/* HTS - set horiz. tab stop */
+				TRACE(printf("= HTS>\n"));
+				SCROLLER_HTS(cons->scroller);
+				continue;
+			case 'N':
+				TRACE(printf("= S2>\n"));
+				xterm->charset = 2;
+				xterm->translate = translation[xterm->g[2]];
+				CONSOLE_CLEAR_MODE(cons,KGI_CM_XT_DISPLAY_CTRL);
+				continue;
+			case 'O':
+				TRACE(printf("= S3>\n"));
+				xterm->charset = 3;
+				xterm->translate = translation[xterm->g[3]];
+				CONSOLE_CLEAR_MODE(cons,KGI_CM_XT_DISPLAY_CTRL);
+				continue;
+#if 0
+			case 'Z':	/* DECID - report ID */
+				TRACE(printf("= DECID>\n"));
+				xterm_report(cons, id);
+				continue;
+#endif
+			case 'n':  /* XXX full locking shift select G2 set */
+			case 'o':  /* XXX full locking shift select G3 set */
+				continue;
+			case '7':	/* DECSC - save cursor */
+				TRACE(printf("= DECSC>\n"));
+				xterm_save_cur(cons);
+				continue;
+#ifndef STRICT_XTERM
+			case '%':
+				xterm->state = ESpercent;
+				continue;
+#endif
+			}
+
+			/*
+			 * Now care of sequences that (potentially) alter
+			 * the cursor position. Note that *all* cases have
+			 * to be terminated with 'break'.
+			 */
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+
+			switch (c) {
+			case 'E':	/* NEL - next line */
+				TRACE(printf("= NEL>\n"));
+				SCROLLER_CR(cons->scroller);
+				SCROLLER_LF(cons->scroller);
+				break;
+			case 'M':	/* RI - reverse index */
+				TRACE(printf("= RI>\n"));
+				SCROLLER_REVERSE_LF(cons->scroller);
+				break;
+			case 'D':	/* IND - index (down one line) */
+				TRACE(printf("= IND>\n"));
+				SCROLLER_LF(cons->scroller);
+				break;
+			case '8':	/* DECRC - restore cursor */
+				TRACE(printf("= DECRC>\n"));
+				xterm_restore_cur(cons);
+				break;
+			case 'c':	/* RIS - reset to initial state */
+				TRACE(printf("= RIS>\n"));
+				xterm_do_reset(cons, 1);
+				break;
+			default:
+				TRACE(printf("= unknown ESC>\n"));
+			}
+			SCROLLER_MARK(cons->scroller);
+			continue;			
+		case ESsquare:
+			for (xterm->npar = 0; xterm->npar < XTERM_MAX_NPAR; xterm->npar++) 
+				xterm->par[xterm->npar] = 0;
+
+			xterm->npar = 0;
+			xterm->state = ESgetpars;
+
+			if (c == '[') {		/* Function key */
+				TRACE(printf("%c", (char) c));
+				xterm->state = ESfunckey;
+				continue;
+			}
+			if (c == '?') {
+				TRACE(printf("%c", (char) c));
+				cons->flags |= KGI_CF_XT_QUESTION;
+				continue;
+			}
+			/* Fall through if ((c != '[') && (c != '?')) */
+		case ESgetpars:
+			if ((c == ';') && (xterm->npar < XTERM_MAX_NPAR-1)) {
+				TRACE(printf("%c", (char) c));
+				xterm->npar++;
+				continue;
+			} else {
+				if ((c >= '0') && (c <= '9')) {
+					TRACE(printf("%c", (char) c));
+					xterm->par[xterm->npar] *= 10;
+					xterm->par[xterm->npar] += c-'0';
+					continue;
+				} else {
+					xterm->state = ESgotpars;
+				}
+			}
+			/* Fall through when parameters are complete! */
+		case ESgotpars:
+			xterm->state = ESnormal;
+			TRACE(printf("%c", (char) c));
+
+			if (cons->flags & KGI_CF_XT_QUESTION) {
+				/*
+				 * All these sequences may alter cursor
+				 * position. Terminate cases with 'break'!
+				 */
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				switch(c) {
+				case 'h':	/* SM - set mode */
+					TRACE(printf("= SM>\n"));
+					xterm_set_mode(cons, 1);
+					break;
+				case 'l':	/* RM - reset mode */
+					TRACE(printf("= RM>\n"));
+					xterm_set_mode(cons, 0);
+					break;
+				case 'r':	/* DECRM - restore mode */
+					TRACE(printf("= DECRM>\n"));	
+					xterm_backup_mode(cons, 0);
+					break;
+				case 's':	/* DECSM - save mode */
+					TRACE(printf("= DECSM>\n"));
+					xterm_backup_mode(cons, 1);
+					break;
+				default:
+					TRACE(printf("= unknown ESC[? >\n"));
+				}
+				SCROLLER_MARK(cons->scroller);
+
+				cons->flags &= ~KGI_CF_XT_QUESTION;
+				continue;
+			}
+
+			/*
+			 * First care of sequences that do not alter
+			 * cursor postion.
+			 */
+			switch(c) {
+			case 'J':	/* ED - erase display	*/
+				TRACE(printf("= ED>\n"));
+				SCROLLER_ERASE_DISPLAY(cons->scroller, xterm->par[0]);
+				continue;
+			case 'K':	/* EL - erase in line */
+				TRACE(printf("= EL>\n"));
+				SCROLLER_ERASE_LINE(cons->scroller, xterm->par[0]);
+				continue;
+
+			case 'P':
+				TRACE(printf("= ?_?>\n"));
+				if (xterm->par[0] <= 0) 
+					xterm->par[0] = 1;
+				SCROLLER_DELETE_CHARS(cons->scroller, xterm->par[0]);
+				continue;
+#if 0
+			case 'c':	/* ??? DA - device attributes */
+				TRACE(printf("= DA>\n"));
+				if (!xterm->par[0]) {
+
+					xterm_report(cons, id);
+				}
+				continue;
+#endif
+			case 'g':	/* TBC - tabulation clear */
+				TRACE(printf("= TBC>\n"));
+				SCROLLER_TBC(cons->scroller, xterm->par[0]);
+				continue;
+			case 'm':	/* SGR - select graphic redition */
+				TRACE(printf("= SGR>\n"));
+				csi_m(cons);
+				continue;
+
+#if 0
+			case 'n':	/* DSR - device status report */
+				TRACE(printf("= DSR>\n"));
+				if (xterm->par[0] == 5) {
+
+					xterm_report(cons, status);
+
+				} else {
+
+					if (xterm->par[0] == 6) {
+
+					     xterm_report(cons, cursor);
+					}
+				}
+				continue;
+#endif
+			case '@':	/* ICH - insert (blank) character(s) */
+				TRACE(printf("= ICH>\n"));
+				if (! xterm->par[0]) 
+					xterm->par[0]++;
+				SCROLLER_INSERT_CHARS(cons->scroller, xterm->par[0]);
+				continue;
+#		if 0
+			case 'q':	/* ??? DECLL - load LED */
+					/* ??? check this! */
+
+				if (!PAR[0]) {
+
+					kbd_set_led_state(&KBD_STATE, 0);
+
+				} else {
+
+					if (PAR[0] < 5) {
+
+						kbd_set_led(&KBD_STATE, PAR[0]-1);
+						kbd_setleds(KBD);
+					}
+				}
+				continue;
+#		endif
+#		ifndef STRICT_XTERM
+			case 'X':
+				SCROLLER_ERASE_CHARS(cons->scroller, xterm->par[0]);
+				continue;
+			case ']':	/* setterm functions */
+				xterm_set_term(cons);
+				continue;
+#		endif
+			}
+
+			/*
+			 * Now handle those sequences that may alter
+			 * cursor position. NOTE: all cases have to
+			 * be terminated with 'break'.
+			 */
+			SCROLLER_MODIFIED_MARK(cons->scroller);
+
+			switch(c) {
+			case 'A':	/* CUU - cursor up	*/
+				TRACE(printf("= CUU>\n"));
+				if (!xterm->par[0]) 
+					xterm->par[0]++;
+
+				SCROLLER_MOVE(cons->scroller, 0, - xterm->par[0]);
+				break;
+			case 'B':	/* CUD - cursor down	*/
+			case 'e':
+				TRACE(printf("= CUD>\n"));
+				if (!xterm->par[0]) 
+					xterm->par[0]++;
+
+				SCROLLER_MOVE(cons->scroller, 0, xterm->par[0]);
+				break;
+			case 'C':	/* CUF - cursor forward	*/
+			case 'a':
+				TRACE(printf("= CUF>\n"));
+				if (!xterm->par[0]) 
+					xterm->par[0]++;
+
+				SCROLLER_MOVE(cons->scroller, xterm->par[0], 0);
+				break;
+			case 'D':	/* CUB - cursor backward*/
+				TRACE(printf("= CUB>\n"));
+				if (!xterm->par[0]) 
+					xterm->par[0]++;
+
+				SCROLLER_MOVE(cons->scroller, - xterm->par[0], 0);
+				break;
+			case 'H':	/* CUP - set cursor position */
+			case 'f':	/* HVP - horiz. and vert. position */
+				TRACE(printf(c=='H' ? "= CUP>\n" : "= HVP>\n"));
+				if (xterm->par[0]) 
+					xterm->par[0]--;
+
+				if (xterm->par[1]) 
+					xterm->par[1]--;
+
+				top = 0;
+				if (CONSOLE_MODE(cons, KGI_CM_ORIGIN)) 
+					SCROLLER_GET(cons->scroller, 0, &top, &bottom, 0, 0, 0, 0);
+
+				xterm->par[0] += top;
+				SCROLLER_GOTOXY(cons->scroller,
+						xterm->par[1], xterm->par[0]);
+				break;
+			case 'L':
+				TRACE(printf("= ?_?>\n"));
+				if (xterm->par[0] <= 0)
+					xterm->par[0] = 1;
+
+				SCROLLER_SCROLL_TOP(cons->scroller, xterm->par[0]);
+				break;
+			case 'M':
+				TRACE(printf("= ?_?>\n"));
+				if (xterm->par[0] <= 0) 
+					xterm->par[0] = 1;
+
+				SCROLLER_SCROLL_BOTTOM(cons->scroller, xterm->par[0]);
+				break;
+			case 'h':	/* SM - set mode */
+				TRACE(printf("= SM>\n"));
+				xterm_set_mode(cons, 1);
+				break;
+			case 'l':	/* RM - reset mode */
+				TRACE(printf("= RM>\n"));
+				xterm_set_mode(cons, 0);
+				break;
+			case 'r':	/* DECSTBM - set top & bottom margin */
+				TRACE(printf("= DECSTBM>\n"));
+				SCROLLER_MARGINS(cons->scroller, xterm->par[0],
+						 xterm->par[1]);
+				break;
+			case 'x':	/* !!! DECREQTPARM - report parameter */
+				TRACE(printf("= DECREQTPARM>\n"));
+				break;
+#		ifndef STRICT_XTERM
+			case 's':
+				TRACE(printf("= save cur>\n"));
+				xterm_save_cur(cons);
+				break;
+			case 'u':
+				TRACE(printf("= rest cur>\n"));
+				xterm_restore_cur(cons);
+				break;
+			case 'E':
+				if (!xterm->par[0]) 
+					xterm->par[0]++;
+
+				SCROLLER_MOVE(cons->scroller, 0, xterm->par[0]);
+				SCROLLER_GOTOX(cons->scroller, 0);
+				break;
+			case 'F':
+				if (!xterm->par[0])
+					xterm->par[0]++;
+	
+				SCROLLER_MOVE(cons->scroller, 0, - xterm->par[0]);
+				SCROLLER_GOTOX(cons->scroller, 0);
+				break;
+			case 'G':
+			case '`':
+				if (xterm->par[0]) 
+					xterm->par[0]--;
+
+				SCROLLER_GOTOX(cons->scroller, xterm->par[0]);
+				break;
+			case 'd':
+				if (xterm->par[0]) 
+					xterm->par[0]--;
+
+				top = 0;
+				if (CONSOLE_MODE(cons, KGI_CM_ORIGIN)) {
+					SCROLLER_GET(cons->scroller, 0, &top, &bottom,
+						     0, 0, 0, 0);
+				}
+				xterm->par[0] += top;
+				SCROLLER_GOTOY(cons->scroller, xterm->par[0]);
+				break;
+#			endif
+			default:
+				TRACE(printf("= unknown ESC[>\n"));
+			}
+			SCROLLER_MARK(cons->scroller);
+			continue;
+		case ESpercent:
+			xterm->state = ESnormal;
+			TRACE(printf("%c", (char) c));
+			switch (c) {
+			case '@':	/* defined in ISO 2022 */
+				TRACE(printf("= UTF-8 off>\n"));
+				CONSOLE_CLEAR_MODE(cons, KGI_CM_XT_UTF8);
+				continue;
+			case 'G':	/* prelim official escape code */
+			case '8':	/* retained for compatibility */
+				TRACE(printf("= UTF-8 on>\n"));
+				CONSOLE_SET_MODE(cons, KGI_CM_XT_UTF8);
+				continue;
+			}
+			TRACE(printf("= unkown ESC-percent>\n"));
+			continue;
+		case ESfunckey:
+			xterm->state = ESnormal;
+			TRACE(printf("fn-key %c\n", (char) c));
+			continue;
+		case EShash:
+			if (c == '8') {	/* DEC screen alignment test */
+				TRACE(printf("= DECSAT>\n"));
+				SCROLLER_GET(cons->scroller, 0, 0, 0, 0, 0,
+					     &attrfl, &erase);
+				erase = (erase & 0xff00) | 'E';
+				SCROLLER_SET(cons->scroller, attrfl, erase);
+				SCROLLER_ERASE_DISPLAY(cons->scroller, 2);
+				erase = (erase & 0xff00) | ' ';
+				SCROLLER_SET(cons->scroller, attrfl, erase);
+			} else {
+				TRACE(printf("= unkown ESC-#>\n"));
+			}
+			xterm->state = ESnormal;
+			continue;
+		case ESset:
+			TRACE(printf("%c>\n", (char) c));
+			xterm_set_charset(cons, xterm->par[0], c);
+			xterm->state = ESnormal;
+			continue;
+		default:
+			TRACE(printf("<%.2x, state %i>\n", c, xterm->state));
+			xterm->state = ESnormal;
+			continue;
+		}
+	}
+
+	if (cons->flags & KGI_CF_NEED_WRAP) 
+		SCROLLER_MODIFIED_WRAP(cons->scroller);
+	else
+		SCROLLER_MODIFIED_MARK(cons->scroller);
+
+	SCROLLER_SYNC(cons->scroller);
+
+	return (n);
+}
+
+/*
+ * Font translation tables.
+ */
+
+static kgi_unicode_t translation[][256] = {
+  /* 8-bit Latin-1 mapped to Unicode -- trivial mapping */
+#define LAT1_MAP	0
+  {
+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
+    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
+    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
+    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
+    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
+    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
+    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
+  },
+  /* VT100 graphics mapped to Unicode */
+#define GRAF_MAP	1
+  {
+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
+    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
+    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+    0x0028, 0x0029, 0x002a, 0x2192, 0x2190, 0x2191, 0x2193, 0x002f,
+    0x2588, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
+    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x00a0,
+    0x25c6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0, 0x00b1,
+    0x2591, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c, 0xf800,
+    0xf801, 0x2500, 0xf803, 0xf804, 0x251c, 0x2524, 0x2534, 0x252c,
+    0x2502, 0x2264, 0x2265, 0x03c0, 0x2260, 0x00a3, 0x00b7, 0x007f,
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
+  },
+  /* IBM Codepage 437 mapped to Unicode */
+#define IBMPC_MAP	2
+  {
+    0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022, 
+    0x25d8, 0x25cb, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
+    0x25b6, 0x25c0, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
+    0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
+    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
+    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
+    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
+    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
+    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
+    0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
+    0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
+    0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
+    0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
+    0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
+    0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
+    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
+    0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
+    0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
+    0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
+    0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
+    0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
+    0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
+    0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
+    0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
+    0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
+  }, 
+  /* User mapping -- default to codes for direct font mapping */
+#define USER_MAP	3
+  {
+    0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007,
+    0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f,
+    0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017,
+    0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,
+    0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,
+    0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f,
+    0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,
+    0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f,
+    0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047,
+    0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f,
+    0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057,
+    0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f,
+    0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067,
+    0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f,
+    0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077,
+    0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f,
+    0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086, 0xf087,
+    0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e, 0xf08f,
+    0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096, 0xf097,
+    0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e, 0xf09f,
+    0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6, 0xf0a7,
+    0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae, 0xf0af,
+    0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6, 0xf0b7,
+    0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be, 0xf0bf,
+    0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6, 0xf0c7,
+    0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce, 0xf0cf,
+    0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6, 0xf0d7,
+    0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de, 0xf0df,
+    0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6, 0xf0e7,
+    0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee, 0xf0ef,
+    0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6, 0xf0f7,
+    0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe, 0xf0ff
+  }
+#define LAST_MAP	4
+};
+
+/*
+ * The standard kernel character-to-font mappings are not invertible
+ * -- this is just a best effort.
+ */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_emuxterm.h sys/dev/kgc/kgc_emuxterm.h
--- sys/dev/kgc/kgc_emuxterm.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_emuxterm.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,105 @@
+/*-
+ * Copyright (C) 1996-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * XTERM console parser state
+ */
+
+#ifndef	_KGI_XTERM_H
+#define	_KGI_XTERM_H
+
+#define	XTERM_MAX_NPAR	16
+
+enum kgi_console_mode_xterm_e {
+	KGI_CM_XT_DISPLAY_CTRL = KGI_CM_LAST, /* display control characters*/
+	KGI_CM_XT_TOGGLE_META,		/* set meta bit 0x80		*/
+	KGI_CM_XT_UTF8,			/* do utf8 decoding		*/
+	KGI_CM_XT_APPLIC_KEY,		/* keypad in application mode	*/
+
+	KGI_CM_XT_CURSOR_KEY,		/* DECCKM - cursor key mode	*/
+	KGI_CM_XT_COLUMN132,		/* 132 column mode		*/
+	KGI_CM_XT_X10_MOUSE,		/* x10 compatible mouse report	*/
+	KGI_CM_XT_TEXTRONIX_MODE,	/* enter textronix mode		*/
+
+	KGI_CM_XT_ALLOW_132MODE,	/* allow switch to 132 columns	*/
+	KGI_CM_XT_CURSES_FIX,		/* allow hack for curses	*/
+	KGI_CM_XT_MARGIN_BELL,		/* margin bell			*/
+	KGI_CM_XT_LOGGING,		/* do logging			*/
+
+	KGI_CM_XT_REPORT_MOUSE,		/* report mouse			*/
+	KGI_CM_XT_TRACK_MOUSE,		/* report & hilite track mouse	*/
+	KGI_CM_XT_ANSI,			/* DECANM - ANSI mode		*/
+	KGI_CM_XT_NEWLINE,		/* ENTER sends CR/CRLF		*/
+
+	KGI_CM_XT_INSERT,		/* ANSI insert mode		*/
+	KGI_CM_XT_META_ESC,		/* META chars with ESC-prefix	*/
+
+	KGI_CM_XT_LAST
+};
+
+enum kgi_console_flags_xterm_e {
+	KGI_CF_XT_QUESTION	= 0x40000000,	/* ESC?[ sequence?	*/
+	KGI_CF_XT_NUM_LOCK	= 0x20000000,	/* num_lock key active	*/
+	KGI_CF_XT_CAPS_LOCK	= 0x10000000,	/* CAPS-shift, locked	*/
+	KGI_CF_XT_CAPS_STICKY	= 0x08000000,	/* CAPS-shift, sticky	*/
+
+	KGI_CF_XT_ALL		= 0x78000000
+};
+
+
+enum xterm_states_e {
+	ESnormal,	ESesc,		ESsquare,	ESgetpars,
+	ESgotpars,	ESfunckey, 	EShash,		ESset,
+	ESpercent,	ESignore
+};
+
+typedef struct {
+	kgi_console_t	cons;
+
+	kgi_u8_t	state;
+	kgi_u8_t	charset;	
+	kgi_u8_t	s_charset;
+	kgi_u8_t	utf_count;
+
+	struct {
+		kgi_u_t pitch, duration;
+
+	}		bell;
+
+	kgi_u_t		npar;
+	unsigned long	par[XTERM_MAX_NPAR];
+
+	kgi_isochar_t	utf_char;
+	kgi_unicode_t	*translate;
+
+	kgi_s_t		s_x, s_y;	/* saved cursor position	*/
+	kgi_s_t		p_x, p_y;	/* saved pointer position	*/
+
+	kgi_u8_t	s_g[4];
+	kgi_u8_t	g[4];
+	kgi_u8_t	colors[8];
+	kgi_u8_t	s_colors[8];
+
+	kgi_u_t		s_attrfl;
+	unsigned long	s_mode;	/* saved modes			*/
+} kgi_console_xterm_t;
+
+#define	LAT1_MAP	0
+#define	GRAF_MAP	1
+#define	IBMPC_MAP	2
+#define	USER_MAP	3
+
+extern void xterm_do_reset(kgi_console_t *cons, int do_reset);
+extern void xterm_handle_kii_event(kii_device_t *dev, kii_event_t *ev);
+extern int xterm_do_write(kgi_console_t *cons, const char *buf, int count);
+
+#endif	/* #ifdef _KGI_XTERM_H */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_gfbdflt.c sys/dev/kgc/kgc_gfbdflt.c
--- sys/dev/kgc/kgc_gfbdflt.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_gfbdflt.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,4654 @@
+/*-
+ * Copyright (c) 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Andrew Doran.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * From FreeBSD: src/sys/dev/fb/boot_font.c,v 1.1 2001/11/01 08:26:29 obrien Exp
+ */
+
+/*
+ * This font lives in the public domain. It it a PC font, IBM encoding,
+ * which was designed for use with syscons.
+ *
+ * Copyright (c) 2000 Andrew Miklic
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+
+kgc_gfb_font_t kgc_bold8x16 = {
+	8,
+	16,
+	{
+	/* \00 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \01 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x42, 	/* .*....*. */
+	0x81, 	/* *......* */
+	0xe7, 	/* ***..*** */
+	0xa5, 	/* *.*..*.* */
+	0x99, 	/* *..**..* */
+	0x81, 	/* *......* */
+	0x99, 	/* *..**..* */
+	0x42, 	/* .*....*. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \02 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x7e, 	/* .******. */
+	0xff, 	/* ******** */
+	0x99, 	/* *..**..* */
+	0xdb, 	/* **.**.** */
+	0xe7, 	/* ***..*** */
+	0xff, 	/* ******** */
+	0xe7, 	/* ***..*** */
+	0x7e, 	/* .******. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \03 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \04 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0xfe, 	/* *******. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \05 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0xd6, 	/* **.*.**. */
+	0xfe, 	/* *******. */
+	0xd6, 	/* **.*.**. */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \06 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0x54, 	/* .*.*.*.. */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \07 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \010 */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xe7, 	/* ***..*** */
+	0xc3, 	/* **....** */
+	0xc3, 	/* **....** */
+	0xe7, 	/* ***..*** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+
+	/* \011 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x42, 	/* .*....*. */
+	0x42, 	/* .*....*. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \012 */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xc3, 	/* **....** */
+	0x99, 	/* *..**..* */
+	0xbd, 	/* *.****.* */
+	0xbd, 	/* *.****.* */
+	0x99, 	/* *..**..* */
+	0xc3, 	/* **....** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+
+	/* \013 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1e, 	/* ...****. */
+	0x0e, 	/* ....***. */
+	0x1a, 	/* ...**.*. */
+	0x30, 	/* ..**.... */
+	0x78, 	/* .****... */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0x78, 	/* .****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \014 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \015 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x18, 	/* ...**... */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x10, 	/* ...*.... */
+	0x10, 	/* ...*.... */
+	0x30, 	/* ..**.... */
+	0x70, 	/* .***.... */
+	0x20, 	/* ..*..... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \016 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3e, 	/* ..*****. */
+	0x22, 	/* ..*...*. */
+	0x3e, 	/* ..*****. */
+	0x22, 	/* ..*...*. */
+	0x22, 	/* ..*...*. */
+	0x22, 	/* ..*...*. */
+	0x22, 	/* ..*...*. */
+	0x26, 	/* ..*..**. */
+	0x6e, 	/* .**.***. */
+	0xe4, 	/* ***..*.. */
+	0x40, 	/* .*...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \017 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x92, 	/* *..*..*. */
+	0x54, 	/* .*.*.*.. */
+	0x28, 	/* ..*.*... */
+	0xc6, 	/* **...**. */
+	0x28, 	/* ..*.*... */
+	0x54, 	/* .*.*.*.. */
+	0x92, 	/* *..*..*. */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \020 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x70, 	/* .***.... */
+	0x78, 	/* .****... */
+	0x7c, 	/* .*****.. */
+	0x7e, 	/* .******. */
+	0x7e, 	/* .******. */
+	0x7c, 	/* .*****.. */
+	0x78, 	/* .****... */
+	0x70, 	/* .***.... */
+	0x60, 	/* .**..... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \021 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0e, 	/* ....***. */
+	0x1e, 	/* ...****. */
+	0x3e, 	/* ..*****. */
+	0x7e, 	/* .******. */
+	0x7e, 	/* .******. */
+	0x3e, 	/* ..*****. */
+	0x1e, 	/* ...****. */
+	0x0e, 	/* ....***. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \022 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0xfe, 	/* *******. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0xfe, 	/* *******. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \023 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \024 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0xf4, 	/* ****.*.. */
+	0xf4, 	/* ****.*.. */
+	0xf4, 	/* ****.*.. */
+	0x74, 	/* .***.*.. */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x14, 	/* ...*.*.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \025 */
+	0x00, 	/* ........ */
+	0x1e, 	/* ...****. */
+	0x30, 	/* ..**.... */
+	0x78, 	/* .****... */
+	0xdc, 	/* **.***.. */
+	0xce, 	/* **..***. */
+	0xe7, 	/* ***..*** */
+	0x73, 	/* .***..** */
+	0x3b, 	/* ..***.** */
+	0x1e, 	/* ...****. */
+	0x0c, 	/* ....**.. */
+	0x78, 	/* .****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \026 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \027 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0xfe, 	/* *******. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0xfe, 	/* *******. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+
+	/* \030 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x7c, 	/* .*****.. */
+	0xfe, 	/* *******. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \031 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0xfe, 	/* *******. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \032 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x08, 	/* ....*... */
+	0x0c, 	/* ....**.. */
+	0xfe, 	/* *******. */
+	0xff, 	/* ******** */
+	0xfe, 	/* *******. */
+	0x0c, 	/* ....**.. */
+	0x08, 	/* ....*... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \033 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x30, 	/* ..**.... */
+	0x7f, 	/* .******* */
+	0xff, 	/* ******** */
+	0x7f, 	/* .******* */
+	0x30, 	/* ..**.... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \034 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x33, 	/* ..**..** */
+	0x66, 	/* .**..**. */
+	0xee, 	/* ***.***. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \035 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x24, 	/* ..*..*.. */
+	0x66, 	/* .**..**. */
+	0xff, 	/* ******** */
+	0x66, 	/* .**..**. */
+	0x24, 	/* ..*..*.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \036 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x7e, 	/* .******. */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \037 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x7e, 	/* .******. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*   */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ! */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* " */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x77, 	/* .***.*** */
+	0x66, 	/* .**..**. */
+	0xcc, 	/* **..**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* # */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0xfe, 	/* *******. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0xfe, 	/* *******. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* $ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x10, 	/* ...*.... */
+	0x7c, 	/* .*****.. */
+	0xd6, 	/* **.*.**. */
+	0xd0, 	/* **.*.... */
+	0xd0, 	/* **.*.... */
+	0x7c, 	/* .*****.. */
+	0x16, 	/* ...*.**. */
+	0x16, 	/* ...*.**. */
+	0xd6, 	/* **.*.**. */
+	0x7c, 	/* .*****.. */
+	0x10, 	/* ...*.... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* % */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc4, 	/* **...*.. */
+	0x0c, 	/* ....**.. */
+	0x08, 	/* ....*... */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x20, 	/* ..*..... */
+	0x60, 	/* .**..... */
+	0x46, 	/* .*...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* & */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0x76, 	/* .***.**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ' */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1c, 	/* ...***.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ( */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ) */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* * */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0xff, 	/* ******** */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* + */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* , */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1c, 	/* ...***.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* - */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* . */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* / */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x04, 	/* .....*.. */
+	0x0c, 	/* ....**.. */
+	0x08, 	/* ....*... */
+	0x18, 	/* ...**... */
+	0x10, 	/* ...*.... */
+	0x30, 	/* ..**.... */
+	0x20, 	/* ..*..... */
+	0x60, 	/* .**..... */
+	0x40, 	/* .*...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 0 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 1 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x38, 	/* ..***... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 2 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 3 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x3c, 	/* ..****.. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 4 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0c, 	/* ....**.. */
+	0x1c, 	/* ...***.. */
+	0x3c, 	/* ..****.. */
+	0x6c, 	/* .**.**.. */
+	0xcc, 	/* **..**.. */
+	0xfe, 	/* *******. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 5 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 6 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 7 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 8 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* 9 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x78, 	/* .****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* : */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ; */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* < */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* = */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* > */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ? */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x1c, 	/* ...***.. */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* @ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xde, 	/* **.****. */
+	0xde, 	/* **.****. */
+	0xde, 	/* **.****. */
+	0xde, 	/* **.****. */
+	0xdc, 	/* **.***.. */
+	0xc0, 	/* **...... */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* A */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* B */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* C */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* D */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xf8, 	/* *****... */
+	0xcc, 	/* **..**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xcc, 	/* **..**.. */
+	0xf8, 	/* *****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* E */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* F */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* G */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xce, 	/* **..***. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* H */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* I */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* J */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1e, 	/* ...****. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0x78, 	/* .****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* K */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xcc, 	/* **..**.. */
+	0xd8, 	/* **.**... */
+	0xf0, 	/* ****.... */
+	0xe0, 	/* ***..... */
+	0xe0, 	/* ***..... */
+	0xf0, 	/* ****.... */
+	0xd8, 	/* **.**... */
+	0xcc, 	/* **..**.. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* L */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* M */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xee, 	/* ***.***. */
+	0xfe, 	/* *******. */
+	0xfe, 	/* *******. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* N */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xe6, 	/* ***..**. */
+	0xf6, 	/* ****.**. */
+	0xfe, 	/* *******. */
+	0xde, 	/* **.****. */
+	0xce, 	/* **..***. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* O */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* P */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* Q */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xf6, 	/* ****.**. */
+	0xde, 	/* **.****. */
+	0x7c, 	/* .*****.. */
+	0x0c, 	/* ....**.. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* R */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0xd8, 	/* **.**... */
+	0xcc, 	/* **..**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* S */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc0, 	/* **...... */
+	0x60, 	/* .**..... */
+	0x38, 	/* ..***... */
+	0x0c, 	/* ....**.. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* T */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* U */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* V */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* W */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xfe, 	/* *******. */
+	0xee, 	/* ***.***. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* X */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* Y */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* Z */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* [ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc0, 	/* **...... */
+	0x40, 	/* .*...... */
+	0x60, 	/* .**..... */
+	0x20, 	/* ..*..... */
+	0x30, 	/* ..**.... */
+	0x10, 	/* ...*.... */
+	0x18, 	/* ...**... */
+	0x08, 	/* ....*... */
+	0x0c, 	/* ....**.. */
+	0x04, 	/* .....*.. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ] */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x0c, 	/* ....**.. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ^ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* _ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ` */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* a */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* b */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* c */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* d */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* e */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* f */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0xf0, 	/* ****.... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* g */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+
+	/* h */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* i */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* j */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+
+	/* k */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0xcc, 	/* **..**.. */
+	0xd8, 	/* **.**... */
+	0xf0, 	/* ****.... */
+	0xd8, 	/* **.**... */
+	0xcc, 	/* **..**.. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* l */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* m */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xec, 	/* ***.**.. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* n */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* o */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* p */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+
+	/* q */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+
+	/* r */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* s */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc0, 	/* **...... */
+	0x70, 	/* .***.... */
+	0x1c, 	/* ...***.. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* t */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0xfc, 	/* ******.. */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x30, 	/* ..**.... */
+	0x1c, 	/* ...***.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* u */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* v */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x10, 	/* ...*.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* w */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xd6, 	/* **.*.**. */
+	0xd6, 	/* **.*.**. */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* x */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* y */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+
+	/* z */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* { */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0e, 	/* ....***. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x0e, 	/* ....***. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* | */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* } */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x70, 	/* .***.... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* ~ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0177 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0200 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x98, 	/* *..**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+
+	/* \0201 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0202 */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0203 */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0204 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0205 */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0206 */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0207 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x38, 	/* ..***... */
+	0x98, 	/* *..**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+
+	/* \0210 */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0211 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0212 */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0213 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0214 */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0215 */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0216 */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x10, 	/* ...*.... */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0217 */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0220 */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfc, 	/* ******.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0221 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0xdb, 	/* **.**.** */
+	0x1b, 	/* ...**.** */
+	0x7f, 	/* .******* */
+	0xd8, 	/* **.**... */
+	0xdb, 	/* **.**.** */
+	0x6e, 	/* .**.***. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0222 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3f, 	/* ..****** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x6c, 	/* .**.**.. */
+	0x6f, 	/* .**.**** */
+	0x6c, 	/* .**.**.. */
+	0x7c, 	/* .*****.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xcf, 	/* **..**** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0223 */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0224 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0225 */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0226 */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0227 */
+	0x00, 	/* ........ */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0230 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+
+	/* \0231 */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0232 */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0233 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0xc3, 	/* **....** */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc3, 	/* **....** */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0234 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x60, 	/* .**..... */
+	0xf0, 	/* ****.... */
+	0x60, 	/* .**..... */
+	0xf0, 	/* ****.... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x66, 	/* .**..**. */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0235 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0236 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xcf, 	/* **..**** */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x07, 	/* .....*** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/* \0237 */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0e, 	/* ....***. */
+	0x1b, 	/* ...**.** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x3c, 	/* ..****.. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xd8, 	/* **.**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x00, 	/* ........ */
+	0xc6, 	/* **...**. */
+	0xe6, 	/* ***..**. */
+	0xf6, 	/* ****.**. */
+	0xfe, 	/* *******. */
+	0xde, 	/* **.****. */
+	0xce, 	/* **..***. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x70, 	/* .***.... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x06, 	/* .....**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x38, 	/* ..***... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x2c, 	/* ..*.**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x38, 	/* ..***... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x38, 	/* ..***... */
+	0x68, 	/* .**.*... */
+	0x7c, 	/* .*****.. */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x36, 	/* ..**.**. */
+	0x6c, 	/* .**.**.. */
+	0xd8, 	/* **.**... */
+	0xd8, 	/* **.**... */
+	0x6c, 	/* .**.**.. */
+	0x36, 	/* ..**.**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xd8, 	/* **.**... */
+	0x6c, 	/* .**.**.. */
+	0x36, 	/* ..**.**. */
+	0x36, 	/* ..**.**. */
+	0x6c, 	/* .**.**.. */
+	0xd8, 	/* **.**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+	0x82, 	/* *.....*. */
+	0x10, 	/* ...*.... */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x95, 	/* *..*.*.* */
+	0x00, 	/* ........ */
+	0xa9, 	/* *.*.*..* */
+	0x00, 	/* ........ */
+	0x95, 	/* *..*.*.* */
+	0x00, 	/* ........ */
+	0xa9, 	/* *.*.*..* */
+	0x00, 	/* ........ */
+	0x95, 	/* *..*.*.* */
+	0x00, 	/* ........ */
+	0xa9, 	/* *.*.*..* */
+	0x00, 	/* ........ */
+	0x95, 	/* *..*.*.* */
+	0x00, 	/* ........ */
+	0xa9, 	/* *.*.*..* */
+
+	/*  */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+	0x92, 	/* *..*..*. */
+	0x49, 	/* .*..*..* */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xf8, 	/* *****... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xfc, 	/* ******.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0xf8, 	/* *****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xf8, 	/* *****... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x1f, 	/* ...***** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x1f, 	/* ...***** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xff, 	/* ******** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3f, 	/* ..****** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x3f, 	/* ..****** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3f, 	/* ..****** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x1f, 	/* ...***** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3f, 	/* ..****** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0xff, 	/* ******** */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+	0x3c, 	/* ..****.. */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xf8, 	/* *****... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1f, 	/* ...***** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+
+	/*  */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+	0xf0, 	/* ****.... */
+
+	/*  */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+	0x0f, 	/* ....**** */
+
+	/*  */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0xff, 	/* ******** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x77, 	/* .***.*** */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xcc, 	/* **..**.. */
+	0xde, 	/* **.****. */
+	0x73, 	/* .***..** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc4, 	/* **...*.. */
+	0xc8, 	/* **..*... */
+	0xc4, 	/* **...*.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xdc, 	/* **.***.. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x03, 	/* ......** */
+	0x7e, 	/* .******. */
+	0xec, 	/* ***.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x68, 	/* .**.*... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7f, 	/* .******* */
+	0xf0, 	/* ****.... */
+	0xd8, 	/* **.**... */
+	0xd8, 	/* **.**... */
+	0xd8, 	/* **.**... */
+	0xd8, 	/* **.**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x7c, 	/* .*****.. */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0xdb, 	/* **.**.** */
+	0xdb, 	/* **.**.** */
+	0xdb, 	/* **.**.** */
+	0xdb, 	/* **.**.** */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xfe, 	/* *******. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x3c, 	/* ..****.. */
+	0x66, 	/* .**..**. */
+	0xc3, 	/* **....** */
+	0xc3, 	/* **....** */
+	0xc3, 	/* **....** */
+	0xc3, 	/* **....** */
+	0x66, 	/* .**..**. */
+	0x24, 	/* ..*..*.. */
+	0xa5, 	/* *.*..*.* */
+	0xe7, 	/* ***..*** */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1e, 	/* ...****. */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x3e, 	/* ..*****. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x66, 	/* .**..**. */
+	0x3c, 	/* ..****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0xdb, 	/* **.**.** */
+	0xdb, 	/* **.**.** */
+	0xdb, 	/* **.**.** */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x03, 	/* ......** */
+	0x06, 	/* .....**. */
+	0x7e, 	/* .******. */
+	0xcf, 	/* **..**** */
+	0xdb, 	/* **.**.** */
+	0xf3, 	/* ****..** */
+	0x7e, 	/* .******. */
+	0x60, 	/* .**..... */
+	0xc0, 	/* **...... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x1c, 	/* ...***.. */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x7c, 	/* .*****.. */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x1c, 	/* ...***.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0xc6, 	/* **...**. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xfe, 	/* *******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x7e, 	/* .******. */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x06, 	/* .....**. */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0c, 	/* ....**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0x30, 	/* ..**.... */
+	0x18, 	/* ...**... */
+	0x0c, 	/* ....**.. */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x0e, 	/* ....***. */
+	0x1b, 	/* ...**.** */
+	0x1b, 	/* ...**.** */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+
+	/*  */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0xd8, 	/* **.**... */
+	0xd8, 	/* **.**... */
+	0x70, 	/* .***.... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x7e, 	/* .******. */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x00, 	/* ........ */
+	0x76, 	/* .***.**. */
+	0xdc, 	/* **.***.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x38, 	/* ..***... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x38, 	/* ..***... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x18, 	/* ...**... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x03, 	/* ......** */
+	0x02, 	/* ......*. */
+	0x06, 	/* .....**. */
+	0x04, 	/* .....*.. */
+	0x0c, 	/* ....**.. */
+	0x08, 	/* ....*... */
+	0xd8, 	/* **.**... */
+	0x50, 	/* .*.*.... */
+	0x70, 	/* .***.... */
+	0x20, 	/* ..*..... */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0xd8, 	/* **.**... */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x6c, 	/* .**.**.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x78, 	/* .****... */
+	0xcc, 	/* **..**.. */
+	0x18, 	/* ...**... */
+	0x30, 	/* ..**.... */
+	0x60, 	/* .**..... */
+	0xfc, 	/* ******.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+
+	/*  */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x7c, 	/* .*****.. */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	0x00, 	/* ........ */
+	}
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_gfbrndr.c sys/dev/kgc/kgc_gfbrndr.c
--- sys/dev/kgc/kgc_gfbrndr.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_gfbrndr.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,672 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions. 
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGC (BSD) General FB renderer
+ */
+
+#include <dev/kgi/maintainers.h>
+#define	MAINTAINER	Nicholas_Souchu
+
+#include "opt_kgi.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/linker.h>
+#include <sys/linker.h>
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_kgirndr.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+#include <dev/kgc/kgc_backgnd.h>
+
+#include "render_if.h"
+
+/* For now don't use background in high/true colour modes */
+#ifdef KGC_RENDER_16BITS 
+#undef KGC_RENDER_BACKGROUND
+#endif
+
+typedef struct {
+	/*
+	 * Must be there if you use KGI resources interface
+	 */
+	__KGC_KGIRNDR_DATA;
+
+	kgi_u_t		width;
+	kgi_u_t		height;
+	kgi_u_t		depth;
+
+	/* XXX Maximum of 2 pixel lines of 10 pixels with bpp=16 */
+	kgi_u8_t	pointed[10 * 2 * 2];
+	kgi_ucoord_t	cursor;
+
+	kgc_gfb_font_t	*font;
+	unsigned char	*bgnd;
+
+	kgi_u16_t	palette[256*3];
+} gfbrndr_meta;
+
+static int
+gfbrndr_putp(kgi_virt_addr_t fb, kgi_u32_t off, kgi_u32_t p, kgi_u32_t a,
+	     int size, int bpp, int bit_ltor, int byte_ltor, unsigned char *bgnd)
+{
+	int i, j, k, num_shifts;
+	kgi_u32_t _p, val, mask[32];
+
+	if (bpp < 1)
+		return(-1);
+
+	  /*
+	   * If we don't display bits right-to-left (little-bitian?),
+	   * then perform a bit-swap on p...
+	   */
+	if(bit_ltor) {
+		num_shifts = 8 * size;
+		for(i = 0, _p = 0; i < num_shifts; i++, p >>= 1) {
+			_p <<= 1;
+			_p |= (p & 0x00000001);
+		}
+	} else 
+		_p = p;
+
+	val = 0;
+
+	switch(bpp) {
+#if 0
+	/* Accelerate the simplest cases... */
+	case 1:
+		if((a & 0x00000001) == 0)
+			val[0] = 0;
+		else if(size <= 0)
+			val[0] = 0;
+		else if(size == 1)
+			val[0] = _p & 0x000000ff;
+		else if(size == 2)
+			val[0] = _p & 0x0000ffff;
+		else if(size == 3)
+			val[0] = _p & 0x00ffffff;
+		else if(size == 4)
+			val[0] = _p & 0xffffffff;
+		break;
+#endif
+	case 8:
+		if(size > 0) {
+			a &= 0x000000ff;
+			val = a | (a << 8) | (a << 16) | (a << 24);
+			mask[0] = 0;
+			if(_p & 0x00000001) mask[0] |= (0xff);
+			if(_p & 0x00000002) mask[0] |= (0xff << 8);
+			if(_p & 0x00000004) mask[0] |= (0xff << 16);
+			if(_p & 0x00000008) mask[0] |= (0xff << 24);
+			mask[1] = 0;
+			if(_p & 0x00000010) mask[1] |= (0xff);
+			if(_p & 0x00000020) mask[1] |= (0xff << 8);
+			if(_p & 0x00000040) mask[1] |= (0xff << 16);
+			if(_p & 0x00000080) mask[1] |= (0xff << 24);
+		}
+		if(size > 1) {
+			mask[2] = 0;
+			if(_p & 0x00000100) mask[2] |= (0xff);
+			if(_p & 0x00000200) mask[2] |= (0xff << 8);
+			if(_p & 0x00000400) mask[2] |= (0xff << 16);
+			if(_p & 0x00000800) mask[2] |= (0xff << 24);
+			mask[3] = 0;
+			if(_p & 0x00001000) mask[3] |= (0xff);
+			if(_p & 0x00002000) mask[3] |= (0xff << 8);
+			if(_p & 0x00004000) mask[3] |= (0xff << 16);
+			if(_p & 0x00008000) mask[3] |= (0xff << 24);
+		}	
+		if(size > 2) {
+			mask[4] = 0;
+			if(_p & 0x00010000) mask[4] |= (0xff);
+			if(_p & 0x00020000) mask[4] |= (0xff << 8);
+			if(_p & 0x00040000) mask[4] |= (0xff << 16);
+			if(_p & 0x00080000) mask[4] |= (0xff << 24);
+			mask[5] = 0;
+			if(_p & 0x00100000) mask[5] |= (0xff);
+			if(_p & 0x00200000) mask[5] |= (0xff << 8);
+			if(_p & 0x00400000) mask[5] |= (0xff << 16);
+			if(_p & 0x00800000) mask[5] |= (0xff << 24);
+		}
+		if(size > 3) {
+			mask[6] = 0;
+			if(_p & 0x01000000) mask[6] |= (0xff);
+			if(_p & 0x02000000) mask[6] |= (0xff << 8);
+			if(_p & 0x04000000) mask[6] |= (0xff << 16);
+			if(_p & 0x08000000) mask[6] |= (0xff << 24);
+			mask[7] = 0;
+			if(_p & 0x10000000) mask[7] |= (0xff);
+			if(_p & 0x20000000) mask[7] |= (0xff << 8);
+			if(_p & 0x40000000) mask[7] |= (0xff << 16);
+			if(_p & 0x80000000) mask[7] |= (0xff << 24);
+		}
+		break;
+	case 16:
+		if(size > 0) {
+			a &= 0x0000ffff;
+			val = 0xffffffff;
+			mask[0] = 0;
+			if(_p & 0x00000001) mask[0] |= (0xffff);
+			if(_p & 0x00000002) mask[0] |= (0xffff << 16);
+			mask[1] = 0;
+			if(_p & 0x00000004) mask[1] |= (0xffff);
+			if(_p & 0x00000008) mask[1] |= (0xffff << 16);
+			mask[2] = 0;
+			if(_p & 0x00000010) mask[2] |= (0xffff);
+			if(_p & 0x00000020) mask[2] |= (0xffff << 16);
+			mask[3] = 0;
+			if(_p & 0x00000040) mask[3] |= (0xffff);
+			if(_p & 0x00000080) mask[3] |= (0xffff << 16);
+		}
+		if(size > 1) {
+			mask[4] = 0;
+			if(_p & 0x00000100) mask[4] |= (0xffff);
+			if(_p & 0x00000200) mask[4] |= (0xffff << 16);
+			mask[5] = 0;
+			if(_p & 0x00000400) mask[5] |= (0xffff);
+			if(_p & 0x00000800) mask[5] |= (0xffff << 16);
+			mask[6] = 0;
+			if(_p & 0x00001000) mask[6] |= (0xffff);
+			if(_p & 0x00002000) mask[6] |= (0xffff << 16);
+			mask[7] = 0;
+			if(_p & 0x00004000) mask[7] |= (0xffff);
+			if(_p & 0x00008000) mask[7] |= (0xffff << 16);
+		}
+		if(size > 2) {
+			mask[8] = 0;
+			if(_p & 0x00010000) mask[8] |= (0xffff);
+			if(_p & 0x00020000) mask[8] |= (0xffff << 16);
+			mask[9] = 0;
+			if(_p & 0x00040000) mask[9] |= (0xffff);
+			if(_p & 0x00080000) mask[9] |= (0xffff << 16);
+			mask[10] = 0;
+			if(_p & 0x00100000) mask[10] |= (0xffff);
+			if(_p & 0x00200000) mask[10] |= (0xffff << 16);
+			mask[11] = 0;
+			if(_p & 0x00400000) mask[11] |= (0xffff);
+			if(_p & 0x00800000) mask[11] |= (0xffff << 16);
+		}
+		if(size > 3) {
+			mask[12] = 0;
+			if(_p & 0x01000000) mask[12] |= (0xffff);
+			if(_p & 0x02000000) mask[12] |= (0xffff << 16);
+			mask[13] = 0;
+			if(_p & 0x04000000) mask[13] |= (0xffff);
+			if(_p & 0x08000000) mask[13] |= (0xffff << 16);
+			mask[14] = 0;
+			if(_p & 0x10000000) mask[14] |= (0xffff);
+			if(_p & 0x20000000) mask[14] |= (0xffff << 16);
+			mask[15] = 0;
+			if(_p & 0x40000000) mask[15] |= (0xffff);
+			if(_p & 0x80000000) mask[15] |= (0xffff << 16);
+		}
+		break;
+	default:
+		break;
+	}
+	j = (bpp == 1) ? 1 : bpp * size / sizeof(kgi_u32_t);
+
+	/*
+	 * If we don't display bytes right-to-left (little-endian),
+	 * then perform a byte-swap on p (we don't have to swap if
+	 * bpp == 1 and val[0] == 0)...
+	 */
+	if((byte_ltor) && (j > 1) && (mask[j] != 0)) {
+		for(i = 0; i < (j - i); i++) {
+			_p = mask[j - i];
+			mask[j - i] = mask[i];
+			mask[i] = _p;
+		}
+		for(i = 0; i < j; i++) {
+			_p = mask[i];
+			for(k = 0, mask[i] = 0; k < sizeof(kgi_u32_t);
+			    k++, _p >>= 8) {
+				mask[i] <<= 8;
+				mask[i] |= (_p & 0xff);
+			}
+		}
+	}
+
+	for(i = 0; i < j; i++) {
+		/* Write the pixel-row... */
+		*((kgi_u32_t *)(fb) + off + i) = (val & mask[i]) | ((bgnd) ?
+			(*((kgi_u32_t *)(bgnd) + off + i) & ~mask[i]) : 0);
+	}
+	return(0);
+}
+
+#define PIX2POS(pixel) (pixel & 0xFF)
+#define PIX2ATTR(pixel) ((pixel & 0xFF00) >> 8)
+
+static int
+gfbrndr_putcs(render_t r, kgc_textbuf_t *tb, kgi_u_t start,
+	      kgi_u_t offset, kgi_u_t count)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+	kgi_u32_t poff;
+	kgi_u_t row, col, n;
+	kgi_u8_t *pixel;
+	kgi_u16_t *text = tb->buf + start;
+	int i;
+
+	/* Iterate on the string */
+	for (n = 0; n < count; n++) {
+		/* Get the start of the array of pixels rows for this
+		 * character...
+		 */
+		pixel = &render->font->data[PIX2POS(text[n]) * render->font->height];
+
+		/* Calculate the new cursor position... */
+		row = (offset + n) / render->width;
+		col = (offset + n) % render->width;
+		
+		/* Iterate over all the pixel rows for this character... */
+		for(i = 0; i < render->font->height; i++) {
+			/* Get the address of the character's pixel-row... */
+			poff = (((((row * render->font->height) + i) *
+				  render->mode.img[0].size.x) +
+				 (col * render->font->width)) *
+				(render->depth / 8) / sizeof(kgi_u32_t));
+			
+			/* Now display the current pixel row... */
+			gfbrndr_putp(render->fb->win.virt, poff, pixel[i],
+				     PIX2ATTR(text[n]), sizeof(kgi_u8_t),
+				     render->depth, 1, 0, render->bgnd);
+		}
+	}
+	return(0);
+}
+
+static void 
+gfbrndr_get(render_t r, kgi_ucoord_t *size, kgi_ucoord_t *virt,
+			     kgi_u_t *flags)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	/* No hardscroll, virt == real */
+	if (size && virt) {
+		size->x = render->width;
+		size->y = render->height;
+		virt->x = render->width;
+		virt->y = render->height;
+	}
+
+	if (flags) {
+		*flags = render->flags;
+
+		/* Hard code no hardscroll */
+		*flags |= KGI_RF_NO_HARDSCROLL;
+
+		*flags |= (render->mode.img[0].flags & KGI_IF_TILE_Y) ?
+			KGI_RF_TILE_Y : 0;
+	}
+}
+
+static void 
+gfbrndr_set(render_t r, kgi_ucoord_t *size, kgi_ucoord_t *virt)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	render->width = virt->x;
+	render->height = virt->y;
+}
+
+static kgi_u_t
+gfbrndr_ctop(render_t r, kgi_isochar_t sym)
+{
+	/* Use direct mapping between the char and the glyph */
+	return ((kgi_u_t)sym);
+}
+
+#ifdef KGC_RENDER_BACKGROUND
+static void 
+gfbrndr_bgnd_draw(render_t r)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	/* If focused draw/redraw the background */
+	if (render->kgi.flags & KGI_DF_FOCUSED) {		
+		/*
+		 * Only update the screen if focused. Avoid palette
+		 * setting but get it in the render.
+		 */
+		backgnd_draw(r->devid, render->bgnd, render->palette);
+
+		/*
+		 * XXX Force 7 as light gray, consequently your
+		 * image shall not contain any 7 or it will be
+		 * light gray!!
+		 */
+		render->palette[7*3] = render->palette[7*3+1] =
+			render->palette[7*3+2] = 66*0xFF/100 << 8;
+		
+		/* Apply the modified palette */
+		if (render->ilut->Set)
+			render->ilut->Set(render->ilut, 0, 0, 256, KGI_AM_COLORS,
+					  render->palette);
+	}
+}
+
+static int 
+gfbrndr_callback(render_t r, int action, void *arg)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+	kgi_u_t size = 0;
+
+	switch (action) {
+	case BACKGND_INIT:
+		/* If no background allocated for this render, do it */
+		if (!render->bgnd) {
+			size = render->mode.img[0].size.x * render->mode.img[0].size.y *
+				((kgi_attr_bits(render->mode.img[0].bpfa) + 1) / 8);
+		
+			if (!(render->bgnd = kgi_kmalloc(size)))
+				return (ENOMEM);
+		
+			bzero(render->bgnd, size);
+		}
+	
+		/* Draw in the allocated background buffer */
+		gfbrndr_bgnd_draw(r);
+
+		/* 
+		 * XXX FIXME
+		 * memcpy(render->fb->win.virt, render->bgnd, size);
+		 */
+		break;
+	case BACKGND_TERM:
+		/* XXX Blank the screen? */
+		
+		/* Release the background buffer */
+		if (render->bgnd) {
+			kgi_kfree(render->bgnd);
+			render->bgnd = NULL;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return (0);
+}
+#endif
+
+static void 
+gfbrndr_unmap(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+
+	render->flags &= ~KGI_RF_NEEDS_UPDATE;
+}
+
+static void 
+gfbrndr_map(render_t r)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	/* Draw/redraw the background */
+#ifdef KGC_RENDER_BACKGROUND
+	gfbrndr_bgnd_draw(r);
+#endif
+
+	/* Tell the scroller to update the screen */
+	render->flags |= KGI_RF_NEEDS_UPDATE;
+}	
+
+static void 
+gfbrndr_hide_gadgets(render_t r)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	kgi_u32_t poff;
+	kgi_u8_t *addr, *saved;
+	int i, j, k;
+
+	if (!(r->cons->flags & KGI_CF_CURSOR_SHOWN) ||
+	    !(render->kgi.flags & KGI_DF_FOCUSED))
+		return;
+
+	/* Restore the 2 lines overwritten by the cursor */
+	saved = &render->pointed[0];
+	for(i = render->font->height-2; i < render->font->height; i++) {
+		/* Get the address of the character's pixel-row... */
+		poff = (((((render->cursor.y * render->font->height) + i) *
+			  render->mode.img[0].size.x) +
+			 (render->cursor.x * render->font->width)) *
+			(render->depth / 8));
+
+		/* Iterate over the columns of this row */
+		for (j=0; j < render->font->width; j+=render->depth / 8) {
+			addr = (kgi_u8_t *)(render->fb->win.virt) + poff + j; 
+			for (k=0; k < render->depth / 8; k++) {
+				addr[k] = *saved++;
+			}
+		}
+	}
+
+	r->cons->flags &= ~KGI_CF_CURSOR_SHOWN;
+}
+
+static void 
+gfbrndr_show_gadgets(render_t r, kgi_u_t x, kgi_u_t y, kgi_u_t offset)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+	kgi_u32_t poff;
+	kgi_u8_t *addr, *save;
+	int i, j, k;
+
+	if (!CONSOLE_MODE(r->cons, KGI_CM_SHOW_CURSOR) ||
+	    (r->cons->flags & KGI_CF_CURSOR_SHOWN) ||
+	    !(render->kgi.flags & KGI_DF_FOCUSED))
+		return;
+	
+	gfbrndr_hide_gadgets(r);
+
+	render->cursor.x = x;
+	render->cursor.y = y;
+
+	/* Overwrite 2 lines to print the cursor */
+	save = &render->pointed[0];
+	for(i = render->font->height-2; i < render->font->height; i++) {
+		/* Get the address of the character's pixel-row... */
+		poff = (((((render->cursor.y * render->font->height) + i) *
+			  render->mode.img[0].size.x) +
+			 (render->cursor.x * render->font->width)) *
+			(render->depth / 8));
+
+		/* Iterate over the columns of this row */
+		for (j=0; j < render->font->width; j+=render->depth / 8) {
+			addr = (kgi_u8_t *)(render->fb->win.virt) + poff + j; 
+			for (k=0; k < render->depth / 8; k++) {
+				*save++ = addr[k];
+				addr[k] = 7;
+			}
+		}
+	}
+
+	r->cons->flags |= KGI_CF_CURSOR_SHOWN;
+}
+
+/*
+ * Some common display resolutions. 
+ */
+const kgi_u16_t modes[][2] =
+{
+
+#ifdef KGC_RENDER_1280x1024
+	{ 1280, 1024 }, 
+#endif
+#ifdef KGC_RENDER_1024x768
+	{ 1024, 768 },
+#endif
+#ifdef KGC_RENDER_800x600
+	{ 800, 600 },
+#endif
+#ifdef KGC_RENDER_640x480
+	{ 640, 480 },
+#endif
+#ifdef KGC_RENDER_640x400
+	{ 640, 400 },
+#endif
+#ifdef KGC_RENDER_320x240
+	{ 320, 240 },
+#endif
+#ifdef KGC_RENDER_320x200
+	{ 320, 200 },
+#endif
+	{ 0, 0 }
+};
+
+static void 
+gfbrndr_handle_event(kgi_device_t *device, kgi_event_t *event)
+{
+	kgi_console_t *cons = (kgi_console_t *)device->priv.priv_ptr;
+	render_t r = cons->render;
+
+	switch (event->notice.command) {
+	case KGI_EVENT_NOTICE_NEW_DISPLAY:
+		/* Redo common initialization, especially concerning KGI resources */
+		kgirndr_init(r);
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+static kgi_s_t
+gfbrndr_init(render_t r, kgi_u_t devid)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+	kgi_s_t error = KGI_ENODEV, i;
+
+	bzero(render, sizeof(*render));
+
+	render->mode.images = 1;
+	/* render->mode.flags |= KGI_MF_BOOT; XXX avoids mode alloc */
+#ifdef KGC_RENDER_16BITS
+	render->mode.img[0].fam = KGI_AM_RGB;
+	render->mode.img[0].bpfa[0] = 5;
+	render->mode.img[0].bpfa[1] = 6;
+	render->mode.img[0].bpfa[2] = 5;
+	render->mode.img[0].bpfa[3] = 0;
+#else
+	render->mode.img[0].fam = KGI_AM_COLOR_INDEX;
+	render->mode.img[0].bpfa[0] = 8;
+	render->mode.img[0].bpfa[1] = 0;
+#endif
+	
+	render->kgi.mode = &(render->mode);
+	render->kgi.flags |= KGI_DF_CONSOLE;
+	render->kgi.priv.priv_ptr = kgc_render_cons(r);
+
+	render->kgi.MapDevice = kgc_map_kgi;
+	render->kgi.UnmapDevice = kgc_unmap_kgi;
+	render->kgi.HandleEvent = gfbrndr_handle_event;
+
+	for (i = 0; modes[i][0] && modes[i][1]; i++) {
+		render->mode.img[0].size.x = render->mode.img[0].virt.x = modes[i][0];
+		render->mode.img[0].size.y = render->mode.img[0].virt.y = modes[i][1];
+
+		if (!(error = kgi_register_device(&(render->kgi), r->devid)))
+			goto found;
+	}
+	return (error);
+
+ found:
+	/* Common initialization, especially concerning KGI resources */
+	kgirndr_init(r);
+
+#ifndef KGC_DEFAULT_FONT
+#define KGC_DEFAULT_FONT kgc_bold8x16
+#endif
+
+	render->font = &(KGC_DEFAULT_FONT);
+	render->width = render->mode.img[0].size.x / render->font->width;
+	render->height = render->mode.img[0].size.y / render->font->height;
+#ifdef KGC_RENDER_16BITS
+	render->depth = 16;
+#else
+	render->depth = 8;
+#endif
+
+	if (!kgi_current_focus(render->kgi.dpy_id))
+		kgi_map_device(render->kgi.id);
+
+	/* Initialize the background */
+#ifdef KGC_RENDER_BACKGROUND
+	backgnd_init(r->devid, gfbrndr_callback, NULL);
+#endif
+
+	return (KGI_EOK);
+}
+
+static void 
+gfbrndr_done(render_t r)
+{
+	gfbrndr_meta *render = kgc_render_meta(r);
+
+	/* Terminate the background management */
+#ifdef KGC_RENDER_BACKGROUND
+	backgnd_term(r->devid);
+#endif
+
+	/* Release KGI resources */
+	if (render->kgi.flags & KGI_DF_FOCUSED)
+		kgi_unmap_device(render->kgi.id);
+
+	kgi_unregister_device(&render->kgi);
+}
+
+static render_method_t gfbrndr_methods[] = {
+	/* Specific methods */
+	RENDERMETHOD(render_init,		gfbrndr_init),
+	RENDERMETHOD(render_done,		gfbrndr_done),
+	RENDERMETHOD(render_put_text,		gfbrndr_putcs),
+	RENDERMETHOD(render_ctop,		gfbrndr_ctop),
+	RENDERMETHOD(render_get,		gfbrndr_get),
+	RENDERMETHOD(render_set,		gfbrndr_set),
+	RENDERMETHOD(render_map,		gfbrndr_map),
+	RENDERMETHOD(render_unmap,		gfbrndr_unmap),
+	RENDERMETHOD(render_show_gadgets,	gfbrndr_show_gadgets),
+	RENDERMETHOD(render_hide_gadgets,	gfbrndr_hide_gadgets),
+	RENDERMETHOD(render_undo_gadgets,	gfbrndr_hide_gadgets),
+
+	/* Methods using KGI generic interface */
+	RENDERMETHOD(render_ptoa,		kgirndr_ptoa_color),
+	RENDERMETHOD(render_atop,		kgirndr_atop_color),
+	RENDERMETHOD_END
+};
+
+render_driver_t gfbrndr_driver = {
+	"gfbrndr",
+	gfbrndr_methods,
+	sizeof(gfbrndr_meta)
+};
+
+DECLARE_RENDER(gfbrndr, gfbrndr_driver, gfbrndr_meta);
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_gfbrndr.h sys/dev/kgc/kgc_gfbrndr.h
--- sys/dev/kgc/kgc_gfbrndr.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_gfbrndr.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,30 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI BSD font implementation
+ */
+
+#ifndef _kgc_gfbrndr_h
+#define	_kgc_gfbrndr_h
+
+typedef struct {
+	kgi_s_t width;
+	kgi_s_t height;
+	kgi_u8_t data[256 * 16];
+} kgc_gfb_font_t;
+
+extern kgc_gfb_font_t kgc_bold8x16;
+
+extern void gfbrndr_configure(kgi_console_t *cons);
+
+#endif	/* #ifndef _kgc_gfbrndr_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_isodflt.c sys/dev/kgc/kgc_isodflt.c
--- sys/dev/kgc/kgc_isodflt.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_isodflt.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,48 @@
+/*-
+ * Copyright (C) 1996-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI console default font data structures
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <dev/kgi/opt_kgi.h>
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kgi/kgii.h>
+
+#include <dev/kgc/kgc_isorndr.h>
+
+#define	CONFIG_ISO_FONT_8x8
+#define	CONFIG_ISO_FONT_8x14
+#define	CONFIG_ISO_FONT_9x16
+
+#ifndef CONFIG_ISO_FONT_FILE
+#define CONFIG_ISO_FONT_FILE <kgc/default-font-ibm437>
+#endif
+#include CONFIG_ISO_FONT_FILE
+
+kgi_console_font_t *default_font[CONFIG_KGII_MAX_NR_DEFFONTS] = {
+	/* XXX FIXME: for now there must be only one font per height*/
+	CONFIG_ISO_FONT_9x16
+	CONFIG_ISO_FONT_8x14
+	CONFIG_ISO_FONT_8x8
+	NULL
+};
+
+#ifdef notyet
+#include <kgi/default-ptr>
+#include <kgi/default-color>
+#endif /* notyet */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_isorndr.c sys/dev/kgc/kgc_isorndr.c
--- sys/dev/kgc/kgc_isorndr.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_isorndr.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,198 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI ISO font renderer
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_ATOMIC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_kgirndr.h>
+#include <dev/kgc/kgc_isorndr.h>
+
+#include "render_if.h"
+
+typedef struct {
+	/*
+	 * Must be there if you use KGI resources interface
+	 */
+	__KGC_KGIRNDR_DATA
+
+	kgi_console_font_t	*font;
+} isorndr_meta;
+
+static kgi_u_t 
+isorndr_ctop(render_t r, kgi_isochar_t sym)
+{
+	isorndr_meta *isorndr = kgc_render_meta(r);
+	kgi_console_font_t *font = isorndr->font;
+	kgi_u_t row  = KGI_ISOCHAR_ROW(sym);
+	kgi_u_t cell = KGI_ISOCHAR_CELL(sym);
+	kgi_console_font_cellinfo_t *cellinfo;
+	kgi_u_t l = 0, h, m;
+
+	KRN_ASSERT(font);
+	cellinfo = font->info->cellinfo[row];
+
+	if (row == 0xF0)		/* display directly */
+		return (cell);
+
+	if ((sym & 0xFFFF0000) || !cellinfo) 
+		return (font->info->default_pos);
+
+	if (test_bit(row, font->info->map_direct)) 
+		return (((kgi_u8_t *) cellinfo) [cell]);
+
+	if (sym > cellinfo->sym)
+		return (font->info->default_pos); /* symbol not in list?	*/
+
+	h = cellinfo->pos;
+	cellinfo++;
+
+	if (sym < cellinfo->sym) 
+		return (font->info->default_pos);
+
+	if (cellinfo->sym == sym)
+		return (cellinfo->pos);
+
+	do {	/* search matching cell */
+		if (cellinfo[h].sym == sym) 
+			return (cellinfo[h].pos);
+
+		m = (--h + l) >> 1;
+
+		if (sym > cellinfo[m].sym) {
+			l = m;
+		} else { 
+			h = m;
+		}
+	} while (l < h); 
+
+	return (font->info->default_pos); /* no position defined */
+}
+
+static kgi_isochar_t 
+isorndr_ptoc(render_t r, kgi_u_t pos)
+{
+	isorndr_meta *isorndr = kgc_render_meta(r);
+	kgi_console_font_t *font = isorndr->font;
+
+	return (font->info->inversemap[(pos < font->info->positions) ? pos : 0]);
+}
+
+static void 
+isorndr_putcs(render_t r, kgc_textbuf_t *tb, kgi_u_t start,
+			  kgi_u_t offset, kgi_u_t count)
+{
+	isorndr_meta *render = kgc_render_meta(r);
+
+	if (render->text16) {
+		(render->text16->PutText16)(render->text16, offset, tb->buf + start,
+		 count);
+	}
+}
+
+static void 
+isorndr_get_sizes(render_t r, kgi_ucoord_t *size, kgi_ucoord_t *virt)
+{
+	isorndr_meta *render = kgc_render_meta(r);
+
+	size->x = render->text16->size.x;
+	size->y = render->text16->size.y;
+	virt->x = render->text16->size.x;
+	virt->y = render->text16->size.y;
+}
+
+static void 
+isorndr_set_sizes(render_t r, kgi_ucoord_t *size, kgi_ucoord_t *virt,
+			      kgi_u8_t depth)
+{
+	isorndr_meta *render = kgc_render_meta(r);
+
+	/* only virtual sizes may be modified */
+	render->text16->size.x = virt->x;
+	render->text16->size.y = virt->y;
+}
+
+/*
+ * console font handling
+ */
+static kgi_console_font_t *
+isorndr_default_font(render_t r)
+{
+	isorndr_meta *render = kgc_render_meta(r);
+	kgi_u_t i = 0;
+
+	KRN_DEBUG(3, "searching font for height %i", render->text16->font.y);
+	for (i = 0; default_font[i] && 
+		(default_font[i]->size.y > render->text16->font.y); i++) 
+		;
+	KRN_DEBUG(3, "found font %i (%p)", i, default_font[i]);
+	return (default_font[i]);
+}
+
+static kgi_s_t
+isorndr_init(render_t r)
+{
+	isorndr_meta *render = kgc_render_meta(r);
+
+	/* Common initialization, especially concerning resources */
+	kgirndr_init(r);
+	
+	render->font = isorndr_default_font(r);
+
+	return (KGI_EOK);
+}
+
+static render_method_t isorndr_methods[] = {
+	/* Specific methods */
+	RENDERMETHOD(render_init,		isorndr_init),
+	RENDERMETHOD(render_put_text,		isorndr_putcs),
+	RENDERMETHOD(render_ptoc,		isorndr_ptoc),
+	RENDERMETHOD(render_ctop,		isorndr_ctop),
+	RENDERMETHOD(render_get_sizes,		isorndr_get_sizes),
+	RENDERMETHOD(render_set_sizes,		isorndr_set_sizes),
+
+	/* Methods using KGI generic interface */
+	RENDERMETHOD(render_map,		kgirndr_map),
+	RENDERMETHOD(render_ptoa,		kgirndr_ptoa_color),
+	RENDERMETHOD(render_atop,		kgirndr_atop_color),
+	RENDERMETHOD(render_show_gadgets,	kgirndr_show_gadgets),
+	RENDERMETHOD(render_hide_gadgets,	kgirndr_hide_gadgets),
+	RENDERMETHOD(render_undo_gadgets,	kgirndr_undo_gadgets),
+	RENDERMETHOD_END
+};
+
+render_driver_t isorndr_driver = {
+	"isorndr",
+	isorndr_methods,
+	sizeof(isorndr_meta)
+};
+
+DECLARE_RENDER(isorndr, isorndr_driver, isorndr_meta);
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_isorndr.h sys/dev/kgc/kgc_isorndr.h
--- sys/dev/kgc/kgc_isorndr.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_isorndr.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,63 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI ISO font implementation
+ */
+
+#ifndef _kgc_isorndr_h
+#define	_kgc_isorndr_h
+
+/* console fonts
+ *
+ * The console fonts have (at maximum) 256 font positions as this can
+ * (hopefully) be done or emulated on all displays. To support ISO10646 as
+ * good and fast as possible, we use a (speed and common case) optimized
+ * mapping not to exhaust memory:
+ *
+ * Generally cellinfo[ISO_ROW(x)] points to data about row ISO_ROW(x):
+ *
+ * * NULL if the font has no positions that map to this row.
+ * * if bit number row of map_direct is set, cellinfo[row] is a pointer
+ *   to an 'kgi_u8 map[256]' array, map[ISO_CELL(sym)] giving the font
+ *   position. Use this if more than 31 font postions map to this row.
+ * * else cellinfo[row] points to an array kgi_font_cellinfo's, sorted
+ *   in ascending order of cellinfo.sym and the first giving total
+ *   number of cells and highest cell assigned.
+ */
+
+typedef struct {
+	kgi_isochar_t	sym;
+	kgi_u_t		pos;
+} kgi_console_font_cellinfo_t;
+
+typedef struct {
+	kgi_u_t		positions;	/* number of positions defined	*/
+	kgi_u_t		default_pos;	/* position to use as default	*/
+	__kgi_phys_addr_t	map_direct[8];
+	void		*cellinfo[256];	/* map info isochar->fontpos	*/
+	kgi_isochar_t	inversemap[256];/* map info fontpos->isochar	*/
+} kgi_console_font_info_t;
+
+typedef struct {
+	kgi_ucoord_t	size;		/* distance between char's	*/
+	kgi_ucoord_t	bitmap;		/* bitmap size			*/
+	kgi_u_t		base;		/* base line			*/
+
+	kgi_console_font_info_t *info;	/* font info			*/
+	kgi_u8_t	*data;		/* font data			*/
+} kgi_console_font_t;
+
+extern kgi_console_font_t *	default_font[CONFIG_KGII_MAX_NR_DEFFONTS];
+
+#endif	/* #ifndef _kgc_isorndr_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_kgirndr.c sys/dev/kgc/kgc_kgirndr.c
--- sys/dev/kgc/kgc_kgirndr.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_kgirndr.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,287 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI rendering
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_ATOMIC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_kgirndr.h>
+#include <dev/kgc/kgc_backgnd.h>
+
+#include "render_if.h"
+
+/*
+ * color mode attribute to pixel value mapping. We care of the foreground
+ * and background colors. The rest is just best effort.
+ */
+kgi_u_t 
+kgirndr_atop_color(render_t r, kgi_u_t attr)
+{
+	register kgi_u_t val = (attr & KGI_CA_REVERSE)
+		? (((attr & 0x0007) << 8) | ((attr & 0x0700) << 4))
+		: (((attr & 0x0007) << 12) | (attr & 0x0700));
+
+	if (attr & KGI_CA_BLINK) 
+		val |= 0x8000;
+
+	if (attr & KGI_CA_BOLD) 
+		val |= 0x0800;
+
+	return (val);
+}
+
+kgi_u_t 
+kgirndr_ptoa_color(render_t r, kgi_u_t val)
+{
+
+	return (((val & 0x8000) ? KGI_CA_BLINK : KGI_CA_NORMAL)
+		| ((val & 0x0800) ? KGI_CA_BOLD  : KGI_CA_NORMAL)
+		| ((val & 0x7000) >> 12) | (val & 0x0F00));
+}
+
+/*
+ * monochrome attribute mapping. We care about the attributes possible
+ * and ignore colors.
+ */
+kgi_u_t 
+kgirndr_atop_mono(kgi_u_t attr)
+{
+	register kgi_u_t
+	val = (attr & KGI_CA_UNDERLINE)
+		? 0x0100	/* MDA can't do reverse underline :-( */
+		: ((attr & KGI_CA_REVERSE) ? 0x7000 : 0x0700);
+
+	if (attr & KGI_CA_BLINK) 
+		val |= 0x8000;
+
+	if (attr & KGI_CA_BOLD) 
+		val |= 0x0800;
+
+	return (val);
+}
+
+kgi_u_t 
+kgirndr_ptoa_mono(render_t r, kgi_u_t val)
+{
+	register kgi_u_t
+	attr = ((val & 0x7700) == 0x0100)
+		? KGI_CA_UNDERLINE
+		: (val & 0x7000) ? KGI_CA_REVERSE : KGI_CA_NORMAL;
+
+	if (val & 0x8000) 
+		attr |= KGI_CA_BLINK;
+
+	if (val & 0x0800) 
+		attr |= KGI_CA_BOLD;
+
+	return (attr);
+}
+
+static void
+kgirndr_parse_resource(kgirndr_meta *render, kgi_resource_t *resource)
+{
+	kgi_marker_t *marker;
+
+	switch (resource->type) {
+	case KGI_RT_MMIO_FRAME_BUFFER:
+		KRN_DEBUG(2, "mmio fb: %s", resource->name);
+		render->fb = (kgi_mmio_region_t *) resource;
+		break;
+	case KGI_RT_TEXT16_CONTROL:
+		KRN_DEBUG(2, "text16: %s", resource->name);
+		render->text16 = (kgi_text16_t *) resource;
+		break;
+	case KGI_RT_CURSOR_CONTROL:
+		marker = (kgi_marker_t *) resource;
+		if ((NULL == render->cur) ||
+		    (render->cur->Undo && (NULL == marker->Undo))) {
+			KRN_DEBUG(2, "cursor: %s", resource->name);
+			render->cur = marker;
+		}
+		break;
+	case KGI_RT_POINTER_CONTROL:
+		marker = (kgi_marker_t *) resource;
+		if ((NULL == render->ptr) ||
+		    (render->ptr->Undo && (NULL == marker->Undo))) {
+			KRN_DEBUG(2, "pointer: %s", resource->name);
+			render->ptr = marker;
+		}
+		break;
+	case KGI_RT_TLUT_CONTROL:
+		KRN_DEBUG(2, "tlut: %s", resource->name);
+		render->tlut = (kgi_tlut_t *) resource;
+		break;
+	case KGI_RT_ILUT_CONTROL:
+		KRN_DEBUG(2, "ilut: %s", resource->name);
+		render->ilut = (kgi_ilut_t *) resource;
+		break;
+	default:
+		KRN_ERROR("unknown resource->type 0x%.8x", resource->type);
+		break;
+	}
+
+	return;
+} 
+
+kgi_error_t 
+kgirndr_init(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+	kgi_resource_t *resource;
+	kgi_u_t	index;
+
+	/* Parse global resources */
+	for (index = 0; index < __KGI_MAX_NR_IMAGE_RESOURCES; index ++) {
+		if ((resource = render->kgi.mode->resource[index]))
+			kgirndr_parse_resource(render, resource);
+	}
+
+	/*
+	 * Parse per-image resources, eventually overwritting
+	 * global resources.
+	 */
+	for (index = 0; index < __KGI_MAX_NR_IMAGE_RESOURCES; index ++) {
+		if ((resource = render->kgi.mode->img[0].resource[index]))
+			kgirndr_parse_resource(render, resource);
+	}
+
+	return (KGI_EOK);
+}
+
+void 
+kgirndr_hide_gadgets(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+	kgi_console_t *cons = kgc_render_cons(r);
+
+	if (cons->flags & KGI_CF_POINTER_SHOWN) {
+		KRN_ASSERT(render->ptr);
+		render->ptr->Hide(render->ptr);
+		cons->flags &= ~KGI_CF_POINTER_SHOWN;
+	}
+	if (cons->flags & KGI_CF_CURSOR_SHOWN) {
+		KRN_ASSERT(render->cur);
+		render->cur->Hide(render->cur);
+		cons->flags &= ~KGI_CF_CURSOR_SHOWN;
+	}
+}
+
+void 
+kgirndr_undo_gadgets(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+	kgi_console_t *cons = kgc_render_cons(r);
+
+	if ((cons->flags & KGI_CF_POINTER_SHOWN) && render->ptr->Undo) {
+		render->ptr->Undo(render->ptr);
+		cons->flags &= ~KGI_CF_POINTER_SHOWN;
+	}
+	if ((cons->flags & KGI_CF_CURSOR_SHOWN) && render->cur->Undo) {
+		render->cur->Undo(render->cur);
+		cons->flags &= ~KGI_CF_CURSOR_SHOWN;
+	}
+}
+
+void 
+kgirndr_show_gadgets(render_t r, kgi_u_t x, kgi_u_t y, kgi_u_t offset)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+	kgi_console_t *cons = kgc_render_cons(r);
+
+	kgirndr_undo_gadgets(r);
+
+	if ((render->kgi.flags & KGI_DF_FOCUSED) &&
+		(cons->kii.flags & KII_DF_FOCUSED) && !offset) {
+		if (CONSOLE_MODE(cons, KGI_CM_SHOW_CURSOR) && render->cur) {
+			cons->flags |= KGI_CF_CURSOR_SHOWN;
+			render->cur->Show(render->cur, x, y);
+		}
+		if (CONSOLE_MODE(cons, KGI_CM_SHOW_POINTER) && render->ptr) {
+			cons->flags |= KGI_CF_POINTER_SHOWN;
+			render->ptr->Show(render->ptr,
+				cons->kii.ptr.x, cons->kii.ptr.y);
+		}
+
+	} else {
+		KRN_ASSERT(! (cons->flags & KGI_CF_CURSOR_SHOWN));
+		KRN_ASSERT(! (cons->flags & KGI_CF_POINTER_SHOWN));
+	}
+}
+
+#ifdef notyet
+void 
+kgirndr_unmap(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+
+	render->flags &= ~KGI_RF_NEEDS_UPDATE;
+}
+
+void 
+kgirndr_map(render_t r)
+{
+	kgirndr_meta *render = kgc_render_meta(r);
+
+	render->flags |= KGI_RF_NEEDS_UPDATE;
+
+	if (render->ilut) {
+		if (render->ilut->Set) {
+			(render->ilut->Set)(render->ilut, NULL, 
+				    0, 256, KGI_AM_COLORS, (kgi_u16_t *)&render->palette);
+		}
+		if (render->ilut->Select)
+			(render->ilut->Select)(render->ilut, 0);
+	}
+	
+	kgirndr_meta *render = kgc_render_meta(r);
+	kgi_console_t *cons = kgc_render_cons(r);
+
+	if (render->tlut) {
+		if (render->tlut->Set) {
+			(render->tlut->Set)(render->tlut, 0, 
+				0, render->font->info->positions - 1,
+				render->font->data);
+		}
+		if (render->tlut->Select) 
+			(render->tlut->Select)(render->tlut, 0);
+	}
+	if (render->ptr && 
+		(render->ptr->modes & KGI_MM_3COLOR) &&
+		(render->ptr->size.x == 64 && render->ptr->size.y == 64)) {
+		(render->ptr->SetMode)(render->ptr, KGI_MM_3COLOR);
+		(render->ptr->SetShape)(render->ptr, 0, 
+			0,0, default_ptr_64x64, default_ptr_color);
+		if (render->ptr->Select) 
+			(render->ptr->Select)(render->ptr, 0);
+	}
+}
+#endif /* notyet */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_kgirndr.h sys/dev/kgc/kgc_kgirndr.h
--- sys/dev/kgc/kgc_kgirndr.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_kgirndr.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,46 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI rendering
+ */
+
+#ifndef _kgc_kgirndr_h
+#define	_kgc_kgirndr_h
+
+#define __KGC_KGIRNDR_DATA		\
+	kgi_device_t		kgi;	\
+	kgi_mode_t		mode;	\
+	kgi_u_t			flags;	\
+	kgi_mmio_region_t	*fb;	\
+	kgi_text16_t		*text16;\
+	kgi_ilut_t		*ilut;	\
+	kgi_tlut_t		*tlut;	\
+	kgi_marker_t		*cur;	\
+	kgi_marker_t		*ptr
+
+typedef struct {
+	/* Must be there if you use KGI resources interface */
+	__KGC_KGIRNDR_DATA;
+} kgirndr_meta;
+
+extern kgi_u_t kgirndr_atop_color(render_t r, kgi_u_t attr);
+extern kgi_u_t kgirndr_ptoa_color(render_t r, kgi_u_t val);
+extern kgi_u_t kgirndr_atop_mono(kgi_u_t attr);
+extern kgi_u_t kgirndr_ptoa_mono(render_t r, kgi_u_t val);
+extern kgi_error_t kgirndr_init(render_t r);
+extern void kgirndr_hide_gadgets(render_t r);
+extern void kgirndr_undo_gadgets(render_t r);
+extern void kgirndr_show_gadgets(render_t r, kgi_u_t x, kgi_u_t y, kgi_u_t offset);
+
+#endif	/*  _kgc_kgirndr_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_mapper.c sys/dev/kgc/kgc_mapper.c
--- sys/dev/kgc/kgc_mapper.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_mapper.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,85 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI console mapper
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+
+#include "scroller_if.h"
+#include "render_if.h"
+
+kii_s_t 
+kgc_unmap_kii(kii_device_t *dev)
+{
+	kgi_console_t *cons = dev->priv.priv_ptr;
+
+	if (cons && cons->render)
+		RENDER_HIDE_GADGETS((render_t)cons->render);
+
+	return (KII_EOK);
+}
+
+void 
+kgc_map_kii(kii_device_t *dev)
+{
+	kgi_console_t *cons = dev->priv.priv_ptr;
+
+	if (cons && cons->render)
+		RENDER_SHOW_GADGETS((render_t)cons->render, 0, 0, 0);
+}
+
+kgi_s_t 
+kgc_unmap_kgi(kgi_device_t *dev)
+{
+	kgi_console_t *cons = dev->priv.priv_ptr;
+
+	if (cons && cons->scroller)
+		SCROLLER_UNMAP((scroller_t)cons->scroller);
+	if (cons && cons->render)
+		RENDER_UNMAP((render_t)cons->render);
+
+	return (KGI_EOK);
+}
+
+void 
+kgc_map_kgi(kgi_device_t *dev)
+{
+	kgi_console_t *cons = dev->priv.priv_ptr;
+
+	/* Render mapped before scroller to enable scroller sync */
+	if (cons && cons->render)
+		RENDER_MAP((render_t)cons->render);
+	if (cons && cons->scroller)
+		SCROLLER_MAP((scroller_t)cons->scroller);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_render.c sys/dev/kgc/kgc_render.c
--- sys/dev/kgc/kgc_render.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_render.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,220 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGC core render.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_render.h>
+
+typedef struct {
+	int static_alloc;
+	render_t r;
+} render_alloc_t;
+
+typedef struct {
+	int static_alloc;
+	render_driver_t *drv;
+} driver_register_t;
+
+/*
+ * Render classes are registered to displays. Render instances are
+ * allocated to devices.
+ */
+static driver_register_t kgc_render_drivers[KGI_MAX_NR_DISPLAYS];
+static render_alloc_t  kgc_renders[KGI_MAX_NR_DEVICES];
+
+void 
+kgc_render_init(void)
+{
+
+	bzero(kgc_render_drivers, sizeof(kgc_render_drivers));
+	bzero(kgc_renders, sizeof(kgc_renders));
+}
+
+/*
+ * Allocate a new render instance. The driver (render class) has already been
+ * registered to the display.
+ * The render instance is assigned to the given KII consoles.
+ * If the render is statically allocated, then let the caller allocate the render
+ * meta.
+ */
+render_t 
+kgc_render_alloc(kgi_u_t devid, render_t static_render)
+{
+	render_t r;
+	kgi_u_t display;
+
+	/*
+	 * One can't allocated the console 0 'cause reserved to
+	 * boot messages and is allocated statically.
+	 */
+	if (!KII_VALID_CONSOLE_ID(devid))
+		return (NULL);
+
+	if (kgc_renders[devid].r) {
+		KRN_ERROR("Render already allocated to %d", devid);
+		return (NULL);
+	}
+
+	display = display_map[devid];
+
+	if (!kgc_render_drivers[display].drv) {
+		KRN_ERROR("No render class registered to display %d", display);
+		return (NULL);
+	}
+
+	if (!static_render) {
+		r = (render_t)kobj_create((kobj_class_t)kgc_render_drivers[display].drv,
+					  M_KGI, M_WAITOK);
+	} else 
+		r = static_render;
+	
+	if (!r) {
+		KRN_ERROR("Could not create render %d", devid);
+		return (NULL);
+	}
+
+	if (!static_render) {
+		if (!(r->meta = kgi_kmalloc(kgc_render_drivers[display].drv->size))) {
+			KRN_ERROR("Could not allocate render meta %d", devid);
+		}
+	}
+
+	kgc_renders[devid].r = r;
+	kgc_renders[devid].static_alloc = (static_render) ? 1 : 0;
+	r->devid = devid;
+
+	return (r);
+}
+
+void 
+kgc_render_release(kgi_u_t devid)
+{
+
+	if (!KII_VALID_CONSOLE_ID(devid))
+		return;
+
+	if (!kgc_renders[devid].r) {
+		KRN_ERROR("Render not allocated to %d", devid);
+		return;
+	}
+
+	if (!kgc_renders[devid].static_alloc) {
+		kgi_kfree(kgc_renders[devid].r->meta);
+		kobj_delete((kobj_t)kgc_renders[devid].r, M_KGI);
+	}
+
+	kgc_renders[devid].r = NULL;
+	kgc_renders[devid].static_alloc = 0;
+}
+
+kgi_error_t 
+kgc_render_register(render_driver_t *driver, kgi_u_t display,
+		kgi_u8_t already_allocated)
+{
+
+	if (!KGI_VALID_DISPLAY_ID(display) || !driver)
+		return (KGI_EINVAL);
+
+	if (kgc_render_drivers[display].drv) {
+		KRN_ERROR("Render driver already registered to display %d", display);
+		return (KGI_EINVAL);
+	}
+
+	if (!already_allocated) {
+		/* Compile the render class */
+		kobj_class_compile((kobj_class_t)driver);
+	} else 
+		kgc_render_drivers[display].static_alloc = 1;
+
+
+	/* Remember the render class for the display */
+	kgc_render_drivers[display].drv = driver;
+
+	return (KGI_EOK);
+}
+
+kgi_error_t 
+kgc_render_unregister(render_driver_t *driver)
+{
+	kgi_u_t i, display = -1;
+
+	if (!driver)
+		return (KGI_EOK);
+
+	/* All devices of the display shall have their render freed */
+	for (i = 0; KGI_VALID_DEVICE_ID(i); i++) {
+		if (kgc_render_drivers[display_map[i]].drv == driver) {
+			display = display_map[i];
+			if (kgc_renders[i].r) {
+				KRN_ERROR("At least a render still allocated to device %d", i);
+				return (KGI_EINVAL);
+			}
+		}
+	}
+
+	if (display != -1) {
+		/* Free the render class if not allocated statically */
+		if (!kgc_render_drivers[display].static_alloc)
+			kobj_class_free((kobj_class_t)driver);
+
+		kgc_render_drivers[display].drv = NULL;
+		kgc_render_drivers[display].static_alloc = 0;
+	}
+
+	return (KGI_EOK);
+}
+
+render_t 
+kgc_get_render(kgi_u_t devid)
+{
+
+	if (!KGI_VALID_CONSOLE_ID(devid))
+		return (NULL);
+
+	KRN_ASSERT(kgc_renders[devid].r->devid == devid);
+
+	return kgc_renders[devid].r;
+}
+
+void *
+kgc_render_meta(render_t r)
+{
+
+	return (r->meta);
+}
+
+kgi_console_t *
+kgc_render_cons(render_t r)
+{
+
+	return (r->cons);
+}
+
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_render.h sys/dev/kgc/kgc_render.h
--- sys/dev/kgc/kgc_render.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_render.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,80 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI console implementation specific definitions
+ */
+
+#ifndef _kgc_render_h
+#define	_kgc_render_h
+
+#define KGI_RF_NO_HARDSCROLL	0x00000001
+#define KGI_RF_TILE_Y		0x00000002
+#define KGI_RF_NEEDS_UPDATE	0x00000004
+
+typedef struct render		*render_t;
+typedef struct render_driver	render_driver_t;
+#define render_method_t	kobj_method_t
+
+struct render_driver {
+	KOBJ_CLASS_FIELDS;
+	render_driver_t	*previous;
+};
+
+#define RENDERMETHOD		KOBJMETHOD
+#define RENDERMETHOD_END	KOBJMETHOD_END
+
+struct render {
+	/*
+	 * A render is a kernel object. The first field must be the
+	 * current ops table for the object.
+	 */
+	KOBJ_FIELDS;
+
+	kgi_u_t		devid;
+	kgi_console_t	*cons;
+	void		*meta;
+};
+
+/*
+ * At the declaration, propose the backdoor for early initialization,
+ * when malloc is not yet ready.
+ */
+#define DECLARE_RENDER(name,driver,meta_type)					\
+	static meta_type console_meta;						\
+	static struct render console_render;					\
+	static struct kobj_ops render_ops;					\
+	void name##_configure(kgi_console_t *cons)				\
+	{									\
+		kobj_class_compile_static((kobj_class_t)&driver, &render_ops);	\
+		kobj_init((kobj_t)&console_render, (kobj_class_t)&driver);	\
+		console_render.meta = &console_meta;				\
+		console_render.cons = cons;					\
+		if (cons)							\
+			cons->render = &console_render;				\
+		kgc_render_register(&driver, 0, 1);				\
+		kgc_render_register(&driver, 2, 1);				\
+		kgc_render_alloc(0, &console_render);				\
+	}
+
+/* Register the render from first to last consoles. */
+extern void kgc_render_init(void);
+extern render_t kgc_get_render(kgi_u_t devid);
+extern render_t kgc_render_alloc(kgi_u_t devid, render_t r);
+extern void kgc_render_release(kgi_u_t devid);
+extern kgi_error_t kgc_render_register(render_driver_t *render, kgi_u_t display,
+				       kgi_u8_t already_allocated);
+extern kgi_error_t kgc_render_unregister(render_driver_t *driver);
+extern void *kgc_render_meta(render_t r);
+extern kgi_console_t *kgc_render_cons(render_t r);
+
+#endif	/* !_kgc_render_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_scroller.c sys/dev/kgc/kgc_scroller.c
--- sys/dev/kgc/kgc_scroller.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_scroller.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,220 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGC core scroller
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_scroller.h>
+
+typedef struct {
+	int static_alloc;
+	scroller_t s;
+} scroller_alloc_t;
+
+typedef struct {
+	int static_alloc;
+	scroller_driver_t *drv;
+} driver_register_t;
+
+/*
+ * Render classes are registered to displays. Render instances are
+ * allocated to devices.
+ */
+static driver_register_t kgc_scroller_drivers[KGI_MAX_NR_DISPLAYS];
+static scroller_alloc_t  kgc_scrollers[KGI_MAX_NR_DEVICES];
+
+void 
+kgc_scroller_init(void)
+{
+
+	bzero(kgc_scroller_drivers, sizeof(kgc_scroller_drivers));
+	bzero(kgc_scrollers, sizeof(kgc_scrollers));
+}
+
+/*
+ * Allocate a new scroller instance. The driver (scroller class) has already been
+ * registered to the display.
+ * The scroller instance is assigned to the given KII consoles.
+ * If the scroller is statically allocated, then let the caller allocate the scroller
+ * meta.
+ */
+scroller_t 
+kgc_scroller_alloc(kgi_u_t devid, scroller_t static_scroller)
+{
+	scroller_t s;
+	kgi_u_t display;
+
+	/*
+	 * One can't allocated the console 0 'cause reserved to
+	 * boot messages and is allocated statically.
+	 */
+	if (!KII_VALID_CONSOLE_ID(devid))
+		return (NULL);
+
+	if (kgc_scrollers[devid].s) {
+		KRN_ERROR("Render already allocated to %d", devid);
+		return (NULL);
+	}
+
+	display = display_map[devid];
+
+	if (!kgc_scroller_drivers[display].drv) {
+		KRN_ERROR("No scroller class registered to display %d", display);
+		return (NULL);
+	}
+
+	if (!static_scroller) {
+		s = (scroller_t)kobj_create((kobj_class_t)
+			kgc_scroller_drivers[display].drv, M_KGI, M_WAITOK);
+	} else
+		s = static_scroller;
+
+	if (!s) {
+		KRN_ERROR("Could not create scroller %d", devid);
+		return (NULL);
+	}
+
+	if (!static_scroller) {
+		if (!(s->meta = kgi_kmalloc(kgc_scroller_drivers[display].drv->size))) {
+			KRN_ERROR("Could not allocate scroller meta %d", devid);
+		}
+	}
+
+	kgc_scrollers[devid].s = s;
+	kgc_scrollers[devid].static_alloc = (static_scroller) ? 1 : 0;
+	s->devid = devid;
+
+	return (s);
+}
+
+void 
+kgc_scroller_release(kgi_u_t devid)
+{
+
+	if (!KII_VALID_CONSOLE_ID(devid))
+		return;
+
+	if (!kgc_scrollers[devid].s) {
+		KRN_ERROR("Render not allocated to %d", devid);
+		return;
+	}
+
+	if (!kgc_scrollers[devid].static_alloc) {
+		kgi_kfree(kgc_scrollers[devid].s->meta);
+		kobj_delete((kobj_t)kgc_scrollers[devid].s, M_KGI);
+	}
+
+	kgc_scrollers[devid].s = NULL;
+	kgc_scrollers[devid].static_alloc = 0;
+}
+
+kgi_error_t 
+kgc_scroller_register(scroller_driver_t *driver, kgi_u_t display,
+		kgi_u8_t already_allocated)
+{
+
+	if (!KGI_VALID_DISPLAY_ID(display) || !driver)
+		return (KGI_EINVAL);
+
+	if (kgc_scroller_drivers[display].drv) {
+		KRN_ERROR("Render driver already registered to display %d", display);
+		return (KGI_EINVAL);
+	}
+
+	if (!already_allocated) {
+		/* Compile the scroller class */
+		kobj_class_compile((kobj_class_t)driver);
+	} else {
+		kgc_scroller_drivers[display].static_alloc = 1;
+	}
+
+	/* Remember the scroller class for the display */
+	kgc_scroller_drivers[display].drv = driver;
+
+	return (KGI_EOK);
+}
+
+kgi_error_t 
+kgc_scroller_unregister(scroller_driver_t *driver)
+{
+	kgi_u_t i, display = -1;
+
+	if (!driver)
+		return (KGI_EOK);
+
+	/* All devices of the display shall have their scroller freed */
+	for (i = 0; KGI_VALID_DEVICE_ID(i); i++) {
+		if (kgc_scroller_drivers[display_map[i]].drv == driver) {
+			display = display_map[i];
+			if (kgc_scrollers[i].s) {
+				KRN_ERROR("At least a scroller still allocated to device %d", i);
+				return (KGI_EINVAL);
+			}
+		}
+	}
+
+	if (display != -1) {
+		/* Free the scroller class if not allocated statically */
+		if (!kgc_scroller_drivers[display].static_alloc)
+			kobj_class_free((kobj_class_t)driver);
+
+		kgc_scroller_drivers[display].drv = NULL;
+		kgc_scroller_drivers[display].static_alloc = 0;
+	}
+
+	return (KGI_EOK);
+}
+
+scroller_t 
+kgc_get_scroller(kgi_u_t devid)
+{
+
+	if (!KGI_VALID_CONSOLE_ID(devid))
+		return (NULL);
+
+	KRN_ASSERT(kgc_scrollers[devid].s->devid == devid);
+
+	return (kgc_scrollers[devid].s);
+}
+
+void *
+kgc_scroller_meta(scroller_t s)
+{
+
+	return (s->meta);
+}
+
+kgi_console_t *
+kgc_scroller_cons(scroller_t s)
+{
+
+	return (s->cons);
+}
+
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_scroller.h sys/dev/kgc/kgc_scroller.h
--- sys/dev/kgc/kgc_scroller.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_scroller.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,81 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI scroll generic implementation
+ */
+
+#ifndef _kgc_scroller_h
+#define	_kgc_scroller_h
+
+typedef struct scroller		*scroller_t;
+typedef struct scroller_driver	scroller_driver_t;
+#define scroller_method_t	kobj_method_t
+
+struct scroller_driver {
+	KOBJ_CLASS_FIELDS;
+	scroller_driver_t	*previous;
+};
+
+struct scroller {
+	/*
+	 * A scroller is a kernel object. The first field must be the
+	 * current ops table for the object.
+	 */
+	KOBJ_FIELDS;
+
+	kgi_u_t		devid;
+	kgi_console_t		*cons;
+	void			*meta;
+};
+
+#define SCROLLMETHOD		KOBJMETHOD
+#define SCROLLMETHOD_END	KOBJMETHOD_END
+
+/*
+ * At the declaration, propose the backdoor for early initialization,
+ * when malloc is not yet ready.
+ */
+#define DECLARE_SCROLLER(name,driver,meta_type)					\
+	static meta_type console_meta;						\
+	static struct scroller console_scroller;				\
+	static struct kobj_ops scroller_ops;					\
+	void name##_configure(kgi_console_t *cons)				\
+	{									\
+	kobj_class_compile_static((kobj_class_t)&driver, &scroller_ops);	\
+	kobj_init((kobj_t)&console_scroller, (kobj_class_t)&driver);		\
+	console_scroller.meta = &console_meta;					\
+	console_scroller.cons = cons;						\
+	if (cons)								\
+		cons->scroller = &console_scroller;				\
+	kgc_scroller_register(&driver, 0, 1);					\
+	kgc_scroller_register(&driver, 2, 1);					\
+	kgc_scroller_alloc(0, &console_scroller);				\
+	}
+
+/*
+ * Register the scroller from first to last consoles.
+ */
+extern void kgc_scroller_init(void);
+extern scroller_t kgc_get_scroller(kgi_u_t devid);
+extern scroller_t kgc_scroller_alloc(kgi_u_t devid, scroller_t s);
+extern void kgc_scroller_release(kgi_u_t devid);
+extern kgi_error_t kgc_scroller_register(scroller_driver_t *scroller, kgi_u_t display,
+				       kgi_u8_t already_allocated);
+extern kgi_error_t kgc_scroller_unregister(scroller_driver_t *driver);
+extern void *kgc_scroller_meta(scroller_t s);
+extern kgi_console_t *kgc_scroller_cons(scroller_t s);
+
+/* XXX FIXME */
+extern void textscroller_configure(kgi_console_t *cons);
+
+#endif	/* !_kgc_scroller_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_textbuf.c sys/dev/kgc/kgc_textbuf.c
--- sys/dev/kgc/kgc_textbuf.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_textbuf.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI text buffer implementation
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+
+/*
+ * text buffer operations
+ */
+
+void 
+tb_set(kgc_textbuf_t *tb, kgi_u_t src, kgi_u_t val, kgi_u_t cnt)
+{
+	kgi_u16_t *buf;
+
+	buf = tb->buf + src;
+	cnt--;
+	do {
+		buf[cnt] = val;
+	} while ((kgi_s_t) --cnt >= 0);
+}
+
+void 
+tb_move(kgc_textbuf_t *tb, kgi_u_t dst, kgi_u_t src, kgi_u_t cnt)
+{
+	char *tmp, *s;
+	void *dest = tb->buf + dst;
+	const void *source = tb->buf + src;
+	size_t count = sizeof(kgi_u16_t)*cnt;
+
+	if (dest <= source) {
+		tmp = (char *) dest;
+		s = (char *) source;
+		while (count--)
+			*tmp++ = *s++;
+	} else {
+		tmp = (char *) dest + count;
+		s = (char *) source + count;
+		while (count--)
+			*--tmp = *--s;
+	}
+}
+
+#ifdef not_used
+
+/* XXX Shall be provided by the render, not the scroller */
+static void 
+tb_invert(kgc_textbuf_t *tb, kgi_u_t start, kgi_u_t end)
+{
+	kgi_u16_t *buf;
+
+	buf = tb->buf + start;
+	while (start++ <= end) {
+		*buf = ((*buf) & 0x88FF) 
+			| (((*buf)<<4) & 0x7000) | (((*buf>>4)) & 0x0700);
+		buf++;
+	}
+}
+
+#endif /* not_used */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_textbuf.h sys/dev/kgc/kgc_textbuf.h
--- sys/dev/kgc/kgc_textbuf.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_textbuf.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,35 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI text buffer implementation
+ */
+#ifndef _kgc_textbuf_h
+#define _kgc_textbuf_h
+
+typedef struct {
+	kgi_u16_t	*buf;	/* background/scrollback buffer	*/
+
+	kgi_u_t		total;	/* total characters in buffer	*/
+	kgi_u_t		frame;	/* characters per visible frame	*/
+	kgi_ucoord_t	size;	/* visible size of buffer	*/
+	kgi_ucoord_t	virt;	/* virtual size of buffer	*/
+
+#define TBF_ALLOCATED	0x00000001
+	kgi_u_t		flags;	/* flags for the buffer         */
+} kgc_textbuf_t;
+
+extern void tb_set(kgc_textbuf_t *tb, kgi_u_t src, kgi_u_t val, kgi_u_t cnt);
+extern void tb_move(kgc_textbuf_t *tb, kgi_u_t dst, kgi_u_t src, kgi_u_t cnt);
+
+#endif /* _kgc_textbuf_h */
diff -x CVS -x .svn -aurpN sys/dev/kgc/kgc_textscroller.c sys/dev/kgc/kgc_textscroller.c
--- sys/dev/kgc/kgc_textscroller.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/kgc_textscroller.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,1178 @@
+/*
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI text scroller implementation.
+ */
+ 
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_ATOMIC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+
+#include "scroller_if.h"
+#include "render_if.h"
+
+#define	MAX_COLUMNS	160
+#define	MAX_TAB_STOPS	MAX_COLUMNS/(8*sizeof(unsigned long))
+
+typedef struct {
+	/* the scroller textbuffer */
+	kgc_textbuf_t	tb;		/* interface with the renders */
+
+	/* miscellaneous scroller variables */
+	kgi_u_t		from, to;
+	kgi_u_t		offset;
+	kgi_u_t		last_offset;
+	kgi_u_t		top, bottom;
+	kgi_u_t		origin;
+	kgi_u_t		org;
+	kgi_u_t		x,y,s_x,s_y;
+	kgi_u_t		wpos;
+	kgi_u_t		pos;
+	kgi_u_t		mark;
+
+	unsigned long	tab_stop[MAX_TAB_STOPS];
+
+	/* attributes */
+	kgi_u_t		attrfl,s_attrfl;	/* global (default) kgi attribute */
+	kgi_u_t		attr;		/* global (default) pixel attribute */
+	kgi_u_t		erase;		/* erase pixel + attribute */
+} textscroller_meta;
+
+static void 
+textscroller_mark(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	
+	scroll->mark = scroll->wpos;
+}
+
+static void 
+textscroller_modified(scroller_t s, kgi_u_t from, kgi_u_t to)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	KRN_ASSERT(from <= to);
+
+	if (from < scroll->from) 
+		scroll->from = from;
+
+	if (scroll->to < to) 
+		scroll->to = to;
+}
+
+static void 
+textscroller_modified_mark(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	if (scroll->mark != scroll->wpos)
+		textscroller_modified(s, scroll->mark, scroll->wpos);
+}
+
+static void 
+textscroller_modified_wrap(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_modified(s, scroll->mark, scroll->wpos+1);
+}
+
+static void 
+textscroller_update_attr(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	scroll->erase = scroll->attr = RENDER_ATOP(cons->render, scroll->attrfl);
+	scroll->erase |= RENDER_CTOP(cons->render, 0x20);
+}
+
+static void
+textscroller_cr(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	RENDER_UNDO_GADGETS(cons->render);
+
+	scroll->wpos -= scroll->x;
+	scroll->pos -= scroll->x;
+	scroll->x = 0;
+
+	RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y, scroll->offset);
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+static void 
+textscroller_write(scroller_t s, kgi_isochar_t c)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	scroll->tb.buf[scroll->pos] = scroll->attr | RENDER_CTOP(cons->render, c);
+
+	if (scroll->x == (scroll->tb.size.x - 1)) {
+		cons->flags |= KGI_CF_NEED_WRAP;
+		return;
+	}
+
+	scroll->x++;
+	scroll->wpos++;
+	scroll->pos++;
+}
+
+/*
+ * textscroller_sync() has to sync the display with the scroller state. The
+ * scroller keeps track of the area modified. If there were any 
+ * modifications since the last textscroller_sync(), the area from cons->from
+ * cons->to contained in the currently displayed area needs to be updated.
+ */
+static void 
+textscroller_sync(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_s_t orig;
+	kgi_u_t render_flags;
+
+	KRN_ASSERT(cons);
+
+	RENDER_GET(cons->render, 0, 0, &render_flags);
+	if (! (render_flags & KGI_RF_NEEDS_UPDATE))
+		return;
+
+	orig = scroll->origin - scroll->offset;
+	if (orig < 0) {
+		if ((cons->flags & KGI_CF_NO_HARDSCROLL) ||
+			(!(cons->flags & KGI_CF_NO_HARDSCROLL) &&
+			(cons->flags & KGI_CF_SPLITLINE))) {
+				orig += scroll->tb.virt.y;
+		} else {
+			orig = 0;
+		}
+	}
+	KRN_ASSERT((kgi_u_t) orig < scroll->tb.virt.y);
+
+	if (cons->flags & KGI_CF_NO_HARDSCROLL) {
+		kgi_s_t frm = scroll->from;
+		kgi_s_t end = scroll->to;
+		kgi_s_t tb_total = scroll->tb.total;
+
+		kgi_s_t back = (orig *= scroll->tb.virt.x) + scroll->tb.frame;
+		kgi_u16_t *buf = scroll->tb.buf;
+
+		KRN_ASSERT(buf);
+
+		if (scroll->offset || (scroll->last_offset != scroll->offset) ||
+			(cons->flags & KGI_CF_SCROLLED)) {
+			frm = orig;
+			end = back;
+		}
+		cons->flags &= ~KGI_CF_SCROLLED;
+
+		if ((end < frm) || (end < orig) || (back < frm))
+			return;
+
+		if (frm < orig) 
+			frm = orig;
+
+		if (back < end) 
+			end = back;
+
+		RENDER_UNDO_GADGETS(cons->render);
+
+		if (frm < tb_total) {
+			if (tb_total >= end) {
+				RENDER_PUT_TEXT(cons->render, &scroll->tb, frm,
+						frm-orig, end-frm);
+			} else {
+				RENDER_PUT_TEXT(cons->render, &scroll->tb, frm,
+						frm-orig, tb_total-frm);
+
+				RENDER_PUT_TEXT(cons->render, &scroll->tb, 0,
+						tb_total-orig, end-tb_total);
+			}
+		} else {
+			RENDER_PUT_TEXT(cons->render, &scroll->tb, frm-tb_total,
+					frm-orig, end-frm);
+		}
+
+		RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y,
+				    scroll->offset);
+	} else {
+/*
+		if (cons->flags & KGI_CF_SCROLLED) {
+
+			cons->flags &= ~KGI_CF_SCROLLED;
+			kgidev_set_origin(&(cons->kgi), 0, 0, 
+				orig*cons->font->size.y);
+
+			if (cons->flags & KGI_CF_SPLITLINE) {
+
+				kgi_s_t split = cons->font->size.y *
+					((orig+scroll->tb.size.y < scroll->tb.virt.y)
+						? cons->text16.size.y
+						: scroll->tb.virt.y - orig);
+
+				kgidev_set_split(&(cons->kgi), split - 1);
+			}
+		}
+*/
+	}
+
+	scroll->last_offset = scroll->offset;
+	scroll->from = (kgi_u_t) -1L;
+	scroll->to   = 0;
+}
+
+/*
+ * cons->tb.buf may be set if allocated statically before calling
+ * textscroller_init()
+ */
+static kgi_s_t 
+textscroller_init(scroller_t s, kgi_u16_t *buffer)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_ucoord_t render_size, render_virt;
+
+	/* The buffer address may be passed in case of static allocation */
+	if (buffer) {
+		scroll->tb.buf = buffer;
+	} else {
+		if (!(scroll->tb.buf = kgi_kmalloc(CONFIG_KGII_CONSOLEBUFSIZE))) {
+			KRN_ERROR("text buffer allocation failed");
+			return (KGI_ENOMEM);
+		}
+		memset(scroll->tb.buf, 0, CONFIG_KGII_CONSOLEBUFSIZE);
+		scroll->tb.flags |= TBF_ALLOCATED;
+	}
+
+	RENDER_GET(cons->render, &render_size, &render_virt, 0);
+
+	scroll->tb.size.x = render_size.x;
+	scroll->tb.size.y = render_size.y;
+
+	scroll->tb.virt.x = render_size.x;
+	scroll->tb.virt.y = CONFIG_KGII_CONSOLEBUFSIZE / 
+		(sizeof(*scroll->tb.buf)*scroll->tb.virt.x);
+	if (scroll->tb.virt.y < 2*render_size.y) {
+		if ((scroll->tb.buf) && (scroll->tb.flags & TBF_ALLOCATED)) {
+			KRN_ERROR("text buffer too small, reset failed");
+			kgi_kfree(scroll->tb.buf);
+			scroll->tb.buf = NULL;
+		}
+		return (KGI_ENOMEM);
+	}
+
+	if (scroll->tb.virt.y < render_size.y) 
+		render_virt.y = scroll->tb.virt.y;
+
+	if (scroll->tb.virt.y > render_size.y) 
+		render_virt.y = scroll->tb.size.y;
+
+
+	RENDER_SET(cons->render, &render_size, &render_virt);
+
+	scroll->tb.frame = scroll->tb.virt.x * scroll->tb.size.y;
+	scroll->tb.total = scroll->tb.virt.x * scroll->tb.virt.y;
+
+	scroll->from = scroll->tb.total;
+	scroll->to = 0;
+	scroll->offset = scroll->last_offset = 0;
+
+	cons->flags |= KGI_CF_NO_HARDSCROLL;
+
+	CONSOLE_SET_MODE(cons, KGI_CM_SHOW_CURSOR);
+
+	KRN_ASSERT(render_size.x == scroll->tb.size.x);
+	KRN_ASSERT(render_size.y == scroll->tb.size.y);
+	KRN_ASSERT(render_virt.x == scroll->tb.virt.x);
+
+	KRN_DEBUG(4, "%ix%i (%ix%i virt) scroller initialized",
+		render_size.x, render_size.y,
+		render_virt.x, render_virt.y);
+
+	return (0);
+}
+
+#if 0
+static kgi_s_t textscroller_resize(scroller_t s, kgi_u_t new_sizex,
+	kgi_u_t new_sizey)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_u16_t *src, *dst;
+	kgi_u_t new_tb_sizey, i,j;
+
+	KRN_ASSERT(new_sizex);
+	KRN_ASSERT(new_sizey);
+
+	new_tb_sizey = CONFIG_KGII_CONSOLEBUFSIZE /
+		(sizeof(*scroll->tb.buf)*new_sizex);
+
+	if (new_tb_sizey < 2*new_sizey) {
+
+		KRN_DEBUG(1, "text buffer to small, resize failed")
+	}
+
+#warning finish!
+}
+#endif
+
+static void 
+textscroller_bs(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	RENDER_UNDO_GADGETS(cons->render);
+
+	if (scroll->x) {
+		scroll->x--;
+		scroll->wpos--;
+		scroll->pos--;
+		cons->flags &= ~KGI_CF_NEED_WRAP;
+	}
+
+	RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y, scroll->offset);
+}
+
+static void 
+textscroller_hts(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	scroll->tab_stop[scroll->x >> 5] |= (1 << (scroll->x & 31));
+}
+
+static void 
+textscroller_tbc(scroller_t s, kgi_u_t tab)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	if (!tab) {		
+		scroll->tab_stop[scroll->x >> 5] &= ~(1 << (scroll->x & 31));		
+	} else {
+		if (tab == 3) {			
+			scroll->tab_stop[0] =
+			scroll->tab_stop[1] =
+			scroll->tab_stop[2] =
+			scroll->tab_stop[3] =
+			scroll->tab_stop[4] = 0;
+		}
+	}
+}
+
+static void 
+textscroller_ht(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	RENDER_UNDO_GADGETS(cons->render);
+
+	scroll->pos -= scroll->x;
+	scroll->wpos -= scroll->x;
+	while (scroll->x < scroll->tb.size.x - 1) {		
+		scroll->x++;
+		if (scroll->tab_stop[scroll->x >> 5] &
+		    (1 << (scroll->x & 31))) {			
+			break;
+		}
+	}
+	scroll->pos  += scroll->x;
+	scroll->wpos += scroll->x;
+
+	RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y, scroll->offset);
+}
+
+static void 
+textscroller_mksound(scroller_t s, kgi_u_t pitch, kgi_u_t duration)
+{
+
+	KRN_DEBUG(3, "textscroller_mksound(%p, %i, %i) not implemented yet.",
+		  s, pitch, duration);
+}
+
+/*
+ * Scroll down n lines between t(op) and b(ottom) and clear the new top
+ * area using ERASE. If n is greater than b-t, we scroll only b-t lines.
+ * If bottom is more than SIZE_Y, bottom is less or equal top or n is zero
+ * we do nothing.
+ */
+static void 
+textscroller_down(scroller_t s, kgi_u_t t, kgi_u_t b, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_u_t src, dst, end;	/* first/last pixel to move	*/
+	kgi_u_t cnt;		/* size of area to clean	*/
+	kgi_u_t h1, h2;		/* subexpression		*/
+	kgi_u_t tb_total;		/* text buffer size		*/
+	kgc_textbuf_t *tb = &scroll->tb;
+
+	if ((scroll->tb.size.y < b) || (b <= t) || !n) 
+		return;
+
+	if (n > (b - t)) 
+		n = b - t;
+
+	end  = t + scroll->origin;
+	dst  = b + scroll->origin;
+	tb_total = scroll->tb.virt.x;
+	end *= tb_total;
+	dst *= tb_total;
+	cnt  = tb_total*n;
+	tb_total *= scroll->tb.virt.y;
+	src  = dst - cnt;
+
+	KRN_ASSERT((end <= src) && (src < dst));
+
+	textscroller_modified(s, end, dst);
+
+	if (src > end) {
+		if (end >= tb_total) {
+			dst -= tb_total;
+			src -= tb_total;
+			end -= tb_total;
+		}
+
+		if (dst <= tb_total) {
+			tb_move(tb, end + cnt, end, src - end);
+		} else {
+			if (src > tb_total) {
+				h1 = src - tb_total;
+				tb_move(tb, dst - src, 0, h1);
+				src -= h1;
+				dst -= h1;
+			}
+
+			h1 = dst - tb_total;
+			h2 = src - end;
+
+			if (h1 < h2) {
+				tb_move(tb, 0, src - h1, h1);
+				h2 -= h1;
+				tb_move(tb, tb_total - h2, end, h2);
+			} else {
+				tb_move(tb, dst - h2 - tb_total, end, h2);
+			}
+		}
+	}
+
+	/* clear top area */
+
+	if (end < tb_total) {
+		if (tb_total >= (end + cnt)) {
+			tb_set(tb, end, scroll->erase, cnt);
+
+		} else {
+			tb_set(tb, end, scroll->erase, tb_total - end);
+			tb_set(tb, 0, scroll->erase, end + cnt - tb_total);
+		}
+	} else {
+		tb_set(tb, end - tb_total, scroll->erase, cnt);
+	}
+}
+
+static void 
+textscroller_scroll_top(scroller_t s, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_down(s, scroll->y, scroll->bottom, n);
+}
+
+/*
+ * erase in line using ERASE. The area erased depends on arg. 
+ */
+static void 
+textscroller_erase_line(scroller_t s, kgi_u_t arg)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t src, cnt;
+
+	switch (arg) {
+	case 0:	/* from cursor to end of line	*/
+		src = scroll->wpos;
+		cnt = scroll->tb.virt.x - scroll->x;
+		break;
+	case 1:	/* from line start to cursor	*/
+		src = scroll->wpos - scroll->x;
+		cnt = scroll->x + 1;
+		break;
+	case 2:	/* erase entire line	*/
+		src = scroll->wpos - scroll->x;
+		cnt = scroll->tb.virt.x;
+		break;
+	default:
+		return;
+	}
+
+	textscroller_modified(s, src, src + cnt);
+
+	if (scroll->tb.total <= src) 
+		src -= scroll->tb.total;
+
+	tb_set(&scroll->tb, src, scroll->erase, cnt);
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+/* Insert n ERASE characters. */
+static void 
+textscroller_insert_chars(scroller_t s, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t src = scroll->wpos;
+	kgi_u_t cnt = scroll->tb.virt.x - scroll->x;
+
+	KRN_ASSERT((cnt > 0) && (n > 0));
+
+	textscroller_modified(s, src, src + cnt);
+
+	if (scroll->tb.total <= src) 
+		src -= scroll->tb.total;
+
+	if (n < cnt) {
+		tb_move(&scroll->tb, src + n, src, cnt - n);
+		cnt = n;
+	}
+
+	tb_set(&scroll->tb, src, scroll->erase, cnt);
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+
+/* Delete n characters. Clear the end of the line using ERASE. */
+static void 
+textscroller_delete_chars(scroller_t s, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t cnt = scroll->tb.virt.x - scroll->x;
+	kgi_u_t src = scroll->wpos;
+
+	textscroller_modified(s, src, src + cnt);
+
+	if (scroll->tb.total <= src) 
+		src -= scroll->tb.total;
+
+	if (n < cnt) {
+		tb_move(&scroll->tb, src, src + n, cnt - n);
+		tb_set(&scroll->tb, src + cnt - n, scroll->erase, n);
+	} else {
+		tb_set(&scroll->tb, src, scroll->erase, cnt);
+	}
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+
+/* erase the following n chars. (maximum is end of line). */
+static void 
+textscroller_erase_chars(scroller_t s, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	KRN_ASSERT(n > 0);
+	if (n > (scroll->tb.size.x - scroll->x)) {
+		n = scroll->tb.virt.x - scroll->x;
+	}
+
+	tb_set(&scroll->tb, scroll->pos, scroll->erase, n);
+	textscroller_modified(s, scroll->wpos, scroll->wpos + n);
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+/*
+ * Do a reverse linefeed. This means to scroll down one line if the cursor
+ * is at the top of the scrolling region or simply to move the cursor up
+ * one line.
+ */
+static void 
+textscroller_reverse_lf(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	RENDER_UNDO_GADGETS(cons->render);
+
+	if (scroll->y == scroll->top) {
+		textscroller_down(s, scroll->top, scroll->bottom, 1);
+	} else {
+		if (scroll->y > scroll->top) {
+			scroll->y--;
+			scroll->wpos -= scroll->tb.virt.x;
+
+			if (scroll->pos < scroll->tb.virt.x) {
+				scroll->pos += scroll->tb.total - scroll->tb.virt.x;
+			} else {
+				scroll->pos -= scroll->tb.virt.x;
+			}
+		}
+	}
+
+	RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y, scroll->offset);
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+static void 
+textscroller_done(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	if ((scroll->tb.buf) && (scroll->tb.flags & TBF_ALLOCATED)) {
+		kgi_kfree(scroll->tb.buf);
+		scroll->tb.buf = NULL;
+	}
+}
+
+/* Erase in display using ERASE. The area cleared depends on arg. */
+static void 
+textscroller_erase_display(scroller_t s, kgi_u_t arg)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t src, cnt = scroll->tb.frame;	/* area to erase	*/
+	kgi_u_t tb_total = scroll->tb.virt.x*scroll->tb.virt.y;
+
+	switch (arg) {
+	case 0:	/* from cursor to end of screen	*/
+		src = scroll->wpos;
+		cnt -= scroll->wpos - scroll->org;
+		break;
+	case 1:	/* from start of screen to cursor */
+		src = scroll->org;
+		cnt = scroll->wpos + 1 - scroll->org;
+		break;
+	case 2:	/* erase entire screen */
+		src = scroll->org;
+		break;
+	default:
+		return;
+	}
+
+	textscroller_modified(s, src, src + cnt);
+
+	if (src < tb_total) {
+		if (tb_total >= (src + cnt)) {
+			tb_set(&scroll->tb, src, scroll->erase, cnt);
+		} else {
+			tb_set(&scroll->tb, src, scroll->erase, tb_total-src);
+			tb_set(&scroll->tb, 0, scroll->erase, 
+				src + cnt - tb_total);
+		}
+	} else {
+		tb_set(&scroll->tb, src - tb_total, scroll->erase, cnt);
+	}
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+
+/* Move cursor to the specified position. We have to check all boundaries. */
+static void 
+textscroller_gotoxy(scroller_t s, kgi_s_t new_x, kgi_s_t new_y)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_s_t max_y, min_y;
+	kgi_s_t max_x;
+#define	min_x	0
+
+	RENDER_UNDO_GADGETS(cons->render);
+
+	if (CONSOLE_MODE(cons, KGI_CM_ORIGIN)) {
+		min_y = scroll->top;
+		max_y = scroll->bottom;
+	} else {
+		min_y = 0;
+		max_y = scroll->tb.size.y;
+	}
+
+	max_x = scroll->tb.size.x;
+	scroll->x = (new_x < min_x) ? min_x : ((new_x < max_x) ? new_x : max_x-1);
+	scroll->y = (new_y < min_y) ? min_y : ((new_y < max_y) ? new_y : max_y-1);
+
+	scroll->pos = scroll->wpos = scroll->org +
+		scroll->y*scroll->tb.virt.x + scroll->x;
+
+	if (scroll->tb.total <= scroll->pos) 
+		scroll->pos -= scroll->tb.total;
+
+	RENDER_SHOW_GADGETS(cons->render, scroll->x, scroll->y, scroll->offset);
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+static void 
+textscroller_gotox(scroller_t s, kgi_s_t x)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_gotoxy(s, x, scroll->y);
+}
+
+static void 
+textscroller_gotoy(scroller_t s, kgi_s_t y)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_gotoxy(s, scroll->x, y);
+}
+
+static void 
+textscroller_move(scroller_t s, kgi_s_t col, kgi_s_t lin)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_gotoxy(s, scroll->x + col, scroll->y + lin);
+}
+
+static void 
+textscroller_need_sync(scroller_t s)
+{
+	/* XXX mark_bh(CONSOLE_BH); */
+	return;
+}
+
+/*
+ * increase the scroll-back offset by <lines> lines. <lines> defaults to
+ * half the number of lines of the visible screen if less or equal zero. 
+ * As we may be called from a IRQ service, we do not sync the display
+ * because this may take some long time. We just mark the CONSOLE_BH and
+ * do syncing there.
+ */
+static void 
+textscroller_backward(scroller_t s, int lines)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t max = scroll->tb.virt.y - scroll->tb.size.y;
+
+	if (lines <= 0) 
+		lines = scroll->tb.size.y/2;
+
+	scroll->offset += lines;
+	if (scroll->offset > max) 
+		scroll->offset = max;
+
+	CONSOLE_CLEAR_MODE(cons, KGI_CM_SHOW_CURSOR);
+
+	cons->flags |= KGI_CF_SCROLLED;
+
+	textscroller_need_sync(s);
+}
+
+/*
+ * decrease the scroll-back offset by <lines> lines. <lines> defaults to
+ * half the number of lines of the visible screen if less or equal zero.
+ * As we may be called from an IRQ service, we do not sync the display
+ * because this may take some long time. We just mark the CONSOLE_BH
+ * and do syncing there.
+ */
+static void 
+textscroller_forward(scroller_t s, int lines)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	if (lines <= 0) 
+		lines = scroll->tb.size.y/2;
+
+	scroll->offset -= lines;
+	if (scroll->offset >= scroll->tb.total) 
+		scroll->offset = 0;
+
+	if (scroll->offset == 0) 
+		CONSOLE_SET_MODE(cons, KGI_CM_SHOW_CURSOR);
+
+	cons->flags |= KGI_CF_SCROLLED;
+
+	textscroller_need_sync(s);
+}
+
+/*
+ * Scroll up n lines between t(op) and b(ottom) and erase the 'new' bottom
+ * area using ERASE. If n is greater than b-t, we scroll only b-t lines.
+ * If bottom is more than SIZE_Y, bottom is less or equal top, or n is zero
+ * we do nothing.
+ */
+static void 
+textscroller_up(scroller_t s, kgi_u_t t, kgi_u_t b, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t src, end;	/* first and last pixel to move	*/
+	kgi_u_t clean, cnt;	/* first pixel/# pixels to clean*/ 
+	kgi_u_t dst;		/* pixel to move to		*/
+	kgi_u_t h1, h2;		/* temporary variables		*/
+	kgi_u_t tb_total;
+	kgc_textbuf_t *tb = &scroll->tb;
+
+	if ((scroll->tb.size.y < b) || (b <= t) || !n) 
+		return;
+
+	if (n > (b - t)) 
+		n = b - t;
+
+	dst  = t + scroll->origin;
+	end  = b + scroll->origin;
+
+	tb_total = scroll->tb.virt.x;
+
+	dst *= tb_total;
+	end *= tb_total;
+
+	cnt  = n*tb_total;
+	tb_total *= scroll->tb.virt.y;
+	src  = dst + cnt;
+
+	KRN_ASSERT((dst < src) && (src <= end));
+
+	if (CONSOLE_MODE(cons, KGI_CM_ALT_SCREEN) || t || (b < scroll->tb.size.y)) {
+		/* can't use origin adjustment */
+		textscroller_modified(s, dst, end);
+
+		if (end <= src) {
+			clean = dst;
+		} else {
+			clean = end - cnt;
+
+			if (dst >= tb_total) {
+				dst -= tb_total;
+				src -= tb_total;
+				end -= tb_total;
+			}
+
+			KRN_ASSERT(dst < tb_total);
+
+			if (end <= tb_total) {
+				tb_move(tb, dst, src, end - src);
+			} else {
+				if (src < tb_total) {
+					h1 = tb_total - src;
+					tb_move(tb, dst, src, h1);
+					src += h1;
+					dst += h1;
+				}
+
+				h1 = tb_total - dst;
+				h2 = end - src;
+
+				KRN_ASSERT((h1 > 0) && (h2 > 0));
+
+				if (h1 < h2) {
+					tb_move(tb, dst, src - tb_total, h1);
+					tb_move(tb, 0, src - dst, h2 - h1);
+				} else {
+					tb_move(tb, dst, src - tb_total, h2);
+				}
+			}
+		}
+
+	} else {
+
+		/* adjust origin */
+
+		cons->flags |= KGI_CF_SCROLLED;
+
+		if (scroll->offset) {
+			scroll->offset += n;
+			if (scroll->offset > (scroll->tb.virt.y - scroll->tb.size.y)) {
+				scroll->offset = 0;
+			}
+		}
+
+		scroll->origin += n;
+		scroll->org    += cnt;
+		scroll->wpos   += cnt;
+		scroll->pos    += cnt;
+
+		if (tb_total <= scroll->pos) 
+			scroll->pos -= tb_total;
+
+		if (tb_total <= scroll->org) {
+			scroll->org	-= tb_total;
+			scroll->wpos	-= tb_total;
+			scroll->origin	-= scroll->tb.virt.y;
+		}
+		clean = scroll->org + scroll->tb.frame - cnt;
+	}
+
+	/* clear bottom area */
+	textscroller_modified(s, clean, clean + cnt);
+
+	if (clean < tb_total) {
+		if (tb_total >= (clean + cnt)) {
+			tb_set(tb, clean, scroll->erase, cnt);
+		} else {
+			tb_set(tb, clean, scroll->erase, tb_total - clean);
+			tb_set(tb, 0, scroll->erase, clean + cnt - tb_total);
+		}
+	} else {
+		tb_set(tb, clean - tb_total, scroll->erase, cnt);
+	}
+}
+
+static void 
+textscroller_scroll_bottom(scroller_t s, kgi_u_t n)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	textscroller_up(s, scroll->y, scroll->bottom, n);
+}
+
+/*
+ * Do a linefeed. This means to scroll up one line if the cursor is at
+ * the bottom line of the scrolling region or simply to move the cursor
+ * down one line.
+ */
+static void 
+textscroller_lf(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	if ((scroll->y + 1) == scroll->bottom) {
+		textscroller_up(s, scroll->top, scroll->bottom, 1);
+	} else {
+		if (scroll->y < (scroll->tb.size.y - 1)) {
+			scroll->y++;
+			scroll->wpos += scroll->tb.virt.x;
+			scroll->pos  += scroll->tb.virt.x;
+
+			if (scroll->tb.total <= scroll->pos) {
+				scroll->pos -= scroll->tb.total;
+			}
+		}
+	}
+
+	cons->flags &= ~KGI_CF_NEED_WRAP;
+}
+
+static void 
+textscroller_reset(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	CONSOLE_SET_MODE(cons, KGI_CM_SHOW_CURSOR);
+	CONSOLE_SET_MODE(cons, KGI_CM_AUTO_WRAP);
+
+	scroll->tab_stop[0] = 0x01010100;
+	scroll->tab_stop[1] = scroll->tab_stop[2] = scroll->tab_stop[3] =
+		scroll->tab_stop[4] = 0x01010101;
+
+	scroll->origin = scroll->org = scroll->top = 0;
+	scroll->bottom = scroll->tb.size.y;
+
+	scroll->attrfl = KGI_CA_NORMAL | 
+		KGI_CA_COLOR(KGI_CC_LIGHTGRAY, KGI_CC_BLACK);
+}
+
+static void 
+textscroller_get(scroller_t s, kgi_ucoord_t *size, kgi_u_t *top,
+		kgi_u_t *bottom, kgi_u_t *x, kgi_u_t *y, kgi_u_t *attrfl,
+		kgi_u_t *erase)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	if (size) {
+		size->x = scroll->tb.size.x;
+		size->y = scroll->tb.size.y;
+	}
+
+	if (top && bottom) {
+		*top = scroll->top;
+		*bottom = scroll->bottom;
+	}
+
+	if (x && y) {
+		*x = scroll->x;
+		*y = scroll->y;
+	}
+
+	if (attrfl) 
+		*attrfl = scroll->attrfl;
+
+	if (erase) 
+		*erase = scroll->erase;
+}
+
+static void 
+textscroller_set(scroller_t s, kgi_u_t attrfl, kgi_u_t erase)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	scroll->attrfl = attrfl;
+	scroll->erase = erase;
+}
+
+static void 
+textscroller_margins(scroller_t s, kgi_u_t top, kgi_u_t bottom)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	if (!top) 	
+		top ++;
+
+	if (!bottom) 		
+		bottom = scroll->tb.size.y;
+	
+	/* Minimum allowed region is 2 lines */
+	if ((top < bottom) && (bottom <= scroll->tb.size.y)) {		
+		scroll->top    = top - 1;
+		scroll->bottom = bottom;
+		textscroller_gotoxy(s, 0, 0);
+	}
+}
+	
+static void 
+textscroller_save(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	scroll->s_x = scroll->x;
+	scroll->s_y = scroll->y;
+	scroll->s_attrfl = scroll->attrfl;
+}
+
+static void 
+textscroller_restore(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+
+	scroll->x = scroll->s_x;
+	scroll->y = scroll->s_y;
+	scroll->attrfl = scroll->s_attrfl;	
+
+	textscroller_gotoxy(s, scroll->x, scroll->y);
+}
+
+static void 
+textscroller_unmap(scroller_t s)
+{
+	kgi_console_t *cons = kgc_scroller_cons(s);
+
+	cons->flags |=  KGI_CF_SPLITLINE;
+	cons->flags &= ~KGI_CF_NO_HARDSCROLL;
+}
+
+static void 
+textscroller_map(scroller_t s)
+{
+	textscroller_meta *scroll = kgc_scroller_meta(s);
+	kgi_console_t *cons = kgc_scroller_cons(s);
+	kgi_u_t render_flags = 0;
+
+	RENDER_GET(cons->render, 0, 0, &render_flags);
+	if (render_flags & KGI_RF_NO_HARDSCROLL) {
+		kgi_s_t org = scroll->origin - scroll->offset;
+		if (org < 0) 
+			org += scroll->tb.virt.y;
+
+		KRN_ASSERT((0 <= org && org) < scroll->tb.virt.y);
+		KRN_DEBUG(3, "using softscroll");
+
+		cons->flags |= KGI_CF_NO_HARDSCROLL | KGI_CF_SPLITLINE;
+		org *= scroll->tb.virt.x;
+		textscroller_modified(s, org, org + scroll->tb.frame);
+	} else {
+		cons->flags &= ~KGI_CF_NO_HARDSCROLL;
+
+		if (render_flags & KGI_RF_TILE_Y) {
+			cons->flags |= KGI_CF_SPLITLINE;
+			KRN_DEBUG(1, "hardscroll & splitline");
+		} else {
+			cons->flags &= ~KGI_CF_SPLITLINE;
+			KRN_DEBUG(1, "hardscroll only");
+		}
+		KRN_ASSERT(scroll->tb.buf);
+
+		RENDER_PUT_TEXT(cons->render, &scroll->tb, 0, 0, scroll->tb.total);
+	}
+	textscroller_sync(s);
+}
+
+static scroller_method_t textscroller_methods[] = {
+	SCROLLMETHOD(scroller_init,		textscroller_init),
+	SCROLLMETHOD(scroller_done,		textscroller_done),
+	SCROLLMETHOD(scroller_get,		textscroller_get),
+	SCROLLMETHOD(scroller_set,		textscroller_set),
+	SCROLLMETHOD(scroller_margins,		textscroller_margins),
+	SCROLLMETHOD(scroller_map,		textscroller_map),
+	SCROLLMETHOD(scroller_unmap,		textscroller_unmap),
+	SCROLLMETHOD(scroller_reset,		textscroller_reset),
+	SCROLLMETHOD(scroller_erase_display,	textscroller_erase_display),
+	SCROLLMETHOD(scroller_gotoxy,		textscroller_gotoxy),
+	SCROLLMETHOD(scroller_backward,		textscroller_backward),
+	SCROLLMETHOD(scroller_forward,		textscroller_forward),
+	SCROLLMETHOD(scroller_update_attr,	textscroller_update_attr),
+	SCROLLMETHOD(scroller_cr,		textscroller_cr),
+	SCROLLMETHOD(scroller_lf,		textscroller_lf),
+	SCROLLMETHOD(scroller_bs,		textscroller_bs),
+	SCROLLMETHOD(scroller_hts,		textscroller_hts),
+	SCROLLMETHOD(scroller_tbc,		textscroller_tbc),
+	SCROLLMETHOD(scroller_ht,		textscroller_ht),
+	SCROLLMETHOD(scroller_write,		textscroller_write),
+	SCROLLMETHOD(scroller_sync,		textscroller_sync),
+	SCROLLMETHOD(scroller_mark,		textscroller_mark),
+	SCROLLMETHOD(scroller_modified_mark,	textscroller_modified_mark),
+	SCROLLMETHOD(scroller_modified_wrap,	textscroller_modified_wrap),
+	SCROLLMETHOD(scroller_mksound,		textscroller_mksound),
+	SCROLLMETHOD(scroller_erase_line,	textscroller_erase_line),
+	SCROLLMETHOD(scroller_insert_chars,	textscroller_insert_chars),
+	SCROLLMETHOD(scroller_delete_chars,	textscroller_delete_chars),
+	SCROLLMETHOD(scroller_erase_chars,	textscroller_erase_chars),
+	SCROLLMETHOD(scroller_reverse_lf,	textscroller_reverse_lf),
+	SCROLLMETHOD(scroller_down,		textscroller_down),
+	SCROLLMETHOD(scroller_up,		textscroller_up),
+	SCROLLMETHOD(scroller_move,		textscroller_move),
+	SCROLLMETHOD(scroller_scroll_top,	textscroller_scroll_top),
+	SCROLLMETHOD(scroller_scroll_bottom,	textscroller_scroll_bottom),
+	SCROLLMETHOD(scroller_gotox,		textscroller_gotox),
+	SCROLLMETHOD(scroller_gotoy,		textscroller_gotoy),
+	SCROLLMETHOD(scroller_save,		textscroller_save),
+	SCROLLMETHOD(scroller_restore,		textscroller_restore),
+	SCROLLMETHOD_END
+};
+
+static scroller_driver_t textscroller_driver = {
+	"textscroller",
+	textscroller_methods,
+	sizeof(textscroller_meta)
+};
+
+DECLARE_SCROLLER(textscroller, textscroller_driver, textscroller_meta);
diff -x CVS -x .svn -aurpN sys/dev/kgc/render_if.m sys/dev/kgc/render_if.m
--- sys/dev/kgc/render_if.m	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/render_if.m	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,121 @@
+#-
+# Copyright (C) 2003 Nicholas Souchu
+#
+# This file is distributed under the terms and conditions of the 
+# MIT/X public license. Please see the file COPYRIGHT.MIT included
+# with this software for details of these terms and conditions.
+# Alternatively you may distribute this file under the terms and
+# conditions of the GNU General Public License. Please see the file 
+# COPYRIGHT.GPL included with this software for details of these terms
+# and conditions.
+
+#
+# KGC renderer interface
+#
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_render.h>
+
+INTERFACE render;
+
+METHOD kgi_s_t init {
+	render_t r;
+	kgi_u_t devid;
+};
+
+METHOD void done {
+	render_t r;
+};
+
+METHOD void map {
+	render_t r;
+};
+
+METHOD void unmap {
+	render_t r;
+};
+
+METHOD void get {
+	render_t r;
+	kgi_ucoord_t *size;
+	kgi_ucoord_t *virt;
+	kgi_u_t *flags;
+};
+
+METHOD void set {
+	render_t r;
+	kgi_ucoord_t *size;
+	kgi_ucoord_t *virt;
+};
+
+METHOD int put_text {
+	render_t r;
+	kgc_textbuf_t *tb;
+	kgi_u_t start;
+	kgi_u_t offset;
+	kgi_u_t count;
+};
+
+METHOD kgi_u_t atop {
+	render_t r;
+	kgi_u_t attr;
+};
+
+METHOD kgi_u_t ptoa {
+	render_t r;
+	kgi_u_t val;
+};
+
+METHOD kgi_isochar_t ptoc {
+	render_t r;
+	kgi_u_t pos;
+};
+
+METHOD kgi_u_t ctop {
+	render_t r;
+	kgi_isochar_t sym;
+};
+
+METHOD void hide_gadgets {
+	render_t r;
+};
+
+METHOD void undo_gadgets {
+	render_t r;
+};
+
+METHOD void show_gadgets {
+	render_t r;
+	kgi_u_t x;
+	kgi_u_t y;
+	kgi_u_t offset;
+};
+
+METHOD void load_font {
+	render_t r;
+	kgi_u_t page;
+	kgi_u_t size;
+	kgi_u8_t *data;
+	kgi_u_t ch;
+	kgi_s_t count;
+};
+
+METHOD void save_font {
+	render_t r;
+	kgi_u_t page;
+	kgi_u_t size;
+	kgi_u8_t *data;
+	kgi_u_t ch;
+	kgi_s_t count;
+};
+
+METHOD void show_font {
+	render_t r;
+	kgi_u_t page;
+};
diff -x CVS -x .svn -aurpN sys/dev/kgc/scroller_if.m sys/dev/kgc/scroller_if.m
--- sys/dev/kgc/scroller_if.m	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgc/scroller_if.m	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,217 @@
+#-
+# Copyright (C) 2003 Nicholas Souchu
+#
+# This file is distributed under the terms and conditions of the 
+# MIT/X public license. Please see the file COPYRIGHT.MIT included
+# with this software for details of these terms and conditions.
+# Alternatively you may distribute this file under the terms and
+# conditions of the GNU General Public License. Please see the file 
+# COPYRIGHT.GPL included with this software for details of these terms
+# and conditions.
+
+#
+# KGC scroller interface
+#
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_scroller.h>
+
+INTERFACE scroller;
+
+METHOD kgi_s_t init {
+	scroller_t s;
+	kgi_u16_t *buffer;
+};
+
+METHOD void done {
+	scroller_t s;
+};
+
+METHOD void get {
+	scroller_t s;
+	kgi_ucoord_t *size;
+	kgi_u_t *top;
+	kgi_u_t *bottom;
+	kgi_u_t *x;
+	kgi_u_t *y;
+	kgi_u_t *attrfl;
+	kgi_u_t *erase;
+};
+
+METHOD void set {
+	scroller_t s;
+	kgi_u_t attrfl;
+	kgi_u_t erase;
+};
+
+METHOD void margins {
+	scroller_t s;
+	kgi_u_t top;
+	kgi_u_t bottom;
+};
+
+METHOD void map {
+	scroller_t s;
+};
+
+METHOD void unmap {
+	scroller_t s;
+};
+
+METHOD void reset {
+	scroller_t s;
+};
+
+METHOD void erase_display {
+	scroller_t s;
+	kgi_u_t arg;
+};
+
+METHOD void gotoxy {
+	scroller_t s;
+	kgi_s_t x;
+	kgi_s_t y;
+};
+
+METHOD void backward {
+	scroller_t s;
+	kgi_s_t lines;
+};
+
+METHOD void forward {
+	scroller_t s;
+	kgi_s_t lines;
+};
+
+METHOD void update_attr {
+	scroller_t s;
+};
+
+METHOD void bs {
+	scroller_t s;
+};
+
+METHOD void hts {
+	scroller_t s;
+};
+
+METHOD void tbc {
+	scroller_t s;
+	kgi_u_t tab;
+};
+
+METHOD void ht {
+	scroller_t s;
+};
+
+METHOD void lf {
+	scroller_t s;
+};
+
+METHOD void cr {
+	scroller_t s;
+};
+
+METHOD void sync {
+	scroller_t s;
+};
+
+METHOD void write {
+	scroller_t s;
+	kgi_isochar_t c;
+};
+
+METHOD void mark {
+	scroller_t s;
+};
+
+METHOD void modified_mark {
+	scroller_t s;
+};
+
+METHOD void modified_wrap {
+	scroller_t s;
+};
+
+METHOD void mksound {
+	scroller_t s;
+	kgi_u_t pitch;
+	kgi_u_t duration;
+};
+
+METHOD void erase_line {
+	scroller_t s;
+	kgi_u_t arg;
+};
+
+METHOD void insert_chars {
+	scroller_t s;
+	kgi_u_t n;
+};
+
+METHOD void delete_chars {
+	scroller_t s;
+	kgi_u_t n;
+};
+
+METHOD void erase_chars {
+	scroller_t s;
+	kgi_u_t n;
+};
+
+METHOD void reverse_lf {
+	scroller_t s;
+};
+
+METHOD void down {
+	scroller_t s;
+	kgi_u_t t;
+	kgi_u_t b;
+	kgi_u_t n;
+};
+
+METHOD void up {
+	scroller_t s;
+	kgi_u_t t;
+	kgi_u_t b;
+	kgi_u_t n;
+};
+
+METHOD void move {
+	scroller_t s;
+	kgi_s_t c;
+	kgi_s_t l;
+};
+
+METHOD void scroll_top {
+	scroller_t s;
+	kgi_u_t n;
+};
+
+METHOD void scroll_bottom {
+	scroller_t s;
+	kgi_u_t n;
+};
+
+METHOD void gotox {
+	scroller_t s;
+	kgi_s_t x;
+};
+
+METHOD void gotoy {
+	scroller_t s;
+	kgi_s_t y;
+};
+
+METHOD void save {
+	scroller_t s;
+};
+
+METHOD void restore {
+	scroller_t s;
+};
diff -x CVS -x .svn -aurpN sys/dev/kgi/accel.h sys/dev/kgi/accel.h
--- sys/dev/kgi/accel.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/accel.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,53 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2004 Nicholas Souchu 
+ *  
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * /dev/graphic accel OS dependent definitions
+ */
+
+#ifndef _kgi_accel_h
+#define	_kgi_accel_h
+
+typedef struct
+{
+	__KGI_ACCEL_BUFFER
+
+	/* Below, fields hidden to the graphic drivers */
+
+	TAILQ_HEAD(, vm_page) memq;	/* list of resident pages */
+
+} graph_accel_buffer_t;
+
+/*
+ * Accelerator mappings
+ */
+typedef struct
+{
+	__GRAPH_RESOURCE_MAPPING
+
+	unsigned long	buf_offset;	/* current mapped buffer offset	*/
+	unsigned long	buf_size;	/* size of the buffers		*/
+	unsigned long	buf_mask;	/* mask to wrap buffer		*/
+	unsigned int	buf_order;	/* ln2(buffer_size)-PAGE_SHIFT	*/
+
+	graph_accel_buffer_t *buf_current;	/* list of buffers		*/
+
+} graph_accel_mapping_t;
+
+#define SIZ(order) (1 << (order + PAGE_SHIFT))
+#define VM(field) (vma->vm_##field)
+
+extern int graph_accel_mmap(vm_area_t vma, graph_mmap_setup_t *mmap_setup,
+			    graph_mapping_t **the_map);
+
+#endif /* #ifndef _kgi_accel_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/compiler.h sys/dev/kgi/compiler.h
--- sys/dev/kgi/compiler.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/compiler.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,24 @@
+/*-
+ * Copyright (c) 1998-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI compiler dependent stuff
+ */
+#ifndef	_kgi_compiler_h
+#define	_kgi_compiler_h
+
+#ifdef	__STRICT_ANSI__
+#	define	inline
+#	define	signed
+#endif
+
+#endif	/* #ifndef _kgi_compiler_h	*/
diff -x CVS -x .svn -aurpN sys/dev/kgi/config.h sys/dev/kgi/config.h
--- sys/dev/kgi/config.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/config.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,3 @@
+/*-*
+ * config.h -- Just a fake.
+ */
diff -x CVS -x .svn -aurpN sys/dev/kgi/debug.h sys/dev/kgi/debug.h
--- sys/dev/kgi/debug.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/debug.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,4 @@
+/*-*
+ * debug.h is maintained for compatibility purpose
+ */
+#include <dev/kgi/kgidbg.h>
diff -x CVS -x .svn -aurpN sys/dev/kgi/graphic.h sys/dev/kgi/graphic.h
--- sys/dev/kgi/graphic.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/graphic.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,104 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * /dev/graphic resource mapper definition.
+ */
+#ifndef _kgi_graphic_h
+#define	_kgi_graphic_h
+
+#define	GRAPH_MAJOR	60
+#define	GRAPH_NAME	"graphic"
+
+typedef struct graph_file_s	graph_file_t;
+typedef struct graph_device_s	graph_device_t;
+typedef struct graph_mapping_s	graph_mapping_t;
+
+#define	__GRAPH_RESOURCE_MAPPING					  \
+	graph_file_t		*file;	/* the file this belongs to	*/\
+	graph_device_t		*device;/* the device this belongs to	*/\
+	graph_mapping_t		*next;	/* mappings of same file	*/\
+	graph_mapping_t		*other;	/* mappings of same resource	*/\
+					/* belonging to the same device */\
+	struct vm_area_struct   *vma;   /* the vm area of the map       */\
+	kgi_resource_t		*resource; /* the resource mapped	*/
+
+struct graph_mapping_s {
+	__GRAPH_RESOURCE_MAPPING
+};
+
+/*
+ * A device represents the actual device.
+ */
+struct graph_device_s {
+	kgi_device_t	kgi;
+
+	graph_mapping_t	*mappings[__KGI_MAX_NR_RESOURCES];
+
+	kgi_mutex_t	cmd_mtx;
+};
+
+/*
+ * A file is a particular virtual view of a device.
+ */
+typedef enum {
+	GRAPH_FF_CLIENT_IDENTIFIED	= 0x00000001,
+	GRAPH_FF_SESSION_LEADER		= 0x00000002
+
+} graph_file_flags_t;
+
+typedef struct {
+	
+	kgic_mapper_mmap_setup_request_t request;
+	
+	const kgi_resource_t *resource;
+	pid_t pid;
+	gid_t gid;
+
+} graph_mmap_setup_t;
+
+struct graph_file_s {
+	unsigned long refcnt;
+	graph_file_flags_t	flags;
+
+	graph_mmap_setup_t	mmap_setup;
+		
+	kgi_u_t		device_id;
+	kgi_u_t		previous;
+
+	graph_device_t	*device;
+	graph_mapping_t	*mappings;
+};
+
+#define	GRAPH_MAX_NR_DEVICES	16
+#define	GRAPH_MAX_NR_IMAGES		16
+
+/* Maximum number of opened graph files */
+#define GRAPH_MAX_NR_FILES	16
+
+extern graph_file_t *graph_files[GRAPH_MAX_NR_FILES];
+
+extern int graph_command(graph_file_t *file, unsigned int cmd, void *data,
+			 struct thread *td);
+extern int graph_resource_command(graph_file_t *file, unsigned int cmd,
+				  void *data);
+
+extern void graph_unmap_map(graph_mapping_t *map);
+extern void graph_unmap_resource(graph_mapping_t *map);
+
+extern void graph_add_mapping(graph_file_t *file, graph_mapping_t *map);
+extern void graph_delete_mapping(graph_mapping_t *map);
+
+extern void graph_device_map(kgi_device_t *dev);
+extern kgi_s_t graph_device_unmap(kgi_device_t *dev);
+
+#endif	/* #ifndef _kgi_graphic_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/i386-compiler.h sys/dev/kgi/i386-compiler.h
--- sys/dev/kgi/i386-compiler.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/i386-compiler.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,165 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * i386 compiler dependent stuffitude.
+ */
+
+#ifndef	_kgi_i386_compiler_h
+#define	_kgi_i386_compiler_h
+
+#ifdef __STRICT_ANSI__
+#	undef	inline
+#	define	inline
+#endif
+
+#ifdef __GNUC__
+#ifdef	KGI_SYS_NEED_IO
+/*
+ * Intel style in/out I/O space.
+ */
+extern __inline__ __kgi_u8_t io_in8 (const io_vaddr_t addr) 
+{
+	__kgi_u8_t  val;
+	__asm__ __volatile__ ("inb %w1,%0" : "=a" (val) : "Nd" (addr));
+	return val;
+}
+
+extern __inline__ __kgi_u16_t io_in16(const io_vaddr_t addr)
+{
+	__kgi_u16_t val;
+	__asm__ __volatile__ ("inw %w1,%0" : "=a" (val) : "Nd" (addr));
+	return val;
+}
+
+extern __inline__ __kgi_u32_t io_in32(const io_vaddr_t addr)
+{
+	__kgi_u32_t val;
+	__asm__ __volatile__ ("inl %w1,%0" : "=a" (val) : "Nd" (addr));
+	return val;
+}
+
+
+extern __inline__ void io_out8(const __kgi_u8_t val, const io_vaddr_t addr)
+{
+	__asm__ __volatile__ ("outb %b0,%w1" : : "a" (val), "Nd" (addr));
+}
+
+extern __inline__ void io_out16(const __kgi_u16_t val, const io_vaddr_t addr)
+{
+	__asm__ __volatile__ ("outw %w0,%w1" : : "a" (val), "Nd" (addr));
+}
+
+extern __inline__ void io_out32(const __kgi_u32_t val, io_vaddr_t addr)
+{
+	__asm__ __volatile__ ("outl %0,%w1" : : "a" (val), "Nd" (addr));
+}
+
+
+extern __inline__ void io_ins8(const io_vaddr_t addr, void *buf, 
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; insb" 
+		: "=D" (buf), "=c" (cnt) : "d" (addr), "0" (buf), "1" (cnt));
+}
+
+extern __inline__ void io_ins16(const io_vaddr_t addr, void * buf,
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; insw" 
+		: "=D" (buf), "=c" (cnt) : "d" (addr), "0" (buf), "1" (cnt));
+}
+
+extern __inline__ void io_ins32(const io_vaddr_t addr, void *buf,
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; insl"
+		: "=D" (buf), "=c" (cnt) : "d" (addr), "0" (buf), "1" (cnt));
+}
+
+extern __inline__ void io_outs8(const io_vaddr_t addr, const void *buf,
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; outsb"
+		: "=S" (buf), "=c" (cnt) : "d" (addr), "0" (buf), "1" (cnt));
+}
+
+extern __inline__ void io_outs16(const io_vaddr_t addr, const void *buf,
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; outsw"
+		: "=S" (buf), "=c" (cnt) : "d" (addr), "0" (buf), "1" (cnt));
+}
+
+extern __inline__ void io_outs32(const io_vaddr_t addr, const void *buf,
+	__kgi_size_t cnt)
+{
+	__asm__ __volatile__ ("cld ; rep ; outsl"
+		: "=S" (buf), "=c" (cnt) : "d" (addr),"0" (buf), "1" (cnt));
+}
+
+/*
+ * memory I/O space
+ */
+
+#define	__DECLARE_MEM_OPS(w)						\
+	extern __inline__ __kgi_u##w##_t mem_in##w (mem_vaddr_t addr) 	\
+	{								\
+		return *((__volatile__ __kgi_u##w##_t *) addr);		\
+	}								\
+	extern __inline__ void mem_out##w (const __kgi_u##w##_t val,	\
+		const mem_vaddr_t addr)					\
+	{								\
+		*((__volatile__ __kgi_u##w##_t *) addr) = val;		\
+	}								\
+	extern __inline__ void mem_ins##w (const mem_vaddr_t addr,	\
+		void *buf, __kgi_size_t cnt)				\
+	{								\
+		register __kgi_size_t i = 0;				\
+		while (i < cnt) {					\
+			((__volatile__ __kgi_u##w##_t *) buf)[i++] =	\
+				*((__volatile__ __kgi_u##w##_t *) addr);\
+		}							\
+	}								\
+	extern __inline__ void mem_outs##w (const mem_vaddr_t addr, 	\
+		const void *buf, __kgi_size_t cnt)			\
+	{								\
+		register __kgi_size_t i = 0;				\
+		while (i < cnt) {					\
+			*((__volatile__ __kgi_u##w##_t *) addr) =	\
+			     ((__volatile__ __kgi_u##w##_t *) buf)[i++];\
+		}							\
+	}								\
+	extern __inline__ void mem_put##w (const mem_vaddr_t addr,	\
+		const void *buf, __kgi_size_t cnt)			\
+	{								\
+		register __kgi_size_t i = 0;				\
+		while (i < cnt) {					\
+			((__volatile__ __kgi_u##w##_t *) addr)[i] =	\
+			     ((__volatile__ __kgi_u##w##_t *) buf)[i];	\
+			i++;						\
+		}							\
+	}
+
+__DECLARE_MEM_OPS(8)
+__DECLARE_MEM_OPS(16)
+__DECLARE_MEM_OPS(32)
+
+#undef	inline
+#define	inline	__inline__
+
+#endif	/* #ifdef KGI_SYS_NEED_IO */
+#endif	/* #ifdef __GNUC__	*/
+
+#endif	/* #ifdef _kgi_i386_compiler_h */
+
+
diff -x CVS -x .svn -aurpN sys/dev/kgi/io.h sys/dev/kgi/io.h
--- sys/dev/kgi/io.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/io.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,256 @@
+/*-
+ * Copyright (C) 1997-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the  
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * Hardware I/O layer definiton.
+ */
+
+#ifndef _kgi_io_h
+#define _kgi_io_h
+
+/*
+ * Explanations on I/O regions can be found in the system layer 
+ * documentation.
+ */
+
+/*
+ * PCI configuration space
+ *
+ * These functions should be used to access the PCI configuration space.
+ * As the address is given by the hardware wiring, a registration
+ * scheme doesn't make sense. But I/O is pretty useful :) For the same
+ * reason, and as it is used for configuration (bootstrap) purposes,
+ * a physical->virtual mapping is not possible. All addresses are
+ * virtual and no mapping takes place.
+ */
+#ifdef __KGI_SYS_IO_HAS_PCICFG
+
+
+#ifdef KGI_SYS_NEED_i64
+typedef __kgi_u64_t	pcicfg_vaddr_t;	/* the virtual address type	*/
+#define PCICFG_64_NULL ((pcicfg_vaddr_t) 0xFFFFFFFFFFFFFFFF)
+#define PCICFG_NULL PCICFG_64_NULL
+#else
+typedef __kgi_u32_t	pcicfg_vaddr_t;	/* the virtual address type	*/
+#define	PCICFG_32_NULL ((pcicfg_vaddr_t) 0xFFFF0000)	/* an invalid virtual address	*/
+#define PCICFG_NULL PCICFG_32_NULL
+#endif
+
+#define	PCICFG_VADDR(bus, slot, fn)	\
+	!((bus+1 > 0) || (slot+1 > 0) || (fn+1 > 0))			\
+	? PCICFG_NULL							\
+	: ( (pcicfg_vaddr_t)						\
+		((((bus) & 0xFF) << 24) | (PCI_DEVFN((slot),(fn)) << 16)) )
+
+#define	PCICFG_BUS(vaddr)	(((vaddr) >> 24) & 0xFF)
+#define	PCICFG_DEV(vaddr)	PCI_SLOT(((vaddr) >> 16) & 0xFF)
+#define	PCICFG_FN(vaddr)	PCI_FUNC(((vaddr) >> 16) & 0xFF)
+#define	PCICFG_REG(vaddr)	((vaddr) & 0xFFFF)
+#define	PCICFG_SIGNATURE(vendor, device) ((vendor << 16) | device)
+
+/*
+ * FreeBSD specific stuff.
+ */
+extern pcicfg_vaddr_t pcicfg_dev2cfg(device_t dev);
+extern struct pcicfg_dev *pcicfg_lookup_device(pcicfg_vaddr_t pcidev);
+extern device_t pcicfg_get_device(pcicfg_vaddr_t pcidev);
+extern int pcicfg_add_device(device_t dev);
+extern int pcicfg_remove_device(device_t dev);
+
+extern void pcicfg_claim_device(pcicfg_vaddr_t addr);
+extern void pcicfg_free_device(pcicfg_vaddr_t addr);
+extern int pcicfg_find_device(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures);
+extern int pcicfg_find_subsystem(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures);
+extern int pcicfg_find_class(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures);
+
+extern __kgi_u8_t  pcicfg_in8 (const pcicfg_vaddr_t vaddr);
+extern __kgi_u16_t pcicfg_in16(const pcicfg_vaddr_t vaddr);
+extern __kgi_u32_t pcicfg_in32(const pcicfg_vaddr_t vaddr);
+
+extern void pcicfg_out8 (const __kgi_u8_t  val, const pcicfg_vaddr_t vaddr);
+extern void pcicfg_out16(const __kgi_u16_t val, const pcicfg_vaddr_t vaddr);
+extern void pcicfg_out32(const __kgi_u32_t val, const pcicfg_vaddr_t vaddr);
+
+#define	PCICFG_SET_BASE32(value, reg)		\
+		pcicfg_out32(0xFFFFFFFF, reg);	\
+		pcicfg_in32(reg);		\
+		pcicfg_out32((value), reg)
+
+#endif /* #ifdef __KGI_SYS_IO_HAS_PCICFG	*/
+
+
+#ifdef __KGI_SYS_IO_HAS_BUS
+
+typedef enum {
+    KGI_BUS_UNKNOWN = 0,
+
+    KGI_BUS_PCI = 1,
+    KGI_BUS_ISA = 2,
+
+    KGI_BUS_LAST = 2
+} kgi_bustype_t;
+
+/* Generic bus data */
+typedef struct {
+    kgi_bustype_t type;
+} *kgi_busdev_t;
+
+/* PCI bus data */
+typedef struct {
+    kgi_bustype_t type;
+    pcicfg_vaddr_t pcicfg;
+} kgi_pcidev_t;
+
+/* ISA bus data */
+typedef struct {
+    kgi_bustype_t type;
+    void *dev;
+} kgi_isadev_t;
+
+#endif	/* #ifdef __KGI_SYS_IO_HAS_BUS	*/
+
+#define __KGI_SYS_IO(x)	\
+typedef struct {									\
+	kgi_busdev_t 	busdev;		/* Bus specific data            */\
+	pcicfg_vaddr_t	device;		/* (PCI) device this belongs to	*/\
+	x##_vaddr_t	base_virt;	/* virtual base address		*/\
+	x##_paddr_t	base_io;	/* I/O base address		*/\
+	x##_baddr_t	base_bus;	/* bus address			*/\
+	x##_paddr_t	base_phys;	/* physical address		*/\
+	__kgi_size_t	size;		/* size of region		*/\
+	x##_paddr_t	decode;		/* decoded I/O address lines	*/\
+	__kgi_u32_t	rid;		/* region unique id for device  */\
+	const __kgi_ascii_t *name;	/* name of the region		*/\
+									\
+} x##_region_t;								\
+extern int	   x##_check_region (x##_region_t *r);			\
+extern x##_vaddr_t x##_claim_region (x##_region_t *r);			\
+extern x##_vaddr_t x##_free_region  (x##_region_t *r);			\
+extern x##_vaddr_t x##_alloc_region (x##_region_t *r);			\
+									\
+extern __kgi_u8_t  x##_in8  (const x##_vaddr_t vaddr);			\
+extern __kgi_u16_t x##_in16 (const x##_vaddr_t vaddr);			\
+extern __kgi_u32_t x##_in32 (const x##_vaddr_t vaddr);			\
+									\
+extern void x##_out8  (const __kgi_u8_t  val, const x##_vaddr_t vaddr);	\
+extern void x##_out16 (const __kgi_u16_t val, const x##_vaddr_t vaddr);	\
+extern void x##_out32 (const __kgi_u32_t val, const x##_vaddr_t vaddr);	\
+									\
+extern void x##_ins8  (const x##_vaddr_t addr, void *buf, __kgi_size_t cnt);\
+extern void x##_ins16 (const x##_vaddr_t addr, void *buf, __kgi_size_t cnt);\
+extern void x##_ins32 (const x##_vaddr_t addr, void *buf, __kgi_size_t cnt);\
+									\
+extern void x##_outs8  (const x##_vaddr_t addr, const void *buf, __kgi_size_t cnt);\
+extern void x##_outs16 (const x##_vaddr_t addr, const void *buf, __kgi_size_t cnt);\
+extern void x##_outs32 (const x##_vaddr_t addr, const void *buf, __kgi_size_t cnt);\
+  
+
+
+/*
+ * Intel style in/out I/O space
+ *
+ * The io_in.. / io_out.. functions generate the necessary hardware
+ * actions to do a read/write cycle in a cards I/O space. (Registers
+ * accessed via the in.. / out.. instructions on i386 architecture.)
+ */
+#ifdef __KGI_SYS_IO_HAS_IO
+
+
+#define	IO_NULL	((io_vaddr_t) 0)	/* an invalid virtual address	*/
+#define	IO_DECODE_ALL ((io_paddr_t) -1UL) /* all lines being decoded	*/
+
+typedef __kgi_u_t	io_paddr_t;	/* the physical address type	*/
+typedef __kgi_u_t	io_vaddr_t;	/* the virtual address type	*/
+typedef __kgi_u_t	io_baddr_t;	/* the bus address type		*/
+
+__KGI_SYS_IO(io)
+
+#endif	/* #ifdef __KGI_SYS_IO_HAS_IO */
+
+/*
+ * memory I/O space
+ *
+ * This is the 'normal' shared memory I/O space accessed using the
+ * mov instructions on i386 architecture. The difference between
+ * *vaddr = val and mem_out32(val, vaddr) is that the latter will not
+ * be optimized away when compiling with maximum optimization.
+ */
+#ifdef __KGI_SYS_IO_HAS_MEM
+
+
+#define	MEM_NULL	((mem_vaddr_t) 0) /* an invalid virtual address	*/
+#define	MEM_DECODE_ALL	((mem_paddr_t) -1UL) /* all lines being decoded	*/
+
+typedef __kgi_phys_addr_t mem_paddr_t;	/* the physical address type	*/
+typedef __kgi_virt_addr_t mem_vaddr_t;	/* the virtual address type	*/
+typedef	__kgi_bus_addr_t  mem_baddr_t;	/* the bus address type		*/
+
+__KGI_SYS_IO(mem)
+
+
+extern void mem_put8 (const mem_vaddr_t dst, const void *buf, __kgi_size_t cnt);
+extern void mem_put16(const mem_vaddr_t dst, const void *buf, __kgi_size_t cnt);
+extern void mem_put32(const mem_vaddr_t dst, const void *buf, __kgi_size_t cnt);
+
+extern void mem_get8 (void *buf, const mem_vaddr_t src, __kgi_size_t cnt);
+extern void mem_get16(void *buf, const mem_vaddr_t src, __kgi_size_t cnt);
+extern void mem_get32(void *buf, const mem_vaddr_t src, __kgi_size_t cnt);
+
+#endif	/* #ifdef __KGI_SYS_IO_HAS_MEM */
+
+/* 
+ * irq handling
+ *
+ * use similar to io regions.
+ */
+#ifdef __KGI_SYS_IO_HAS_IRQ
+
+#define	IRQ_NULL	((unsigned int) -1)	/* an invalid irq line	*/
+#define	IRQ_DECODE_ALL	((irq_mask_t) -1)	/* all lines decoded	*/
+
+typedef __kgi_u_t	irq_mask_t;
+
+typedef enum {
+	IF_SHARED_IRQ	= 0x00000001,	/* line is shared */
+	IF_RANDOM_IRQ	= 0x00000010	/* line used as random source */	
+} irq_flags_t;
+
+typedef struct irq_system_s irq_system_t; /* system dependent data */
+typedef int irq_handler_fn(void *meta, void *meta_io, irq_system_t *system);
+
+typedef struct {
+	pcicfg_vaddr_t		device;	/* (PCI) device this belongs to	*/
+	irq_flags_t		flags;	/* properties			*/
+	const __kgi_ascii_t	*name;	/* name of the line		*/
+	__kgi_u_t		line;	/* requested IRQ line		*/
+	__kgi_u32_t		rid;	/* region unique id for device  */
+
+	void	*meta;			/* handler meta data		*/
+	void	*meta_io;		/* handler meta I/O data	*/
+	irq_handler_fn	*High, *Low;	/* high/low priority handlers	*/
+} irq_line_t;
+
+/*
+ * These may be OS dependent, and have to be supplied by the OS/kernel
+ * layer. As they aren't performance critical either, a call doesn't hurt.
+ */
+extern __kgi_error_t  irq_claim_line(irq_line_t *irq);
+extern void irq_free_line(irq_line_t *irq);
+
+#endif /* #ifdef __KGI_SYS_IO_HAS_IRQ	*/
+
+#undef	__KGI_SYS_IO_HAS_PCICFG
+#undef	__KGI_SYS_IO_HAS_IO
+#undef	__KGI_SYS_IO_HAS_MEM
+#undef	__KGI_SYS_IO_HAS_IRQ
+
+#endif /* #ifdef _kgi_io_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi.h sys/dev/kgi/kgi.h
--- sys/dev/kgi/kgi.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,39 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent stuff
+ */
+
+#ifndef _kgi_kgi_h
+#define _kgi_kgi_h
+
+/*
+ * kgi.h is now just a set of includes. Each of them
+ * has its own rule of #ifdef _KERNEL depending on
+ * their respective purpose.
+ */
+
+#include <dev/kgi/system.h>
+
+KGI_SYS_DECLARE_INTEGRAL_TYPES(kgi)
+
+#include <dev/kgi/kgierr.h>
+#include <dev/kgi/kgidbg.h>
+#include <dev/kgi/kgityp.h>
+#include <dev/kgi/kgimod.h>
+#include <dev/kgi/kgires.h>
+#include <dev/kgi/kgidpy.h>
+#include <dev/kgi/kgicmd.h>
+
+#endif	/* #ifndef _kgi_kgi_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_core.c sys/dev/kgi/kgi_core.c
--- sys/dev/kgi/kgi_core.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_core.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,696 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions. 
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI display manager.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_MUTEX
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+SYSINIT(kgi, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, kgi_init, NULL);
+
+static int initialized  = 0;
+int console_initialized = 0;
+
+kgi_mutex_t kgi_lock;
+
+kgi_u8_t console_map[CONFIG_KGII_MAX_NR_FOCUSES][CONFIG_KGII_MAX_NR_CONSOLES];
+kgi_u8_t graphic_map[CONFIG_KGII_MAX_NR_FOCUSES][CONFIG_KGII_MAX_NR_CONSOLES];
+kgi_u8_t focus_map[CONFIG_KGII_MAX_NR_DEVICES];
+kgi_u8_t display_map[CONFIG_KGII_MAX_NR_DEVICES];
+
+MALLOC_DEFINE(M_KGI, "kgi", "KGI data structures");
+
+static kgi_device_t	 *kgidevice[KGI_MAX_NR_DEVICES];
+static kgi_display_t *kgidpy[KGI_MAX_NR_DISPLAYS];
+
+/*
+ * Display handling.
+ */
+kgi_error_t 
+kgidev_display_command(kgi_device_t *dev, kgi_u_t cmd, void *data)
+{
+
+	if (!(dev->flags & KGI_DF_FOCUSED)) {
+		KRN_ERROR("Protocol error.");
+		return (KGI_EPROTO);
+	}
+	if (!KGI_VALID_DISPLAY_ID(dev->dpy_id) ||
+		(NULL == kgidpy[dev->dpy_id])) {
+		KRN_DEBUG(1, "No valid display device.");
+		return (KGI_ENODEV);
+	}
+	KRN_ASSERT((cmd & KGIC_TYPE_MASK) == KGIC_DISPLAY_COMMAND);
+	return ((NULL == kgidpy[dev->dpy_id]->Command)
+		? -ENXIO
+		: (kgidpy[dev->dpy_id]->Command)(kgidpy[dev->dpy_id], cmd, data));
+}
+
+/*
+ * Check if a mode is valid. This returns a valid <mode> and KGI_EOK if
+ * the mode can be done. NOTE: <cmd> must be either KGI_TC_PROPOSE or
+ * KGI_TC_CHECK. <dpy> and <mode> must be valid.
+ */
+static kgi_error_t 
+kgidpy_check_mode(kgi_display_t *dpy, kgi_mode_t *m, kgi_timing_command_t cmd)
+{
+	kgi_error_t err;
+
+	KRN_ASSERT(dpy);
+	KRN_ASSERT(m);
+	KRN_ASSERT(cmd == KGI_TC_PROPOSE || cmd == KGI_TC_CHECK);
+
+	if (!m->dev_mode && dpy->mode_size) {
+		m->dev_mode = kgi_kmalloc(dpy->mode_size);
+		if (!m->dev_mode) {			
+			KRN_ERROR("Out of memory.");
+			return (KGI_ENOMEM);
+		}
+		m->flags |= KGI_MF_ALLOCATED;
+	}
+
+	err = (dpy->CheckMode)(dpy, cmd,
+		m->img, m->images, m->dev_mode,
+		m->resource, __KGI_MAX_NR_RESOURCES);
+
+	if (err) {
+		if (m->flags & KGI_MF_ALLOCATED) {
+			kgi_kfree(m->dev_mode);
+			m->dev_mode = NULL;
+		}
+		return (err);
+	}
+
+#if 0
+	for (i = 0; i < __KGI_MAX_NR_RESOURCES; i++) {
+
+		if (m->resource[i] && 
+			(m->resource[i]->type == KGI_RT_ACCELERATOR)) {
+
+			kgi_accel_t *accel = (kgi_accel_t *) m->resource[i];
+			kgi_queue_head_t *idle;
+			if (NULL == (idle = kgi_kmalloc(sizeof(*idle)))) {
+
+				KRN_ERROR("out of memory!");
+				m->resource[i] = NULL;
+			}
+			accel->idle = idle;
+			kgi_init_queue_head(accel->idle);
+		}
+	}
+#endif
+	return (KGI_EOK);
+}
+
+static void 
+kgidpy_release_mode(kgi_display_t *dpy, kgi_mode_t *m)
+{
+
+#ifdef notyet
+	kgi_u_t i;
+
+	for (i = 0; i < __KGI_MAX_NR_RESOURCES; i++) {
+		if (m->resource[i] && 
+			(m->resource[i]->type == KGI_RT_ACCELERATOR)) {
+			kgi_accel_t *accel = (kgi_accel_t *) m->resource[i];
+			kgi_kfree(accel->idle);
+			accel->idle = NULL;
+		}
+	}
+#endif
+
+	if (m->dev_mode) {
+		if (m->flags & KGI_MF_ALLOCATED) {
+			kgi_kfree(m->dev_mode);
+			m->flags &= ~KGI_MF_ALLOCATED;
+			m->dev_mode = NULL;
+		} else {
+			KRN_ERROR("Loosing dev_mode allocated statically.");
+			m->dev_mode = NULL;
+		}
+	}
+}
+	
+
+static void 
+kgidpy_set_mode(kgi_display_t *dpy, kgi_mode_t *m)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_ASSERT(m);
+	KRN_ASSERT(dpy->mode_size ? m->dev_mode != NULL : 1);
+
+	(dpy->SetMode)(dpy, m->img, m->images, m->dev_mode);
+}
+
+static void 
+kgidpy_unset_mode(kgi_display_t *dpy, kgi_mode_t *m)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_ASSERT(m);
+	KRN_ASSERT(dpy->mode_size ? m->dev_mode != NULL : 1);
+
+	if (dpy->UnsetMode) 
+		(dpy->UnsetMode)(dpy, m->img, m->images, m->dev_mode);
+}
+
+/*
+ * Device handling.
+ */
+kgi_error_t 
+kgi_register_device(kgi_device_t *dev, kgi_u_t index)
+{
+	kgi_s_t err;
+	kgi_u_t focus, console;
+	kgi_u8_t *map;
+
+	if (!(dev && KGI_VALID_CONSOLE_ID(index))) {
+		KRN_ERROR("Invalid arguments %p, %i", dev, index);
+		return (KGI_EINVAL);
+	}
+	dev->id = (dev->flags & KGI_DF_CONSOLE) 
+		? index : index + KGI_MAX_NR_CONSOLES;
+
+	KRN_ASSERT(sizeof(console_map) == sizeof(graphic_map));
+	map = (dev->flags & KGI_DF_CONSOLE) ? console_map[0] : graphic_map[0];
+	index = 0;
+	while ((index < sizeof(console_map)) && (map[index] != dev->id)) 
+		index++;
+	
+	focus   = index / KGI_MAX_NR_CONSOLES;
+	console = index % KGI_MAX_NR_CONSOLES;
+	if (!(KGI_VALID_FOCUS_ID(focus) && KGI_VALID_CONSOLE_ID(console) &&
+		KGI_VALID_DEVICE_ID(map[index]) && (map[index] == dev->id))) {
+			KRN_ERROR("No %s device allowed (dev %i)",
+			(dev->flags & KGI_DF_CONSOLE) ? "console" : "graphic",
+			dev->id);
+		dev->id = KGI_INVALID_DEVICE;
+		return (KGI_ENODEV);
+	}
+	if (kgidevice[dev->id]) {
+		KRN_DEBUG(1, "Device %i (%s %i-%i) is busy", dev->id,
+			(dev->flags & KGI_DF_CONSOLE) ? "console" : "graphic",
+			focus, console);
+		dev->id = KGI_INVALID_DEVICE;
+		return (KGI_EBUSY);
+	}
+
+	dev->dpy_id = display_map[dev->id];
+	if (!(KGI_VALID_DISPLAY_ID(dev->dpy_id) && kgidpy[dev->dpy_id])) {
+		KRN_ERROR("No display to attach device (dpy %i, dev %i)",
+			dev->dpy_id, dev->id);
+		dev->dpy_id = KGI_INVALID_DISPLAY;
+		dev->id  = KGI_INVALID_DEVICE;
+		return (KGI_ENODEV);
+	}
+	if ((err = kgidpy_check_mode(kgidpy[dev->dpy_id], dev->mode,
+		KGI_TC_PROPOSE))) {
+		KRN_ERROR("Initial mode check with dpy %i failed (%i)",
+			dev->dpy_id, err);
+		dev->dpy_id = KGI_INVALID_DISPLAY;
+		dev->id = KGI_INVALID_DEVICE;
+		return (KGI_EINVAL);
+	}
+	if (!(dev->flags & KGI_DF_CONSOLE)) {
+		kgi_display_t *dpy = kgidpy[dev->dpy_id];
+
+		while (dpy) {
+			dpy->graphic++;
+			(dpy->IncRefcount)(dpy);
+			dpy = dpy->prev;
+		}
+	}
+	kgidevice[dev->id] = dev;
+
+	KRN_DEBUG(2, "KGI device %i registered.", dev->id);
+
+	return (KGI_EOK);
+}
+
+void 
+kgi_unregister_device(kgi_device_t *dev)
+{
+
+	KRN_ASSERT(dev);
+	KRN_ASSERT(KGI_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(dev == kgidevice[dev->id]);
+	KRN_ASSERT(! (dev->flags & KGI_DF_FOCUSED));
+
+	if (!(dev->flags & KGI_DF_CONSOLE)) {
+		kgi_display_t *dpy = kgidpy[dev->dpy_id];
+		
+		while (dpy) {
+			(dpy->DecRefcount)(dpy);
+			dpy->graphic--;
+			dpy = dpy->prev;
+		}
+	}
+	kgidevice[dev->id] = NULL;
+
+	kgidpy_release_mode(kgidpy[dev->dpy_id], dev->mode);
+
+	KRN_DEBUG(2, "KGI device %i unregistered.", dev->id);
+
+	dev->dpy_id = KGI_INVALID_DISPLAY;
+	dev->id = KGI_INVALID_DEVICE;
+}
+
+/*
+ * Checking of non CONSOLE devices is not allowed. All attached devices must
+ * be consoles.
+ */
+static kgi_error_t 
+kgi_check_device_mode(kgi_display_t *dpy, kgi_s_t id)
+{
+	kgi_error_t error = KGI_ENODEV;
+	kgi_device_t *dev = kgidevice[id];
+	kgi_mode_t mode;
+	kgi_u_t i;
+
+	KRN_ASSERT(KGI_VALID_DEVICE_ID(id));
+
+	if (!dev)
+		return (KGI_EOK);
+
+	/* Refuse to reattach a device not in console mode. */
+	if (dev->flags & KGI_DF_CONSOLE) {
+		bzero(&mode, sizeof(mode));
+
+		mode.flags = dev->mode->flags & ~KGI_MF_ALLOCATED;
+		mode.images = dev->mode->images;
+
+		mode.img[0].size.x = dev->mode->img[0].size.x;
+		mode.img[0].size.y = dev->mode->img[0].size.y;
+		mode.img[0].virt.x = dev->mode->img[0].virt.x;
+		mode.img[0].virt.y = dev->mode->img[0].virt.y;
+		mode.img[0].cam = dev->mode->img[0].cam;
+		mode.img[0].fam = dev->mode->img[0].fam;
+
+		for (i = 0 ; i < __KGI_MAX_NR_ATTRIBUTES; i++)
+			mode.img[0].bpca[i] = dev->mode->img[0].bpca[i];
+		for (i = 0 ; i < __KGI_MAX_NR_ATTRIBUTES; i++)
+			mode.img[0].bpfa[i] = dev->mode->img[0].bpfa[i];
+
+		error = kgidpy_check_mode(dpy, &mode, KGI_TC_PROPOSE);
+
+		kgidpy_release_mode(dpy, &mode);
+	}
+
+	return (error);
+}
+
+/*
+ * Shall only be called once the device mode has been checked. The previous
+ * display mode is freed here.
+ */
+static void 
+kgi_reattach_device(kgi_display_t *dpy, kgi_s_t id)
+{
+	kgi_event_t event;
+	kgi_error_t error;
+	kgi_device_t *dev = kgidevice[id];
+	int was_focused = 0;
+
+	KRN_ASSERT(KGI_VALID_DEVICE_ID(id));
+
+	if (!dev)
+		return;
+
+	/* Refuse to reattach a device not in console mode. */
+	if (dev->flags & KGI_DF_CONSOLE) {
+		KRN_DEBUG(2, "Reattaching device %i", id);
+
+		/* Unmap any focused device. */
+		if (dev->flags & KGI_DF_FOCUSED) {
+			was_focused = 1;
+			kgi_unmap_device(id);
+		}
+
+		/* Free the previous display mode. */
+		kgidpy_release_mode(dpy, dev->mode);
+
+		/* Allocate the new display mode, supposed to be ok. */
+		if ((error = kgidpy_check_mode(dpy, dev->mode, KGI_TC_PROPOSE)))
+			KRN_ERROR("Failed to reattach device %i (%d)", id, error);
+		
+		/* Notify the device of the display change. */
+		event.notice.command = KGI_EVENT_NOTICE_NEW_DISPLAY;
+		
+		/* Send the event before remapping the device. */
+		if (kgidevice[id]->HandleEvent) 
+			kgidevice[id]->HandleEvent(kgidevice[id], &event);		
+
+		if (was_focused)
+			kgi_map_device(id);
+	}
+}
+
+static inline kgi_u_t 
+kgi_can_do_console(kgi_display_t *dpy)
+{
+	kgi_mode_t mode;
+	kgi_error_t err;
+
+	memset(&mode, 0, sizeof(mode));
+	mode.images = 1;
+	mode.img[0].flags |= KGI_IF_TEXT16;
+
+	err = kgidpy_check_mode(dpy, &mode, KGI_TC_PROPOSE);
+
+	if (mode.dev_mode && (mode.flags & KGI_MF_ALLOCATED)) {
+		kgi_kfree(mode.dev_mode);
+		mode.dev_mode = NULL;
+	}
+
+	return ((KGI_EOK == err) ? (mode.img[0].flags & KGI_IF_TEXT16) : 0);
+}
+
+static inline kgi_u_t 
+kgi_must_do_console(kgi_display_t *dpy)
+{
+	kgi_u_t i;
+
+	for (i = 0; i < KGI_MAX_NR_DEVICES; i++) {
+		if ((display_map[i] == dpy->id) && kgidevice[i] &&
+			(kgidevice[i]->flags & KGI_DF_TEXT16)) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+/*
+ * Register <dpy> under <id>. If <id> is negative, we search for the first
+ * free one.
+ */
+kgi_error_t 
+kgi_register_display(kgi_display_t *dpy, kgi_u_t id)
+{
+	kgi_display_t *prev;
+	kgi_error_t error = KGI_EOK;
+	kgi_u_t i;
+
+	KRN_DEBUG(2, "Registering %s %s display with id %i", 
+		dpy->vendor, dpy->model, id);
+
+	if (!KGI_VALID_DISPLAY_ID(id)) {
+		for (id = 0; (id < KGI_MAX_NR_DISPLAYS) && kgidpy[id]; id++) 
+			; /* nothing */
+		if (KGI_MAX_NR_DISPLAYS <= id) 
+			return (KGI_ENOMEM);
+		
+		KRN_DEBUG(2, "Auto-assigned new id %i", id);
+	}
+
+	if (!KGI_VALID_DISPLAY_ID(id) || !dpy ||
+		(kgidpy[id] && kgidpy[id]->graphic)) {
+		KRN_ERROR("Can't replace display %i", id);
+		return (KGI_EINVAL);
+	}
+
+	if (kgi_must_do_console(dpy) && !kgi_can_do_console(dpy)) {
+		KRN_DEBUG(1, "New display has too but can't do console.");
+		kgidpy[id] = dpy->prev;
+		dpy->prev = NULL;
+		dpy->id = KGI_INVALID_DISPLAY;
+		return (KGI_EINVAL);
+	}
+
+	/* Check mode for each device registered. */
+	for (i = 0; i < KGI_MAX_NR_DEVICES; i++) {
+		if (display_map[i] == id) {
+			/* If can't set device mode, fail. */
+			if ((error = kgi_check_device_mode(dpy, i)))
+				return (KGI_EINVAL);
+		}
+	}
+
+	dpy->id = id;
+	dpy->graphic = 0;
+	dpy->prev = kgidpy[id];
+	kgidpy[dpy->id] = dpy;
+
+	/*
+	 * If no error during checks, check display specific modes and
+	 * set the mode for the focused device if any.
+	 */
+	if (!error) {
+		for (i = 0; i < KGI_MAX_NR_DEVICES; i++) {
+			if (display_map[i] == id) {
+				kgi_reattach_device(dpy, i);
+			}
+		}
+		KRN_NOTICE("Display %i: %s %s registered.", dpy->id,
+			   dpy->vendor, dpy->model);
+	}
+
+	prev = dpy->prev;
+	while (prev) {
+		(prev->IncRefcount)(prev);
+		prev = prev->prev;
+	}
+
+	return (error);
+}
+
+void 
+kgi_unregister_display(kgi_display_t *dpy)
+{ 
+	kgi_display_t *prev;
+	kgi_u_t i;
+
+	KRN_ASSERT(dpy);
+	KRN_ASSERT(KGI_VALID_DISPLAY_ID(dpy->id));
+	KRN_ASSERT(kgidpy[dpy->id] == dpy);
+	KRN_ASSERT(dpy->graphic == 0);
+
+	kgidpy[dpy->id] = dpy->prev;
+
+	for (i = 0; i < KGI_MAX_NR_DEVICES; i++) {
+		if (display_map[i] == dpy->id) {
+			kgi_reattach_device(dpy->prev, i);
+		}
+	}
+
+	prev = kgidpy[dpy->id];
+	while (prev) {
+		(prev->DecRefcount)(prev);
+		prev = prev->prev;
+	}
+
+	KRN_NOTICE("Display %i: %s %s unregistered.", dpy->id,
+		dpy->vendor, dpy->model);
+	dpy->id   = KGI_INVALID_DISPLAY;
+	dpy->prev = NULL;
+}
+	
+kgi_error_t 
+kgi_unmap_device(kgi_u_t dev_id)
+{
+	kgi_device_t *dev;
+	kgi_display_t *dpy;
+
+	if (!(KGI_VALID_DEVICE_ID(dev_id) && kgidevice[dev_id] &&
+		KGI_VALID_DISPLAY_ID(display_map[dev_id]) &&
+		(dpy = kgidpy[display_map[dev_id]]))) {
+		KRN_DEBUG(3, "No target or display, no unmap done.");
+		return (KGI_EINVAL);
+	}
+
+	if (!(dev = dpy->focus))
+		return (KGI_EOK);
+
+	KRN_DEBUG(3, "Unmapping device %i from display %i", dev->id, dpy->id);
+
+	if (dev->UnmapDevice) {
+		kgi_error_t err;
+		if ((err = dev->UnmapDevice(dev))) 
+			return (err);
+	}
+
+	kgidpy_unset_mode(dpy, dev->mode);
+
+	dpy->focus = NULL;
+	dev->flags &= ~KGI_DF_FOCUSED;
+
+	return (KGI_EOK);
+}
+
+void 
+kgi_map_device(kgi_u_t dev_id)
+{
+	kgi_device_t *dev;
+	kgi_display_t *dpy;
+
+	if (!(KGI_VALID_DEVICE_ID(dev_id) && (dev = kgidevice[dev_id]) &&
+		KGI_VALID_DISPLAY_ID(display_map[dev_id]) &&
+		(dpy = kgidpy[display_map[dev_id]]))) {
+		KRN_DEBUG(3, "No target or display for device %i, no map done.", dev_id);
+		return;
+	}
+	KRN_ASSERT(dpy->focus == NULL);
+
+	KRN_DEBUG(3, "Mapping device %i on display %i", dev->id, dpy->id);
+
+	dpy->focus = dev;
+	dev->flags |= KGI_DF_FOCUSED;
+
+	kgidpy_set_mode(dpy, dev->mode);
+
+	if (dev->MapDevice) 
+		(dev->MapDevice)(dev);	
+}
+
+kgi_device_t *
+kgi_current_focus(kgi_u_t dpy_id)
+{
+
+	KRN_ASSERT(KGI_VALID_DISPLAY_ID(dpy_id));
+	KRN_ASSERT(kgidpy[dpy_id]);
+
+	return kgidpy[dpy_id]->focus;
+}
+
+kgi_u_t 
+kgi_current_devid(kgi_u_t dpy_id)
+{
+
+	if (!kgidpy[dpy_id])
+		return (0);
+
+	if (!kgidpy[dpy_id]->focus)
+		return (-1);
+
+	return (kgidpy[dpy_id]->focus->id);
+}
+
+kgi_error_t 
+kgi_display_registered(kgi_u_t dpy_id)
+{
+
+	return ((KGI_VALID_DISPLAY_ID(dpy_id) && kgidpy[dpy_id]) 
+		? KGI_EOK : KGI_ENODEV);
+}
+
+/*
+ * KGI manager initialization.
+ *
+ * All kernel services need to be accessible when kgi_init is called,
+ * especially PCI-scanning, kgi_kmalloc*() services. We first
+ * initialize global variables and then get the services running.
+ */
+static void 
+kgi_init_maps(kgi_u_t nr_displays, kgi_u_t nr_focuses)
+{
+	kgi_u_t display = 0, device;
+	for (device = 0; device < CONFIG_KGII_MAX_NR_CONSOLES; device++) {
+		kgi_u_t focus = device / 
+					(CONFIG_KGII_MAX_NR_CONSOLES / CONFIG_KGII_MAX_NR_FOCUSES);
+		kgi_u_t console = device % 
+					(CONFIG_KGII_MAX_NR_CONSOLES / CONFIG_KGII_MAX_NR_FOCUSES);
+		if (!(KGI_VALID_FOCUS_ID(focus) && KGI_VALID_CONSOLE_ID(console)))
+			continue;
+		
+		KRN_DEBUG(4, "Mapping device %i on focus %i, display %i, console %i",
+			device, focus, display, console);
+
+		console_map[focus][console] = device;
+		graphic_map[focus][console] = device + CONFIG_KGII_MAX_NR_CONSOLES;
+
+		focus_map[device] = 
+				focus_map[device + CONFIG_KGII_MAX_NR_CONSOLES] = focus;
+
+		display_map[device] = 
+				display_map[device + CONFIG_KGII_MAX_NR_CONSOLES] = display;
+
+		if ((device % CONFIG_KGII_MAX_NR_FOCUSES) ==
+			CONFIG_KGII_MAX_NR_FOCUSES - 1) {
+			if (nr_displays > nr_focuses) {
+				display++;
+				nr_displays--;
+			}
+		}
+		if (console == (CONFIG_KGII_MAX_NR_CONSOLES /
+			CONFIG_KGII_MAX_NR_FOCUSES) - 1) {
+			nr_focuses--;
+			nr_displays--;
+			display++;
+		}
+	}
+}
+
+kgi_u_t 
+kgi_attr_bits(const kgi_u8_t *bpa)
+{
+	kgi_u_t bits = 0;
+	
+	if (bpa) {
+		while (*bpa) {
+			bits += *(bpa++);
+		}
+	}
+
+	return (bits);
+}
+
+/*
+ * Initialize the KGI system if not already performed.
+ */
+void 
+kgi_init(void)
+{
+	kgi_u_t nr_displays, nr_focuses;
+
+	kii_configure(0);
+
+	if (!initialized) {	
+		memset(display_map, 0xFF, sizeof(display_map));
+		memset(focus_map,   0xFF, sizeof(focus_map));
+		memset(console_map, 0xFF, sizeof(console_map));
+		memset(graphic_map, 0xFF, sizeof(graphic_map));
+
+		memset(kgidpy, 0, sizeof(kgi_display_t));
+		memset(kgidevice, 0, sizeof(kgi_device_t));
+
+		nr_displays = 0;
+		
+		nr_displays += dpy_null_init(nr_displays, CONFIG_KGI_DISPLAYS);
+		KRN_DEBUG(1, "%i displays initialized.", nr_displays);
+		
+		nr_focuses = 0;
+		/* XXX	nr_focuses  = focus_init(); */
+		
+		kgi_init_maps(nr_displays, nr_focuses);
+
+		kgi_mutex_init(&kgi_lock, "KGI Giant lock.");
+
+		initialized = 1;
+	}
+
+	return;
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_daemon.c sys/dev/kgi/kgi_daemon.c
--- sys/dev/kgi/kgi_daemon.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_daemon.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,56 @@
+/*-
+ * Copyright (C) 2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI daemon
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_PROC
+#define KGI_SYS_NEED_MUTEX
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+static void kgi_daemon(void);
+
+struct proc *kgiproc;
+
+static struct kproc_desc kgi_kp = {
+	"kgidaemon",
+	kgi_daemon,
+	&kgiproc
+};
+SYSINIT(kgidaemon, SI_SUB_KTHREAD_KGI, SI_ORDER_FIRST, kproc_start, &kgi_kp);
+
+void 
+kgi_daemon(void)
+{
+	kgi_mutex_lock(&kgi_lock);
+	while (TRUE) {
+		msleep(&kgiproc, &kgi_lock.mutex, PZERO /* XXX */,
+		       "kdsleep", hz /* 1s */);
+
+		/* Poll the keyboard events needing system action */
+		kii_bottomhalf();
+	}
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_dpynull.c sys/dev/kgi/kgi_dpynull.c
--- sys/dev/kgi/kgi_dpynull.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_dpynull.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,287 @@
+/*-
+* Copyright (C) 1999-2000 Steffen Seeger
+*
+* This file is distributed under the terms and conditions of the 
+* MIT/X public license. Please see the file COPYRIGHT.MIT included
+* with this software for details of these terms and conditions.
+* Alternatively you may distribute this file under the terms and
+* conditions of the GNU General Public License. Please see the file 
+* COPYRIGHT.GPL included with this software for details of these terms
+* and conditions.
+*/
+
+/*
+ * NULL display code
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define	KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+/*
+ * kernel interface
+ */
+
+typedef struct {
+	kgi_dot_port_mode_t	dpm;
+
+	kgi_accel_t		blubber_accel;
+	kgi_marker_t		cur;
+	kgi_marker_t		ptr;
+	kgi_text16_t		text16;
+
+} dpy_null_mode_t;
+
+typedef struct {
+	kgi_display_t		dpy;
+	kgi_mode_t		mode;
+	kgi_ucoord_t		size;
+
+} dpy_null_display_t;
+
+static dpy_null_display_t dpy_data[CONFIG_KGI_DISPLAYS];
+static int dpy_index = 0;
+
+/* text16 operations */
+static void 
+dpy_null_show(kgi_marker_t *marker, kgi_u_t x, kgi_u_t y)
+{
+
+	KRN_ASSERT(marker);
+}
+
+static void 
+dpy_null_hide(kgi_marker_t *marker)
+{
+
+	KRN_ASSERT(marker);
+}
+
+#define	dpy_null_undo	dpy_null_hide
+
+
+static void dpy_null_put_text16(kgi_text16_t *text16,
+	kgi_u_t offset, const kgi_u16_t *text, kgi_u_t count)
+{
+}
+
+static void 
+dpy_null_inc_refcount(kgi_display_t *dpy)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_DEBUG(2, "dpy_null display refcount increment");
+}
+
+static void 
+dpy_null_dec_refcount(kgi_display_t *dpy)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_DEBUG(2, "dpy_null display refcount decrement");
+}
+
+static int dpy_null_check_mode(kgi_display_t *dpy, kgi_timing_command_t cmd,
+	kgi_image_mode_t *img, kgi_u_t images, void *dev_mode, 
+	const kgi_resource_t **r, kgi_u_t rsize)
+{
+#define	DEFAULT(x)	if (! (x)) { x = dpy_null->mode.x; }
+#define	MATCH(x)	((x) == dpy_null->mode.x)
+	dpy_null_display_t *dpy_null = (dpy_null_display_t *) dpy;
+	dpy_null_mode_t *devmode = (dpy_null_mode_t *) dev_mode;
+
+	if (images != 1) {
+		KRN_DEBUG(2, "%i image layers are not supported.", images);
+		return (-EINVAL);
+	}
+
+	switch (cmd) {
+	case KGI_TC_PROPOSE:
+		DEFAULT(img[0].virt.x);
+		DEFAULT(img[0].virt.y);
+		DEFAULT(img[0].size.x);
+		DEFAULT(img[0].size.y);
+		DEFAULT(img[0].frames);
+		DEFAULT(img[0].tluts);
+		DEFAULT(img[0].iluts);
+		DEFAULT(img[0].aluts);
+		if (!img[0].fam) {
+			img[0].fam  = dpy_null->mode.img[0].fam;
+			img[0].cam  = dpy_null->mode.img[0].cam;
+			memcpy(img[0].bpfa, dpy_null->mode.img[0].bpfa,
+				sizeof(img[0].bpfa));
+			memcpy(img[0].bpca, dpy_null->mode.img[0].bpca,
+				sizeof(img[0].bpca));
+		}
+		/* fall through */
+	case KGI_TC_CHECK:
+		if (!(MATCH(img[0].virt.x) && MATCH(img[0].virt.y) &&
+			MATCH(img[0].size.x) && MATCH(img[0].size.y) &&
+			MATCH(img[0].frames) && MATCH(img[0].tluts) &&
+			MATCH(img[0].iluts) && MATCH(img[0].aluts))) {
+			KRN_DEBUG(2, "image mode does not match boot mode");
+			return (-EINVAL);
+		}
+		if (!MATCH(img[0].fam) || !MATCH(img[0].cam) ||
+			strncmp(img[0].bpfa, dpy_null->mode.img[0].bpfa,
+				__KGI_MAX_NR_ATTRIBUTES) ||
+			strncmp(img[0].bpca, dpy_null->mode.img[0].bpca,
+				__KGI_MAX_NR_ATTRIBUTES)) {
+			KRN_DEBUG(2, "attributes do not match boot mode");
+			return (-EINVAL);
+		}
+
+		devmode->dpm.dots.x = 8*img[0].size.x;
+		devmode->dpm.dots.y = 12*img[0].size.y;
+		devmode->dpm.dam    = img[0].fam;
+		devmode->dpm.bpda   = img[0].bpfa;
+		img[0].out = &devmode->dpm;
+		img[0].flags = KGI_IF_TEXT16;
+
+		devmode->cur.meta	= dpy_null;
+		devmode->cur.meta_io	= NULL;
+		devmode->cur.type	= KGI_RT_CURSOR_CONTROL;
+		devmode->cur.prot	= KGI_PF_DRV_RWS;
+		devmode->cur.name	= "cursor control";
+		devmode->cur.size.x	= 1;
+		devmode->cur.size.y	= 1;
+		devmode->cur.Show	= dpy_null_show;
+		devmode->cur.Hide	= dpy_null_hide;
+		devmode->cur.Undo	= dpy_null_undo;
+
+		devmode->ptr.meta	= dpy_null;
+		devmode->ptr.meta_io	= NULL;
+		devmode->ptr.type	= KGI_RT_POINTER_CONTROL;
+		devmode->ptr.prot	= KGI_PF_DRV_RWS;
+		devmode->ptr.name	= "pointer control";
+		devmode->ptr.size.x	= 1;
+		devmode->ptr.size.y	= 1;
+		devmode->ptr.Show	= dpy_null_show;
+		devmode->ptr.Hide	= dpy_null_hide;
+		devmode->ptr.Undo	= dpy_null_undo;
+
+		devmode->text16.meta		= dpy_null;
+		devmode->text16.meta_io		= NULL;
+		devmode->text16.type		= KGI_RT_TEXT16_CONTROL;
+		devmode->text16.prot		= KGI_PF_DRV_RWS;
+		devmode->text16.name		= "text16 control";
+		devmode->text16.size.x		= img[0].size.x;
+		devmode->text16.size.y		= img[0].size.y;
+		devmode->text16.virt.x		= img[0].virt.x;
+		devmode->text16.virt.y		= img[0].virt.y;
+		devmode->text16.cell.x		= 8;
+		devmode->text16.cell.y		= 12;
+		devmode->text16.font.x		= 8;
+		devmode->text16.font.y		= 12;
+		devmode->text16.PutText16	= dpy_null_put_text16;
+
+		img[0].resource[0] = (kgi_resource_t *) &(devmode->text16);
+		img[0].resource[1] = (kgi_resource_t *) &(devmode->cur);
+		img[0].resource[2] = (kgi_resource_t *) &(devmode->ptr);
+
+		return (KGI_EOK);
+	default:
+		KRN_INTERNAL_ERROR;
+		return (-EINVAL);
+	}
+#undef	MATCH
+#undef	DEFAULT
+}
+
+static void 
+dpy_null_set_mode(kgi_display_t *dpy, kgi_image_mode_t *img,
+	kgi_u_t images, void *dev_mode)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_ASSERT(img);
+	KRN_ASSERT(images == 1);
+	KRN_ASSERT(dev_mode);
+}
+
+static inline kgi_display_t *
+dpy_null_alloc(kgi_u_t size_x, kgi_u_t size_y)
+{
+	dpy_null_display_t *dpy_null;
+
+	KRN_ASSERT(size_x && size_y);
+
+	if (dpy_index >= CONFIG_KGI_DISPLAYS)
+		return (NULL);
+
+	/* Allocate null displays statically for early initialization */
+	dpy_null = &dpy_data[dpy_index];
+	dpy_index ++;
+
+	memset(dpy_null, 0, sizeof(*dpy_null));
+
+	/* initialize display struct */
+	dpy_null->dpy.revision = KGI_DISPLAY_REVISION;
+	sprintf(dpy_null->dpy.vendor, "KGI null display");
+	sprintf(dpy_null->dpy.model, "%p", dpy_null);
+	dpy_null->dpy.flags = 0;
+	dpy_null->dpy.mode_size = sizeof(dpy_null_mode_t);
+	dpy_null->dpy.Command = NULL;
+
+	/* dpy_null->dpy.priv.priv_u64 = 0; */
+	dpy_null->dpy.mode = &dpy_null->mode;
+	dpy_null->dpy.id = KGI_INVALID_DISPLAY;
+	dpy_null->dpy.graphic = 0;
+	dpy_null->dpy.IncRefcount = dpy_null_inc_refcount;
+	dpy_null->dpy.DecRefcount = dpy_null_dec_refcount;
+
+	dpy_null->dpy.CheckMode	 = dpy_null_check_mode;
+	dpy_null->dpy.SetMode	 = dpy_null_set_mode;
+
+	dpy_null->dpy.focus = NULL;
+
+	/* initialize mode struct */
+	dpy_null->mode.revision	 = KGI_MODE_REVISION;
+	dpy_null->mode.images     = 1;
+	dpy_null->mode.img[0].out = NULL;
+	dpy_null->mode.img[0].flags = 0;
+	dpy_null->mode.img[0].virt.x = size_x;
+	dpy_null->mode.img[0].virt.y = size_y;
+	dpy_null->mode.img[0].size.x = size_x;
+	dpy_null->mode.img[0].size.y = size_y;
+	dpy_null->mode.img[0].frames = 1;
+	dpy_null->mode.img[0].fam = KGI_AM_COLOR_INDEX | KGI_AM_TEXT |
+		KGI_AM_FOREGROUND_INDEX | KGI_AM_TEXTURE_INDEX;
+	dpy_null->mode.img[0].bpfa[0] = 4;	/* bg color */
+	dpy_null->mode.img[0].bpfa[1] = 4;	/* fg color */
+	dpy_null->mode.img[0].bpfa[2] = 8;	/* texture  */
+
+	return ((kgi_display_t *) dpy_null);
+}
+
+int 
+dpy_null_init(int display, int max_display)
+{
+	/*
+	 * We fill up with null-displays. This allows for true multihead
+	 * with X.
+	 */
+	while (display < max_display) {
+		kgi_display_t *dpy = dpy_null_alloc(80, 25);
+		if (!dpy)
+			return (display);
+		if (kgi_register_display(dpy, display)) {
+			dpy_index--;
+			return (display);
+		}
+		display++;
+	}
+	return (display);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_sysatomic.c sys/dev/kgi/kgi_sysatomic.c
--- sys/dev/kgi/kgi_sysatomic.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_sysatomic.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,76 @@
+/*-
+ * Copyright (C) 2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI FreeBSD atomic system layer
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_ATOMIC
+#include <dev/kgi/system.h>
+
+kgi_atomic_t
+kgi_test_and_set_bit32(__kgi_u32_t b, volatile void *p)
+{
+	int s = splhigh();
+	__kgi_u32_t m = 1<<b;
+	__kgi_u32_t r = *(volatile __kgi_u32_t *)p & m;
+	*(volatile __kgi_u32_t *)p |= m;
+	splx(s);
+	return (r);
+}
+
+void
+kgi_clear_bit(int b, volatile void *p)
+{
+
+    atomic_clear_int(((volatile int *)p) + (b >> 5), 1 << (b & 0x1f));
+}
+
+void
+kgi_set_bit(int b, volatile void *p)
+{
+
+    atomic_set_int(((volatile int *)p) + (b >> 5), 1 << (b & 0x1f));
+}
+
+int
+kgi_test_bit(int b, volatile void *p)
+{
+
+    return (((volatile int *)p)[b >> 5] & (1 << (b & 0x1f)));
+}
+
+int
+kgi_find_first_zero_bit(volatile void *p, int max)
+{
+    int b;
+
+    for (b = 0; b < max; b += 32) {
+	if (((volatile int *)p)[b >> 5] != ~0) {
+	    for (;;) {
+		if ((((volatile int *)p)[b >> 5] & (1 << (b & 0x1f))) == 0)
+		    return (b);
+		b++;
+	    }
+	}
+    }
+    return (max);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_sysmem.c sys/dev/kgi/kgi_sysmem.c
--- sys/dev/kgi/kgi_sysmem.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_sysmem.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,131 @@
+/*-
+* Copyright (C) 2004 Nicholas Souchu
+*
+* This file is distributed under the terms and conditions of the 
+* MIT/X public license. Please see the file COPYRIGHT.MIT included
+* with this software for details of these terms and conditions.
+* Alternatively you may distribute this file under the terms and
+* conditions of the GNU General Public License. Please see the file 
+* COPYRIGHT.GPL included with this software for details of these terms
+* and conditions.
+*/
+
+/*
+ * KGI FreeBSD memory system layer
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#define KGI_SYS_NEED_USER
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgidbg.h>
+
+/*
+ * No mutexes should be held (except for Giant) across functions which
+ * access memory in userspace, such as copyin(9), copyout(9), uiomove(9),
+ * fuword(9), etc.  No locks are needed when calling these functions.
+ */
+
+/*
+ * Copy a kernel area to user process area.
+ */
+__kgi_u32_t
+kgi_copy_to_user(void *to, const void *from, __kgi_u32_t n)
+{
+
+	if (copyout(from, to, n))
+		return (0);
+
+	return (n);
+}
+
+/*
+ * Copy a user process area to a kernel area.
+ */
+__kgi_u32_t
+kgi_copy_from_user(void *to, const void *from, __kgi_u32_t n)
+{
+
+	if (copyin(from, to, n))
+		return (0);
+
+	return (n);
+}
+
+/*
+ * Map a physical address (buffer) into kernel virtual memory.
+ * The size is truncate to a perfect number of pages.
+ */
+__kgi_virt_addr_t
+kgi_map_buffer(__kgi_phys_addr_t paddr, __kgi_size_t size)
+{
+	__kgi_virt_addr_t vaddr;
+	__kgi_phys_addr_t off;
+
+	off = paddr - trunc_page(paddr);
+	vaddr = (__kgi_virt_addr_t)pmap_mapdev(paddr - off, size + off);
+
+	return (vaddr + off);
+}
+
+/*
+ * Unmap a physical address (buffer) from kernel virtual memory.
+ */
+void
+kgi_unmap_buffer(__kgi_virt_addr_t vaddr, __kgi_size_t size)
+{
+
+	pmap_unmapdev((vm_offset_t)vaddr, (vm_size_t)size);
+}
+
+/*
+ * Allocate kernel memory of type M_KGI.
+ */
+void *
+kgi_kmalloc(__kgi_size_t size)
+{
+	void *ptr = malloc(size, M_KGI, M_NOWAIT);
+	KRN_DEBUG(3, "Allocating %p (%d)", (void *)ptr, size);
+	return (ptr);
+}
+
+/*
+ * Release kernel memory of type M_KGI.
+ */
+void 
+kgi_kfree(const void *ptr)
+{
+
+	KRN_DEBUG(3, "Freeing %p", (void *)ptr);
+	free((void *)ptr, M_KGI);
+}
+
+/*
+ * Allocate a contiguous memory.
+ */
+void *
+kgi_cmalloc(__kgi_size_t size)
+{
+
+	return (contigmalloc(size, M_KGI, M_NOWAIT, 0, ~0, PAGE_SIZE, 0));
+}
+
+/*
+ * Release a contiguous memory.
+ */
+void 
+kgi_cfree(const void *ptr, __kgi_size_t size)
+{
+
+	contigfree((void *)ptr, size, M_KGI);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_sysmutex.c sys/dev/kgi/kgi_sysmutex.c
--- sys/dev/kgi/kgi_sysmutex.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_sysmutex.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,77 @@
+/*-
+ * Copyright (C) 2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI FreeBSD mutex system layer
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define KGI_SYS_NEED_MUTEX
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgi.h>
+
+void
+kgi_mutex_init(kgi_mutex_t *mtx, const char *name)
+{
+
+	mtx_init(&mtx->mutex, name, NULL, MTX_DEF);
+	cv_init(&mtx->var, name);
+}
+
+void
+kgi_mutex_done(kgi_mutex_t *mtx)
+{
+
+	cv_destroy(&mtx->var);
+	mtx_destroy(&mtx->mutex);
+}
+
+/*
+ * Wait on the mutex e.g unlock the mutex
+ * and add the thread to the list of waiting
+ * threads on this mutex. When the thread is
+ * made runnable again, it owns the mutex.
+ *
+ * Important: the mutex must be already locked by
+ * the current running thread when calling
+ * kgi_mutex_wait().
+ */
+void
+kgi_mutex_wait(kgi_mutex_t *mtx)
+{
+
+	cv_wait(&mtx->var, &mtx->mutex);
+}
+
+/*
+ * Wakeup (unblock) threads waiting on the mutex.
+ *
+ * If unblock_all is TRUE then unblock all waiters
+ * otherwise only one.
+ */
+void
+kgi_mutex_signal(kgi_mutex_t *mtx, int unblock_all)
+{
+
+	if (unblock_all)
+		cv_broadcast(&mtx->var);
+	else
+		cv_signal(&mtx->var);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgi_syspci.c sys/dev/kgi/kgi_syspci.c
--- sys/dev/kgi/kgi_syspci.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgi_syspci.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,780 @@
+/*-
+ * Copyright (C) 2001 Nicholas Souchu - Alcve
+ * Copyright (C) 2003 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI FreeBSD PCI system layer
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#define KGI_SYS_NEED_USER
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kgi/kgii.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/rman.h>
+
+#include <dev/pci/pcivar.h>
+#include <dev/pci/pcireg.h>
+
+#define	__KRN_BUF_SIZE	1024
+
+LIST_HEAD(pcicfg_list, pcicfg_dev) pcicfg_head = LIST_HEAD_INITIALIZER(head);
+LIST_HEAD(pcicfg_resource_list, pcicfg_resource);
+
+struct pcicfg_resource {
+	int type;
+	
+	int rid;
+	
+	struct resource *res;
+	void *intrhand;
+	union {
+		io_region_t io;
+		mem_region_t mem;
+		irq_line_t irq;
+	} region;
+	
+	LIST_ENTRY(pcicfg_resource) entries;
+};
+
+struct pcicfg_dev {
+	pcicfg_vaddr_t pcidev;
+	device_t dev;
+
+#define PCICFG_CLAIMED	1
+	int flags;
+
+	struct pcicfg_resource_list resources;
+
+	LIST_ENTRY(pcicfg_dev) entries;
+};
+
+static int initialized = 0;
+
+/*
+ * PCI configuration space
+ */
+struct pcicfg_dev *
+pcicfg_lookup_device(pcicfg_vaddr_t pcidev)
+{
+	struct pcicfg_dev *p;
+
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+		if (p->pcidev == pcidev)
+			return (p);
+	}
+
+	return (NULL);
+}
+
+/* lookup the first matching pcicfg device_t */
+device_t 
+pcicfg_get_device(pcicfg_vaddr_t pcidev)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(pcidev);
+
+	if (p)
+		return (p->dev);
+
+	return (NULL);
+}
+
+pcicfg_vaddr_t 
+pcicfg_dev2cfg(device_t dev)
+{
+	u_int32_t bus, slot, func;
+
+	bus = pci_get_bus(dev);
+	slot = pci_get_slot(dev);
+	func = pci_get_function(dev);
+
+	return (PCICFG_VADDR(bus, slot, func)); 
+}
+
+/* XXX not SMP safe */
+int 
+pcicfg_add_device(device_t dev)
+{
+	struct pcicfg_dev *p;
+	pcicfg_vaddr_t pcidev;
+
+	/* If not done, initialize the pcicfg system. */
+	if (!initialized) {
+		LIST_INIT(&pcicfg_head);
+		initialized = 1;
+	}
+
+	pcidev = pcicfg_dev2cfg(dev);
+
+	/* Check if pci device already in the list. */
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+		if (p->pcidev == pcidev)
+			return (KGI_EOK);
+	}
+
+	p = (struct pcicfg_dev *)kgi_kmalloc(sizeof(struct pcicfg_dev));
+	if (!p)
+		return (KGI_ENOMEM);
+
+	memset(p, 0, sizeof(*p));
+
+	/* Store the internal device for future reference. */
+	p->dev = dev;
+	p->pcidev = pcidev;
+
+	/* Initialize the list of resources for this device. */
+	LIST_INIT(&p->resources);
+
+	/* Insert in the global list of pci configs. */
+	LIST_INSERT_HEAD(&pcicfg_head, p, entries);
+
+	return (KGI_EOK);
+}
+
+/* XXX not SMP safe */
+int 
+pcicfg_remove_device(device_t dev)
+{
+	struct pcicfg_dev *p;
+	struct pcicfg_resource *r;
+
+	if (!initialized)
+		return (KGI_EINVAL);
+
+	/* Scan the list of pci configs. */
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+                if (p->dev == dev) {
+			/* Delete the list of resources for this device. */
+			while (!LIST_EMPTY(&p->resources)) {
+				r = LIST_FIRST(&p->resources);
+				LIST_REMOVE(r, entries);
+
+				/* XXX bus_xxx free the resources!! */
+				kgi_kfree(r);
+			}
+			LIST_REMOVE(p, entries);
+			kgi_kfree(p);
+
+			return (0);
+		}
+	}
+
+	return (KGI_EINVAL);
+}
+
+/* claim the device so that no other driver will get it */
+void 
+pcicfg_claim_device(pcicfg_vaddr_t addr)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(addr);
+
+	if (p)
+		p->flags |= PCICFG_CLAIMED;
+}
+
+/* free the device so that other driver will get it */
+void 
+pcicfg_free_device(pcicfg_vaddr_t addr)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(addr);
+
+	if (p)
+		p->flags &= ~PCICFG_CLAIMED;
+}
+
+/*
+ * Find the PCI device/subsystem in the list of registered devices.
+ *
+ * The PCI cfg space is actually the list of devices found by the pci bus. 
+ *
+ * A PCI device must have been previously scanned and found by the pci
+ * bus (see board_probe()) for being found here.
+ *
+ * Actually, if a driver is going there, there's a lot of chance something
+ * will be found.
+ */
+int 
+pcicfg_find_device(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures)
+{
+	struct pcicfg_dev *p;
+	const __kgi_u32_t *check;
+	__kgi_u32_t signature;
+	u_int16_t vendor, device;
+
+	KRN_DEBUG(4, "scanning device in pcicfg space:");
+
+	/* Search among registered boards */
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+		/* If device already claimed, not a candidate */
+		if (p->flags & PCICFG_CLAIMED)
+			continue;
+
+		device = pci_get_device(p->dev);
+		vendor = pci_get_vendor(p->dev);
+
+		KRN_DEBUG(4, "scanning device %x %x\n", vendor, device);
+
+		signature = PCICFG_SIGNATURE(vendor, device);
+
+		/* Scan all signatures for the given dev */
+		check = signatures;
+		while (*check && (*check != signature)) 
+			check++;
+
+		/* Finally, the first dev after "after" is returned */
+		if (*check && (*check == signature)) {
+			*addr = pcicfg_dev2cfg(p->dev);
+
+			KRN_DEBUG(4, "found device %.8x at %.8x", 
+				  signature, *addr);
+			return (0);
+		}
+	}
+
+	*addr = PCICFG_NULL;
+	return (KGI_EINVAL);
+}
+
+int 
+pcicfg_find_subsystem(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures)
+{
+	struct pcicfg_dev *p;
+	const __kgi_u32_t *check;
+	__kgi_u32_t signature;
+	u_int16_t subvendor, subdevice;
+	u_int16_t vendor, device;
+
+	KRN_DEBUG(4, "scanning subsystem in pcicfg space:");
+
+	/* Search among registered boards */
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+		/* If device already claimed, not a candidate */
+		if (p->flags & PCICFG_CLAIMED)
+			continue;
+
+		device = pci_get_device(p->dev);
+		vendor = pci_get_vendor(p->dev);
+
+		subdevice = pci_get_subdevice(p->dev);
+		subvendor = pci_get_subvendor(p->dev);
+
+		signature = PCICFG_SIGNATURE(subvendor, subdevice);
+
+		KRN_DEBUG(4, "scanning device %x %x, subsystem %x %x\n", 
+			vendor, device, subvendor, subdevice);
+
+		check = signatures;
+		while (*check && (*check != signature)) 
+			check++;
+
+		if (*check && (*check == signature)) {
+			*addr = pcicfg_dev2cfg(p->dev);
+
+			KRN_DEBUG(4, "found device %.8x at %.8x", 
+				  signature, *addr);
+			return (KGI_EOK);
+		}
+	}
+
+	*addr = PCICFG_NULL;
+	return (KGI_ENODEV);
+}
+
+int 
+pcicfg_find_class(pcicfg_vaddr_t *addr, const __kgi_u32_t *signatures)
+{
+	struct pcicfg_dev *p;
+	const __kgi_u32_t *check;
+	u_int16_t class;
+
+	KRN_DEBUG(4, "scanning class in pcicfg space:");
+
+	LIST_FOREACH(p, &pcicfg_head, entries) {
+		/* If device already claimed, not a candidate */
+		if (p->flags & PCICFG_CLAIMED)
+			continue;
+
+		class = pci_get_class(p->dev) << 8;
+
+		KRN_DEBUG(4, "scanning device with class %.8x", class);
+
+		check = signatures;
+		while (*check && (*check != class)) 
+			check++;
+
+		if (*check && (*check == class)) {
+			*addr = pcicfg_dev2cfg(p->dev);
+
+			KRN_DEBUG(4, "found device of class %.8x at %.8x", 
+				  class, *addr);
+
+			return (KGI_EOK);
+		}
+	}
+
+	*addr = PCICFG_NULL;
+	return (KGI_ENODEV);
+}
+
+
+#define VADDR_BASE (vaddr & ~0xFF)
+#define VADDR_OFFSET (vaddr & 0xFF)
+
+__kgi_u8_t  
+pcicfg_in8 (const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return (-1);
+
+	return pci_read_config(dev, VADDR_OFFSET, 1);
+}
+
+__kgi_u16_t 
+pcicfg_in16(const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return (-1);
+
+	return pci_read_config(dev, VADDR_OFFSET, 2);
+}
+
+__kgi_u32_t 
+pcicfg_in32(const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return (-1);
+
+	return pci_read_config(dev, VADDR_OFFSET, 4);
+}
+
+void 
+pcicfg_out8 (const __kgi_u8_t val, const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return;
+
+	pci_write_config(dev, VADDR_OFFSET, val, 1);
+
+	return;
+}
+
+void 
+pcicfg_out16(const __kgi_u16_t val, const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return;
+
+	pci_write_config(dev, VADDR_OFFSET, val, 2);
+
+	return;
+}
+
+void 
+pcicfg_out32(const __kgi_u32_t val, const pcicfg_vaddr_t vaddr)
+{
+	device_t dev = pcicfg_get_device(VADDR_BASE);
+
+	if (!dev)
+		return;
+
+	pci_write_config(dev, VADDR_OFFSET, val, 4);
+}
+
+/*
+ * io I/O space
+ */
+__kgi_error_t 
+io_check_region(io_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	struct resource *res = NULL;
+	int rid = r->rid;
+
+	/* Is the device registered? */
+	if (!p)
+		goto error;
+
+	/* Try to allocate the resource */
+	if (!(res = bus_alloc_resource(p->dev, SYS_RES_IOPORT, &rid,
+				       r->base_io, r->base_io + (r->size -1),
+				       r->size, RF_ACTIVE | RF_SHAREABLE))) {
+
+		/* Try to set the resource before allocation */
+		bus_set_resource(p->dev, SYS_RES_IOPORT, rid, r->base_io,
+				 r->size);
+
+		res = bus_alloc_resource(p->dev, SYS_RES_IOPORT, &rid,
+					 r->base_io, r->base_io + (r->size -1),
+					 r->size, RF_ACTIVE | RF_SHAREABLE);
+	}
+
+	/* Resource allocation succeeded, release then report ok */
+	if (res) {
+		bus_release_resource(p->dev, SYS_RES_IOPORT, rid, res);
+
+		KRN_DEBUG(2, "io_check_region('%s', base 0x%x, size %i): ok",
+			  r->name, r->base_io, r->size);
+
+		return (KGI_EOK);
+	}
+
+error:
+	KRN_DEBUG(2, "io_check_region('%s', base 0x%x, size %i): "
+		  "failed", r->name, r->base_io, r->size);
+	return (KGI_ENODEV);
+}
+
+io_vaddr_t 
+io_claim_region(io_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	device_t dev = pcicfg_get_device(r->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+	struct resource *res = NULL;
+	int rid = r->rid;
+
+	pcicfg_res = (struct pcicfg_resource *)kgi_kmalloc(sizeof(struct
+		pcicfg_resource));
+
+	if (!p || !dev || !pcicfg_res)
+		goto error;
+
+	memset(pcicfg_res, 0, sizeof(*pcicfg_res));
+
+	KRN_ASSERT(r->base_virt == 0); /* claim of claimed region? */
+
+	if (!(res = bus_alloc_resource(dev, SYS_RES_IOPORT, &rid,
+				       r->base_io, r->base_io + (r->size -1),
+				       r->size, RF_ACTIVE | RF_SHAREABLE)))
+		goto error;
+
+	r->base_virt = r->base_phys = r->base_bus = r->base_io;
+
+	pcicfg_res->type = SYS_RES_IOPORT;
+	pcicfg_res->rid = rid;
+	pcicfg_res->res = res;
+	pcicfg_res->region.io = *r;
+
+	LIST_INSERT_HEAD(&p->resources, pcicfg_res, entries);
+
+	KRN_DEBUG(2, "io_claim_region('%s', base_io %.4x, base_virt %.4x, "
+		"base_phys %.4x, base_bus %.4x): success", r->name,
+		r->base_io, r->base_virt, r->base_phys, r->base_bus);
+
+	return (r->base_virt);
+
+error:
+	KRN_DEBUG(2, "mem_claim_region('%s', base_io 0x%x, size %i): failed",
+		  r->name, (kgi_u32_t)r->base_io, (kgi_u_t)r->size);
+	if (pcicfg_res)
+		kgi_kfree(pcicfg_res);
+	return (0);
+}
+
+io_vaddr_t 
+io_free_region(io_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+	int error;
+
+	if (!p)
+		return (KGI_EINVAL);
+
+	LIST_FOREACH(pcicfg_res, &p->resources, entries) {
+		if ((pcicfg_res->type == SYS_RES_IOPORT) &&
+		    (pcicfg_res->region.io.base_virt == r->base_virt) &&
+		    (pcicfg_res->region.io.size == r->size)) {
+			break;
+		}
+	}
+
+	if (pcicfg_res) {
+		KRN_DEBUG(2, "io_free_region('%s', base_io %.4x, base_virt %.4x, "
+			  "base_phys %.4x, base_bus %.4x)", r->name,
+			  r->base_io, r->base_virt, r->base_phys,
+			  r->base_bus);
+		
+		error = bus_release_resource(p->dev, SYS_RES_IOPORT,
+					     pcicfg_res->rid, pcicfg_res->res);
+		
+		LIST_REMOVE(pcicfg_res, entries);
+		kgi_kfree(pcicfg_res);
+		
+		r->base_virt = 0;
+		r->base_phys = r->base_bus = 0;
+	}
+
+	return (0);
+}
+
+io_vaddr_t 
+io_alloc_region(io_region_t *r)
+{
+	/*	AFAIK nothing appropriate under Linux yet. */
+	return (0);
+}
+
+/*
+ * memory I/O space
+ */
+__kgi_error_t 
+mem_check_region(mem_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	struct resource *res = NULL;
+	int rid = r->rid;
+
+	/* Is the device registered? */
+	if (!p)
+		goto error;
+
+	/* Try to allocate the resource */
+	if (!(res = bus_alloc_resource(p->dev, SYS_RES_MEMORY, &rid,
+				       r->base_io, r->base_io + (r->size -1),
+				       r->size, RF_ACTIVE | RF_SHAREABLE))) {
+		/* Try to set the resource before allocation */
+		bus_set_resource(p->dev, SYS_RES_MEMORY, rid, r->base_io,
+				 r->size);
+
+		res = bus_alloc_resource(p->dev, SYS_RES_MEMORY, &rid,
+					 r->base_io, r->base_io + (r->size -1),
+					 r->size, RF_ACTIVE | RF_SHAREABLE);
+	}
+
+	/* Resource allocation succeeded, release then report ok */
+	if (res) {
+		bus_release_resource(p->dev, SYS_RES_MEMORY, rid, res);
+
+		KRN_DEBUG(2, "mem_check_region('%s', base 0x%x, size %i): ok",
+			  r->name, r->base_io, r->size);
+
+		return (KGI_EOK);
+	}
+
+error:
+	KRN_DEBUG(2, "mem_check_region('%s', base 0x%x, size %i): "
+		  "failed", r->name, r->base_io, r->size);
+	return (KGI_ENODEV);
+}
+
+mem_vaddr_t 
+mem_claim_region(mem_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	device_t dev = pcicfg_get_device(r->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+	struct resource *res = NULL;
+	int rid = r->rid;
+
+	pcicfg_res = (struct pcicfg_resource *)kgi_kmalloc(sizeof(struct
+		pcicfg_resource));
+
+	if (!p || !dev || !pcicfg_res)
+		goto error;
+
+	memset(pcicfg_res, 0, sizeof(*pcicfg_res));
+
+	if (!(res = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,
+				       r->base_io, r->base_io + (r->size -1),
+				       r->size, RF_ACTIVE | RF_SHAREABLE)))
+		goto error;
+
+	r->base_phys = (mem_paddr_t) r->base_io;
+	r->base_bus  = (mem_baddr_t) r->base_io;
+	r->base_virt = (mem_vaddr_t) rman_get_virtual(res);
+
+	pcicfg_res->type = SYS_RES_MEMORY;
+	pcicfg_res->rid = rid;
+	pcicfg_res->res = res;
+	pcicfg_res->region.mem = *r;
+
+	LIST_INSERT_HEAD(&p->resources, pcicfg_res, entries);
+
+	KRN_DEBUG(2, "mem_claim_region('%s', base_io %p, base_virt %p, "
+		"base_phys %p, base_bus %p): success", r->name, 
+		(void *) r->base_io, (void *) r->base_virt, 
+		(void *) r->base_phys, (void *) r->base_bus);
+
+	return (r->base_virt);
+
+error:
+	KRN_DEBUG(2, "mem_claim_region('%s', base_io 0x%x, size %i): failed",
+		  r->name, r->base_io, r->size);
+	if (pcicfg_res)
+		kgi_kfree(pcicfg_res);
+	return ((mem_vaddr_t)NULL);
+}
+
+mem_vaddr_t 
+mem_free_region(mem_region_t *r)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(r->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+	int error;
+
+	if (!p)
+		return ((mem_vaddr_t)NULL);
+
+	LIST_FOREACH(pcicfg_res, &p->resources, entries) {
+		if ((pcicfg_res->type == SYS_RES_MEMORY) &&
+		    (pcicfg_res->region.mem.base_virt == r->base_virt) &&
+		    (pcicfg_res->region.mem.size == r->size)) {
+			break;
+		}
+	}
+
+	if (pcicfg_res) {
+		KRN_DEBUG(2, "mem_free_region %s, base_io %p, base_virt %p, "
+			  "base_phys %p, base_bus %p", r->name,
+			  (void *) r->base_io, (void *) r->base_virt,
+			  (void *) r->base_phys, (void *) r->base_bus);
+	
+		error = bus_release_resource(p->dev, SYS_RES_MEMORY,
+					     pcicfg_res->rid, pcicfg_res->res);
+		
+		LIST_REMOVE(pcicfg_res, entries);
+		kgi_kfree(pcicfg_res);
+		
+		r->base_bus  = (mem_baddr_t)NULL;
+		r->base_phys = (mem_paddr_t)NULL;
+		r->base_virt = (mem_vaddr_t)NULL;
+	}
+		
+	return ((mem_vaddr_t)NULL);
+}
+
+mem_vaddr_t 
+mem_alloc_region(mem_region_t *r)
+{
+	/*
+	 * AFAIK there is no resource management for memory regions
+	 * in Linux yet. We just report it failed.
+	 */
+	return ((mem_vaddr_t)NULL);
+}
+
+/*
+ * irq handling
+ */
+static void 
+irq_handler(void *priv)
+{
+	register irq_line_t *irq = (irq_line_t *) priv;
+
+	if (irq->High) 
+		irq->High(irq->meta, irq->meta_io, NULL);
+
+	return;
+}
+
+__kgi_error_t 
+irq_claim_line(irq_line_t *irq)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(irq->device);
+	device_t dev = pcicfg_get_device(irq->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+	struct resource *res = NULL;
+	int rid = irq->line;
+	unsigned int flags = RF_ACTIVE;
+	int error;
+
+	pcicfg_res = (struct pcicfg_resource *)kgi_kmalloc(sizeof(struct
+		pcicfg_resource));
+
+	if (!p || !dev || !pcicfg_res)
+		goto error;
+
+	memset(pcicfg_res, 0, sizeof(*pcicfg_res));
+
+	if (irq->flags & IF_SHARED_IRQ) 
+		flags |= RF_SHAREABLE;
+
+	if (!(res = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1, flags)))
+		goto error;
+
+	if ((error = bus_setup_intr(p->dev, res, INTR_TYPE_MISC,
+			NULL, irq_handler, p, &pcicfg_res->intrhand)))
+		goto error;
+
+	pcicfg_res->type = SYS_RES_IRQ;
+	pcicfg_res->rid = rid;
+	pcicfg_res->res = res;
+	pcicfg_res->region.irq = *irq;
+
+	LIST_INSERT_HEAD(&p->resources, pcicfg_res, entries);
+
+	KRN_DEBUG(2, "irq_claim_line('%s', line %i): success", irq->name,
+		irq->line);
+
+	return (KGI_EOK);
+
+error:
+	KRN_DEBUG(2, "irq_claim_line('%s', line %i): failed", irq->name,
+		irq->line);
+	if (res)
+		bus_release_resource(p->dev, SYS_RES_IRQ, 0, res);
+	if (pcicfg_res)
+		kgi_kfree(pcicfg_res);
+	return (KGI_EINVAL);
+}
+
+void 
+irq_free_line(irq_line_t *irq)
+{
+	struct pcicfg_dev *p = pcicfg_lookup_device(irq->device);
+	struct pcicfg_resource *pcicfg_res = NULL;
+
+	LIST_FOREACH(pcicfg_res, &p->resources, entries) {
+		if ((pcicfg_res->type == SYS_RES_IRQ) &&
+		    (pcicfg_res->region.irq.line == irq->line)) {
+			break;
+		}
+	}
+
+	if (pcicfg_res) {
+		KRN_DEBUG(2, "irq_free_line('%s', line %i)", irq->name, irq->line);
+
+		bus_teardown_intr(p->dev, pcicfg_res->res, pcicfg_res->intrhand);
+		bus_release_resource(p->dev, SYS_RES_IRQ, 0, pcicfg_res->res);
+		
+		LIST_REMOVE(pcicfg_res, entries);
+		kgi_kfree(pcicfg_res);
+	}
+
+	return;
+}
+
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgicmd.h sys/dev/kgi/kgicmd.h
--- sys/dev/kgi/kgicmd.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgicmd.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,416 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI command definitions
+ */
+
+#ifndef _kgi_command_h
+#define	_kgi_command_h
+
+/*
+ * null command data. No input, no output.
+ */
+typedef struct {
+} kgic_null_t;
+
+#define	kgic_null_result_t	kgic_null_t
+#define	kgic_null_request_t	kgic_null_t
+
+#define KGIC_UNION(type, command)			\
+typedef union						\
+{ 							\
+	kgic_##type##_##command##_request_t request;	\
+	kgic_##type##_##command##_result_t  result;	\
+} kgic_##type##_##command##_union_t;
+
+/*
+ * mapper commands
+ */
+typedef struct {
+	kgi_ascii_t	client[64];
+	kgi_version_t	client_version;
+} kgic_mapper_identify_request_t;
+
+typedef struct {
+	kgi_ascii_t	mapper[64];
+	kgi_version_t	mapper_version;
+	kgi_u32_t	resources;
+} kgic_mapper_identify_result_t;
+
+KGIC_UNION(mapper, identify);
+
+typedef struct {
+	kgi_u32_t	images;
+} kgic_mapper_set_images_request_t;
+
+typedef kgic_null_result_t kgic_mapper_set_images_result_t;
+
+KGIC_UNION(mapper, set_images);
+
+typedef kgic_null_request_t kgic_mapper_get_images_request_t;
+
+typedef struct {
+	kgi_u32_t	images;
+} kgic_mapper_get_images_result_t;
+
+KGIC_UNION(mapper, get_images);
+
+typedef struct {
+	kgi_u32_t		image;
+	kgi_image_mode_t	mode;
+} kgic_mapper_set_image_mode_request_t;
+
+typedef kgic_null_result_t kgic_mapper_set_image_mode_result_t;
+
+KGIC_UNION(mapper, set_image_mode);
+
+typedef struct {
+	kgi_u32_t	image;
+} kgic_mapper_get_image_mode_request_t;
+
+typedef struct {
+	kgi_image_mode_t	mode;
+} kgic_mapper_get_image_mode_result_t;
+
+KGIC_UNION(mapper, get_image_mode);
+
+#define __KGIC_RESOURCE_REQUEST_COMMON \
+	kgi_u_t image, resource;
+
+/*
+ * set image in kgic_mapper_resource_info_request_t to this get mode 
+ * resource info.  0 to __KGI_MAX_NR_IMAGE_RESOURCES will get per image
+ * resource info.
+ */
+#define	KGIC_MAPPER_NON_IMAGE_RESOURCE   -1
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON
+} kgic_mapper_resource_info_request_t;
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON
+	kgi_ascii_t		name[64];
+	kgi_resource_type_t	type;
+	kgi_protection_flags_t	protection;
+
+	union {
+		struct {
+			kgi_u32_t	access;
+			kgi_u32_t	align;
+			kgi_size_t	size;
+			kgi_size_t	window;
+		} mmio;
+		struct {
+			kgi_u32_t	buffers;
+			kgi_size_t	buffer_size;
+
+		} accel;
+		struct {
+			kgi_size_t		aperture_size;
+		} shmem;
+	} info;
+} kgic_mapper_resource_info_result_t;
+
+KGIC_UNION(mapper, resource_info);
+
+typedef struct {	
+	kgi_resource_type_t type;
+	__KGIC_RESOURCE_REQUEST_COMMON
+	
+	union {	
+		struct {		
+			kgi_u_t buffers;
+			kgi_u_t max_order;
+			kgi_u_t min_order;
+			kgi_u_t priority;
+		} accel;
+	} private;	
+} kgic_mapper_mmap_setup_request_t;
+
+typedef kgic_null_result_t kgic_mapper_mmap_setup_result_t;
+
+KGIC_UNION(mapper, mmap_setup);
+
+typedef struct {
+	kgi_u_t device_id;
+} kgic_mapper_attach_request_t;
+
+typedef kgic_null_result_t kgic_mapper_attach_result_t;
+
+KGIC_UNION(mapper, attach);
+
+typedef struct {
+	kgi_u_t unit;
+} kgic_mapper_get_unit_request_t;
+
+typedef struct {
+	kgi_u_t unit;
+} kgic_mapper_get_unit_result_t;
+
+KGIC_UNION(mapper, get_unit);
+
+typedef struct
+{
+	__KGIC_RESOURCE_REQUEST_COMMON;	
+} kgic_resource_request_t;
+
+
+/*
+ * {c,a,i,t}lut commands
+ */
+
+typedef kgic_null_result_t kgic_clut_get_info_request_t;
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t tables;
+	kgi_u_t entries;
+	
+} kgic_clut_get_info_result_t;
+
+KGIC_UNION(clut, get_info);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t	lut;
+} kgic_clut_select_request_t;
+
+typedef kgic_null_result_t kgic_clut_select_result_t;
+
+KGIC_UNION(clut, select);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+
+	kgi_u_t	lut;
+	kgi_u_t	idx;
+	kgi_u_t cnt;
+	kgi_attribute_mask_t am;
+	kgi_u16_t *data;
+} kgic_clut_set_request_t;
+
+typedef kgic_null_result_t kgic_clut_set_result_t;
+
+KGIC_UNION(clut, set);
+
+/* alut */
+typedef kgic_clut_select_request_t 	kgic_alut_select_request_t;
+typedef kgic_null_result_t 		kgic_alut_select_result_t;
+typedef kgic_clut_set_request_t 	kgic_alut_set_request_t;
+typedef kgic_null_result_t 		kgic_alut_set_result_t;
+
+KGIC_UNION(alut, select);
+KGIC_UNION(alut, set);
+
+/* ilut */
+typedef kgic_clut_select_request_t 	kgic_ilut_select_request_t;
+typedef kgic_null_result_t 		kgic_ilut_select_result_t;
+typedef kgic_clut_set_request_t 	kgic_ilut_set_request_t;
+typedef kgic_null_result_t 		kgic_ilut_set_result_t;
+
+KGIC_UNION(ilut, select);
+KGIC_UNION(ilut, set);
+
+/* tlut */
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u16_t	lut;		/* image and lut number */
+} kgic_tlut_select_request_t;
+
+typedef kgic_null_result_t kgic_tlut_select_result_t;
+
+KGIC_UNION(tlut, select);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u16_t	lut;		/* image and lut number	*/
+	kgi_u16_t	idx, cnt;	/* first entry to set	*/
+	kgi_u16_t	dx, dy;		/* bitmap size		*/
+	kgi_size_t	size;		/* size of the data buffer */
+	kgi_u8_t	*data;
+} kgic_tlut_set_request_t;
+
+typedef kgic_null_result_t kgic_tlut_set_result_t;
+
+KGIC_UNION(tlut, set);
+
+/*
+ * marker commands
+ */
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;	
+} kgic_marker_info_request_t;
+
+typedef struct {
+	kgi_marker_mode_t 	modes;
+	kgi_u8_t 		shapes;
+	kgi_u8_coord_t 		size;	
+} kgic_marker_info_result_t;
+
+KGIC_UNION(marker, info);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_marker_mode_t mode;	
+} kgic_marker_set_mode_request_t;
+
+typedef kgic_null_result_t kgic_marker_set_mode_result_t;
+
+KGIC_UNION(marker, set_mode);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t shape;
+} kgic_marker_select_request_t;
+
+typedef kgic_null_result_t kgic_marker_select_result_t;
+
+KGIC_UNION(marker, select);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t shape;
+	kgi_u_t hot_x, hot_y;
+	void *data;
+	kgi_rgb_color_t *color;	
+} kgic_marker_set_shape_request_t;
+
+typedef kgic_null_result_t kgic_marker_set_shape_result_t;
+
+KGIC_UNION(marker, set_shape);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t x,y;	
+} kgic_marker_show_request_t;
+
+typedef kgic_null_result_t  kgic_marker_show_result_t;
+
+KGIC_UNION(marker, show);
+
+/*
+ * text16 commands
+ */
+
+typedef kgic_null_request_t kgic_text16_info_request_t;
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_ucoord_t size;
+	kgi_ucoord_t virt;
+	kgi_ucoord_t cell;
+	kgi_ucoord_t font;		     
+} kgic_text16_info_result_t;
+
+KGIC_UNION(text16, info);
+
+typedef struct {
+	__KGIC_RESOURCE_REQUEST_COMMON;
+	
+	kgi_u_t offset;
+	kgi_u16_t *text;
+	kgi_u_t cnt;	
+} kgic_text16_put_text16_request_t;
+
+typedef kgic_null_result_t kgic_text16_put_text16_result_t;
+
+KGIC_UNION(text16, put_text16);
+
+/*
+ * display commands
+ */
+
+
+/*
+ * KGI command encoding
+ */
+
+/* Include ioccom.h for _IOxx definitions */
+#include <sys/ioccom.h>
+
+#define KGIC_IO(type, command, callback, code) \
+	KGIC_##type##_##command = _IO(KGIC_##type##_COMMAND >> 8, code)
+
+#define KGIC_IOR(type, command, callback, code) \
+	KGIC_##type##_##command = _IOR(KGIC_##type##_COMMAND >> 8, code, kgic_##callback##_result_t)
+
+#define KGIC_IOW(type, command, callback, code) \
+	KGIC_##type##_##command = _IOW(KGIC_##type##_COMMAND >> 8, code, kgic_##callback##_request_t)
+
+#define KGIC_IOWR(type, command, callback, code) \
+	KGIC_##type##_##command = _IOWR(KGIC_##type##_COMMAND >> 8, code, kgic_##callback##_union_t)
+	
+
+typedef enum {
+	KGIC_MAPPER_COMMAND	= 0x00000000,	/* ext. mapper commands	*/
+		KGIC_IOWR(MAPPER, IDENTIFY,		mapper_identify,	0x0001),
+		KGIC_IOW (MAPPER, SET_IMAGES,		mapper_set_images,	0x0002),
+		KGIC_IOR (MAPPER, GET_IMAGES,		mapper_get_images,	0x0003),
+		KGIC_IOW (MAPPER, SET_IMAGE_MODE,	mapper_set_image_mode,	0x0004),
+		KGIC_IOWR(MAPPER, GET_IMAGE_MODE,	mapper_get_image_mode,	0x0005),
+		KGIC_IO  (MAPPER, MODE_CHECK,		null,			0x0006),
+		KGIC_IO  (MAPPER, MODE_SET,		null,			0x0007),
+		KGIC_IO  (MAPPER, MODE_UNSET,		null,			0x0008),
+		KGIC_IO  (MAPPER, MODE_DONE,		null,			0x0009),
+		KGIC_IOWR(MAPPER, RESOURCE_INFO,	mapper_resource_info,	0x000A),
+		KGIC_IOW (MAPPER, MMAP_SETUP,		mapper_mmap_setup,	0x000B),
+		KGIC_IOW (MAPPER, ATTACH,		mapper_attach,		0x000C),
+		KGIC_IOWR(MAPPER, GET_UNIT,		mapper_get_unit,	0x000D),
+
+	KGIC_RESOURCE_COMMAND   = 0x00000100,   /* resource commands */
+		/* commands for KGI_RT_{ILUT,ALUT}_CONTROL */
+		KGIC_IOR (RESOURCE, CLUT_GET_INFO,	clut_get_info,		0x0001),
+		KGIC_IOW (RESOURCE, CLUT_SELECT,	clut_select,		0x0002),
+		KGIC_IOW (RESOURCE, CLUT_SET,		clut_set,		0x0003),
+		/* commands for KGI_RT_TLUT_CONTROL */
+		KGIC_IOW (RESOURCE, TLUT_SELECT,	tlut_select,		0x0020),
+		KGIC_IOW (RESOURCE, TLUT_SET,		tlut_set,		0x0021),
+		/* commands from KGI_RT_{CURSOR,POINTER}_CONTROL */
+		KGIC_IOW (RESOURCE, MARKER_SET_MODE,	marker_set_mode,	0x0030),
+		KGIC_IOW (RESOURCE, MARKER_SELECT,	marker_select,		0x0031),
+		KGIC_IOW (RESOURCE, MARKER_SET_SHAPE,	marker_set_shape,	0x0032),
+		KGIC_IOW (RESOURCE, MARKER_SHOW,	marker_show,		0x0033),
+		KGIC_IO  (RESOURCE, MARKER_HIDE,	null,			0x0034),
+		KGIC_IO  (RESOURCE, MARKER_UNDO,	null,			0x0035),
+		KGIC_IOWR(RESOURCE, MARKER_INFO,	marker_info,		0x0036),
+		/* commands for KGI_RT_TEXT16_CONTROL */
+		KGIC_IOW (RESOURCE, TEXT16_PUT_TEXT16,	text16_put_text16,	0x0040),
+		KGIC_IOR (RESOURCE, TEXT16_INFO,	text16_info,		0x0041),
+
+	KGIC_MODE_COMMAND	= 0x00008000,	/* mode commands	*/
+
+	KGIC_DISPLAY_COMMAND	= 0x0000C000,	/* display commands	*/
+
+	KGIC_TYPE_MASK		= 0x0000FF00,
+	KGIC_NR_MASK		= 0x000000FF,
+	KGIC_COMMAND_MASK	= KGIC_TYPE_MASK | KGIC_NR_MASK
+
+} kgi_command_t;
+
+#define	KGIC_COMMAND(cmd)	((cmd) & KGIC_COMMAND_MASK)
+#define	KGIC_SIZE(cmd)		(IOCPARM_LEN(cmd))
+#define	KGIC_READ(cmd)		((cmd) & IOC_OUT)
+#define	KGIC_WRITE(cmd)		((cmd) & IOC_IN)
+
+#endif	/* #ifndef _kgi_command_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgidbg.h sys/dev/kgi/kgidbg.h
--- sys/dev/kgi/kgidbg.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgidbg.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,187 @@
+/*-
+* Copyright (C) 1997-2000 Steffen Seeger
+* Copyright (C) 2003-2004 Nicholas Souchu
+* 
+* This file is distributed under the terms and conditions of the 
+* MIT/X public license. Please see the file COPYRIGHT.MIT included
+* with this software for details of these terms and conditions.
+* Alternatively you may distribute this file under the terms and
+* conditions of the GNU General Public License. Please see the file 
+* COPYRIGHT.GPL included with this software for details of these terms
+* and conditions.
+*/
+
+/*
+ * A generic debugging framework.
+ */
+
+#ifndef	__kgi_kgidbg_h
+#define	__kgi_kgidbg_h
+
+/*
+ * kernel debugging macros
+ */
+#ifdef	_KERNEL
+
+/*
+ * platform-independent interface definitions
+ */
+
+#define	KRN_DEBUG_ANSI_CPP	1
+
+/* Distinguish a bit KGI debug level symbol */
+#ifndef KGI_DBG_LEVEL
+#define KGI_DBG_LEVEL 0
+#endif
+
+/* Ensure compat with KGI original debug level symbol */
+#ifndef DEBUG_LEVEL
+#define DEBUG_LEVEL 0
+#endif
+
+extern int console_initialized;
+
+#define	KRN_ERROR(fmt, args...) 					\
+		if (console_initialized)				\
+			printf(fmt "\n", ##args)
+#define	KRN_NOTICE(fmt, args...) 					\
+		if (console_initialized)				\
+			printf(fmt "\n", ##args)
+#define	KRN_DEBUG(level, fmt, args...)					\
+		if (console_initialized && (level <= KGI_DBG_LEVEL ||   \
+		    level <= DEBUG_LEVEL))				\
+			printf("<%i> " fmt "\n", level, ##args)
+#define KRN_BOOT(fmt, args...)						\
+		if (console_initialized && bootverbose)			\
+			printf(fmt "\n", ##args)
+
+#define	KRN_ASSERT(x)							\
+	if (x) {} else { KRN_DEBUG(0, "%s", #x); }
+
+#define	KRN_INTERNAL_ERROR						\
+		KRN_ERROR("KGI internal error")
+
+#ifdef KGI_DBG_LEVEL
+#define	KRN_TRACE(level, x)	\
+		if (level <= KGI_DBG_LEVEL) { x; } else do {} while (0)
+#else
+#define	KRN_TRACE(level, x)	
+#endif
+
+#ifndef PANIC
+#define PANIC(x) panic(__FILE__ ": " x);
+#endif
+
+#	define	__krn_error	printf
+#	define	__krn_notice	printf
+#	define	__krn_debug	log
+
+#else	/* #ifdef _KERNEL */
+
+/*
+ * library debugging macros
+ */
+#ifdef	__LIBRARY__
+
+#	ifdef __STRICT_ANSI__
+
+#		define	LIB_DEBUG_ANSI_CPP	1
+
+#		define	LIB_ERROR	__lib_error
+#		define	LIB_DEBUG	__lib_debug
+#		define	LIB_NOTICE	__lib_notice
+
+#		define	LIB_ASSERT(x)	if (x) {} else {}
+
+#	else
+
+#		define	LIB_DEBUG_GNU_CPP	1
+
+#		define	LIB_ERROR(fmt, args...)	\
+			__lib_error( __FILE__ , __LINE__ , \
+				__PRETTY_FUNCTION__ , fmt , ##args )
+
+#		ifdef KGI_DBG_LEVEL
+#			define	LIB_DEBUG(level, fmt, args... )		\
+				if (level <= KGI_DBG_LEVEL) {		\
+					__lib_debug( __FILE__ ,		\
+					__LINE__ , __PRETTY_FUNCTION__	\
+					, level , fmt , ##args );	\
+				}
+#		else
+#			define	LIB_DEBUG(x...) do {} while(0)
+#		endif
+
+#		define	LIB_NOTICE(fmt, args...)		\
+			__lib_notice( fmt , ##args )
+#		define	LIB_ASSERT(x)	\
+			if (x) {} else { LIB_DEBUG(0, "assertion %s failed.", #x); }
+#	endif
+
+#	define	LIB_INTERNAL_ERROR	\
+		LIB_ERROR("internal error. Please report to %s. Thanks.", MAINTAINER)
+
+#ifdef KGI_DBG_LEVEL
+#	define	LIB_TRACE(level, x)	\
+		if (level <= KGI_DBG_LEVEL) { x; } else do {} while (0)
+#else
+#	define	LIB_TRACE(level, x)	
+#endif
+
+#endif	/* #ifdef __LIBRARY__ */
+
+/*
+ * application debugging macros
+ */
+
+#ifdef	__APPLICATION__
+
+#	ifdef __STRICT_ANSI__
+
+#		define	APP_DEBUG_ANSI_CPP	1
+
+#		define	APP_ERROR	__app_error
+#		define	APP_DEBUG	__app_debug
+#		define	APP_NOTICE	__app_notice
+
+#		define	APP_ASSERT(x)	if (x) {} else {}
+
+#	else
+
+#		define	APP_DEBUG_GNU_CPP	1
+
+#		define	APP_ERROR(fmt, args...)	\
+			__app_error( __FILE__ , __LINE__ , \
+				__PRETTY_FUNCTION__ , fmt , ##args )
+
+#		ifdef KGI_DBG_LEVEL
+#			define	APP_DEBUG(level, fmt, args... )		\
+				if (level <= KGI_DBG_LEVEL) {		\
+					__app_debug( __FILE__ ,		\
+					__LINE__ , __PRETTY_FUNCTION__	\
+					, level , fmt , ##args );	\
+				}
+#		else
+#			define	APP_DEBUG(x...) do {} while(0)
+#		endif
+
+#		define	APP_NOTICE(fmt, args...)		\
+			__app_notice( fmt , ##args )
+#		define	APP_ASSERT(x)	\
+			if (x) {} else { APP_DEBUG(0, "assertion %s failed.", #x); }
+#	endif
+
+#	define	APP_INTERNAL_ERROR	\
+		APP_ERROR("internal error. Please report to %s. Thanks.", MAINTAINER)
+
+#ifdef KGI_DBG_LEVEL
+#	define	APP_TRACE(level, x)	\
+		if (level <= KGI_DBG_LEVEL) { x; } else do {} while (0)
+#else
+#	define	APP_TRACE(level, x)	
+#endif
+
+#endif	/* #ifdef __APPLICATION__ */
+#endif	/* #ifdef _KERNEL */
+
+#endif /* _kgi_kgidbg_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgidpy.h sys/dev/kgi/kgidpy.h
--- sys/dev/kgi/kgidpy.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgidpy.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,135 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent stuff
+ */
+
+#ifndef _kgi_kgidpy_h
+#define _kgi_kgidpy_h
+
+#ifdef _KERNEL
+
+/*
+ * Displays.
+ */
+
+#define	KGI_DISPLAY_REVISION	0x00010000
+
+typedef struct kgi_display_s kgi_display_t;
+
+typedef void kgi_display_refcount_fn(kgi_display_t *);
+
+typedef kgi_error_t kgi_display_check_mode_fn(kgi_display_t *dpy,
+		kgi_timing_command_t cmd, kgi_image_mode_t *img, kgi_u_t images,
+		void *dev_mode, const kgi_resource_t **r, kgi_u_t rsize);
+
+typedef	void kgi_display_set_mode_fn(kgi_display_t *dpy,
+		kgi_image_mode_t *img, kgi_u_t images, void *dev_mode);
+
+typedef kgi_error_t kgi_display_command_fn(kgi_display_t *dpy, kgi_u_t cmd, void *data);
+
+struct kgi_display_s {
+	kgi_u_t		revision;	/* KGI/driver revision 	*/
+#define KGI_MAX_VENDOR_STRING	64
+	kgi_ascii_t	vendor[KGI_MAX_VENDOR_STRING];	/* manufacturer		*/
+	kgi_ascii_t	model[KGI_MAX_VENDOR_STRING];	/* model/trademark	*/
+	kgi_u32_t	flags;		/* special capabilities	*/
+	kgi_u_t		mode_size;	/* private mode size	*/
+
+
+	kgi_mode_t	*mode;	/* currently set mode			*/
+
+	kgi_u_t	id;		/* display number, init to -1		*/
+	kgi_u_t	graphic;	/* non-console devices attached		*/
+	struct kgi_display_s *prev; /* previous driver 		*/
+
+	kgi_display_refcount_fn		*IncRefcount;
+	kgi_display_refcount_fn		*DecRefcount;
+
+	kgi_display_check_mode_fn	*CheckMode;
+	kgi_display_set_mode_fn		*SetMode;
+	kgi_display_set_mode_fn		*UnsetMode;
+	kgi_display_command_fn		*Command;
+
+	struct kgi_device_s	*focus;	/* current focus	*/
+};
+
+/*
+ * KGI events
+ */
+
+#define KGI_EVENT_NOTICE_NEW_DISPLAY   0x00000001
+
+typedef struct {
+	kgi_u_t		command;
+} kgi_event_notice_t;
+
+typedef union {
+	kgi_event_notice_t	notice;
+} kgi_event_t;
+
+/*
+ * devices
+ * DF_CONSOLE is not text mode anymore but may be graphic. This is just a
+ * question of map. DF_TEXT16 shall be used to specify a text console.
+ */
+typedef enum {
+	KGI_DF_FOCUSED			= 0x00000001,
+	KGI_DF_CONSOLE			= 0x00000002,
+	KGI_DF_CLONED			= 0x00000004,
+	KGI_DF_TEXT16			= 0x00000008
+} kgi_device_flags_t;
+
+typedef void kgi_device_map_device_fn(struct kgi_device_s *);
+typedef kgi_s_t kgi_device_unmap_device_fn(struct kgi_device_s *);
+typedef void kgi_device_handle_event_fn(struct kgi_device_s *, kgi_event_t *);
+
+
+typedef struct kgi_device_s {
+	kgi_u_t			id;	/* device number 		*/
+	kgi_u_t			dpy_id;	/* display number		*/
+	kgi_device_flags_t	flags;	/* device flags			*/
+
+	kgi_device_map_device_fn	*MapDevice;
+	kgi_device_unmap_device_fn	*UnmapDevice;
+	kgi_device_handle_event_fn	*HandleEvent;
+
+	kgi_mode_t	*mode;	/* currently set mode			*/
+
+	kgi_private_t	priv;	/* device private state			*/
+} kgi_device_t;
+
+extern kgi_u_t kgi_attr_bits(const kgi_u8_t *bpa);
+
+extern void    kgi_map_device(kgi_u_t dev_id);
+extern kgi_s_t kgi_unmap_device(kgi_u_t dev_id);
+
+extern kgi_s_t kgi_register_device(kgi_device_t *dev, kgi_u_t idx);
+extern void    kgi_unregister_device(kgi_device_t *dev);
+extern kgi_error_t kgi_check_mode(kgi_u_t dev_id, kgi_mode_t *m);
+
+extern kgi_s_t kgi_register_display(kgi_display_t *dpy, kgi_u_t id);
+extern void    kgi_unregister_display(kgi_display_t *dpy);
+extern kgi_s_t kgi_display_registered(kgi_u_t id);
+
+extern kgi_device_t *kgi_current_focus(kgi_u_t dpy_id);
+extern kgi_u_t kgi_current_devid(kgi_u_t dpy_id);
+extern void kgidev_show_gadgets(kgi_device_t *dev);
+extern void kgidev_undo_gadgets(kgi_device_t *dev);
+
+extern kgi_error_t kgidev_display_command(kgi_device_t *dev, kgi_u_t cmd, void *data);
+
+#endif /* _KERNEL */
+
+#endif /* _kgi_kgidpy_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgierr.h sys/dev/kgi/kgierr.h
--- sys/dev/kgi/kgierr.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgierr.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,63 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI error codes
+ */
+
+#ifndef	_kgi_kgierr_h
+#define	_kgi_kgierr_h
+
+#define KGI_EAGAIN	EAGAIN
+#define KGI_EPROTO	ENOTSUP
+#define KGI_ENXIO	ENXIO
+#define KGI_EBADF	EBADF
+#define KGI_EINVAL	EINVAL
+#define KGI_ENOMEM	ENOMEM
+#define KGI_EPERM	EPERM
+#define KGI_EFAULT	EFAULT
+#define KGI_EBUSY	EBUSY
+#define KGI_ENODEV	ENODEV
+
+enum __kgi_error {
+	KGI_EOK	= 0,
+	KGI_NOMEM,
+	KGI_INVAL,
+	KGI_NOSUP,
+	KGI_NODEV,
+	KGI_FAILED,
+	KGI_DLL_ERROR,
+	KGI_NOT_IMPLEMENTED,
+	KGI_UNKNOWN,
+	KGI_CLK_LIMIT,
+
+	KGI_NO_DISPLAY,
+
+	KGI_LIB		= 0x01000000,
+	KGI_KGI		= 0x02000000,
+	KGI_DRIVER	= 0x02000000,
+	KGI_MONITOR	= 0x02100000,
+	KGI_RAMDAC	= 0x02200000,
+	KGI_CHIPSET	= 0x02300000,
+	KGI_CLOCK	= 0x02400000,
+	
+	KGI_DRV		= 0x03000000,
+
+	KGI_ERROR_SUBSYSTEM = 0x7F000000,
+
+	__KGI_LAST_ERROR
+};
+
+#define	KGI_ERRNO(system, code)	((KGI_##system) | (KGI_##code))
+
+#endif	/* _kgi_kgierr_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgii.h sys/dev/kgi/kgii.h
--- sys/dev/kgi/kgii.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgii.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,58 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent foo.
+ */
+
+#ifndef _kgi_kgii_h
+#define _kgi_kgii_h
+
+/*
+ * KGI/KII limits. 
+ * NOTE	All limits need to be less than 255.
+ */
+#define	CONFIG_KGII_MAX_NR_DISPLAYS	8
+#define	CONFIG_KGII_MAX_NR_INPUTS	255
+#define	CONFIG_KGII_MAX_NR_FOCUSES	8
+#define	CONFIG_KGII_MAX_NR_CONSOLES	96
+#define	CONFIG_KGII_MAX_NR_DEVICES	(2*CONFIG_KGII_MAX_NR_CONSOLES)
+
+#define	INVALID_DISPLAY	((unsigned)-1)
+#define	INVALID_INPUT	((unsigned)-1)
+#define	INVALID_FOCUS	((unsigned)-1)
+#define	INVALID_CONSOLE	((unsigned)-1)
+#define	INVALID_DEVICE	((unsigned)-1)
+
+#define	CONFIG_KGII_MAX_NR_DEFFONTS	4
+#define	CONFIG_KGII_CONSOLEBUFSIZE	(16*PAGE_SIZE)
+
+#define	CONFIG_KGI_DISPLAYS	4
+
+/*
+ * Public API
+ */
+extern int dpy_null_init(int display, int max_display);
+extern void kgi_init(void);
+extern int focus_init(void);
+extern int kii_configure(int flags);
+
+/*
+ * Public data, kgi.c 
+ */
+extern unsigned char console_map[CONFIG_KGII_MAX_NR_FOCUSES][CONFIG_KGII_MAX_NR_CONSOLES];
+extern unsigned char graphic_map[CONFIG_KGII_MAX_NR_FOCUSES][CONFIG_KGII_MAX_NR_CONSOLES];
+extern unsigned char focus_map[CONFIG_KGII_MAX_NR_DEVICES];
+extern unsigned char display_map[CONFIG_KGII_MAX_NR_DEVICES];
+
+#endif	/* _kgi_kgii_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgimod.h sys/dev/kgi/kgimod.h
--- sys/dev/kgi/kgimod.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgimod.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,206 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent stuff
+ */
+
+#ifndef _kgi_kgimod_h
+#define _kgi_kgimod_h
+
+/* 
+ * Attributes
+ * NOTE	Attribute ordering __must__ not be changed! 
+ */
+typedef enum {
+	KGI_A_COLOR1,		/* intensity of color channel 1	*/
+	KGI_A_COLOR2,		/* intensity of color channel 2 */
+	KGI_A_COLOR3,		/* intensity of color channel 3	*/
+	KGI_A_COLOR_INDEX,	/* color index value		*/
+	KGI_A_ALPHA,		/* alpha value			*/
+	KGI_A_PRIVATE,		/* hardware or driver private	*/
+	KGI_A_APPLICATION,	/* store what you want here	*/
+
+	KGI_A_STENCIL,		/* stencil buffer		*/
+	KGI_A_Z,		/* z-value			*/
+
+	KGI_A_FOREGROUND_INDEX,	/* foreground color index	*/
+	KGI_A_TEXTURE_INDEX,	/* texture index		*/
+	KGI_A_BLINK,		/* blink bit/frequency		*/
+
+	KGI_A_LAST,
+} kgi_attribute_t;
+
+#define	__KGI_AM(x)	KGI_AM_##x = (1 << KGI_A_##x)
+typedef enum {
+	__KGI_AM(PRIVATE),
+	__KGI_AM(APPLICATION),
+	__KGI_AM(STENCIL),
+	__KGI_AM(Z),
+	__KGI_AM(COLOR_INDEX),
+	__KGI_AM(ALPHA),
+	__KGI_AM(COLOR1),
+	__KGI_AM(COLOR2),
+	__KGI_AM(COLOR3),
+	__KGI_AM(FOREGROUND_INDEX),
+	__KGI_AM(TEXTURE_INDEX),
+	__KGI_AM(BLINK),
+
+	KGI_AM_COLORS = KGI_AM_COLOR1 | KGI_AM_COLOR2 | KGI_AM_COLOR3,
+	KGI_AM_ALL = (1 << KGI_A_LAST) - 1
+} kgi_attribute_mask_t;
+#undef __KGI_AM
+#define	KGI_ATTRIBUTE_MASK(attr)	(1 << (attr))
+
+#define	KGI_AM_TEXT	(kgi_attribute_mask_t)(KGI_AM_COLOR_INDEX | KGI_AM_FOREGROUND_INDEX | KGI_AM_TEXTURE_INDEX)
+#define	KGI_AM_I	(kgi_attribute_mask_t)(KGI_AM_COLOR_INDEX)
+#define	KGI_AM_RGB	(kgi_attribute_mask_t)(KGI_AM_COLORS)
+#define	KGI_AM_RGBI	(kgi_attribute_mask_t)(KGI_AM_COLORS | KGI_AM_COLOR_INDEX)
+#define	KGI_AM_RGBA	(kgi_attribute_mask_t)(KGI_AM_COLORS | KGI_AM_ALPHA)
+#define	KGI_AM_RGBX	(kgi_attribute_mask_t)(KGI_AM_COLORS | KGI_AM_APPLICATION)
+#define	KGI_AM_RGBP	(kgi_attribute_mask_t)(KGI_AM_COLORS | KGI_AM_PRIVATE)
+
+/* attribute strings */
+#define	KGI_AS_8888	((const kgi_u8_t[]) { 8,8,8,8,0 })
+#define	KGI_AS_4444	((const kgi_u8_t[]) { 4,4,4,4,0 })
+#define	KGI_AS_5551	((const kgi_u8_t[]) { 5,5,5,1,0 })
+#define	KGI_AS_2321	((const kgi_u8_t[]) { 2,3,2,1,0 })
+#define	KGI_AS_4642	((const kgi_u8_t[]) { 4,6,4,3,0 })
+#define	KGI_AS_AAA2	((const kgi_u8_t[]) { 10,10,10,2,0 })
+#define	KGI_AS_332	((const kgi_u8_t[]) { 3,3,2,0 })
+#define	KGI_AS_565	((const kgi_u8_t[]) { 5,6,5,0 })
+#define	KGI_AS_448	((const kgi_u8_t[]) { 4,4,8,0 })
+#define	KGI_AS_664	((const kgi_u8_t[]) { 6,6,4,0 })
+#define	KGI_AS_888	((const kgi_u8_t[]) { 8,8,8,0 })
+#define	KGI_AS_ACA	((const kgi_u8_t[]) { 10,12,10,0 })
+#define	KGI_AS_88	((const kgi_u8_t[]) { 8,8,0 })
+#define	KGI_AS_8	((const kgi_u8_t[]) { 8,0 })
+#define	KGI_AS_4	((const kgi_u8_t[]) { 4,0 })
+#define	KGI_AS_2	((const kgi_u8_t[]) { 2,0 })
+#define	KGI_AS_1	((const kgi_u8_t[]) { 1,0 })
+
+/*
+ * timing/modes
+ */
+typedef enum {
+	KGI_TC_PROPOSE,			/* propose a timing		*/
+	KGI_TC_LOWER,			/* only lower clock rate	*/
+	KGI_TC_RAISE,			/* only raise clock rate	*/
+	KGI_TC_CHECK,			/* don't modify but check	*/
+	KGI_TC_READY			/* don't care.			*/
+} kgi_timing_command_t;
+
+/*
+ * dot ports are used to connect dot stream sources (image serializers),
+ * dot stream converters (DACs, ...) and dot stream sinks (monitors,...)
+ */
+typedef enum {
+	/* color space */
+	KGI_DPF_CS_LIN_RGB	= 0x00000000,	/* linear rgb space	*/
+	KGI_DPF_CS_LIN_BGR	= 0x00000001,	/* linear bgr space	*/
+	KGI_DPF_CS_LIN_YUV	= 0x00000002,	/* linear yuv space	*/
+	KGI_DPF_CS_MASK		= 0x000000FF,
+
+	/* changeable (after mode set) properties */
+	KGI_DPF_CH_ORIGIN	= 0x00000100,	/* image orgin		*/
+	KGI_DPF_CH_SIZE		= 0x00000200,	/* image size		*/
+	KGI_DPF_CH_ILUT		= 0x00000400,	/* index->attr look up	*/
+	KGI_DPF_CH_ALUT		= 0x00000800,	/* attr->attr look up	*/
+	KGI_DPF_CH_TLUT		= 0x00001000,	/* tindex->pixel texture*/
+	KGI_DPF_CH_MASK		= 0x0000FF00,
+
+	/* dot transfer protocol */
+	KGI_DPF_TP_LRTB_I0	= 0x00000000,	/* l>r, t>b, noninterl.	*/
+	KGI_DPF_TP_LRTB_I1	= 0x00010000,	/* l>r, t>b, interl.	*/
+	KGI_DPF_TP_2XCLOCK	= 0x00080000,	/* load twice per cycle	*/
+	KGI_DPF_TP_MASK		= 0x000F0000,
+	/* ??? stereo handling ? */
+
+	KGI_DPF_MASK		= 0x000FFFFF
+} kgi_dot_port_flags_t;
+
+typedef struct {
+	kgi_dot_port_flags_t	flags;	/* flags		*/
+	kgi_ucoord_t		dots;	/* image size in dots	*/
+	kgi_u_t			dclk;	/* (max) dot clock	*/
+	kgi_ratio_t		lclk;	/* load clock per dclk	*/
+	kgi_ratio_t		rclk;	/* ref clock per dclk	*/
+	kgi_attribute_mask_t	dam;	/* dot attr mask */
+	const kgi_u8_t		*bpda;	/* bits per dot attribute */
+} kgi_dot_port_mode_t;
+
+/*
+ * A dot stream converter (DSC) reads data from it's input dot port(s),
+ * performs a conversion on it and outputs the result on the output port.
+ */
+typedef struct {
+	kgi_dot_port_mode_t	*out;
+	kgi_u_t			inputs;
+	kgi_dot_port_mode_t	in[1];
+} kgi_dsc_mode_t;
+
+/* images */
+typedef enum {
+	KGI_IF_ORIGIN	= 0x00000001,	/* origin can be changed	*/
+	KGI_IF_VIRTUAL	= 0x00000002,	/* virtual size can be changed	*/
+	KGI_IF_VISIBLE	= 0x00000004,	/* visible size can be changed	*/
+	KGI_IF_TILE_X	= 0x00000008,	/* can do virtual x tiling	*/
+	KGI_IF_TILE_Y	= 0x00000010,	/* can do virtual y tiling	*/
+	KGI_IF_ILUT	= 0x00000020,	/* can do index -> attribute	*/
+	KGI_IF_ALUT	= 0x00000040, 	/* can do attribute->attribute	*/
+	KGI_IF_TLUT	= 0x00000080,	/* can do pixel texture look-up	*/
+	KGI_IF_STEREO	= 0x00000100,	/* stereo image			*/
+	KGI_IF_TEXT16	= 0x00000200,	/* can do text16 output		*/
+
+	KGI_IF_ALL	= 0x000003FF	/* all flags known		*/
+} kgi_image_flags_t;
+
+typedef struct {
+	kgi_dot_port_mode_t *out;
+	kgi_image_flags_t flags;
+
+	kgi_ucoord_t	virt;
+	kgi_ucoord_t	size;
+
+	kgi_u8_t	frames;
+	kgi_u8_t	tluts;
+	kgi_u8_t	iluts;
+	kgi_u8_t	aluts;
+	kgi_attribute_mask_t	ilutm;
+	kgi_attribute_mask_t	alutm;
+
+	kgi_attribute_mask_t	fam, cam; /* frame, common attribute mask     */
+	kgi_u8_t	bpfa[__KGI_MAX_NR_ATTRIBUTES];/* bits per frame attr  */
+	kgi_u8_t	bpca[__KGI_MAX_NR_ATTRIBUTES];/* bits per common attr */
+
+	kgi_resource_t	*resource[__KGI_MAX_NR_IMAGE_RESOURCES];
+} kgi_image_mode_t;
+
+typedef enum {
+	KGI_MF_ALLOCATED		= 0x00000001,	/* has been allocated */
+	KGI_MF_BOOT			= 0x00000002	/* mode for boot console */
+} kgi_mode_flags_t;
+
+#define	KGI_MODE_REVISION	0x00010001
+typedef struct {
+	kgi_u_t			revision;  /* data structure revision		*/
+	void			*dev_mode; /* device dependent mode		*/
+	kgi_mode_flags_t	flags;     /* mode flags                	*/
+
+	const kgi_resource_t	*resource[__KGI_MAX_NR_RESOURCES];
+
+	kgi_u_t			images;	   /* number of images		*/
+	kgi_image_mode_t	img[1];	   /* image(s)			*/
+} kgi_mode_t;
+
+#endif /* _kgi_kgimod_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgires.h sys/dev/kgi/kgires.h
--- sys/dev/kgi/kgires.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgires.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,318 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent stuff
+ */
+#ifndef _kgi_kgires_h
+#define _kgi_kgires_h
+
+typedef enum {
+	/*  may be mapped by applications (others) */ 
+	KGI_PF_APP_R		= 0x00000001,	/* read access allowed	*/
+	KGI_PF_APP_W		= 0x00000002,	/* write access allowed	*/
+	KGI_PF_APP_S		= 0x00000004,	/* may be shared	*/
+	KGI_PF_APP_RWS		= 0x00000007,	/* read, write, shared	*/
+	KGI_PF_APP_WP		= 0x00000008,	/* write protected	*/
+	KGI_PF_APP_RP		= 0x00000010,	/* read protected	*/
+	KGI_PF_APP		= 0x0000001F,	/* application flags	*/
+
+	/* may be mapped by trusted applications (group) */
+	KGI_PF_LIB_R		= 0x00000100,	/* read access allowed	*/
+	KGI_PF_LIB_W		= 0x00000200,	/* write access allowed	*/
+	KGI_PF_LIB_S		= 0x00000400,	/* may be shared	*/
+	KGI_PF_LIB_RWS		= 0x00000700,	/* read, write, shared	*/
+	KGI_PF_LIB_WP		= 0x00000800,	/* write protected	*/
+	KGI_PF_LIB_RP		= 0x00001000,	/* read protected	*/
+	KGI_PF_LIB		= 0x00001F00,	/* library flags	*/
+
+	/* may be mapped only by session leader (owner) */
+	KGI_PF_DRV_R		= 0x00010000,	/* read access allowed	*/
+	KGI_PF_DRV_W		= 0x00020000,	/* write access allowed	*/
+	KGI_PF_DRV_S		= 0x00040000,	/* may be shared	*/
+	KGI_PF_DRV_RWS		= 0x00070000,	/* read, write, shared	*/
+	KGI_PF_DRV_WP		= 0x00080000,	/* write protected	*/
+	KGI_PF_DRV_RP		= 0x00100000,	/* read protected	*/
+	KGI_PF_DRV		= 0x001F0000,	/* driver flags		*/
+
+	/* common (global) attributes */
+	KGI_PF_WRITE_ORDER	= 0x01000000,	/* write order matters	*/
+	KGI_PF_READ_ORDER	= 0x02000000,	/* read order matters	*/
+	KGI_PF_WRITE_CACHING	= 0x04000000,	/* allowed if set	*/
+	KGI_PF_READ_CACHING	= 0x08000000	/* allowed if set	*/
+} kgi_protection_flags_t;
+
+typedef enum {
+	KGI_RT_MMIO	= 0x00000000,
+		KGI_RT_MMIO_FRAME_BUFFER,	/* linear frame buffer	*/
+		KGI_RT_MMIO_LOCAL_BUFFER,	/* linear local buffer	*/
+		KGI_RT_MMIO_PRIVATE,		/* private MMIO region	*/
+
+	KGI_RT_SHMEM	= 0x20000000,
+		KGI_RT_SHARED_MEMORY,
+
+	KGI_RT_ACCEL	= 0x40000000,
+		KGI_RT_ACCELERATOR,
+
+	KGI_RT_COMMAND	= 0x60000000,
+		KGI_RT_CURSOR_CONTROL,
+		KGI_RT_POINTER_CONTROL,
+		KGI_RT_ILUT_CONTROL,
+		KGI_RT_ALUT_CONTROL,
+		KGI_RT_TLUT_CONTROL,
+		KGI_RT_TEXT16_CONTROL,
+
+	KGI_RT_MASK	= 0x70000000,	/* WARNING: offset encoding depends! */
+
+	KGI_RT_LAST
+} kgi_resource_type_t;
+
+typedef enum {
+	KGI_MM_TEXT16	= 0x00000001,
+	KGI_MM_WINDOWS	= 0x00000002,
+	KGI_MM_X11	= 0x00000004,
+	KGI_MM_3COLOR	= 0x00000008
+} kgi_marker_mode_t;
+
+#ifdef _KERNEL
+
+typedef struct {
+	kgi_size_t	size;		/* aperture size		*/
+	kgi_bus_addr_t	bus;		/* bus address			*/
+	kgi_phys_addr_t	phys;		/* physical address		*/
+	kgi_virt_addr_t	virt;		/* virtual address		*/
+} kgi_aperture_t;
+
+#define	__KGI_RESOURCE	\
+	void		*meta;		/* meta language object		*/\
+	void		*meta_io;	/* meta language I/O context	*/\
+	kgi_resource_type_t	type;	/* type ID			*/\
+	kgi_protection_flags_t	prot;	/* protection info		*/\
+	const kgi_ascii_t	*name;	/* name/identifier		*/
+
+struct kgi_resource_s {
+	__KGI_RESOURCE
+};
+
+/* MMIO regions */
+
+typedef struct kgi_mmio_region_s kgi_mmio_region_t;
+
+typedef void kgi_mmio_set_offset_fn(kgi_mmio_region_t *r, kgi_size_t offset);
+
+struct kgi_mmio_region_s {
+	__KGI_RESOURCE
+
+	kgi_u_t	access;			/* access widths allowed	*/
+	kgi_u_t	align;			/* alignment requirements	*/
+
+	kgi_size_t	size;		/* total size of the region     */
+	kgi_aperture_t	win;		/* window aperture		*/
+
+	kgi_size_t	offset;		/* window device-local address  */
+	kgi_mmio_set_offset_fn	(*SetOffset);
+};
+
+/* Accelerators */
+typedef enum {
+	KGI_AS_IDLE,			/* has nothing to do		*/
+	KGI_AS_FILL,			/* gets filled by application	*/
+	KGI_AS_QUEUED,			/* is queued			*/
+	KGI_AS_EXEC,			/* being executed		*/
+	KGI_AS_WAIT			/* wait for execution to finish	*/
+} kgi_accel_state_t;
+
+typedef enum {
+	KGI_BF_USEMUTEX		= 0x00000001,	/* Manage buffer mutex	*/
+} kgi_buffer_flags_t;
+
+typedef struct {
+	kgi_aperture_t	aperture;	/* context buffer aperture info	*/
+} kgi_accel_context_t;
+
+typedef struct kgi_accel_buffer_s kgi_accel_buffer_t;
+
+#define __KGI_ACCEL_BUFFER  \
+	kgi_accel_buffer_t *next;	/* next of same mapping		*/\
+	kgi_aperture_t	aperture;	/* buffer aperture location	*/\
+	void		*context;	/* mapping context		*/\
+	kgi_u_t		priority;	/* execution priority		*/\
+	wait_queue_head_t *executed;	/* wakeup when buffer executed	*/\
+	struct {							  \
+		kgi_accel_state_t	state;	/* current buffer state	*/\
+		kgi_accel_buffer_t	*next;	/* next in exec queue	*/\
+		kgi_size_t		size;	/* bytes to execute	*/\
+	} execution;							  \
+	kgi_mutex_t			mtx;	/* buffer mutex		*/\
+	kgi_buffer_flags_t		flags;	/* buffer flags		*/
+
+struct kgi_accel_buffer_s {
+	__KGI_ACCEL_BUFFER
+};
+
+struct kgi_accel_s;
+
+typedef void kgi_accel_init_fn(struct kgi_accel_s *a, void *ctx);
+typedef	void kgi_accel_done_fn(struct kgi_accel_s *a, void *ctx);
+typedef void kgi_accel_exec_fn(struct kgi_accel_s *a,
+		kgi_accel_buffer_t *b);
+typedef void kgi_accel_wait_fn(struct kgi_accel_s *a);
+
+typedef enum {
+	KGI_AF_DMA_BUFFERS	= 0x00000001,	/* uses DMA to exec buffers */
+	KGI_AF_USEMUTEX		= 0x00000002	/* uses mutex               */
+} kgi_accel_flags_t;
+
+typedef struct kgi_accel_s {
+	__KGI_RESOURCE
+
+	kgi_accel_flags_t	flags;	/* accelerator flags		*/
+	kgi_u_t		buffers;	/* recommended number buffers	*/
+	kgi_u_t		buffer_size;	/* recommended buffer size	*/
+
+	void		*context;	/* current context		*/
+	kgi_u_t		context_size;	/* context buffer size		*/
+
+	struct {
+		kgi_accel_buffer_t *queue;	/* buffers to execute	*/
+		void *context;			/* current context	*/
+	} execution;			/* dynamic state		*/
+
+	wait_queue_head_t	*idle;	/* wakeup when becoming idle	*/
+
+	kgi_accel_init_fn	*Init;
+	kgi_accel_done_fn	*Done;
+	kgi_accel_exec_fn	*Exec;
+
+	kgi_mutex_t		mtx;	/* accel resource mutex		*/
+} kgi_accel_t;
+
+
+/*
+ * Shared Memory
+ */
+typedef struct kgi_shmem_context_s kgi_shmem_context_t;
+typedef struct kgi_shmem_s kgi_shmem_t;
+
+typedef kgi_error_t kgi_shmem_context_init_fn(kgi_shmem_t *shmem, 
+	kgi_shmem_context_t *ctx, kgi_size_t size);
+
+typedef void kgi_shmem_context_fn(kgi_shmem_t *shmem, kgi_shmem_context_t *ctx);
+typedef void kgi_shmem_art_fn(kgi_shmem_t *shmem, kgi_aperture_t *range);
+typedef void kgi_shmem_art_map_fn(kgi_shmem_t *shmem, kgi_aperture_t *dst,
+	kgi_aperture_t *src);
+
+struct kgi_shmem_context_s {
+	kgi_aperture_t	aperture;	/* aperture window exported	*/
+	kgi_aperture_t	art_memory;	/* address relocation table (art) */
+	kgi_aperture_t	null_page;	/* 'null' (invalid) memory page	*/
+};
+
+struct kgi_shmem_s {
+	__KGI_RESOURCE
+
+	kgi_size_t	aperture_size;	/* (maximum) aperture size	*/
+
+	void		*ctx;		/* current context		*/
+	kgi_size_t	ctx_size;	/* context struct size		*/
+
+	kgi_shmem_context_init_fn	*ContextInit;
+	kgi_shmem_context_fn		*ContextDone;
+	kgi_shmem_context_fn		*ContextMap;
+
+	kgi_shmem_context_fn		*ARTInit;
+	kgi_shmem_art_fn		*ARTFlush;
+	kgi_shmem_art_map_fn		*ARTMapPages;
+	kgi_shmem_art_fn		*ARTUnmapPages;
+};
+
+/*
+ * command resources
+ */
+typedef struct kgi_marker_s kgi_marker_t;
+struct kgi_marker_s {
+	__KGI_RESOURCE
+
+	kgi_marker_mode_t	modes;	/* possible operation modes	*/
+	kgi_u8_t		shapes;	/* number of shapes		*/
+	kgi_u8_coord_t		size;	/* pattern size			*/
+
+	void (*SetMode)(kgi_marker_t *marker, kgi_marker_mode_t mode);
+	void (*Select)(kgi_marker_t *marker, kgi_u_t shape);
+	void (*SetShape)(kgi_marker_t *marker, kgi_u_t shape,
+		kgi_u_t hot_x, kgi_u_t hot_y, const void *data,
+		const kgi_rgb_color_t *color);
+
+	void (*Show)(kgi_marker_t *marker, kgi_u_t x, kgi_u_t y);
+	void (*Hide)(kgi_marker_t *marker);
+	void (*Undo)(kgi_marker_t *marker);
+	void (*Read)(kgi_marker_t *marker, kgi_u_t *x, kgi_u_t *y);
+};
+
+typedef struct kgi_text16_s kgi_text16_t;
+struct kgi_text16_s {
+	__KGI_RESOURCE
+
+	kgi_ucoord_t	size;		/* visible text cells	*/
+	kgi_ucoord_t	virt;		/* virtual text cells	*/
+	kgi_ucoord_t	cell;		/* dots per text cell	*/
+	kgi_ucoord_t	font;		/* dots per font cell	*/
+	kgi_endian_t	bitendian;	/* font bit endianess   */
+
+	void (*PutText16)(kgi_text16_t *text16, kgi_u_t offset,
+			  const kgi_u16_t *text, kgi_u_t count);
+
+	void (*LoadFont)(kgi_text16_t *text16, kgi_u_t page, kgi_u_t size,
+			 kgi_u8_t *data, kgi_u_t ch, kgi_s_t count);
+	void (*SaveFont)(kgi_text16_t *text16, kgi_u_t page, kgi_u_t size,
+			 kgi_u8_t *data, kgi_u_t ch, kgi_s_t count);
+	void (*ShowFont)(kgi_text16_t *text16, kgi_u_t page);
+};
+
+typedef struct kgi_clut_s kgi_ilut_t;	/* image look up table		*/
+typedef struct kgi_clut_s kgi_alut_t;	/* attribute look up table	*/
+
+typedef struct kgi_clut_s kgi_clut_t;	/* color look up table		*/
+struct kgi_clut_s {
+	__KGI_RESOURCE
+
+	kgi_u_t tables;
+	kgi_u_t entries;
+
+	void (*Select)(kgi_clut_t *lut, kgi_u_t table);
+	void (*Set)(kgi_clut_t *lut, kgi_u_t table, kgi_u_t idx,
+		kgi_u_t count, kgi_attribute_mask_t am, const kgi_u16_t *data);
+	void (*Get)(kgi_clut_t *lut, kgi_u_t table, kgi_u_t idx,
+		kgi_u_t count, kgi_attribute_mask_t am, const kgi_u16_t *data);
+};
+
+typedef struct kgi_tlut_s kgi_tlut_t;	/* texture look up table	*/
+struct kgi_tlut_s {
+	__KGI_RESOURCE
+
+	void (*Select)(kgi_tlut_t *tlut, kgi_u_t table);
+	void (*Set)(kgi_tlut_t *tlut, kgi_u_t table, kgi_u_t idx,
+		kgi_u_t count, const void *data);
+};
+
+#else /* _KERNEL */
+
+/*
+ * Prevent userspace from direct access to
+ * internal data structures
+ */
+#define kgi_resource_t void
+
+#endif /* ! _KERNEL */
+
+#endif /* _kgi_kgires_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgityp.h sys/dev/kgi/kgityp.h
--- sys/dev/kgi/kgityp.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgityp.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,85 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI manager OS kernel independent stuff
+ */
+
+#ifndef _kgi_kgityp_h
+#define _kgi_kgityp_h
+
+#define	KB	*1024
+#define	MB	*(1024*1024)
+#define	GB	*(1024*1024*1024)
+
+
+/*
+ * ISO 10646 defines symbol codes as 32 bit unsigned int organized into
+ * groups, planes, rows and cells. By now only the first plane (group=0,
+ * plane=0) is defined, which maps directly to UNICODE. Use these macros
+ * to extract group, plane, row or cell.
+ */
+#define KGI_ISOCHAR_GROUP(isochar)	(((isochar) >> 24) & 0xFF)
+#define	KGI_ISOCHAR_PLANE(isochar)	(((isochar) >> 16) & 0xFF)
+#define	KGI_ISOCHAR_ROW(isochar)	(((isochar) >>  8) & 0xFF)
+#define	KGI_ISOCHAR_CELL(isochar)	((isochar) & 0xFF)
+
+typedef struct { kgi_u8_t major, minor, patch, extra; } kgi_version_t;
+typedef struct { kgi_s_t x,y; }		kgi_scoord_t;
+typedef struct { kgi_u_t x,y; }		kgi_ucoord_t;
+typedef struct { kgi_u8_t x,y; }	kgi_u8_coord_t;
+typedef struct { kgi_s_t min, max; }	kgi_srange_t;
+typedef struct { kgi_u_t min, max; }	kgi_urange_t;
+
+typedef struct { kgi_u_t mul, div; }	kgi_ratio_t;
+
+typedef struct { kgi_u16_t r,g,b; }	kgi_rgb_color_t;
+typedef union {
+
+	kgi_rgb_color_t	rgb;
+
+} kgi_color_t;
+
+/*
+ * byte order conversions
+ */
+typedef enum {
+	KGI_ENDIAN_LITTLE,
+	KGI_ENDIAN_BIG
+} kgi_endian_t;
+
+#define	KGI_MAX_NR_FOCUSES	CONFIG_KGII_MAX_NR_FOCUSES
+#define	KGI_MAX_NR_CONSOLES	CONFIG_KGII_MAX_NR_CONSOLES
+#define	KGI_MAX_NR_DEVICES	CONFIG_KGII_MAX_NR_DEVICES
+#define	KGI_MAX_NR_DISPLAYS	CONFIG_KGII_MAX_NR_DISPLAYS
+
+#define	KGI_VALID_FOCUS_ID(x)	((x) < KGI_MAX_NR_FOCUSES)
+#define	KGI_VALID_CONSOLE_ID(x)	((x) < KGI_MAX_NR_CONSOLES)
+#define	KGI_VALID_DEVICE_ID(x)	((x) < KGI_MAX_NR_DEVICES)
+#define	KGI_VALID_DISPLAY_ID(x)	((x) < KGI_MAX_NR_DISPLAYS)
+
+#define	KGI_INVALID_FOCUS	INVALID_FOCUS
+#define	KGI_INVALID_CONSOLE	INVALID_CONSOLE
+#define	KGI_INVALID_DISPLAY	INVALID_DISPLAY
+#define	KGI_INVALID_DEVICE	INVALID_DEVICE
+
+/*
+ * Preliminary definition to extend type visibility
+ */
+#define	__KGI_MAX_NR_RESOURCES		16
+#define	__KGI_MAX_NR_IMAGE_RESOURCES	16
+#define __KGI_MAX_NR_ATTRIBUTES		32
+
+typedef struct kgi_resource_s kgi_resource_t;
+
+#endif /* _kgi_kgityp_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_accel.c sys/dev/kgi/kgu_accel.c
--- sys/dev/kgi/kgu_accel.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_accel.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,441 @@
+/*-
+ * Copyright (C) 1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#define KGI_SYS_NEED_MUTEX
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+#include <dev/kgi/accel.h>
+
+/*
+ * Accelerator resource mappings
+ */
+
+static void 
+graph_accel_removepages(vm_area_t vma, graph_accel_buffer_t *buf, int free)
+{
+	vm_page_t m;
+	
+	/*
+	 * Remove the current buffer from the process memory if free is TRUE.
+	 * Any thread then hitting these pages will pagefault.
+	 * XXX Suboptimal!
+	 */
+	while ((m = TAILQ_FIRST(&buf->memq)) != 0) {
+		/* The page associated to the current buffer is removed */
+		TAILQ_REMOVE(&buf->memq, m, kgiq);
+
+		if (free) {
+			/* Remove the page from vm area it is referenced by */
+			kgi_pager_remove(vma, m);
+		}
+	}
+}
+
+/*
+ * In the Linux version, there are only pagefaults on buffer
+ * boundaries.
+ *
+ * Handle page faults for ACCEL mappings
+ *
+ * m is the page allocated by the pager to hold paddr. This enables
+ * link between buffers and VM pages.
+ *
+ * ooffset is a number of bytes rounded to the page size of the
+ * platform. It is an absolute offset in the accel.
+ *
+ * paddr the result is the physical address of the "device" obtained
+ * from the ooffset given.
+ */
+static int 
+graph_accel_nopage(vm_area_t vma, vm_page_t m, vm_offset_t ooffset,
+			      vm_paddr_t *paddr, int prot)
+{
+	graph_accel_mapping_t *map;
+	kgi_accel_t *accel;
+	unsigned long nstart, nend;
+	graph_accel_buffer_t *buf = NULL;
+
+	map = (graph_accel_mapping_t *) VM(private_data);
+	if (map == NULL) {
+		KRN_DEBUG(1, "invalid (cloned ?) vma %p, sending signal", vma);
+		panic("don't know how to signal...");	/* XXX */
+	}
+	KRN_ASSERT(vma == map->vma);
+
+	accel = (kgi_accel_t *) map->resource;
+	KRN_ASSERT(KGI_RT_ACCELERATOR == accel->type);
+
+	KRN_DEBUG(3, "accel_nopage @%.8x, vma %p, %x", (kgi_u32_t)ooffset,
+		  vma, prot);
+
+	/*
+	 * The page ooffset must be in the current buffer (no exec)
+	 * or in the next buffer, but nothing else.
+	 */
+	if (ooffset < map->buf_offset)
+		return (-1);
+	
+	if (ooffset < (map->buf_offset + map->buf_size))
+		goto pagefound;
+
+	/*
+	 * Compute the start/end offsets of the buffer next to the
+	 * current one.
+	 */
+	nstart = (map->buf_offset + map->buf_size) & map->buf_mask;
+	nend = nstart + map->buf_size;
+	if (! ((nstart <= ooffset) && (ooffset < nend))) {
+		KRN_DEBUG(1, "ooffset %.8lx not in %.8lx-%.8lx for next buffer",
+			(u_long)ooffset, nstart, nend);
+		return (-1);
+	}
+
+	buf = map->buf_current;
+
+	/*
+	 * Lock the mutex of the next buffer to be sure to own
+	 * it immediatly when running again
+	 */
+	kgi_mutex_lock(&buf->next->mtx);
+
+	/*
+	 * Wait for the next buffer to be idle before starting
+	 * the execution of the current one. See later.
+	 */
+	while (buf->next->execution.state != KGI_AS_IDLE) {
+		buf->next->flags |= KGI_BF_USEMUTEX;
+		kgi_mutex_wait(&buf->next->mtx);
+	}
+
+	KRN_ASSERT(KGI_AS_FILL == buf->execution.state);
+	KRN_DEBUG(3, "exec buffer %.8x", buf->aperture.phys);
+
+	kgi_mutex_lock(&buf->mtx);
+
+	/* Remove all pages of this buffer = VM_PROT_NONE */
+	graph_accel_removepages(vma, buf, 1 /* yes, free */);
+	
+	/* Start "execution" of the buffer */
+	buf->execution.size = 
+		(ooffset == nstart) ? map->buf_size : (ooffset - nstart);
+
+	accel->Exec(accel, (kgi_accel_buffer_t *)buf);
+
+	kgi_mutex_unlock(&buf->mtx);
+
+	/* Go to the next buffer */
+	map->buf_current = (graph_accel_buffer_t *)buf->next;
+
+	/*
+	 * We are sure it is idle since we have waited for it.
+	 * See above.
+	 */
+	KRN_ASSERT(KGI_AS_IDLE == buf->execution.state);
+	buf->execution.state = KGI_AS_FILL;
+
+	map->buf_offset = nstart;
+	
+	kgi_mutex_unlock(&buf->next->mtx);
+
+ pagefound:
+	/* Attach the page to the buffer */
+	TAILQ_INSERT_TAIL(&buf->memq, m, kgiq);
+	*paddr = buf->aperture.phys + (ooffset - map->buf_offset);
+
+	return (0);
+}
+
+static void 
+graph_accel_close(vm_area_t vma)
+{
+	graph_accel_mapping_t *map = (graph_accel_mapping_t *) VM(private_data);
+	kgi_accel_t *accel = (kgi_accel_t *) map->resource;
+	graph_accel_buffer_t *buf = NULL;
+
+	map = (graph_accel_mapping_t *) VM(private_data);
+	if (map == NULL) 
+		return;
+	KRN_ASSERT(map->vma == vma);
+
+	accel = (kgi_accel_t *) map->resource;
+	KRN_ASSERT(KGI_RT_ACCELERATOR == accel->type);
+
+	KRN_DEBUG(1, "accel_unmap vma %p, map %p", vma, map);
+
+	/* Search executable buffers among all its buffers.
+	 */
+	buf = (graph_accel_buffer_t *)map->buf_current->next;
+	while ((buf->execution.next == NULL) &&
+	       (buf != map->buf_current)) {
+		buf = (graph_accel_buffer_t *)buf->next;
+	}
+
+	kgi_mutex_lock(&buf->mtx);
+
+	/* Wait to have no more buffer to execute for this map */
+	while (buf->execution.next != NULL) {
+		buf->flags |= KGI_BF_USEMUTEX;
+		kgi_mutex_wait(&buf->mtx);
+	}
+
+	buf->execution.state = KGI_AS_IDLE;
+
+	accel->Done(accel, buf->context);
+
+	/*
+	 * free context, buffers and buffer infos
+	 */
+	buf = map->buf_current;
+	kgi_kfree(buf->context);
+
+	KRN_ASSERT(buf);
+	KRN_ASSERT(buf->next);
+	do {
+		kgi_accel_buffer_t *next = buf->next;
+		
+		/*
+		 * Remove the pages from the buf list, but keep
+		 * them unfreed yet (already done?)
+		 */
+		graph_accel_removepages(vma, buf, 0 /* don't free */);
+
+		KRN_DEBUG(1, "freeing %.8x with order %i",
+			  buf->aperture.virt, map->buf_order);
+
+		/* Free the contiguous memory of the HW mapping */
+		kgi_cfree((void *)buf->aperture.virt, SIZ(map->buf_order));
+
+		/* Free the buffer */
+		kgi_kfree(buf);
+
+		buf = (graph_accel_buffer_t *)next;
+
+	} while (buf != map->buf_current);
+
+	/*
+	 * Don't unmap VM pages of the map here,
+	 * the pager will do (has done?!) the job
+	 */
+
+	/* Reset the buffer of the map */
+	map->buf_current = NULL;
+
+	/* Unblock threads waiting for the termination of this buffer */
+	kgi_mutex_signal(&buf->mtx, 1 /* all threads */);
+
+	kgi_mutex_unlock(&buf->mtx);
+
+	/* Reset the map of the vma */
+	VM(private_data) = NULL;
+}
+
+/* XXX lock? */
+static void 
+graph_accel_unmap(vm_area_t vma)
+{
+	graph_accel_mapping_t *map = (graph_accel_mapping_t *) VM(private_data);
+	graph_accel_buffer_t *buf;
+
+	/* Reset the buffer queues of pages */
+	buf = map->buf_current;
+	do {
+		kgi_accel_buffer_t *next = buf->next;
+
+		/* Reset the queue of pages */
+		TAILQ_INIT(&buf->memq);
+
+		buf = (graph_accel_buffer_t *)next;
+
+	} while (buf != map->buf_current);
+
+	/* Free every pages of the map */
+	kgi_pager_remove_all(vma);
+}
+
+static struct vm_operations_struct graph_accel_vmops =
+{
+	.open	=	NULL,
+	.close	=	graph_accel_close,
+	.nopage	=	graph_accel_nopage,
+	.unmap  =	graph_accel_unmap,
+};
+
+/*
+ * The area to be mapped is subdivided into buffers
+ */
+int 
+graph_accel_mmap(vm_area_t vma, graph_mmap_setup_t *mmap_setup,
+	  graph_mapping_t **the_map)
+{
+	kgi_accel_t *accel = (kgi_accel_t *)mmap_setup->resource;
+	unsigned long min_order, max_order, priority, order, buffers, i;
+	graph_accel_buffer_t *buf[16];
+	kgi_accel_context_t *context = NULL;
+	graph_accel_mapping_t *map = NULL;
+
+	KRN_DEBUG(1, "mapping buffer %.8x to vma %p",
+		  map->buf_current->aperture.phys, vma);
+
+	min_order = mmap_setup->request.private.accel.min_order;
+	order = max_order = mmap_setup->request.private.accel.max_order;
+	buffers = mmap_setup->request.private.accel.buffers;
+	priority = mmap_setup->request.private.accel.priority;
+
+	memset(buf, 0, sizeof(buf));
+
+	if (buffers > sizeof(buf)/sizeof(buf[0])) {
+		KRN_ERROR("too many buffers (%li) requested", buffers);
+		return (KGI_EINVAL);
+	}
+
+	if (min_order > max_order) {
+		KRN_ERROR("invalid buffer size range (min %li, max %li)",
+ 			min_order, max_order);
+		return (KGI_EINVAL);
+	}
+
+	/*
+	 * XXX check for process limits (don't allow allocation of too
+	 * XXX much memory).
+	 *
+	 *
+	 * allocate mapping and init accelerator context
+	 */
+	if (!(context = kgi_kmalloc(accel->context_size))) {
+		KRN_ERROR("failed to allocate accelerator context");
+		goto no_memory; 
+	}
+	memset(context, 0, accel->context_size);
+
+	context->aperture.size = accel->context_size;
+	context->aperture.virt = (kgi_virt_addr_t)context;
+	context->aperture.bus  = virt_to_phys(context);
+	context->aperture.phys = virt_to_phys(context);
+
+	accel->Init(accel, context);
+
+	/* allocate buffer info */
+	KRN_TRACE(1, memset(buf, 0, sizeof(buf)));
+	for (i = 0; i < buffers; i++) {
+		/* Reserve the among of memory including graph_accel stuff */
+		buf[i] = kgi_kmalloc(sizeof(graph_accel_buffer_t));
+		if (buf[i]) {
+			memset(buf[i], 0, sizeof(*buf[i]));
+			continue;
+		}
+
+		KRN_ERROR("failed to allocate buffer infos");
+		goto no_memory;
+	}
+
+	/*
+	 * allocate DMA buffers. These must be contiguous in physical
+	 * address space and all of same size. We try beginning with
+	 * max_order and check for smaller ones if this fails.
+	 */
+	do {
+		for (i = 0; buf[i]->aperture.virt && (i < buffers); i++) {
+			KRN_DEBUG(1, "freeing %i with order %li",
+				buf[i]->aperture.virt, order + 1);
+			kgi_cfree((void *)buf[i]->aperture.virt, SIZ(order + 1));
+		}
+
+		KRN_DEBUG(1, "trying %i byte buffers", SIZ(order));
+		for (i = 0; i < buffers; i++) {
+			buf[i]->aperture.virt = (kgi_virt_addr_t)kgi_cmalloc(SIZ(order));
+			if (!buf[i]->aperture.virt) {
+				break;
+			}
+			KRN_DEBUG(1, "allocated %i with order %li",
+				buf[i]->aperture.virt, order);
+		}
+
+	} while ((i != buffers) && (--order >= min_order));
+	if (i != buffers) {
+		KRN_ERROR("failed to allocate DMA buffers");
+		goto no_memory;
+	}
+
+	/* arrange buffers in circular list and attach to mapping. */
+	for (i = 0; i < buffers; i++) {
+		buf[i]->next = (kgi_accel_buffer_t *)buf[((i + 1) < buffers) ? (i + 1) : 0];
+		buf[i]->priority = priority;
+		buf[i]->context  = context;
+
+		buf[i]->execution.next	= NULL;
+		buf[i]->execution.state	= KGI_AS_IDLE;
+		buf[i]->execution.size	= 0;
+
+		buf[i]->aperture.size = SIZ(order);
+		buf[i]->aperture.phys = virt_to_phys(buf[i]->aperture.virt);
+		buf[i]->aperture.bus  = virt_to_phys(buf[i]->aperture.virt);
+
+		TAILQ_INIT(&buf[i]->memq);
+	}
+
+	if (!(map = kgi_kmalloc(sizeof(*map)))) {
+		KRN_ERROR("failed to allocate accel map");
+		goto no_memory;
+	}
+	memset(map, 0, sizeof(*map));
+
+	map->buf_current = buf[0];
+	map->buf_order = order;
+	map->buf_size = SIZ(order);
+	map->buf_mask = (buffers - 1) << (order + PAGE_SHIFT);
+
+	map->buf_current->execution.state = KGI_AS_FILL;
+
+	vma->vm_ops = &graph_accel_vmops;
+
+	/* Return the obtained map the upper layers */
+	*the_map = (graph_mapping_t *)map;
+
+	return (KGI_EOK);
+
+no_memory:
+	KRN_ERROR("accel: no memory");
+	if (context) {
+		accel->Done(accel, context);
+		kgi_kfree(context);
+	}
+
+	order++;
+	for (i = 0; buf[i] && (i < buffers); i++) {
+		if (buf[i]->aperture.virt) {
+			KRN_DEBUG(1, "freeing %.8x with order %li",
+				buf[i]->aperture.virt, order);
+			kgi_cfree((void *)buf[i]->aperture.virt, SIZ(order));
+		}
+		if (buf[i])
+			kgi_kfree(buf[i]);
+	}
+	return (KGI_ENOMEM);
+}
+
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_command.c sys/dev/kgi/kgu_command.c
--- sys/dev/kgi/kgu_command.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_command.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,386 @@
+/*-
+ * Copyright (C) 1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+
+/*
+ * command resource
+ */
+int 
+graph_command(graph_file_t *file, unsigned int cmd, void *data,
+			  struct thread *td)
+{
+	if (KGIC_MAPPER_IDENTIFY == cmd) {
+			/*
+			 * For now only force client identification and
+			 * identify myself (no compatibility checks).
+			 */
+			kgic_mapper_identify_result_t	*out = data;
+
+			if (file->flags & GRAPH_FF_CLIENT_IDENTIFIED)
+				return (KGI_EPROTO);
+
+			file->flags |= GRAPH_FF_CLIENT_IDENTIFIED;
+
+			memset(out->mapper, 0, sizeof(out->mapper));
+			strncpy(out->mapper, GRAPH_NAME, sizeof(out->mapper));
+			out->mapper_version.major = 0;
+			out->mapper_version.minor = 9;
+			out->mapper_version.patch = 0;
+			out->mapper_version.extra = 0;
+			out->resources = __KGI_MAX_NR_RESOURCES;
+			/* XXX #warning tell client if it is session leader or not. */
+
+			return (KGI_EOK);
+	}
+
+	/* all commands below require identification */
+	if (!(file->flags & GRAPH_FF_CLIENT_IDENTIFIED)) {
+		KRN_ERROR("cmd = %.8x, but client has not yet identified", cmd);
+		return KGI_EPROTO;
+	}
+	switch (cmd) {
+	case KGIC_MAPPER_SET_IMAGES:
+		{	/* 
+			 * Only the session leader may set the number of
+			 * images as long as device isn't registered.
+			 */
+			kgic_mapper_set_images_request_t *in  = data;
+			kgi_size_t size;
+
+			if (!(file->flags & GRAPH_FF_SESSION_LEADER) ||
+				KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "mode already checked"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+			/* XXX #warning what about resources still mapped?! */
+			if (file->device->kgi.mode) {
+				kgi_kfree(file->device->kgi.mode->dev_mode);
+				file->device->kgi.mode->dev_mode = NULL;
+				kgi_kfree(file->device->kgi.mode);
+				file->device->kgi.mode = NULL;
+			}
+
+			if ((in->images < 1) ||
+				(GRAPH_MAX_NR_IMAGES < in->images)) {
+				KRN_ERROR("no mem");
+				return (KGI_ENOMEM);
+			}
+			size = sizeof(kgi_mode_t) + 
+				sizeof(kgi_image_mode_t)*(in->images - 1);
+			file->device->kgi.mode = kgi_kmalloc(size);
+			if (NULL == file->device->kgi.mode) {
+				KRN_ERROR("no mem");
+				return (KGI_ENOMEM);
+			}
+			memset(file->device->kgi.mode, 0, size);
+			file->device->kgi.mode->revision = KGI_MODE_REVISION;
+			file->device->kgi.mode->images = in->images;
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_GET_IMAGES:
+		{
+			kgic_mapper_get_images_result_t *out = data;
+
+			out->images = file->device->kgi.mode 
+				? file->device->kgi.mode->images : 0;
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_SET_IMAGE_MODE:
+		{
+			kgic_mapper_set_image_mode_request_t *in = data;
+
+			if ((!(file->flags & GRAPH_FF_SESSION_LEADER)) ||
+				KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "mode already checked"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+
+			if (file->device->kgi.mode->images <= in->image) 
+				return (KGI_EINVAL);
+
+			file->device->kgi.mode->img[in->image] = in->mode;
+
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_GET_IMAGE_MODE:
+		{
+			kgic_mapper_get_image_mode_request_t local = 
+				*(kgic_mapper_get_image_mode_request_t *)data;
+			kgic_mapper_get_image_mode_request_t *in = &local;
+			kgic_mapper_get_image_mode_result_t *out = data;
+
+			if (NULL == file->device->kgi.mode) {
+				KRN_ERROR("number of images not yet set");
+				return (KGI_EPROTO);
+			}
+			if (file->device->kgi.mode->images <= in->image) 
+				return (KGI_EINVAL);
+
+			out->mode = file->device->kgi.mode->img[in->image];
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_MODE_CHECK:
+		{
+#if defined(KGI_DBG_LEVEL) && (KGI_DBG_LEVEL > 0)
+			kgi_u_t i;
+#endif
+			kgi_error_t err;
+			if (!(file->flags & GRAPH_FF_SESSION_LEADER) ||
+				(NULL == file->device->kgi.mode)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "number of images not yet set"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+			KRN_ASSERT(!KGI_VALID_DEVICE_ID(file->device->kgi.id));
+			KRN_ASSERT(!KGI_VALID_DISPLAY_ID(file->device->kgi.dpy_id));
+
+			file->device->kgi.MapDevice   = graph_device_map;
+			file->device->kgi.UnmapDevice = graph_device_unmap;
+			file->device->kgi.HandleEvent = NULL;
+
+			err = kgi_register_device(&(file->device->kgi), file->device_id);
+			if (KGI_EOK != err) {
+				KRN_ERROR("Failed to register device (%i)", err);
+				return (err);
+			}
+#if defined(KGI_DBG_LEVEL) && (KGI_DBG_LEVEL > 0)
+			i = 0;
+			while (i < __KGI_MAX_NR_RESOURCES) {
+				const kgi_resource_t *r =
+					file->device->kgi.mode->resource[i];
+
+				if (NULL == r) 
+					break;
+
+				KRN_DEBUG(1, "resource %i (%s) has type %.8x",
+					i, r->name, r->type);
+				i++;
+			}
+#endif
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_MODE_SET:
+		{
+			kgi_device_t *prev;
+			if (!(file->flags & GRAPH_FF_SESSION_LEADER) ||
+				!KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "mode not yet checked"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+			prev = kgi_current_focus(file->device->kgi.dpy_id);
+			if (prev) {
+				KRN_DEBUG(1, "unmapping previous device");
+				switch (kgi_unmap_device(prev->id)) {
+				case KGI_EOK:
+					file->previous = prev->id;
+					break;
+				default:
+					KRN_ERROR("can't unmap current focus");
+					return (KGI_EBUSY);
+				}
+			}
+			kgi_map_device(file->device->kgi.id);
+			KRN_DEBUG(1, "mapping new device");
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_MODE_UNSET:
+		{
+			if (!(file->flags & GRAPH_FF_SESSION_LEADER) ||
+				!KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "mode not yet checked"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+			kgi_unmap_device(file->device->kgi.id);
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_MODE_DONE:
+		{
+			if (!(file->flags & GRAPH_FF_SESSION_LEADER) ||
+				!KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR(
+					(file->flags & GRAPH_FF_SESSION_LEADER)
+					? "mode not yet checked"
+					: "client is not session leader");
+				return (KGI_EPROTO);
+			}
+			if (file->device->kgi.flags & KGI_DF_FOCUSED) {
+				kgi_unmap_device(file->device->kgi.id);
+				if (KGI_VALID_DEVICE_ID(file->previous))
+				    kgi_map_device(file->previous);
+			}
+			kgi_unregister_device(&(file->device->kgi));
+			return (KGI_EOK);
+		}
+	case KGIC_MAPPER_RESOURCE_INFO:
+		{
+			kgic_mapper_resource_info_request_t local = 
+				*(kgic_mapper_resource_info_request_t *)data;
+			kgic_mapper_resource_info_request_t *in = &local;
+			kgic_mapper_resource_info_result_t *out = data;
+			const union {
+				kgi_resource_t		common;
+				kgi_mmio_region_t	mmio;
+				kgi_accel_t		accel;
+				kgi_shmem_t		shmem;
+			} *r;
+
+			if (!KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR("mode not yet checked");
+				return (KGI_EAGAIN);
+			}
+			if (((in->image == KGIC_MAPPER_NON_IMAGE_RESOURCE)?
+			    __KGI_MAX_NR_IMAGE_RESOURCES:
+			    __KGI_MAX_NR_RESOURCES) <= in->resource) {
+				KRN_ERROR("invalid resource ID %d",
+					in->resource);
+				return (KGI_EINVAL);
+			}
+			if ((in->image < 0) ||
+			   (file->device->kgi.mode->images <= in->image)) {
+				if (in->image!=KGIC_MAPPER_NON_IMAGE_RESOURCE) {
+					KRN_ERROR("invalid image %d (%i)",in->image,in->image);
+					return (KGI_EINVAL);
+				}
+			}
+
+			r = (in->image == KGIC_MAPPER_NON_IMAGE_RESOURCE) ?
+			   (void*)file->device->kgi.mode->resource[in->resource]
+			   : (void*)file->device->kgi.mode->img[in->image].resource[in->resource];
+
+			if (r) {
+				memset(out, 0, sizeof(*out));
+
+				strncpy(out->name, r->common.name, sizeof(out->name));
+				out->name[sizeof(out->name)-1] = 0;
+				out->resource = in->resource;
+				out->image = in->image;
+				out->type = r->common.type;
+				out->protection = r->common.prot;
+				switch (r->common.type & KGI_RT_MASK) {
+				case KGI_RT_MMIO:
+					out->info.mmio.access = r->mmio.access;
+					out->info.mmio.align  = r->mmio.align;
+					out->info.mmio.size   = r->mmio.size;
+					out->info.mmio.window =
+						r->mmio.win.size;
+					break;
+				default:
+					KRN_ERROR(
+						"unknown resource type %.8x",
+						r->common.type & KGI_RT_MASK);
+				}
+				return (KGI_EOK);
+			} else {
+				KRN_ERROR("no such resource %i",
+					in->resource);
+				return (KGI_ENXIO);
+			}
+		}
+	case KGIC_MAPPER_MMAP_SETUP:
+		{
+			kgic_mapper_mmap_setup_request_t *in = data;
+
+			KRN_DEBUG(1, "mmap setup");
+
+			if (! KGI_VALID_DEVICE_ID(file->device->kgi.id)) {
+				KRN_ERROR("mode not yet checked");
+				return (KGI_EAGAIN);
+			}
+			if (file->mmap_setup.resource &&
+				(file->mmap_setup.pid != td->td_proc->p_pid ||
+				 file->mmap_setup.gid != td->td_proc->p_pgrp->pg_id)) {
+				KRN_ERROR("only initiator can change mmap setup");
+				return (KGI_EPERM);
+			}
+
+			file->mmap_setup.resource = NULL;
+			file->mmap_setup.pid = 0;
+			file->mmap_setup.gid = 0;
+
+			if (in->image == -1) {
+				if (__KGI_MAX_NR_RESOURCES <= in->resource) {
+					KRN_ERROR("invalid resource ID");
+					return (KGI_EINVAL);
+				}
+				if (!file->device->kgi.mode->resource[in->resource]) {
+					KRN_ERROR("no such resource %i", in->resource);
+					return (KGI_ENXIO);
+				}
+
+				file->mmap_setup.resource = 
+					file->device->kgi.mode->resource[in->resource];
+			} else {
+				if (in->image > file->device->kgi.mode->images) {
+					KRN_ERROR("no such image %i", in->image);
+					return (KGI_ENXIO);
+				}
+				if (__KGI_MAX_NR_IMAGE_RESOURCES <= in->resource) {
+					KRN_ERROR("invalid resource ID");
+					return (KGI_EINVAL);
+				}
+				if (!file->device->kgi.mode->img[in->image].resource[in->  
+					resource]) {
+					KRN_ERROR("no such resource %i", in->resource);
+					return (KGI_ENXIO);
+				}
+
+				file->mmap_setup.resource = 
+					file->device->kgi.mode->resource[in->resource];
+			}
+
+			file->mmap_setup.request = *in;
+			file->mmap_setup.pid = td->td_proc->p_pid;
+			file->mmap_setup.gid = td->td_proc->p_pgrp->pg_id;
+
+			KRN_DEBUG(1, "setup resource %d (at %p)", in->resource,
+				  file->mmap_setup.resource);
+
+			return (KGI_EOK);
+		}
+	default:
+		KRN_DEBUG(1, "command %.4x not (yet) implemented", cmd);
+		return (KGI_ENXIO);
+	}
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_graphic.c sys/dev/kgi/kgu_graphic.c
--- sys/dev/kgi/kgu_graphic.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_graphic.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,573 @@
+/*-
+ * Copyright (C) 1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#define KGI_SYS_NEED_MUTEX
+#define KGI_SYS_NEED_PROC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+#include <dev/kgi/mmio.h>
+#include <dev/kgi/accel.h>
+
+#include <sys/conf.h>
+#include <sys/tty.h>
+
+static struct cdevsw kgu_cdevsw;
+
+/*
+ * per-device static global data.
+ */
+static struct {
+	unsigned int	cnt;
+	graph_device_t	*ptr;
+	pid_t		pid;
+	gid_t		gid;
+} graph_dev[GRAPH_MAX_NR_DEVICES];
+
+/*
+ * Array of graph files. One per process opening a device.
+ * Each graph file entry maintains per-process data along its
+ * interaction with the graphic device.
+ */
+graph_file_t *graph_files[GRAPH_MAX_NR_FILES];
+
+static kgi_u_t 
+graph_device_unit(struct cdev *dev, struct thread *td)
+{
+	kgi_u_t device_id = KGI_INVALID_DEVICE;
+
+	if (dev2unit(dev))
+		device_id = dev2unit(dev) - 1;
+	else
+		if (td)
+			device_id = dev2unit(td->td_proc->p_pgrp->pg_session->s_ttyp->t_dev);
+		else
+			device_id = 0;
+
+	return (device_id);
+}
+
+/*
+ * Note that the device is not registered here but later when
+ * it is attached.
+ */
+static kgi_s_t 
+graph_device_init(kgi_s_t device_id, struct thread *td)
+{
+	graph_device_t *device;
+
+	KRN_ASSERT(device_id >= 0);
+	kgi_mutex_assert(&kgi_lock, KGI_MUTEX_OWNED);
+
+	if (graph_dev[device_id].ptr) {
+		KRN_DEBUG(1, "graph_device %i already initialized", device_id);
+		graph_dev[device_id].cnt++;
+		return (KGI_EOK);
+	}
+	if (graph_dev[device_id].cnt) {
+		KRN_DEBUG(1, "graph_device %i has pending (mmap) references",
+			device_id);
+		return (KGI_EBUSY);
+	}
+	KRN_ASSERT(graph_dev[device_id].pid == 0);
+	KRN_ASSERT(graph_dev[device_id].gid == 0);
+
+	if (NULL == (device = kgi_kmalloc(sizeof(*device)))) {
+		KRN_DEBUG(1, "failed to allocate graph_device %i", device_id);
+		return (KGI_ENOMEM);
+	}
+	memset(device, 0, sizeof(*device));	
+	device->kgi.id = KGI_INVALID_DEVICE;
+	device->kgi.dpy_id = KGI_INVALID_DISPLAY;
+
+	kgi_mutex_init(&device->cmd_mtx, "kgi_graph mutex lock");
+
+	graph_dev[device_id].pid = td->td_proc->p_pid;
+	graph_dev[device_id].gid = td->td_proc->p_pgrp->pg_id;
+	graph_dev[device_id].ptr = device;
+	graph_dev[device_id].cnt++;
+
+	KRN_DEBUG(1, "graph_device %i initialized", device_id);
+	return (KGI_EOK);
+}
+
+static void 
+graph_device_done(kgi_u_t device_id, kgi_u_t previous)
+{
+	graph_device_t *device = graph_dev[device_id].ptr;
+
+	KRN_ASSERT(device_id >= 0);
+	kgi_mutex_assert(&kgi_lock, KGI_MUTEX_OWNED);
+
+	if (--graph_dev[device_id].cnt) {
+		KRN_DEBUG(1, "graph_device %i closed", device_id);
+		return;
+	}
+
+	if (KGI_VALID_DEVICE_ID(device->kgi.id)) {
+		KRN_DEBUG(1, "device still registered (id %i)",	device->kgi.id);
+
+		if (device->kgi.flags & KGI_DF_FOCUSED) {
+			kgi_unmap_device(device->kgi.id);
+			if (KGI_VALID_DEVICE_ID(previous))
+				kgi_map_device(previous);
+		}
+		kgi_unregister_device(&device->kgi);
+		kgi_kfree(device->kgi.mode->dev_mode);
+		device->kgi.mode->dev_mode = NULL;
+	}
+
+	kgi_mutex_done(&device->cmd_mtx);
+
+	kgi_kfree(device);
+	graph_dev[device_id].ptr = NULL;
+
+	KRN_ASSERT(graph_dev[device_id].cnt == 0);
+	KRN_ASSERT(graph_dev[device_id].pid == 0);
+	KRN_ASSERT(graph_dev[device_id].gid == 0);
+
+	KRN_DEBUG(1, "graph_device %i finally closed", device_id);
+}
+
+/*
+ * ioctl() services. This is the primary command interface. Other 
+ * driver-specific interfaces may be provided using mmio-regions or 
+ * by giving direct access to registers where this is safe. 
+ * Other OSes might even have other means.
+ */
+static int 
+graph_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int flags,
+	  struct thread *td)
+{
+	kgi_u_t unit;
+	graph_file_t *file;
+	int io_result = 0;
+
+	/* Unit 0 is used to get a free /dev/event unit. */
+	if (!dev2unit(dev)) {
+		kgic_mapper_get_unit_request_t local = 
+			*(kgic_mapper_get_unit_request_t *)data;
+		kgic_mapper_get_unit_result_t *out = (void *)data;
+	  
+		if (cmd != KGIC_MAPPER_GET_UNIT)
+			return (KGI_EINVAL);
+
+		kgi_mutex_lock(&kgi_lock);
+
+		/* First try the suggested unit. */
+		unit = local.unit;
+		if (!KGI_VALID_DEVICE_ID(unit) || graph_files[unit]) {
+			/* Then try the unit corresponding to the thread VT. */
+			unit = graph_device_unit(dev, td);
+			
+			/* If the VT unit is not free lookup one. */
+			if (graph_files[unit]) {
+				for (unit=0; unit<GRAPH_MAX_NR_FILES; unit++)
+					if (!graph_files[unit])
+						break;
+				if (unit >= GRAPH_MAX_NR_FILES)
+					return (KGI_ENODEV);
+			}
+		}
+		
+		file = kgi_kmalloc(sizeof(*file));
+		if (NULL == file) {
+			KRN_DEBUG(1, "failed to allocate event_file");
+			return (KGI_ENOMEM);
+		}
+		memset(file, 0, sizeof(*file));
+		file->previous = KGI_INVALID_DEVICE;
+
+		graph_files[unit] = file;
+		unit ++;
+		KRN_DEBUG(1, "allocating /dev/graphic%i", unit);
+
+		/* Create the dev entry. */
+		make_dev(&kgu_cdevsw, unit, UID_ROOT, GID_WHEEL,
+			 0600, GRAPH_NAME "%d", unit);
+	
+		out->unit = unit;
+
+		kgi_mutex_unlock(&kgi_lock);
+		return (0);
+	}
+
+	/* Unit should not have been opened if file is null. */
+	unit = dev2unit(dev) - 1;
+	file = graph_files[unit];
+
+	/* attach the process to a specific graph device */
+	if (cmd == KGIC_MAPPER_ATTACH) {
+		kgic_mapper_attach_request_t *in = (void *)data;
+
+		if (file->device) {
+			KRN_ERROR("ioctl() failed: device already attached");
+			return (KGI_EINVAL);
+		}
+
+		if (!KGI_VALID_DEVICE_ID(in->device_id))
+			in->device_id = unit;
+
+		kgi_mutex_lock(&kgi_lock);
+
+		if ((io_result = graph_device_init(in->device_id, td))) 			
+			return (io_result);
+
+		file->device = graph_dev[in->device_id].ptr;
+		file->device_id = in->device_id;
+		if (graph_dev[in->device_id].pid == td->td_proc->p_pid) 
+			file->flags |= GRAPH_FF_SESSION_LEADER;
+
+		KRN_DEBUG(2, "ioctl: attached graphics device %i", in->device_id);
+
+		kgi_mutex_unlock(&kgi_lock);
+		return (KGI_EOK);
+	}
+
+	if (!file->device) {
+		KRN_ERROR("ioctl() failed: no device attached");
+		return (KGI_ENXIO);
+	}
+
+	kgi_mutex_lock(&kgi_lock);
+
+	/* XXX Don't lock yet
+	   kgi_mutex_lock(&file->device->cmd_mtx); */
+
+	switch (cmd & KGIC_TYPE_MASK) {
+	case KGIC_MAPPER_COMMAND:
+		io_result = graph_command(file, cmd, data, td);
+		break;
+	case KGIC_RESOURCE_COMMAND:
+		io_result = graph_resource_command(file, cmd, data);
+		break;
+	case KGIC_DISPLAY_COMMAND:
+		if (KGI_VALID_DEVICE_ID(file->device->kgi.id))
+			io_result = kgidev_display_command(&file->device->kgi, cmd, data);
+		else
+			io_result = KGI_EPROTO;
+		break;
+	default:
+		KRN_DEBUG(1, "command type %.4x not (yet) implemented",
+			(kgi_u_t)(cmd & KGIC_TYPE_MASK));
+		io_result = KGI_EINVAL;
+		goto unlock;
+	}
+
+unlock:
+	/* XXX Don't lock yet
+	   kgi_mutex_unlock(&file->device->cmd_mtx); */
+
+	kgi_mutex_unlock(&kgi_lock);
+
+	return (io_result);
+}
+
+void 
+graph_device_map(kgi_device_t *dev)
+{
+
+	KRN_ASSERT(KGI_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(dev->id >= KGI_MAX_NR_CONSOLES);
+	
+	if (!graph_dev[dev->id - KGI_MAX_NR_CONSOLES].ptr) {	
+		KRN_DEBUG(2, "Could not find device %i (graph %i)", \
+				  dev->id, dev->id - KGI_MAX_NR_CONSOLES);
+		return;
+	}
+
+	/*
+	 * Wakeup any process blocked waiting for the device
+	 * to be mapped.
+	 */
+	kgi_wakeup(dev);
+}
+
+/*
+ * Unmap the graphic device. This removes any mapped page
+ * in order to interrupt a process trying to access the
+ * device while not mapped.
+ * 
+ * kgi_lock owned. 
+ */
+kgi_s_t 
+graph_device_unmap(kgi_device_t *dev)
+{
+	graph_device_t *gdev = (graph_device_t *)dev;
+	int i;
+
+	kgi_mutex_assert(&kgi_lock, KGI_MUTEX_OWNED);
+
+	KRN_ASSERT(KGI_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(dev->id >= KGI_MAX_NR_CONSOLES);
+	
+	if (!graph_dev[dev->id - KGI_MAX_NR_CONSOLES].ptr) {	
+		KRN_DEBUG(2, "Could not find device %i (graph %i)",
+			  dev->id, dev->id - KGI_MAX_NR_CONSOLES);
+		return (KGI_EOK);
+	}
+
+	for (i=0; i < __KGI_MAX_NR_RESOURCES; i++)
+	{
+		graph_mapping_t *map;
+
+		map = gdev->mappings[i];
+
+		/* Lookup every mapping on the device and unmap them */
+		if (map) {
+			do {
+				map = map->other;
+				graph_unmap_map(map);
+			} while (gdev->mappings[i] != map);
+		}
+	}
+
+	return (KGI_EOK);
+}	
+
+/*
+ * Open a graphic special file. We force all processes that made
+ * references mmap() to invalidate these before we allow any reallocation.
+ */
+static int 
+graph_open(struct cdev *dev, int flags, int mode, struct thread *td)
+{
+	graph_file_t *file;
+
+	/*
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 */
+	if (!dev2unit(dev))
+		return (0);
+
+	kgi_mutex_lock(&kgi_lock);
+
+	if (!(file = graph_files[dev2unit(dev) - 1])) {
+		KRN_DEBUG(1, "open: unit not allocated");
+		return (KGI_ENODEV);
+	}
+
+	/*
+	 * Graph files are statically allocated.
+	 * A graph file can be opened only once.
+	 * Device is not initialized here but at attachement
+	 * (see graph_command()).
+	 */
+	if (file->refcnt) {
+		KRN_DEBUG(1, "open: failed, already opened");
+		return (KGI_EBUSY);
+	}
+
+	file->refcnt++;
+
+	kgi_mutex_unlock(&kgi_lock);
+
+	return (KGI_EOK);
+}
+
+static int 
+graph_release(struct cdev *dev, int flags, int mode, struct thread *td)
+{
+	graph_file_t *file;
+
+	/* 
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 */
+	if (!dev2unit(dev))
+		return (0);
+
+	kgi_mutex_lock(&kgi_lock);
+
+	if (!(file = graph_files[dev2unit(dev) - 1])) {
+		KRN_DEBUG(1, "open: unit not allocated");
+		return (KGI_ENODEV);
+	}
+
+	KRN_DEBUG(1, "closing graph device %i (refcnt %i)", 
+		  file->device_id, graph_dev[file->device_id].cnt);
+
+	/*
+	 * Delete all mappings for this file. The vm_area_structs remain
+	 * valid until the process explicitely unmaps them; if they are
+	 * referenced but have no valid vm_private_data field we send SIGBUS.
+	 */
+	while (file->mappings) {
+		graph_mapping_t *map = file->mappings->next;
+		vm_area_t vma = map->vma;
+
+		/* Close any activity on the resource */
+		if (vma->vm_ops && vma->vm_ops->close)
+			vma->vm_ops->close(vma);
+		
+		/* Remove the map from the file */
+		graph_delete_mapping(map);
+
+		/* Free the map */
+		kgi_kfree(map);
+	}
+
+	file->device = NULL;
+
+	file->refcnt--;
+	KRN_ASSERT(file->refcnt == 0);
+
+	if (td->td_proc->p_pid == graph_dev[file->device_id].pid) {
+		KRN_DEBUG(1, "session leader (pid %i) closed graph_device %i",
+			  graph_dev[file->device_id].pid, file->device_id);
+		graph_dev[file->device_id].pid = 0;
+		graph_dev[file->device_id].gid = 0;
+	}
+
+	graph_device_done(file->device_id, file->previous);
+
+	kgi_kfree(file);
+	graph_files[dev2unit(dev) - 1] = NULL;
+
+	kgi_mutex_unlock(&kgi_lock);
+
+	destroy_dev(dev);
+
+	return (0);
+}
+
+/*
+ * graph_mmap() does the neccessary stuff to add a mapping to a file
+ * according to the mmaped resource type.
+ */
+int 
+graph_mmap(struct cdev *dev, vm_area_t vma)
+{
+	kgi_u_t unit = dev2unit(dev) - 1;		/* XXX see graph_open() */
+	graph_file_t *file = graph_files[unit];
+	graph_mapping_t *map;
+	int err;
+
+	if (file->mmap_setup.resource == NULL) {
+		KRN_ERROR("mmap not set up");
+		return (KGI_ENXIO);
+	}
+
+	/*
+	 * Remember the minor of the graphic dev. It will
+	 * be used later to find the file from the vma.
+	 */
+	vma->vm_unit = unit;
+	vma->vm_type = file->mmap_setup.resource->type;
+
+	switch (vma->vm_type & KGI_RT_MASK) {
+	case KGI_RT_MMIO:
+		if ((err = graph_mmio_mmap(vma, &file->mmap_setup, &map))) {
+			KRN_ERROR("mmio mapping failed");
+			return (err);
+		}
+		KRN_DEBUG(1, "mmio mapping succeeded");
+		break;
+	case KGI_RT_ACCEL:
+		if ((err = graph_accel_mmap(vma, &file->mmap_setup, &map))) {
+			KRN_ERROR("accel mapping failed");
+			return (err);
+		}
+		KRN_DEBUG(1, "accel mapping succeeded");
+		break;
+	default:
+		KRN_ERROR("unkown mapping type %.8x", vma->vm_type);
+		return (KGI_ENXIO);
+	}
+
+	/* Link OS dependent and OS independent data */
+	map->vma = vma;
+	vma->vm_private_data = map;
+
+	/* Link to the resource mapped */
+	map->resource = file->mmap_setup.resource;
+
+	/* Link the map to the file entry */
+	map->file = file;
+	graph_add_mapping(file, (graph_mapping_t *) map);
+
+	/* Call the resource callback */
+	if (vma->vm_ops && vma->vm_ops->open)
+		vma->vm_ops->open(vma);
+
+	KRN_DEBUG(1, "mapped resource %s @ %.8x, size %u",
+		file->mmap_setup.resource->name, 
+		(kgi_u_t)vma->vm_offset, (kgi_u_t)vma->vm_size);
+
+	return (KGI_EOK);
+}
+
+static struct cdevsw kgu_cdevsw = {
+	.d_open =	graph_open,
+	.d_close =	graph_release,
+	.d_ioctl =	graph_ioctl,
+	.d_name =	GRAPH_NAME,
+	.d_flags =	D_KGI_PAGING,
+	.d_version =	D_VERSION
+};
+
+static int 
+dev_graphic_init(void)	
+{
+
+	memset(&graph_dev, 0, sizeof(graph_dev));
+	memset(graph_files, 0, sizeof(graph_files));
+  
+	/* Unit 0 is named /dev/graphic */
+	make_dev(&kgu_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, GRAPH_NAME);
+
+  	return (KGI_EOK);
+}
+  
+static int
+kgu_modevent(module_t mod, int type, void *unused)
+{
+	int error = KGI_ENXIO;
+  
+	switch (type) {
+	case MOD_LOAD:
+		error = dev_graphic_init();
+		break;
+	case MOD_UNLOAD:
+		/* XXX dev_graphic_done(); Destroy devs! */
+	default:
+		break;
+	}
+
+	return (error);
+}
+
+static moduledata_t kgu_mod = {
+	"kgu",
+	kgu_modevent,
+	0
+};
+
+DECLARE_MODULE(kgu, kgu_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
+MODULE_VERSION(kgu, 1);
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_map.c sys/dev/kgi/kgu_map.c
--- sys/dev/kgi/kgu_map.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_map.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,163 @@
+/*-
+ * Copyright (C)	1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C)	2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	3
+#endif
+
+#define KGI_SYS_NEED_VM
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+
+/*
+ * Helper functions
+ */
+
+/*
+ * XXX Mapping stuff should be rewritten with queue macros
+ */
+void 
+graph_add_mapping(graph_file_t *file, graph_mapping_t *map)
+{
+	unsigned int i;
+
+	KRN_ASSERT(file);
+	KRN_ASSERT(file->device);
+	KRN_ASSERT(file->device->kgi.mode);
+	KRN_ASSERT(map->resource);
+
+	for (i = 0; i < __KGI_MAX_NR_RESOURCES; i++) {
+		if (file->device->kgi.mode->resource[i] == map->resource) 
+			break;
+	}
+	KRN_ASSERT(i < __KGI_MAX_NR_RESOURCES);
+
+	file->refcnt++;
+
+	map->file = file;
+	if (file->mappings) {
+		map->next = file->mappings->next;
+		file->mappings->next = map;
+	} else {
+		map->next = map;
+		file->mappings = map;
+	}
+
+	map->device = file->device;
+	if (map->device->mappings[i]) {
+		map->other = map->device->mappings[i]->other;
+		map->device->mappings[i]->other = map;
+
+	} else {
+		map->other = map;
+		map->device->mappings[i] = map;
+	}
+	KRN_DEBUG(1, "added mapping %p", map);
+}
+
+void 
+graph_delete_mapping(graph_mapping_t *map)
+{
+	graph_mapping_t *prev;
+	unsigned int i;
+
+	KRN_DEBUG(1, "deleting mapping %p", map);
+	KRN_ASSERT(map);
+	KRN_ASSERT(map->file);
+	KRN_ASSERT(map->device);
+
+	/*delete mapping from mappings-for-same-file list */
+	prev = map->next;
+	while (prev->next != map) 
+		prev = prev->next;
+
+	if (map->file->mappings == map)
+		map->file->mappings = (prev != map) ? prev : NULL;
+
+	prev->next = map->next;
+
+	/* delete from mappings-for-same-region list */
+	prev = map->other;
+	while (prev->other != map) 
+		prev = prev->other;
+
+	i = 0;
+	while ((i < __KGI_MAX_NR_RESOURCES) &&
+		(map->device->kgi.mode->resource[i] != map->resource)) {
+		i++;
+	}
+	KRN_ASSERT(i < __KGI_MAX_NR_RESOURCES);
+
+	if (map->device->mappings[i] == map)
+		map->device->mappings[i] = (prev != map) ? prev : NULL;
+
+	prev->other = map->other;
+
+	map->file->refcnt--;
+
+	KRN_TRACE(1, memset(map, 0, sizeof(*map)));
+}
+
+/*
+ * Prevent access to all the VM pages associated to the object of this map.
+ * The map here is just used to obtain the object.
+ */
+void 
+graph_unmap_map(graph_mapping_t *map)
+{
+	vm_area_t vma = map->vma;
+
+	if (!vma->vm_ops || !vma->vm_ops->unmap) 
+		panic("Don't know how to unmap!!");
+
+	KRN_DEBUG(3, "Unmapping map %p", map);
+
+	/* This operation is resource dependent */
+	vma->vm_ops->unmap(vma);
+}
+
+/*
+ * Unmap mappings of the same resource than the one associated
+ * to the given map. This typically happen when moving a HW window
+ * while linear mapping it in the VM of the processes. When the HW
+ * window is moved, any process that was previously pointing to
+ * the window should pagefault again to update its VM
+ */
+void 
+graph_unmap_resource(graph_mapping_t *map)
+{
+
+	graph_mapping_t *first = map;
+
+	do {
+		KRN_ASSERT(map->resource == first->resource);
+
+		/* The VM pages are deleted but the map is not
+		 * deleted
+		 */
+		graph_unmap_map(map);
+		map = map->other;
+	} while (map != first);
+
+	KRN_DEBUG(3, "mappings for region '%s' unmapped", map->resource->name);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_mmio.c sys/dev/kgi/kgu_mmio.c
--- sys/dev/kgi/kgu_mmio.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_mmio.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,221 @@
+/*-
+ * Copyright (C) 1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	3
+#endif
+
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_VM
+#define KGI_SYS_NEED_MUTEX
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+#include <dev/kgi/mmio.h>
+
+/*
+ * MMIO resource mapping
+ */
+
+/*
+ * Handle page faults for MMIO mappings
+ *
+ * m is the page allocated by the pager to hold paddr (ignored by mmio
+ * mappings since the vma/object already list the pages).
+ *
+ * ooffset is a number of bytes rounded to the page size of the
+ * platform. It is an absolute offset in the mmio.
+ *
+ * paddr the result is the physical address of the "device" obtained
+ * from the ooffset given.
+ */
+static int 
+graph_mmio_nopage(vm_area_t vma, vm_page_t m, vm_offset_t ooffset,
+	  vm_paddr_t *paddr, int prot)
+{
+	graph_mmio_mapping_t *map;
+	kgi_mmio_region_t *mmio;
+	kgi_u32_t offset;
+
+ Retry:
+	kgi_mutex_lock(&kgi_lock);
+
+	map = (graph_mmio_mapping_t *) vma->vm_private_data;
+	if (map == NULL) {
+		KRN_ERROR("invalid (cloned ?) vma %p, sending signal", vma);
+		panic("don't know how to signal...");	/* XXX */
+	}
+
+	mmio = (kgi_mmio_region_t *) map->resource;
+	KRN_ASSERT((mmio->type & KGI_RT_MASK) == KGI_RT_MMIO);
+
+	if (!ooffset)
+		KRN_DEBUG(3, "mmio_nopage @%.8x, vma %p, %x", ooffset, vma, prot);
+
+	if (map->device->kgi.flags & KGI_DF_FOCUSED) {
+		switch(map->type) {
+			/*
+			 * Linear memory mapped linear. The physical address
+			 * returned for the ooffset given as argument is the
+			 * physical base address of the memory + the ooffset
+			 * in bytes
+			 */
+		case GRAPH_MM_LINEAR_LINEAR:
+			map->offset = offset = 0;
+			*paddr = mmio->win.phys + ooffset;
+			break;
+			/*
+			 * Paged memory mapped linear. The physical address
+			 * returned is the physical base address + the offset
+			 * withing the HW window
+			 */
+		case GRAPH_MM_PAGED_LINEAR:
+			offset = ooffset / mmio->win.size;
+			map->offset = ooffset % mmio->win.size;
+			*paddr = mmio->win.phys + map->offset;
+			break;
+		case GRAPH_MM_PAGED_PAGED:
+		case GRAPH_MM_LINEAR_PAGED:
+		default:
+			KRN_INTERNAL_ERROR;
+			panic("don't know how to signal...");
+		}
+
+		if (!ooffset)
+			KRN_DEBUG(3, "mmio_nopage @%.8x, remap vma %p, "
+				  "to '%s' phys %x, offset %x",
+				  ooffset, map->vma, mmio->name, *paddr, offset);
+
+		/*
+		 * Check if we have to move the HW window. If we have,
+		 * the previously mapped window has to be unmapped
+		 */
+		if (offset != mmio->offset) {
+			/* XXX Not tested */
+			graph_unmap_resource((graph_mapping_t *) map);
+
+			if (mmio->SetOffset) {
+				mmio->SetOffset(mmio, offset);
+			} else {
+				mmio->offset = offset;
+			}
+		}
+
+		kgi_mutex_unlock(&kgi_lock);
+		return (0);
+
+	} else {
+		KRN_DEBUG(2, "Not focused, going to sleep!");
+
+		/*
+		 * The thread is trying to access an area while the
+		 * device is not focused --> block it
+		 */
+		msleep(map->device, &kgi_lock.mutex, PDROP | PVM, "mmiosleep", 0);
+		goto Retry;
+	}
+}
+
+/*
+ * graph_mmio_unmap() has to unmap a mmio mapping. As we do not allow
+ * partial mapping of MMIO regions, we consequently have to deny partial
+ * unmapping. This is ensured in mm/mmap.c. We only have to remove our
+ * local mapping state info because the page tables are fixed in mm/mmap.c.
+ */
+static void 
+graph_mmio_close(vm_area_t vma)
+{
+	/* Remove / free pages of the VM area */
+	kgi_pager_remove_all(vma);
+
+	/* Reset the map of the vma */
+	vma->vm_private_data = NULL;
+}
+
+/*
+ * Unmap the MMIO map. No more access shall be permitted to
+ * this map.
+ */
+static void 
+graph_mmio_unmap(vm_area_t vma)
+{
+	/* Just remove all the pages of the map */
+	kgi_pager_remove_all(vma);
+}
+
+static struct vm_operations_struct graph_mmio_vmops =
+{
+	.open	 =	NULL,
+	.close	 =	graph_mmio_close,
+	.nopage	 =	graph_mmio_nopage,
+	.unmap   =	graph_mmio_unmap,
+};
+
+int 
+graph_mmio_mmap(vm_area_t vma, graph_mmap_setup_t *mmap_setup,
+	  graph_mapping_t **the_map)
+{
+	kgi_mmio_region_t *mmio = (kgi_mmio_region_t *)mmap_setup->resource;
+	graph_mmio_mapping_t *map = NULL;
+	vm_ooffset_t size = vma->vm_size;
+
+	KRN_DEBUG(1, "mapping mmio '%s' to vma %p", mmio->name, vma);
+
+	KRN_ASSERT(0 == (mmio->size % mmio->win.size));
+	KRN_ASSERT(mmio->size >= mmio->win.size);
+
+	if ((mmio->win.size & PAGE_MASK) ||
+	    (size > mmio->size) ||
+	    ((mmio->win.size == mmio->size) && (mmio->size % size)) ||
+	    ((mmio->win.size != mmio->size) && (size < mmio->size) &&
+	     (mmio->win.size != size))) {
+
+		KRN_ERROR("mmap size %i, but region size %i, win.size %i",
+			  (int)size, (int)mmio->size, (int)mmio->win.size);
+		return (KGI_EINVAL);
+	}
+
+	KRN_DEBUG(1, "mmap size %i, region size %i, win.size %i OK",
+		  (int)size, (int)mmio->size, (int)mmio->win.size);
+
+	/* XXX warning determine protection flags here! */
+
+	if (!(map = kgi_kmalloc(sizeof(*map)))) {
+		KRN_ERROR("failed to allocate mmio map");
+		return (KGI_ENOMEM);
+	}
+	memset(map, 0, sizeof(*map));
+
+	map->prot = VM_PROT_READ | VM_PROT_WRITE; /* XXX | PROT_SHARED */;
+	map->type = (mmio->win.size == mmio->size) /* linear region? */
+		? ((size == mmio->size)
+			? GRAPH_MM_LINEAR_LINEAR : GRAPH_MM_PAGED_LINEAR)
+		: ((size == mmio->size)
+			? GRAPH_MM_LINEAR_PAGED  : GRAPH_MM_PAGED_PAGED);
+
+	vma->vm_ops = &graph_mmio_vmops;
+
+	/* Return the obtained map the upper layers */
+	*the_map = (graph_mapping_t *)map;
+
+	return (KGI_EOK);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/kgu_resource.c sys/dev/kgi/kgu_resource.c
--- sys/dev/kgi/kgu_resource.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/kgu_resource.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,294 @@
+/*-
+ * Copyright (C) 1995-1997 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2004 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgi/graphic.h>
+
+int 
+graph_resource_command(graph_file_t *file, unsigned int cmd, void *data)
+{
+	const kgic_resource_request_t *in = data;
+	union {
+		kgi_resource_t		common;
+		kgi_clut_t		clut;
+		kgi_tlut_t		tlut;
+		kgi_marker_t		marker;
+		kgi_text16_t		text16;
+	} *r;
+
+	if (!(file->flags & GRAPH_FF_CLIENT_IDENTIFIED)) {
+		KRN_ERROR("cmd = %.8x, but client has not yet identified", cmd);
+		return (KGI_EPROTO);
+	}
+
+	/* check that the resource id is ok */
+	if (((in->image == KGIC_MAPPER_NON_IMAGE_RESOURCE)?
+	    __KGI_MAX_NR_IMAGE_RESOURCES:
+	    __KGI_MAX_NR_RESOURCES) <= in->resource) {
+		KRN_ERROR("invalid resource ID");
+		return (KGI_EINVAL);
+	}
+
+	/* check that the image number is ok */
+	if ((in->image < 0) || (file->device->kgi.mode->images <= in->image)) {
+		if (in->image != KGIC_MAPPER_NON_IMAGE_RESOURCE) {
+			KRN_ERROR("invalid image %d", in->image);
+			return (KGI_EINVAL);
+		}
+	}
+
+	/* get the mode resource or image resource */
+	r = (in->image == KGIC_MAPPER_NON_IMAGE_RESOURCE) ?
+	    (void*)file->device->kgi.mode->resource[in->resource] :
+	    (void*)file->device->kgi.mode->img[in->image].resource[in->resource];
+
+	if (NULL == r) {
+		KRN_ERROR("no %s resource %d", 
+		    in->image == KGIC_MAPPER_NON_IMAGE_RESOURCE?
+		    "mode" : "image", in->resource);
+		return (KGI_EINVAL);
+	}
+
+	switch(cmd) {
+	case KGIC_RESOURCE_CLUT_GET_INFO:
+	{
+		kgic_clut_get_info_result_t *out = data;
+		
+		if ((r->common.type != KGI_RT_ILUT_CONTROL) &&
+		    (r->common.type != KGI_RT_ALUT_CONTROL))
+			return (KGI_EINVAL);
+		
+		out->tables = r->clut.tables;
+		out->entries = r->clut.entries;
+				
+		return (KGI_EOK);
+	}	
+	case KGIC_RESOURCE_CLUT_SELECT:
+	{
+		kgic_clut_select_request_t *in = data;
+
+		if ((r->common.type != KGI_RT_ILUT_CONTROL) &&
+		    (r->common.type != KGI_RT_ALUT_CONTROL))
+			return KGI_EINVAL;
+
+		if (r->clut.Select) {
+			(r->clut.Select)(&r->clut, in->lut);		
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}
+	case KGIC_RESOURCE_CLUT_SET:
+	{
+		kgic_clut_set_request_t *in = data;
+		
+		if ((r->common.type != KGI_RT_ILUT_CONTROL) &&
+		    (r->common.type != KGI_RT_ALUT_CONTROL))
+			return (KGI_EINVAL);
+		
+		if (r->clut.Set) {
+			kgi_u_t attrs;
+			kgi_attribute_mask_t tam;
+
+			if (in->idx >= r->clut.entries)
+				return (KGI_EINVAL);
+				
+			/* clamp the count */
+			if (in->cnt + in->idx > r->clut.entries)
+				in->cnt -= in->cnt + in->idx - r->clut.entries;
+
+			/* count the number of attrs passed in for each entry */
+			for (attrs = 0, tam = in->am; tam; tam >>= 1)
+				attrs += (tam & 1) ? 1:0;
+			
+			if (attrs == 0)
+				return (KGI_EOK);
+				
+			(r->clut.Set)(&r->clut, in->lut, in->idx, in->cnt, 
+				in->am, (kgi_u16_t*)in->data);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}	
+	case KGIC_RESOURCE_TLUT_SELECT:
+	{
+		kgic_tlut_select_request_t *in = data;
+
+		if (r->common.type != KGI_RT_TLUT_CONTROL)
+			return (KGI_EINVAL);
+
+		if (r->tlut.Select) {
+			(r->tlut.Select)(&r->tlut, in->lut);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}
+	case KGIC_RESOURCE_TLUT_SET:
+	{
+		kgic_tlut_set_request_t *in = data;
+
+		if (r->common.type != KGI_RT_TLUT_CONTROL)
+			return (KGI_EINVAL);
+
+		if (r->tlut.Set) {
+			(r->tlut.Set)(&r->tlut, in->lut, in->idx, in->cnt, in->data);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}	
+	case KGIC_RESOURCE_MARKER_SET_MODE:
+	{
+		kgic_marker_set_mode_request_t *in = data;
+
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		if (r->marker.SetMode) {
+			(r->marker.SetMode)(&r->marker, in->mode);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}	
+	case KGIC_RESOURCE_MARKER_SELECT:
+	{
+		kgic_marker_select_request_t *in = data;
+
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		if (r->marker.Select) {
+			(r->marker.Select)(&r->marker, in->shape);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}
+	case KGIC_RESOURCE_MARKER_SET_SHAPE:
+	{
+	  /* kgic_marker_set_shape_request_t *in = data; */
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+		
+/*		if (r->marker.SetShape) {
+		
+			COPY_DATA(in->data, 
+			io_result = (r->marker.SetShape)(&r->marker, in->shape,
+				in->hot_x, in->hot_y, data, */
+		return (KGI_EINVAL);
+	}
+	case KGIC_RESOURCE_MARKER_SHOW:
+	{
+		kgic_marker_show_request_t *in = data;
+
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		if (r->marker.Show) {
+			(r->marker.Show)(&r->marker, in->x, in->y);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}	
+	case KGIC_RESOURCE_MARKER_HIDE:
+	{
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		if (r->marker.Hide) {
+			(r->marker.Hide)(&r->marker);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}	
+	case KGIC_RESOURCE_MARKER_UNDO:
+	{
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		if (r->marker.Undo) {
+			(r->marker.Undo)(&r->marker);
+			return (KGI_EOK);
+		}
+		return (KGI_EINVAL);
+	}		
+	/* this should probably be moved to KGI_MAPPER_RESOURCE_INFO */
+	case KGIC_RESOURCE_MARKER_INFO:
+	{
+		kgic_marker_info_result_t *out = data;
+
+		if ((r->common.type != KGI_RT_CURSOR_CONTROL) &&
+		    (r->common.type != KGI_RT_POINTER_CONTROL))
+			return (KGI_EINVAL);
+
+		out->modes  = r->marker.modes;
+		out->shapes = r->marker.shapes;
+		out->size   = r->marker.size;
+		
+		return (KGI_EOK);
+	}
+
+#if 0
+	case KGIC_RESOURCE_TEXT16_PUT_TEXT16:
+	{
+		kgic_text16_put_text16_request_t *in = data;
+
+		if (r->common.type != KGI_RT_TEXT16_CONTROL)
+			return KGI_EINVAL;
+
+		if (r->text16.PutText16) {
+
+			(r->text16.PutText16)(&r->text16, in->offset, 
+				(kgi_u16_t*)in->data, in->cnt);
+			return KGI_EOK;
+		}
+		return KGI_EINVAL;
+	}		
+#endif
+/* this should probably be moved to KGI_MAPPER_RESOURCE_INFO */
+	case KGIC_RESOURCE_TEXT16_INFO:
+	{
+		kgic_text16_info_result_t *out = data;
+
+		if (r->common.type != KGI_RT_TEXT16_CONTROL)
+			return (KGI_EINVAL);
+
+		out->size = r->text16.size;
+		out->virt = r->text16.virt;
+		out->cell = r->text16.cell;
+		out->font = r->text16.font;
+			
+		return (KGI_EOK);
+	}
+	default:
+		KRN_DEBUG(1, "unknown resource command %.4x", cmd);
+		return (KGI_ENXIO);
+	}
+}
diff -x CVS -x .svn -aurpN sys/dev/kgi/maintainers.h sys/dev/kgi/maintainers.h
--- sys/dev/kgi/maintainers.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/maintainers.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,20 @@
+/*-*
+ * Maintainer definitions.
+ */
+
+#ifndef	_kgi_maintainers_h
+#define	_kgi_maintainers_h
+
+#define	The_GGI_Project	"The GGI Project <ggi-develop@lists.sourceforge.net>"
+#define	The_KGI_Project	"The KGI Project <kgi-develop@lists.sourceforge.net>"
+#define	Emmanuel_Marty	"Emmanuel Marty <kgi-develop@lists.sourceforge.net>"
+#define	Jon_Taylor	"Jon M. Taylor <kgi-develop@lists.sourceforge.net>"
+#define	Steffen_Seeger	"Steffen Seeger <steffen.seeger@kgi-project.org>"
+#define	Brian_S_Julin	"Brian S. Julin <kgi-develop@lists.sourceforge.net>"
+#define	Jos_Hulzink	"Jos Hulzink <kgi-develop@lists.sourceforge.net>"
+#define	Johan_Karlberg	"Johan Karlberg <kgi-develop@lists.sourceforge.net>"
+#define	Rodolphe_Ortalo	"Rodolphe Ortalo <kgi-develop@lists.sourceforge.net>"
+#define Filip_Spacek    "Filip Spacek <fspacek_at_student.math.uwaterloo.ca>"
+#define Nicholas_Souchu "Nicholas Souchu <kgi-develop@lists.sourceforge.net>"
+
+#endif	/* _kgi_maintainers_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/mmio.h sys/dev/kgi/mmio.h
--- sys/dev/kgi/mmio.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/mmio.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,52 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2004 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * /dev/graphic mmio OS dependent definitions
+ */
+
+#ifndef _kgi_mmio_h
+#define	_kgi_mmio_h
+
+/*
+ * MMIO mappings
+ *
+ * /dev/graphic provides a virtualized view to kgi_mmio_regions available
+ * in a particular kgi_mode. Each kgi_mmio_region may be mapped several
+ * times, possibly by several processes.
+ * Per process, we keep a linked list of the various mappings (->next).
+ * Additionally, all mappings of a particular kgi_mmio_region are kept
+ * in a circular linked list (->other).
+ */
+
+typedef enum {
+	GRAPH_MM_INVALID = 0,
+	GRAPH_MM_LINEAR_LINEAR,
+	GRAPH_MM_LINEAR_PAGED,
+	GRAPH_MM_PAGED_LINEAR,
+	GRAPH_MM_PAGED_PAGED,
+	GRAPH_MM_LAST
+} graph_mmio_maptype_t;
+
+typedef struct {
+	__GRAPH_RESOURCE_MAPPING
+
+	graph_mmio_maptype_t	type;	/* mapping type			*/
+	unsigned long 		offset;	/* offset for paged mappings	*/
+	unsigned int		prot;	/* page protection flags	*/
+} graph_mmio_mapping_t;
+
+extern int graph_mmio_mmap(vm_area_t vma, graph_mmap_setup_t *mmap_setup,
+			   graph_mapping_t **map);
+
+#endif /* #ifndef _kgi_mmio_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/pci.h sys/dev/kgi/pci.h
--- sys/dev/kgi/pci.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/pci.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,985 @@
+/*-*
+ * Ripped from linux/pci.h to have PCI definitions on non-Linux archs.
+ *
+ * PCI defines and function prototypes
+ * Copyright 1994, Drew Eckhardt
+ * Copyright 1997, Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+ *
+ * For more information, please consult 
+ * 
+ * PCI BIOS Specification Revision
+ * PCI Local Bus Specification
+ * PCI System Design Guide
+ *
+ * PCI Special Interest Group
+ * M/S HF3-15A
+ * 5200 N.E. Elam Young Parkway
+ * Hillsboro, Oregon 97124-6497
+ * +1 (503) 696-2000 
+ * +1 (800) 433-5177
+ * 
+ * Manuals are $25 each or $50 for all three, plus $7 shipping 
+ * within the United States, $35 abroad.
+ *
+ * $FreeBSD$
+ *
+ */
+
+#ifndef _kgi_pci_pci_h
+#define _kgi_pci_pci_h
+
+#define PCI_ANY_ID (~0)
+
+/*
+ * Under PCI, each device has 256 bytes of configuration address space,
+ * of which the first 64 bytes are standardized as follows:
+ */
+#define PCI_VENDOR_ID		0x00	/* 16 bits */
+#define PCI_DEVICE_ID		0x02	/* 16 bits */
+#define PCI_COMMAND		0x04	/* 16 bits */
+#define  PCI_COMMAND_IO		0x1	/* Enable response in I/O space */
+#define  PCI_COMMAND_MEMORY	0x2	/* Enable response in Memory space */
+#define  PCI_COMMAND_MASTER	0x4	/* Enable bus mastering */
+#define  PCI_COMMAND_SPECIAL	0x8	/* Enable response to special cycles */
+#define  PCI_COMMAND_INVALIDATE	0x10	/* Use memory write and invalidate */
+#define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
+#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
+
+#define PCI_STATUS		0x06	/* 16 bits */
+#define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
+#define  PCI_STATUS_UDF		0x40	/* Support User Definable Features */
+
+#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+#define  PCI_STATUS_DEVSEL_FAST	0x000	
+#define  PCI_STATUS_DEVSEL_MEDIUM 0x200
+#define  PCI_STATUS_DEVSEL_SLOW 0x400
+#define  PCI_STATUS_SIG_TARGET_ABORT 0x800 /* Set on target abort */
+#define  PCI_STATUS_REC_TARGET_ABORT 0x1000 /* Master ack of " */
+#define  PCI_STATUS_REC_MASTER_ABORT 0x2000 /* Set on master abort */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR 0x4000 /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY 0x8000 /* Set on parity error */
+
+#define PCI_CLASS_REVISION	0x08	/* High 24 bits are class, low 8
+					   revision */
+#define PCI_REVISION_ID         0x08    /* Revision ID */
+#define PCI_CLASS_PROG          0x09    /* Reg. Level Programming Interface */
+#define PCI_CLASS_DEVICE        0x0a    /* Device class */
+
+#define PCI_CACHE_LINE_SIZE	0x0c	/* 8 bits */
+#define PCI_LATENCY_TIMER	0x0d	/* 8 bits */
+#define PCI_HEADER_TYPE		0x0e	/* 8 bits */
+#define  PCI_HEADER_TYPE_NORMAL	0
+#define  PCI_HEADER_TYPE_BRIDGE 1
+#define  PCI_HEADER_TYPE_CARDBUS 2
+
+#define PCI_BIST		0x0f	/* 8 bits */
+#define PCI_BIST_CODE_MASK	0x0f	/* Return result */
+#define PCI_BIST_START		0x40	/* 1 to start BIST, 2 secs or less */
+#define PCI_BIST_CAPABLE	0x80	/* 1 if BIST capable */
+
+/*
+ * Base addresses specify locations in memory or I/O space.
+ * Decoded size can be determined by writing a value of 
+ * 0xffffffff to the register, and reading it back.  Only 
+ * 1 bits are decoded.
+ */
+#define PCI_BASE_ADDRESS_0	0x10	/* 32 bits */
+#define PCI_BASE_ADDRESS_1	0x14	/* 32 bits */
+#define PCI_BASE_ADDRESS_2	0x18	/* 32 bits [htype 0 only] */
+#define PCI_BASE_ADDRESS_3	0x1c	/* 32 bits */
+#define PCI_BASE_ADDRESS_4	0x20	/* 32 bits */
+#define PCI_BASE_ADDRESS_5	0x24	/* 32 bits */
+#define  PCI_BASE_ADDRESS_SPACE	0x01	/* 0 = memory, 1 = I/O */
+#define  PCI_BASE_ADDRESS_SPACE_IO 0x01
+#define  PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
+#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
+#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
+#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fUL)
+#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03UL)
+/* bit 1 is reserved if address_space = 1 */
+
+/* Header type 0 (normal devices) */
+#define PCI_CARDBUS_CIS		0x28
+#define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+#define PCI_SUBSYSTEM_ID	0x2e  
+#define PCI_ROM_ADDRESS		0x30	/* 32 bits */
+#define  PCI_ROM_ADDRESS_ENABLE	0x01	/* Write 1 to enable ROM,
+					   bits 31..11 are address,
+					   10..2 are reserved */
+#define PCI_ROM_ADDRESS_MASK	(~0x7ffUL)
+
+/* 0x34-0x3b are reserved */
+#define PCI_INTERRUPT_LINE	0x3c	/* 8 bits */
+#define PCI_INTERRUPT_PIN	0x3d	/* 8 bits */
+#define PCI_MIN_GNT		0x3e	/* 8 bits */
+#define PCI_MAX_LAT		0x3f	/* 8 bits */
+
+/* Header type 1 (PCI-to-PCI bridges) */
+#define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+#define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+#define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+#define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+#define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+#define PCI_IO_LIMIT		0x1d
+#define  PCI_IO_RANGE_TYPE_MASK	0x0f	/* I/O bridging type */
+#define  PCI_IO_RANGE_TYPE_16	0x00
+#define  PCI_IO_RANGE_TYPE_32	0x01
+#define  PCI_IO_RANGE_MASK	~0x0f
+#define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+#define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+#define PCI_MEMORY_LIMIT	0x22
+#define  PCI_MEMORY_RANGE_TYPE_MASK 0x0f
+#define  PCI_MEMORY_RANGE_MASK	~0x0f
+#define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+#define PCI_PREF_MEMORY_LIMIT	0x26
+#define  PCI_PREF_RANGE_TYPE_MASK 0x0f
+#define  PCI_PREF_RANGE_TYPE_32	0x00
+#define  PCI_PREF_RANGE_TYPE_64	0x01
+#define  PCI_PREF_RANGE_MASK	~0x0f
+#define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+#define PCI_PREF_LIMIT_UPPER32	0x2c
+#define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+#define PCI_IO_LIMIT_UPPER16	0x32
+/* 0x34-0x3b is reserved */
+#define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_BRIDGE_CONTROL	0x3e
+#define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+#define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+#define  PCI_BRIDGE_CTL_NO_ISA	0x04	/* Disable bridging of ISA ports */
+#define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+#define  PCI_BRIDGE_CTL_MASTER_ABORT 0x20  /* Report master aborts */
+#define  PCI_BRIDGE_CTL_BUS_RESET 0x40	/* Secondary bus reset */
+#define  PCI_BRIDGE_CTL_FAST_BACK 0x80	/* Fast Back2Back enabled on secondary interface */
+
+/* Header type 2 (CardBus bridges) -- detailed info welcome */
+#define PCI_CB_CARDBUS_BASE	0x10	/* CardBus Socket/ExCa base address */
+#define  PCI_CB_CARDBUS_BASE_TYPE_MASK 0xfff
+#define  PCI_CB_CARDBUS_BASE_MASK ~0xfff
+#define PCI_CB_CAPABILITIES	0x14	/* Offset of list of capabilities in cfg space */
+/* 0x15 reserved */
+#define PCI_CB_SEC_STATUS	0x16	/* Secondary status */
+#define PCI_CB_BUS_NUMBER	0x18	/* PCI bus number */
+#define PCI_CB_CARDBUS_NUMBER	0x19	/* CardBus bus number */
+#define PCI_CB_SUBORDINATE_BUS	0x1a	/* Subordinate bus number */
+#define PCI_CB_CARDBUS_LATENCY	0x1b	/* CardBus latency timer */
+#define PCI_CB_MEMORY_BASE_0	0x1c
+#define PCI_CB_MEMORY_LIMIT_0	0x20
+#define PCI_CB_MEMORY_BASE_1	0x24
+#define PCI_CB_MEMORY_LIMIT_1	0x28
+#define PCI_CB_IO_BASE_0	0x2c
+#define PCI_CB_IO_BASE_0_HI	0x2e
+#define PCI_CB_IO_LIMIT_0	0x30
+#define PCI_CB_IO_LIMIT_0_HI	0x32
+#define PCI_CB_IO_BASE_1	0x34
+#define PCI_CB_IO_BASE_1_HI	0x36
+#define PCI_CB_IO_LIMIT_1	0x38
+#define PCI_CB_IO_LIMIT_1_HI	0x3a
+/* 0x3c-0x3d are same as for htype 0 */
+/* 0x3e-0x3f are same as for htype 1 */
+#define PCI_CB_SUBSYSTEM_ID	0x40
+#define PCI_CB_SUBSYSTEM_VENDOR_ID 0x42
+#define PCI_CB_LEGACY_MODE_BASE	0x44	/* 16-bit PC Card legacy mode base address (ExCa) */
+/* 0x48-0x7f reserved */
+
+/* Device classes and subclasses */
+
+#define PCI_CLASS_NOT_DEFINED		0x0000
+#define PCI_CLASS_NOT_DEFINED_VGA	0x0001
+
+#define PCI_BASE_CLASS_STORAGE		0x01
+#define PCI_CLASS_STORAGE_SCSI		0x0100
+#define PCI_CLASS_STORAGE_IDE		0x0101
+#define PCI_CLASS_STORAGE_FLOPPY	0x0102
+#define PCI_CLASS_STORAGE_IPI		0x0103
+#define PCI_CLASS_STORAGE_RAID		0x0104
+#define PCI_CLASS_STORAGE_OTHER		0x0180
+
+#define PCI_BASE_CLASS_NETWORK		0x02
+#define PCI_CLASS_NETWORK_ETHERNET	0x0200
+#define PCI_CLASS_NETWORK_TOKEN_RING	0x0201
+#define PCI_CLASS_NETWORK_FDDI		0x0202
+#define PCI_CLASS_NETWORK_ATM		0x0203
+#define PCI_CLASS_NETWORK_OTHER		0x0280
+
+#define PCI_BASE_CLASS_DISPLAY		0x03
+#define PCI_CLASS_DISPLAY_VGA		0x0300
+#define PCI_CLASS_DISPLAY_XGA		0x0301
+#define PCI_CLASS_DISPLAY_OTHER		0x0380
+
+#define PCI_BASE_CLASS_MULTIMEDIA	0x04
+#define PCI_CLASS_MULTIMEDIA_VIDEO	0x0400
+#define PCI_CLASS_MULTIMEDIA_AUDIO	0x0401
+#define PCI_CLASS_MULTIMEDIA_OTHER	0x0480
+
+#define PCI_BASE_CLASS_MEMORY		0x05
+#define  PCI_CLASS_MEMORY_RAM		0x0500
+#define  PCI_CLASS_MEMORY_FLASH		0x0501
+#define  PCI_CLASS_MEMORY_OTHER		0x0580
+
+#define PCI_BASE_CLASS_BRIDGE		0x06
+#define  PCI_CLASS_BRIDGE_HOST		0x0600
+#define  PCI_CLASS_BRIDGE_ISA		0x0601
+#define  PCI_CLASS_BRIDGE_EISA		0x0602
+#define  PCI_CLASS_BRIDGE_MC		0x0603
+#define  PCI_CLASS_BRIDGE_PCI		0x0604
+#define  PCI_CLASS_BRIDGE_PCMCIA	0x0605
+#define  PCI_CLASS_BRIDGE_NUBUS		0x0606
+#define  PCI_CLASS_BRIDGE_CARDBUS	0x0607
+#define  PCI_CLASS_BRIDGE_OTHER		0x0680
+
+#define PCI_BASE_CLASS_COMMUNICATION	0x07
+#define PCI_CLASS_COMMUNICATION_SERIAL	0x0700
+#define PCI_CLASS_COMMUNICATION_PARALLEL 0x0701
+#define PCI_CLASS_COMMUNICATION_OTHER	0x0780
+
+#define PCI_BASE_CLASS_SYSTEM		0x08
+#define PCI_CLASS_SYSTEM_PIC		0x0800
+#define PCI_CLASS_SYSTEM_DMA		0x0801
+#define PCI_CLASS_SYSTEM_TIMER		0x0802
+#define PCI_CLASS_SYSTEM_RTC		0x0803
+#define PCI_CLASS_SYSTEM_OTHER		0x0880
+
+#define PCI_BASE_CLASS_INPUT		0x09
+#define PCI_CLASS_INPUT_KEYBOARD	0x0900
+#define PCI_CLASS_INPUT_PEN		0x0901
+#define PCI_CLASS_INPUT_MOUSE		0x0902
+#define PCI_CLASS_INPUT_OTHER		0x0980
+
+#define PCI_BASE_CLASS_DOCKING		0x0a
+#define PCI_CLASS_DOCKING_GENERIC	0x0a00
+#define PCI_CLASS_DOCKING_OTHER		0x0a01
+
+#define PCI_BASE_CLASS_PROCESSOR	0x0b
+#define PCI_CLASS_PROCESSOR_386		0x0b00
+#define PCI_CLASS_PROCESSOR_486		0x0b01
+#define PCI_CLASS_PROCESSOR_PENTIUM	0x0b02
+#define PCI_CLASS_PROCESSOR_ALPHA	0x0b10
+#define PCI_CLASS_PROCESSOR_POWERPC	0x0b20
+#define PCI_CLASS_PROCESSOR_CO		0x0b40
+
+#define PCI_BASE_CLASS_SERIAL		0x0c
+#define PCI_CLASS_SERIAL_FIREWIRE	0x0c00
+#define PCI_CLASS_SERIAL_ACCESS		0x0c01
+#define PCI_CLASS_SERIAL_SSA		0x0c02
+#define PCI_CLASS_SERIAL_USB		0x0c03
+#define PCI_CLASS_SERIAL_FIBER		0x0c04
+
+#define PCI_CLASS_OTHERS		0xff
+
+/*
+ * Vendor and card ID's: sort these numerically according to vendor
+ * (and according to card ID within vendor). Send all updates to
+ * <linux-pcisupport@cck.uni-kl.de>.
+ */
+#define PCI_VENDOR_ID_COMPAQ		0x0e11
+#define PCI_DEVICE_ID_COMPAQ_1280	0x3033
+#define PCI_DEVICE_ID_COMPAQ_SMART2P	0xae10
+#define PCI_DEVICE_ID_COMPAQ_NETEL100	0xae32
+#define PCI_DEVICE_ID_COMPAQ_NETEL10	0xae34
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3I	0xae35
+#define PCI_DEVICE_ID_COMPAQ_NETEL100D	0xae40
+#define PCI_DEVICE_ID_COMPAQ_NETEL100PI	0xae43
+#define PCI_DEVICE_ID_COMPAQ_NETEL100I	0xb011
+#define PCI_DEVICE_ID_COMPAQ_THUNDER	0xf130
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3B	0xf150
+
+#define PCI_VENDOR_ID_NCR		0x1000
+#define PCI_DEVICE_ID_NCR_53C810	0x0001
+#define PCI_DEVICE_ID_NCR_53C820	0x0002
+#define PCI_DEVICE_ID_NCR_53C825	0x0003
+#define PCI_DEVICE_ID_NCR_53C815	0x0004
+#define PCI_DEVICE_ID_NCR_53C860	0x0006
+#define PCI_DEVICE_ID_NCR_53C896	0x000b
+#define PCI_DEVICE_ID_NCR_53C895	0x000c
+#define PCI_DEVICE_ID_NCR_53C885	0x000d
+#define PCI_DEVICE_ID_NCR_53C875	0x000f
+#define PCI_DEVICE_ID_NCR_53C875J	0x008f
+
+#define PCI_VENDOR_ID_ATI		0x1002
+#define PCI_DEVICE_ID_ATI_68800		0x4158
+#define PCI_DEVICE_ID_ATI_215CT222	0x4354
+#define PCI_DEVICE_ID_ATI_210888CX	0x4358
+#define PCI_DEVICE_ID_ATI_215GB		0x4742
+#define PCI_DEVICE_ID_ATI_215GD		0x4744
+#define PCI_DEVICE_ID_ATI_215GP		0x4750
+#define PCI_DEVICE_ID_ATI_215GT		0x4754
+#define PCI_DEVICE_ID_ATI_215GTB	0x4755
+#define PCI_DEVICE_ID_ATI_210888GX	0x4758
+#define PCI_DEVICE_ID_ATI_264VT		0x5654
+
+#define PCI_VENDOR_ID_VLSI		0x1004
+#define PCI_DEVICE_ID_VLSI_82C592	0x0005
+#define PCI_DEVICE_ID_VLSI_82C593	0x0006
+#define PCI_DEVICE_ID_VLSI_82C594	0x0007
+#define PCI_DEVICE_ID_VLSI_82C597	0x0009
+#define PCI_DEVICE_ID_VLSI_82C541	0x000c
+#define PCI_DEVICE_ID_VLSI_82C543	0x000d
+#define PCI_DEVICE_ID_VLSI_82C532	0x0101
+#define PCI_DEVICE_ID_VLSI_82C534	0x0102
+#define PCI_DEVICE_ID_VLSI_82C535	0x0104
+#define PCI_DEVICE_ID_VLSI_82C147	0x0105
+#define PCI_DEVICE_ID_VLSI_VAS96011	0x0702
+
+#define PCI_VENDOR_ID_ADL		0x1005
+#define PCI_DEVICE_ID_ADL_2301		0x2301
+
+#define PCI_VENDOR_ID_NS		0x100b
+#define PCI_DEVICE_ID_NS_87415		0x0002
+#define PCI_DEVICE_ID_NS_87410		0xd001
+
+#define PCI_VENDOR_ID_TSENG		0x100c
+#define PCI_DEVICE_ID_TSENG_W32P_2	0x3202
+#define PCI_DEVICE_ID_TSENG_W32P_b	0x3205
+#define PCI_DEVICE_ID_TSENG_W32P_c	0x3206
+#define PCI_DEVICE_ID_TSENG_W32P_d	0x3207
+#define PCI_DEVICE_ID_TSENG_ET6000	0x3208
+
+#define PCI_VENDOR_ID_WEITEK		0x100e
+#define PCI_DEVICE_ID_WEITEK_P9000	0x9001
+#define PCI_DEVICE_ID_WEITEK_P9100	0x9100
+
+#define PCI_VENDOR_ID_DEC		0x1011
+#define PCI_DEVICE_ID_DEC_BRD		0x0001
+#define PCI_DEVICE_ID_DEC_TULIP		0x0002
+#define PCI_DEVICE_ID_DEC_TGA		0x0004
+#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
+#define PCI_DEVICE_ID_DEC_TGA2		0x000D
+#define PCI_DEVICE_ID_DEC_FDDI		0x000F
+#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
+#define PCI_DEVICE_ID_DEC_21142		0x0019
+#define PCI_DEVICE_ID_DEC_21052		0x0021
+#define PCI_DEVICE_ID_DEC_21150		0x0022
+#define PCI_DEVICE_ID_DEC_21152		0x0024
+
+#define PCI_VENDOR_ID_CIRRUS		0x1013
+#define PCI_DEVICE_ID_CIRRUS_7548	0x0038
+#define PCI_DEVICE_ID_CIRRUS_5430	0x00a0
+#define PCI_DEVICE_ID_CIRRUS_5434_4	0x00a4
+#define PCI_DEVICE_ID_CIRRUS_5434_8	0x00a8
+#define PCI_DEVICE_ID_CIRRUS_5436	0x00ac
+#define PCI_DEVICE_ID_CIRRUS_5446	0x00b8
+#define PCI_DEVICE_ID_CIRRUS_5480	0x00bc
+#define PCI_DEVICE_ID_CIRRUS_5464	0x00d4
+#define PCI_DEVICE_ID_CIRRUS_5465	0x00d6
+#define PCI_DEVICE_ID_CIRRUS_6729	0x1100
+#define PCI_DEVICE_ID_CIRRUS_6832	0x1110
+#define PCI_DEVICE_ID_CIRRUS_7542	0x1200
+#define PCI_DEVICE_ID_CIRRUS_7543	0x1202
+#define PCI_DEVICE_ID_CIRRUS_7541	0x1204
+
+#define PCI_VENDOR_ID_IBM		0x1014
+#define PCI_DEVICE_ID_IBM_FIRE_CORAL	0x000a
+#define PCI_DEVICE_ID_IBM_TR		0x0018
+#define PCI_DEVICE_ID_IBM_82G2675	0x001d
+#define PCI_DEVICE_ID_IBM_MCA		0x0020
+#define PCI_DEVICE_ID_IBM_82351		0x0022
+#define PCI_DEVICE_ID_IBM_SERVERAID	0x002e
+#define PCI_DEVICE_ID_IBM_MPEG2		0x007d
+
+#define PCI_VENDOR_ID_WD		0x101c
+#define PCI_DEVICE_ID_WD_7197		0x3296
+
+#define PCI_VENDOR_ID_AMD		0x1022
+#define PCI_DEVICE_ID_AMD_LANCE		0x2000
+#define PCI_DEVICE_ID_AMD_SCSI		0x2020
+
+#define PCI_VENDOR_ID_TRIDENT		0x1023
+#define PCI_DEVICE_ID_TRIDENT_9397	0x9397
+#define PCI_DEVICE_ID_TRIDENT_9420	0x9420
+#define PCI_DEVICE_ID_TRIDENT_9440	0x9440
+#define PCI_DEVICE_ID_TRIDENT_9660	0x9660
+#define PCI_DEVICE_ID_TRIDENT_9750	0x9750
+
+#define PCI_VENDOR_ID_AI		0x1025
+#define PCI_DEVICE_ID_AI_M1435		0x1435
+
+#define PCI_VENDOR_ID_MATROX		0x102B
+#define PCI_DEVICE_ID_MATROX_MGA_2	0x0518
+#define PCI_DEVICE_ID_MATROX_MIL	0x0519
+#define PCI_DEVICE_ID_MATROX_MYS	0x051A
+#define PCI_DEVICE_ID_MATROX_MIL_2	0x051b
+#define PCI_DEVICE_ID_MATROX_MIL_2_AGP	0x051f
+#define PCI_DEVICE_ID_MATROX_MGA_IMP	0x0d10
+
+#define PCI_VENDOR_ID_CT		0x102c
+#define PCI_DEVICE_ID_CT_65545		0x00d8
+#define PCI_DEVICE_ID_CT_65548		0x00dc
+#define PCI_DEVICE_ID_CT_65550		0x00e0
+#define PCI_DEVICE_ID_CT_65554		0x00e4
+
+#define PCI_VENDOR_ID_MIRO		0x1031
+#define PCI_DEVICE_ID_MIRO_36050	0x5601
+
+#define PCI_VENDOR_ID_NEC		0x1033
+#define PCI_DEVICE_ID_NEC_PCX2		0x0046
+
+#define PCI_VENDOR_ID_FD		0x1036
+#define PCI_DEVICE_ID_FD_36C70		0x0000
+
+#define PCI_VENDOR_ID_SI		0x1039
+#define PCI_DEVICE_ID_SI_6201		0x0001
+#define PCI_DEVICE_ID_SI_6202		0x0002
+#define PCI_DEVICE_ID_SI_503		0x0008
+#define PCI_DEVICE_ID_SI_6205		0x0205
+#define PCI_DEVICE_ID_SI_501		0x0406
+#define PCI_DEVICE_ID_SI_496		0x0496
+#define PCI_DEVICE_ID_SI_601		0x0601
+#define PCI_DEVICE_ID_SI_5107		0x5107
+#define PCI_DEVICE_ID_SI_5511		0x5511
+#define PCI_DEVICE_ID_SI_5513		0x5513
+#define PCI_DEVICE_ID_SI_5571		0x5571
+#define PCI_DEVICE_ID_SI_5597		0x5597
+#define PCI_DEVICE_ID_SI_7001		0x7001
+
+#define PCI_VENDOR_ID_HP		0x103c
+#define PCI_DEVICE_ID_HP_J2585A		0x1030
+#define PCI_DEVICE_ID_HP_J2585B		0x1031
+
+#define PCI_VENDOR_ID_PCTECH		0x1042
+#define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
+#define PCI_DEVICE_ID_PCTECH_RZ1001	0x1001
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_0	0x3000
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_1	0x3010
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_IDE 0x3020
+
+#define PCI_VENDOR_ID_DPT               0x1044   
+#define PCI_DEVICE_ID_DPT               0xa400  
+
+#define PCI_VENDOR_ID_OPTI		0x1045
+#define PCI_DEVICE_ID_OPTI_92C178	0xc178
+#define PCI_DEVICE_ID_OPTI_82C557	0xc557
+#define PCI_DEVICE_ID_OPTI_82C558	0xc558
+#define PCI_DEVICE_ID_OPTI_82C621	0xc621
+#define PCI_DEVICE_ID_OPTI_82C700	0xc700
+#define PCI_DEVICE_ID_OPTI_82C701	0xc701
+#define PCI_DEVICE_ID_OPTI_82C814	0xc814
+#define PCI_DEVICE_ID_OPTI_82C822	0xc822
+#define PCI_DEVICE_ID_OPTI_82C825	0xd568
+
+#define PCI_VENDOR_ID_SGS		0x104a
+#define PCI_DEVICE_ID_SGS_2000		0x0008
+#define PCI_DEVICE_ID_SGS_1764		0x0009
+
+#define PCI_VENDOR_ID_BUSLOGIC		      0x104B
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC 0x0140
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER    0x1040
+#define PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT     0x8130
+
+#define PCI_VENDOR_ID_TI		0x104c
+#define PCI_DEVICE_ID_TI_TVP4010	0x3d04
+#define PCI_DEVICE_ID_TI_TVP4020	0x3d07
+#define PCI_DEVICE_ID_TI_PCI1130	0xac12
+#define PCI_DEVICE_ID_TI_PCI1131	0xac15
+#define PCI_DEVICE_ID_TI_PCI1250	0xac16
+
+#define PCI_VENDOR_ID_OAK		0x104e
+#define PCI_DEVICE_ID_OAK_OTI107	0x0107
+
+/* Winbond have two vendor IDs! See 0x10ad as well */
+#define PCI_VENDOR_ID_WINBOND2		0x1050
+#define PCI_DEVICE_ID_WINBOND2_89C940	0x0940
+
+#define PCI_VENDOR_ID_MOTOROLA		0x1057
+#define PCI_DEVICE_ID_MOTOROLA_MPC105	0x0001
+#define PCI_DEVICE_ID_MOTOROLA_MPC106	0x0002
+#define PCI_DEVICE_ID_MOTOROLA_RAVEN	0x4801
+
+#define PCI_VENDOR_ID_PROMISE		0x105a
+#define PCI_DEVICE_ID_PROMISE_20246	0x4d33
+#define PCI_DEVICE_ID_PROMISE_5300	0x5300
+
+#define PCI_VENDOR_ID_N9		0x105d
+#define PCI_DEVICE_ID_N9_I128		0x2309
+#define PCI_DEVICE_ID_N9_I128_2		0x2339
+
+#define PCI_VENDOR_ID_UMC		0x1060
+#define PCI_DEVICE_ID_UMC_UM8673F	0x0101
+#define PCI_DEVICE_ID_UMC_UM8891A	0x0891
+#define PCI_DEVICE_ID_UMC_UM8886BF	0x673a
+#define PCI_DEVICE_ID_UMC_UM8886A	0x886a
+#define PCI_DEVICE_ID_UMC_UM8881F	0x8881
+#define PCI_DEVICE_ID_UMC_UM8886F	0x8886
+#define PCI_DEVICE_ID_UMC_UM9017F	0x9017
+#define PCI_DEVICE_ID_UMC_UM8886N	0xe886
+#define PCI_DEVICE_ID_UMC_UM8891N	0xe891
+
+#define PCI_VENDOR_ID_X			0x1061
+#define PCI_DEVICE_ID_X_AGX016		0x0001
+
+#define PCI_VENDOR_ID_PICOP		0x1066
+#define PCI_DEVICE_ID_PICOP_PT86C52X	0x0001
+
+#define PCI_VENDOR_ID_APPLE		0x106b
+#define PCI_DEVICE_ID_APPLE_BANDIT	0x0001
+#define PCI_DEVICE_ID_APPLE_GC		0x0002
+#define PCI_DEVICE_ID_APPLE_HYDRA	0x000e
+
+#define PCI_VENDOR_ID_NEXGEN		0x1074
+#define PCI_DEVICE_ID_NEXGEN_82C501	0x4e78
+
+#define PCI_VENDOR_ID_QLOGIC		0x1077
+#define PCI_DEVICE_ID_QLOGIC_ISP1020	0x1020
+#define PCI_DEVICE_ID_QLOGIC_ISP1022	0x1022
+
+#define PCI_VENDOR_ID_CYRIX		0x1078
+#define PCI_DEVICE_ID_CYRIX_5510	0x0000
+#define PCI_DEVICE_ID_CYRIX_PCI_MASTER	0x0001
+#define PCI_DEVICE_ID_CYRIX_5520	0x0002
+#define PCI_DEVICE_ID_CYRIX_5530_LEGACY	0x0100
+#define PCI_DEVICE_ID_CYRIX_5530_SMI	0x0101
+#define PCI_DEVICE_ID_CYRIX_5530_IDE	0x0102
+#define PCI_DEVICE_ID_CYRIX_5530_AUDIO	0x0103
+#define PCI_DEVICE_ID_CYRIX_5530_VIDEO	0x0104
+
+#define PCI_VENDOR_ID_LEADTEK		0x107d
+#define PCI_DEVICE_ID_LEADTEK_805	0x0000
+
+#define PCI_VENDOR_ID_CONTAQ		0x1080
+#define PCI_DEVICE_ID_CONTAQ_82C599	0x0600
+#define PCI_DEVICE_ID_CONTAQ_82C693	0xC693
+
+#define PCI_VENDOR_ID_FOREX		0x1083
+
+#define PCI_VENDOR_ID_OLICOM		0x108d
+#define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
+#define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
+#define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
+#define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
+#define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
+#define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
+
+#define PCI_VENDOR_ID_SUN		0x108e
+#define PCI_DEVICE_ID_SUN_EBUS		0x1000
+#define PCI_DEVICE_ID_SUN_HAPPYMEAL	0x1001
+#define PCI_DEVICE_ID_SUN_SIMBA		0x5000
+#define PCI_DEVICE_ID_SUN_PBM		0x8000
+#define PCI_DEVICE_ID_SUN_SABRE		0xa000
+
+#define PCI_VENDOR_ID_CMD		0x1095
+#define PCI_DEVICE_ID_CMD_640		0x0640
+#define PCI_DEVICE_ID_CMD_643		0x0643
+#define PCI_DEVICE_ID_CMD_646		0x0646
+#define PCI_DEVICE_ID_CMD_670		0x0670
+
+#define PCI_VENDOR_ID_VISION		0x1098
+#define PCI_DEVICE_ID_VISION_QD8500	0x0001
+#define PCI_DEVICE_ID_VISION_QD8580	0x0002
+
+#define PCI_VENDOR_ID_BROOKTREE		0x109e
+#define PCI_DEVICE_ID_BROOKTREE_848	0x0350
+#define PCI_DEVICE_ID_BROOKTREE_849A	0x0351
+#define PCI_DEVICE_ID_BROOKTREE_8474	0x8474
+
+#define PCI_VENDOR_ID_SIERRA		0x10a8
+#define PCI_DEVICE_ID_SIERRA_STB	0x0000
+
+#define PCI_VENDOR_ID_ACC		0x10aa
+#define PCI_DEVICE_ID_ACC_2056		0x0000
+
+#define PCI_VENDOR_ID_WINBOND		0x10ad
+#define PCI_DEVICE_ID_WINBOND_83769	0x0001
+#define PCI_DEVICE_ID_WINBOND_82C105	0x0105
+#define PCI_DEVICE_ID_WINBOND_83C553	0x0565
+
+#define PCI_VENDOR_ID_DATABOOK		0x10b3
+#define PCI_DEVICE_ID_DATABOOK_87144	0xb106
+
+#define PCI_VENDOR_ID_PLX		0x10b5
+#define PCI_DEVICE_ID_PLX_9080		0x9080
+
+#define PCI_VENDOR_ID_3COM		0x10b7
+#define PCI_DEVICE_ID_3COM_3C590	0x5900
+#define PCI_DEVICE_ID_3COM_3C595TX	0x5950
+#define PCI_DEVICE_ID_3COM_3C595T4	0x5951
+#define PCI_DEVICE_ID_3COM_3C595MII	0x5952
+#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
+#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
+#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
+
+#define PCI_VENDOR_ID_SMC		0x10b8
+#define PCI_DEVICE_ID_SMC_EPIC100	0x0005
+
+#define PCI_VENDOR_ID_AL		0x10b9
+#define PCI_DEVICE_ID_AL_M1445		0x1445
+#define PCI_DEVICE_ID_AL_M1449		0x1449
+#define PCI_DEVICE_ID_AL_M1451		0x1451
+#define PCI_DEVICE_ID_AL_M1461		0x1461
+#define PCI_DEVICE_ID_AL_M1489		0x1489
+#define PCI_DEVICE_ID_AL_M1511		0x1511
+#define PCI_DEVICE_ID_AL_M1513		0x1513
+#define PCI_DEVICE_ID_AL_M1521		0x1521
+#define PCI_DEVICE_ID_AL_M1523		0x1523
+#define PCI_DEVICE_ID_AL_M1531		0x1531
+#define PCI_DEVICE_ID_AL_M1533		0x1533
+#define PCI_DEVICE_ID_AL_M3307		0x3307
+#define PCI_DEVICE_ID_AL_M4803		0x5215
+#define PCI_DEVICE_ID_AL_M5219		0x5219
+#define PCI_DEVICE_ID_AL_M5229		0x5229
+#define PCI_DEVICE_ID_AL_M5237		0x5237
+
+#define PCI_VENDOR_ID_MITSUBISHI	0x10ba
+
+#define PCI_VENDOR_ID_SURECOM		0x10bd
+#define PCI_DEVICE_ID_SURECOM_NE34	0x0e34
+
+#define PCI_VENDOR_ID_NEOMAGIC          0x10c8
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2070 0x0001
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128V 0x0002
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZV 0x0003
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2160 0x0004
+
+#define PCI_VENDOR_ID_ASP		0x10cd
+#define PCI_DEVICE_ID_ASP_ABP940	0x1200
+#define PCI_DEVICE_ID_ASP_ABP940U	0x1300
+#define PCI_DEVICE_ID_ASP_ABP940UW	0x2300
+
+#define PCI_VENDOR_ID_CERN		0x10dc
+#define PCI_DEVICE_ID_CERN_SPSB_PMC	0x0001
+#define PCI_DEVICE_ID_CERN_SPSB_PCI	0x0002
+#define PCI_DEVICE_ID_CERN_HIPPI_DST	0x0021
+#define PCI_DEVICE_ID_CERN_HIPPI_SRC	0x0022
+
+#define PCI_VENDOR_ID_NVIDIA		0x10de
+
+#define PCI_VENDOR_ID_IMS		0x10e0
+#define PCI_DEVICE_ID_IMS_8849		0x8849
+
+#define PCI_VENDOR_ID_TEKRAM2		0x10e1
+#define PCI_DEVICE_ID_TEKRAM2_690c	0x690c
+
+#define PCI_VENDOR_ID_TUNDRA		0x10e3
+#define PCI_DEVICE_ID_TUNDRA_CA91C042	0x0000
+
+#define PCI_VENDOR_ID_AMCC		0x10e8
+#define PCI_DEVICE_ID_AMCC_MYRINET	0x8043
+#define PCI_DEVICE_ID_AMCC_S5933	0x807d
+#define PCI_DEVICE_ID_AMCC_S5933_HEPC3	0x809c
+
+#define PCI_VENDOR_ID_INTERG		0x10ea
+#define PCI_DEVICE_ID_INTERG_1680	0x1680
+#define PCI_DEVICE_ID_INTERG_1682	0x1682
+
+#define PCI_VENDOR_ID_REALTEK		0x10ec
+#define PCI_DEVICE_ID_REALTEK_8029	0x8029
+#define PCI_DEVICE_ID_REALTEK_8129	0x8129
+
+#define PCI_VENDOR_ID_TRUEVISION	0x10fa
+#define PCI_DEVICE_ID_TRUEVISION_T1000	0x000c
+
+#define PCI_VENDOR_ID_INIT		0x1101
+#define PCI_DEVICE_ID_INIT_320P		0x9100
+#define PCI_DEVICE_ID_INIT_360P		0x9500
+
+#define PCI_VENDOR_ID_VIA		0x1106
+#define PCI_DEVICE_ID_VIA_82C505	0x0505
+#define PCI_DEVICE_ID_VIA_82C561	0x0561
+#define PCI_DEVICE_ID_VIA_82C586_1	0x0571
+#define PCI_DEVICE_ID_VIA_82C576	0x0576
+#define PCI_DEVICE_ID_VIA_82C585	0x0585
+#define PCI_DEVICE_ID_VIA_82C586_0	0x0586
+#define PCI_DEVICE_ID_VIA_82C595	0x0595
+#define PCI_DEVICE_ID_VIA_82C597_0	0x0597
+#define PCI_DEVICE_ID_VIA_82C926	0x0926
+#define PCI_DEVICE_ID_VIA_82C416	0x1571
+#define PCI_DEVICE_ID_VIA_82C595_97	0x1595
+#define PCI_DEVICE_ID_VIA_82C586_2	0x3038
+#define PCI_DEVICE_ID_VIA_82C586_3	0x3040
+#define PCI_DEVICE_ID_VIA_82C597_1	0x8597
+
+#define PCI_VENDOR_ID_VORTEX		0x1119
+#define PCI_DEVICE_ID_VORTEX_GDT60x0	0x0000
+#define PCI_DEVICE_ID_VORTEX_GDT6000B	0x0001
+#define PCI_DEVICE_ID_VORTEX_GDT6x10	0x0002
+#define PCI_DEVICE_ID_VORTEX_GDT6x20	0x0003
+#define PCI_DEVICE_ID_VORTEX_GDT6530	0x0004
+#define PCI_DEVICE_ID_VORTEX_GDT6550	0x0005
+#define PCI_DEVICE_ID_VORTEX_GDT6x17	0x0006
+#define PCI_DEVICE_ID_VORTEX_GDT6x27	0x0007
+#define PCI_DEVICE_ID_VORTEX_GDT6537	0x0008
+#define PCI_DEVICE_ID_VORTEX_GDT6557	0x0009
+#define PCI_DEVICE_ID_VORTEX_GDT6x15	0x000a
+#define PCI_DEVICE_ID_VORTEX_GDT6x25	0x000b
+#define PCI_DEVICE_ID_VORTEX_GDT6535	0x000c
+#define PCI_DEVICE_ID_VORTEX_GDT6555	0x000d
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP	0x0100
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP	0x0101
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP	0x0102
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP	0x0103
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP	0x0104
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP	0x0105
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP1	0x0110
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP1	0x0111
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP1	0x0112
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP1	0x0113
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP1	0x0114
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP1	0x0115
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP2	0x0120
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP2	0x0121
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP2	0x0122
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP2	0x0123
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP2	0x0124
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP2	0x0125
+
+#define PCI_VENDOR_ID_EF		0x111a
+#define PCI_DEVICE_ID_EF_ATM_FPGA	0x0000
+#define PCI_DEVICE_ID_EF_ATM_ASIC	0x0002
+
+#define PCI_VENDOR_ID_FORE		0x1127
+#define PCI_DEVICE_ID_FORE_PCA200PC	0x0210
+#define PCI_DEVICE_ID_FORE_PCA200E	0x0300
+
+#define PCI_VENDOR_ID_IMAGINGTECH	0x112f
+#define PCI_DEVICE_ID_IMAGINGTECH_ICPCI	0x0000
+
+#define PCI_VENDOR_ID_PHILIPS		0x1131
+#define PCI_DEVICE_ID_PHILIPS_SAA7146	0x7146
+
+#define PCI_VENDOR_ID_CYCLONE		0x113c
+#define PCI_DEVICE_ID_CYCLONE_SDK	0x0001
+
+#define PCI_VENDOR_ID_ALLIANCE		0x1142
+#define PCI_DEVICE_ID_ALLIANCE_PROMOTIO	0x3210
+#define PCI_DEVICE_ID_ALLIANCE_PROVIDEO	0x6422
+#define PCI_DEVICE_ID_ALLIANCE_AT24	0x6424
+#define PCI_DEVICE_ID_ALLIANCE_AT3D	0x643d
+
+#define PCI_VENDOR_ID_VMIC		0x114a
+#define PCI_DEVICE_ID_VMIC_VME		0x7587
+
+#define PCI_VENDOR_ID_DIGI		0x114f
+#define PCI_DEVICE_ID_DIGI_EPC		0x0002
+#define PCI_DEVICE_ID_DIGI_RIGHTSWITCH	0x0003
+#define PCI_DEVICE_ID_DIGI_XEM		0x0004
+#define PCI_DEVICE_ID_DIGI_XR		0x0005
+#define PCI_DEVICE_ID_DIGI_CX		0x0006
+#define PCI_DEVICE_ID_DIGI_XRJ		0x0009
+#define PCI_DEVICE_ID_DIGI_EPCJ		0x000a
+
+#define PCI_VENDOR_ID_MUTECH		0x1159
+#define PCI_DEVICE_ID_MUTECH_MV1000	0x0001
+
+#define PCI_VENDOR_ID_RENDITION		0x1163
+#define PCI_DEVICE_ID_RENDITION_VERITE	0x0001
+#define PCI_DEVICE_ID_RENDITION_VERITE2100 0x2000
+
+#define PCI_VENDOR_ID_TOSHIBA		0x1179
+#define PCI_DEVICE_ID_TOSHIBA_601	0x0601
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC95	0x060a
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC97	0x060f
+
+#define PCI_VENDOR_ID_RICOH		0x1180
+#define PCI_DEVICE_ID_RICOH_RL5C466	0x0466
+
+#define PCI_VENDOR_ID_ARTOP		0x1191
+#define PCI_DEVICE_ID_ARTOP_ATP850UF	0x0005
+
+#define PCI_VENDOR_ID_ZEITNET		0x1193
+#define PCI_DEVICE_ID_ZEITNET_1221	0x0001
+#define PCI_DEVICE_ID_ZEITNET_1225	0x0002
+
+#define PCI_VENDOR_ID_OMEGA		0x119b
+#define PCI_DEVICE_ID_OMEGA_82C092G	0x1221
+
+#define PCI_VENDOR_ID_LITEON		0x11ad
+#define PCI_DEVICE_ID_LITEON_LNE100TX	0x0002
+
+#define PCI_VENDOR_ID_NP		0x11bc
+#define PCI_DEVICE_ID_NP_PCI_FDDI	0x0001
+
+#define PCI_VENDOR_ID_ATT		0x11c1
+#define PCI_DEVICE_ID_ATT_L56XMF	0x0440
+
+#define PCI_VENDOR_ID_SPECIALIX		0x11cb
+#define PCI_DEVICE_ID_SPECIALIX_XIO	0x4000
+#define PCI_DEVICE_ID_SPECIALIX_RIO	0x8000
+
+#define PCI_VENDOR_ID_AURAVISION	0x11d1
+#define PCI_DEVICE_ID_AURAVISION_VXP524	0x01f7
+
+#define PCI_VENDOR_ID_IKON		0x11d5
+#define PCI_DEVICE_ID_IKON_10115	0x0115
+#define PCI_DEVICE_ID_IKON_10117	0x0117
+
+#define PCI_VENDOR_ID_ZORAN		0x11de
+#define PCI_DEVICE_ID_ZORAN_36057	0x6057
+#define PCI_DEVICE_ID_ZORAN_36120	0x6120
+
+#define PCI_VENDOR_ID_COMPEX		0x11f6
+#define PCI_DEVICE_ID_COMPEX_ENET100VG4	0x0112
+#define PCI_DEVICE_ID_COMPEX_RL2000	0x1401
+
+#define PCI_VENDOR_ID_RP               0x11fe
+#define PCI_DEVICE_ID_RP8OCTA          0x0001
+#define PCI_DEVICE_ID_RP8INTF          0x0002
+#define PCI_DEVICE_ID_RP16INTF         0x0003
+#define PCI_DEVICE_ID_RP32INTF         0x0004
+
+#define PCI_VENDOR_ID_CYCLADES		0x120e
+#define PCI_DEVICE_ID_CYCLOM_Y_Lo	0x0100
+#define PCI_DEVICE_ID_CYCLOM_Y_Hi	0x0101
+#define PCI_DEVICE_ID_CYCLOM_Z_Lo	0x0200
+#define PCI_DEVICE_ID_CYCLOM_Z_Hi	0x0201
+
+#define PCI_VENDOR_ID_ESSENTIAL		0x120f
+#define PCI_DEVICE_ID_ROADRUNNER	0x0001
+
+#define PCI_VENDOR_ID_O2		0x1217
+#define PCI_DEVICE_ID_O2_6832		0x6832
+
+#define PCI_VENDOR_ID_3DFX		0x121a
+#define PCI_DEVICE_ID_3DFX_VOODOO	0x0001
+#define PCI_DEVICE_ID_3DFX_VOODOO2	0x0002
+
+#define PCI_VENDOR_ID_SIGMADES		0x1236
+#define PCI_DEVICE_ID_SIGMADES_6425	0x6401
+
+#define PCI_VENDOR_ID_STALLION		0x124d
+#define PCI_DEVICE_ID_STALLION_ECHPCI832 0x0000
+#define PCI_DEVICE_ID_STALLION_ECHPCI864 0x0002
+#define PCI_DEVICE_ID_STALLION_EIOPCI	0x0003
+
+#define PCI_VENDOR_ID_OPTIBASE		0x1255
+#define PCI_DEVICE_ID_OPTIBASE_FORGE	0x1110
+#define PCI_DEVICE_ID_OPTIBASE_FUSION	0x1210
+#define PCI_DEVICE_ID_OPTIBASE_VPLEX	0x2110
+#define PCI_DEVICE_ID_OPTIBASE_VPLEXCC	0x2120
+#define PCI_DEVICE_ID_OPTIBASE_VQUEST	0x2130
+
+#define PCI_VENDOR_ID_ENSONIQ		0x1274
+#define PCI_DEVICE_ID_ENSONIQ_AUDIOPCI	0x5000
+
+#define PCI_VENDOR_ID_PICTUREL		0x12c5
+#define PCI_DEVICE_ID_PICTUREL_PCIVST	0x0081
+
+#define PCI_VENDOR_ID_NVIDIA_SGS	0x12d2
+#define PCI_DEVICE_ID_NVIDIA_SGS_RIVA128 0x0018
+
+#define PCI_VENDOR_ID_SYMPHONY		0x1c1c
+#define PCI_DEVICE_ID_SYMPHONY_101	0x0001
+
+#define PCI_VENDOR_ID_TEKRAM		0x1de1
+#define PCI_DEVICE_ID_TEKRAM_DC290	0xdc29
+
+#define PCI_VENDOR_ID_3DLABS		0x3d3d
+#define PCI_DEVICE_ID_3DLABS_300SX	0x0001
+#define PCI_DEVICE_ID_3DLABS_500TX	0x0002
+#define PCI_DEVICE_ID_3DLABS_DELTA	0x0003
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA	0x0004
+
+#define PCI_VENDOR_ID_AVANCE		0x4005
+#define PCI_DEVICE_ID_AVANCE_ALG2064	0x2064
+#define PCI_DEVICE_ID_AVANCE_2302	0x2302
+
+#define PCI_VENDOR_ID_NETVIN		0x4a14
+#define PCI_DEVICE_ID_NETVIN_NV5000SC	0x5000
+
+#define PCI_VENDOR_ID_S3		0x5333
+#define PCI_DEVICE_ID_S3_PLATO_PXS	0x0551
+#define PCI_DEVICE_ID_S3_ViRGE		0x5631
+#define PCI_DEVICE_ID_S3_TRIO		0x8811
+#define PCI_DEVICE_ID_S3_AURORA64VP	0x8812
+#define PCI_DEVICE_ID_S3_TRIO64UVP	0x8814
+#define PCI_DEVICE_ID_S3_ViRGE_VX	0x883d
+#define PCI_DEVICE_ID_S3_868		0x8880
+#define PCI_DEVICE_ID_S3_928		0x88b0
+#define PCI_DEVICE_ID_S3_864_1		0x88c0
+#define PCI_DEVICE_ID_S3_864_2		0x88c1
+#define PCI_DEVICE_ID_S3_964_1		0x88d0
+#define PCI_DEVICE_ID_S3_964_2		0x88d1
+#define PCI_DEVICE_ID_S3_968		0x88f0
+#define PCI_DEVICE_ID_S3_TRIO64V2	0x8901
+#define PCI_DEVICE_ID_S3_PLATO_PXG	0x8902
+#define PCI_DEVICE_ID_S3_ViRGE_DXGX	0x8a01
+#define PCI_DEVICE_ID_S3_ViRGE_GX2	0x8a10
+#define PCI_DEVICE_ID_S3_ViRGE_MX	0x8c01
+#define PCI_DEVICE_ID_S3_ViRGE_MXP	0x8c02
+#define PCI_DEVICE_ID_S3_ViRGE_MXPMV	0x8c03
+#define PCI_DEVICE_ID_S3_SONICVIBES	0xca00
+
+#define PCI_VENDOR_ID_INTEL		0x8086
+#define PCI_DEVICE_ID_INTEL_82375	0x0482
+#define PCI_DEVICE_ID_INTEL_82424	0x0483
+#define PCI_DEVICE_ID_INTEL_82378	0x0484
+#define PCI_DEVICE_ID_INTEL_82430	0x0486
+#define PCI_DEVICE_ID_INTEL_82434	0x04a3
+#define PCI_DEVICE_ID_INTEL_82092AA_0	0x1221
+#define PCI_DEVICE_ID_INTEL_82092AA_1	0x1222
+#define PCI_DEVICE_ID_INTEL_7116	0x1223
+#define PCI_DEVICE_ID_INTEL_82596	0x1226
+#define PCI_DEVICE_ID_INTEL_82865	0x1227
+#define PCI_DEVICE_ID_INTEL_82557	0x1229
+#define PCI_DEVICE_ID_INTEL_82437	0x122d
+#define PCI_DEVICE_ID_INTEL_82371FB_0	0x122e
+#define PCI_DEVICE_ID_INTEL_82371FB_1	0x1230
+#define PCI_DEVICE_ID_INTEL_82371MX	0x1234
+#define PCI_DEVICE_ID_INTEL_82437MX	0x1235
+#define PCI_DEVICE_ID_INTEL_82441	0x1237
+#define PCI_DEVICE_ID_INTEL_82439	0x1250
+#define PCI_DEVICE_ID_INTEL_82371SB_0	0x7000
+#define PCI_DEVICE_ID_INTEL_82371SB_1	0x7010
+#define PCI_DEVICE_ID_INTEL_82371SB_2	0x7020
+#define PCI_DEVICE_ID_INTEL_82437VX	0x7030
+#define PCI_DEVICE_ID_INTEL_82439TX	0x7100
+#define PCI_DEVICE_ID_INTEL_82371AB_0	0x7110
+#define PCI_DEVICE_ID_INTEL_82371AB	0x7111
+#define PCI_DEVICE_ID_INTEL_82371AB_2	0x7112
+#define PCI_DEVICE_ID_INTEL_82371AB_3	0x7113
+#define PCI_DEVICE_ID_INTEL_82443LX_0	0x7180
+#define PCI_DEVICE_ID_INTEL_82443LX_1	0x7181
+#define PCI_DEVICE_ID_INTEL_P6		0x84c4
+#define PCI_DEVICE_ID_INTEL_82450GX	0x84c5
+
+#define PCI_VENDOR_ID_KTI		0x8e2e
+#define PCI_DEVICE_ID_KTI_ET32P2	0x3000
+
+#define PCI_VENDOR_ID_ADAPTEC		0x9004
+#define PCI_DEVICE_ID_ADAPTEC_7850	0x5078
+#define PCI_DEVICE_ID_ADAPTEC_7855	0x5578
+#define PCI_DEVICE_ID_ADAPTEC_5800	0x5800
+#define PCI_DEVICE_ID_ADAPTEC_7860	0x6078
+#define PCI_DEVICE_ID_ADAPTEC_7861	0x6178
+#define PCI_DEVICE_ID_ADAPTEC_7870	0x7078
+#define PCI_DEVICE_ID_ADAPTEC_7871	0x7178
+#define PCI_DEVICE_ID_ADAPTEC_7872	0x7278
+#define PCI_DEVICE_ID_ADAPTEC_7873	0x7378
+#define PCI_DEVICE_ID_ADAPTEC_7874	0x7478
+#define PCI_DEVICE_ID_ADAPTEC_7895	0x7895
+#define PCI_DEVICE_ID_ADAPTEC_7880	0x8078
+#define PCI_DEVICE_ID_ADAPTEC_7881	0x8178
+#define PCI_DEVICE_ID_ADAPTEC_7882	0x8278
+#define PCI_DEVICE_ID_ADAPTEC_7883	0x8378
+#define PCI_DEVICE_ID_ADAPTEC_7884	0x8478
+
+#define PCI_VENDOR_ID_ATRONICS		0x907f
+#define PCI_DEVICE_ID_ATRONICS_2015	0x2015
+
+#define PCI_VENDOR_ID_HOLTEK		0x9412
+#define PCI_DEVICE_ID_HOLTEK_6565	0x6565
+
+#define PCI_VENDOR_ID_ARK		0xedd8
+#define PCI_DEVICE_ID_ARK_STING		0xa091
+#define PCI_DEVICE_ID_ARK_STINGARK	0xa099
+#define PCI_DEVICE_ID_ARK_2000MT	0xa0a1
+
+/*
+ * The PCI interface treats multi-function devices as independent
+ * devices.  The slot/function address of each device is encoded
+ * in a single byte as follows:
+ *
+ *	7:3 = slot
+ *	2:0 = function
+ */
+#define PCI_DEVFN(slot,func)	((((slot) & 0x1f) << 3) | ((func) & 0x07))
+#define PCI_SLOT(devfn)		(((devfn) >> 3) & 0x1f)
+#define PCI_FUNC(devfn)		((devfn) & 0x07)
+
+#endif /* _kgi_pci_pci_h */
diff -x CVS -x .svn -aurpN sys/dev/kgi/system.h sys/dev/kgi/system.h
--- sys/dev/kgi/system.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/system.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,171 @@
+/*-
+ * Copyright (C) 2003-2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI system layer defintion
+ */
+
+#ifndef	_kgi_system_h
+#define	_kgi_system_h
+
+#define EXPORT_SYMBOL(symbol)
+
+#ifdef _KERNEL
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/linker.h>
+#include <sys/module.h>
+#include <sys/kobj.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/condvar.h>
+#include <sys/proc.h>
+#include <sys/kthread.h>
+#include <sys/kdb.h>
+
+typedef struct {
+	struct mtx mutex;
+	struct cv  var;
+} kgi_mutex_t;
+
+typedef void *wait_queue_head_t;
+
+#else /* _KERNEL */
+
+#include <unistd.h>
+#include <stdint.h>
+
+#endif /* ! _KERNEL */
+
+#include <dev/kgi/compiler.h>
+
+#define MODULE_PARM(var,str)
+#define KERN_ERR "kernel:"
+
+#include <dev/kgi/types.h>
+
+#ifdef KGI_SYS_NEED_USER
+
+extern __kgi_u32_t kgi_copy_to_user(void *to, const void *from, __kgi_u32_t n);
+extern __kgi_u32_t kgi_copy_from_user(void *to, const void *from, __kgi_u32_t n);
+
+#define put_user(x,ptr) kgi_copy_to_user(&x, ptr, sizeof(*ptr))
+#define get_user(x,ptr) kgi_copy_from_user(&x, ptr, sizeof(*ptr))
+
+#endif /* KGI_SYS_NEED_USER */
+
+#ifdef KGI_SYS_NEED_VM
+
+#include <vm/vm.h>
+#include <vm/vm_param.h>
+#include <vm/vm_page.h>
+#include <vm/pmap.h>
+
+#include <vm/kgi_pager.h>
+
+#define virt_to_phys vtophys
+#define virt_to_bus vtophys
+
+extern __kgi_virt_addr_t kgi_map_buffer(__kgi_phys_addr_t paddr, __kgi_size_t size);
+extern void kgi_unmap_buffer(__kgi_virt_addr_t vaddr, __kgi_size_t size);
+
+#endif /* KGI_SYS_NEED_VM */
+
+#ifdef KGI_SYS_NEED_IO
+
+#define	__KGI_SYS_IO_HAS_PCICFG
+#define	__KGI_SYS_IO_HAS_BUS
+#define	__KGI_SYS_IO_HAS_IO
+#define	__KGI_SYS_IO_HAS_MEM
+#define	__KGI_SYS_IO_HAS_IRQ
+
+/* 
+ * XXX I don't think all this stuff has to be there
+ * XXX I'd rather put it in the system specific directory of graphic drivers.
+ */
+
+#include <sys/bus.h>
+#include <dev/kgi/io.h>
+#include <dev/kgi/pci.h>
+#include <dev/kgi/i386-compiler.h>
+
+#endif /* KGI_SYS_NEED_IO */
+
+#ifdef KGI_SYS_NEED_ATOMIC
+
+#include <machine/atomic.h>
+
+typedef __kgi_u32_t kgi_atomic_t;
+
+#define kgi_atomic_set(p, v) (*p=v)
+#define kgi_atomic_read(p) (*p)
+
+extern kgi_atomic_t kgi_test_and_set_bit32(__kgi_u32_t b, volatile void *p);
+extern void kgi_clear_bit(int b, volatile void *p);
+extern void kgi_set_bit(int b, volatile void *p);
+extern int kgi_test_bit(int b, volatile void *p);
+extern int kgi_find_first_zero_bit(volatile void *p, int max);
+
+#endif /* KGI_SYS_NEED_ATOMIC */
+
+#define kgi_udelay(d) DELAY((int)d)
+#define kgi_nanosleep(x) kgi_udelay(2)
+
+#ifdef KGI_SYS_NEED_PROC
+
+#define kgi_wakeup(p) wakeup(p)
+extern struct proc *kgiproc;
+
+#endif /* KGI_SYS_NEED_PROC */
+
+#ifdef KGI_SYS_NEED_MALLOC
+
+#include <sys/malloc.h>
+
+MALLOC_DECLARE(M_KGI);
+
+extern void *kgi_kmalloc(__kgi_size_t size);
+extern void kgi_kfree(const void *ptr);
+extern void *kgi_cmalloc(__kgi_size_t size);
+extern void kgi_cfree(const void *ptr, __kgi_size_t size);
+
+#define kgim_alloc kgi_kmalloc
+#define kgim_free kgi_kfree
+
+#endif /* KGI_SYS_NEED_MALLOC */
+
+#ifdef KGI_SYS_NEED_MUTEX
+
+extern void kgi_mutex_init(kgi_mutex_t *mtx, const char *name);
+extern void kgi_mutex_done(kgi_mutex_t *mtx);
+
+#define kgi_mutex_lock(mtx) do { mtx_lock(&(mtx)->mutex); } while (0)
+#define kgi_mutex_unlock(mtx) do { mtx_unlock(&(mtx)->mutex); } while (0)
+#define kgi_mutex_assert(mtx,type) do { mtx_assert(&(mtx)->mutex, type); } while (0)
+
+extern void kgi_mutex_wait(kgi_mutex_t *mtx);
+extern void kgi_mutex_signal(kgi_mutex_t *mtx, int unblock_all /* TRUE or FALSE */);
+
+#define KGI_MUTEX_OWNED		MA_OWNED
+#define KGI_MUTEX_NOTOWNED	MA_NOTOWNED
+#define KGI_MUTEX_RECURSED	MA_RECURSED
+#define KGI_MUTEX_NOTRECURSED	MA_NOTRECURSED
+
+/* KGI Giant lock. */
+extern kgi_mutex_t kgi_lock;
+
+#endif /* KGI_SYS_NEED_MUTEX */
+
+#endif	/* #ifdef _kgi_system_h */
+
diff -x CVS -x .svn -aurpN sys/dev/kgi/types.h sys/dev/kgi/types.h
--- sys/dev/kgi/types.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgi/types.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,131 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2004 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included 
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI data type definitions
+ */
+
+#ifndef	_kgi_types_h
+#define	_kgi_types_h
+
+/* XXX to deleted */
+#ifdef	__STRICT_ANSI__
+#	define	signed
+#	define	const
+#endif
+
+typedef	int8_t		__kgi_s8_t;
+typedef	uint8_t		__kgi_u8_t;
+
+typedef	int16_t		__kgi_s16_t;
+typedef	uint16_t	__kgi_u16_t;
+
+typedef	int32_t		__kgi_s32_t;
+typedef	uint32_t	__kgi_u32_t;
+
+typedef	int64_t		__kgi_s64_t;
+typedef	uint64_t	__kgi_u64_t;
+
+typedef	int		__kgi_s_t;
+typedef	unsigned int	__kgi_u_t;
+
+typedef	char		__kgi_ascii_t;
+typedef	unsigned short	__kgi_unicode_t;
+typedef	unsigned int	__kgi_isochar_t;
+
+typedef int32_t		__kgi_error_t;
+
+typedef	vm_offset_t	__kgi_virt_addr_t;
+typedef vm_paddr_t	__kgi_phys_addr_t;
+typedef vm_paddr_t	__kgi_bus_addr_t;
+
+typedef ssize_t		__kgi_size_t;
+
+/*
+ * byte order conversions
+ *
+ * For 8bit (byte) types, byteorder conversion doesn't make sense,
+ * so only for 16,32 and 64 bit types conversion is defined.
+ */
+
+#define	HOST_BE		0
+#define	HOST_LE		1
+
+/* 
+ * XXX as this is i386/types.h, i386 optimized (inline) functions should
+ * XXX go here.
+ */
+extern __kgi_u16_t	__kgi_u16_swap(const __kgi_u16_t x);
+extern __kgi_s16_t	__kgi_s16_swap(const __kgi_s16_t x);
+
+extern __kgi_u32_t	__kgi_u32_swap(const __kgi_u32_t x);
+extern __kgi_s32_t	__kgi_s32_swap(const __kgi_s32_t x);
+
+extern __kgi_u64_t	__kgi_u64_swap(const __kgi_u64_t x);
+extern __kgi_s64_t	__kgi_s64_swap(const __kgi_s64_t x);
+
+extern __kgi_unicode_t __kgi_unicode_swap(const __kgi_unicode_t x);
+extern __kgi_isochar_t __kgi_isochar_swap(const __kgi_isochar_t x);
+
+typedef union
+{
+	__kgi_s8_t		priv_s8;
+	__kgi_u8_t		priv_u8;
+
+	__kgi_s16_t		priv_s16;
+	__kgi_u16_t		priv_u16;
+
+	__kgi_s32_t		priv_s32;
+	__kgi_u32_t		priv_u32;
+
+	__kgi_s64_t		priv_s64;
+	__kgi_u64_t		priv_u64;
+
+	__kgi_s_t		priv_s;
+	__kgi_u_t		priv_u;
+
+	__kgi_ascii_t		priv_ascii;
+	__kgi_unicode_t		priv_unicode;
+	__kgi_isochar_t		priv_isochar;
+
+	__kgi_virt_addr_t	priv_virt_addr;
+	__kgi_phys_addr_t	priv_phys_addr;
+	__kgi_bus_addr_t	priv_bus_addr;
+
+	__kgi_size_t		priv_size;
+
+	void			*priv_ptr;
+} __kgi_private_t;
+
+#define	KGI_SYS_DECLARE_INTEGRAL_TYPES(prefix)	\
+	typedef __kgi_u8_t		prefix ## _u8_t;	\
+	typedef	__kgi_s8_t		prefix ## _s8_t;	\
+	typedef	__kgi_u16_t		prefix ## _u16_t;	\
+	typedef	__kgi_s16_t		prefix ## _s16_t;	\
+	typedef	__kgi_u32_t		prefix ## _u32_t;	\
+	typedef	__kgi_s32_t		prefix ## _s32_t;	\
+	typedef	__kgi_u64_t		prefix ## _u64_t;	\
+	typedef	__kgi_s64_t		prefix ## _s64_t;	\
+	typedef	__kgi_u_t		prefix ## _u_t;		\
+	typedef	__kgi_s_t		prefix ## _s_t;		\
+	typedef	__kgi_error_t		prefix ## _error_t;	\
+	typedef __kgi_ascii_t		prefix ## _ascii_t;	\
+	typedef __kgi_unicode_t		prefix ## _unicode_t;	\
+	typedef __kgi_isochar_t		prefix ## _isochar_t;	\
+	typedef	__kgi_private_t		prefix ## _private_t;	\
+	typedef __kgi_virt_addr_t	prefix ## _virt_addr_t;	\
+	typedef __kgi_phys_addr_t	prefix ## _phys_addr_t;	\
+	typedef __kgi_bus_addr_t	prefix ## _bus_addr_t;	\
+	typedef __kgi_size_t		prefix ## _size_t;
+
+#endif	/* #ifdef _kgi_types_h */
diff -x CVS -x .svn -aurpN sys/dev/kgim/kgim.c sys/dev/kgim/kgim.c
--- sys/dev/kgim/kgim.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgim/kgim.c	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,722 @@
+/*-
+ * Copyright (C) 2001 Nicholas Souchu
+ * Copyright (C) 1995-2000 Steffen Seeger 
+ * Copyright (C) 1995-1997 Andreas Beck	
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * KGI kernel driver module environment.
+ */
+
+#include <dev/kgi/maintainers.h>
+#define	MAINTAINER	Nicholas_Souchu
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgim/module.h>
+
+kgi_u_t 
+kgim_attr_bits(const kgi_u8_t *bpa)
+{
+	kgi_u_t bits = 0;
+
+	if (bpa) {
+		while (*bpa) {
+			bits += *(bpa++);
+		}
+	}
+
+	return (bits);
+}
+
+/*
+ * Debugging output functions.
+ */
+#define	__KGIM_BUF_SIZE	1024
+
+#define KERN_NOTICE "kernel:"
+
+#include <machine/stdarg.h>
+
+void 
+kgim_ansi_debug(int level, const char *fmt, ...)
+{
+	char buf[__KGIM_BUF_SIZE];
+	va_list args;
+
+	va_start(args, fmt);
+		vsprintf(buf, fmt, args);
+	va_end(args);
+	printf("<%i>%s\n", level, buf);
+}
+
+void 
+kgim_ansi_error(const char *fmt, ...)
+{
+	char buf[__KGIM_BUF_SIZE];
+	va_list args;
+
+	va_start(args, fmt);
+		vsprintf(buf, fmt, args);
+	va_end(args);
+	printf("%s\n", buf);
+}
+
+void 
+kgim_gnu_debug(const char *file, int line, const char *func, int level,
+	const char *fmt, ...)
+{
+	char buf[__KGIM_BUF_SIZE];
+	va_list args;
+
+	va_start(args, fmt);
+		vsprintf(buf, fmt, args);
+	va_end(args);
+	printf("<%i>%s:%s:%i:D:%s\n", level, file, func, line, buf);
+}
+
+void 
+kgim_gnu_error(const char *file, int line, const char *func, 
+	const char *fmt, ...)
+{
+	char buf[__KGIM_BUF_SIZE];
+	va_list args;
+
+	va_start(args, fmt);
+		vsprintf(buf, fmt, args);
+	va_end(args);
+	printf(KERN_ERR "%s:%s:%i:E:%s\n", file, func, line, buf);
+}
+
+void 
+kgim_notice(const char *fmt, ...)
+{
+	char buf[__KGIM_BUF_SIZE];
+	va_list args;
+
+	va_start(args, fmt);
+		vsprintf(buf, fmt, args);
+	va_end(args);
+	printf(KERN_NOTICE "%s\n", buf);
+}
+
+/*
+ * memset(), memcpy(), memcmp() and strcpy()
+ */
+void 
+kgim_memset(void *p, kgi_u8_t val, kgi_size_t size)
+{
+
+	memset(p, val, size);
+}
+
+void 
+kgim_memcpy(void *dst, const void *src, kgi_size_t size)
+{
+
+	memcpy(dst, src, size);
+}
+
+kgi_s_t 
+kgim_memcmp(const void *s1, const void *s2, kgi_size_t size)
+{
+
+	return (memcmp(s1, s2, size));
+}
+
+kgi_s_t 
+kgim_strcmp(const kgi_u8_t *s1, const kgi_u8_t *s2)
+{
+
+	return (strcmp(s1, s2));
+}
+
+kgi_u8_t *
+kgim_strcpy(kgi_u8_t *dst, const kgi_u8_t *src)
+{
+
+	return (strcpy(dst, src));
+}
+
+kgi_u8_t *
+kgim_strncpy(kgi_u8_t *dst, const kgi_u8_t *src, kgi_size_t size)
+{
+
+	return (strncpy(dst, src, size));
+}
+
+/*
+ * kgim_display_t initialization/deinitalization.
+ */
+#define	KGIM_ALIGN(x)	(((x) + 7) & ~7)
+
+static kgi_error_t 
+kgim_display_command(kgi_display_t *kgi_dpy, kgi_u_t cmd, void *data)
+{
+	/*
+	 * kgim_display_t *kgim = (kgim_display_t *) kgi_dpy;
+	 * kgim_display_mode_t *kgim_mode = (kgim_display_mode_t *) dev_mode;
+	 */
+	KRN_ERROR("kgim_display_command(cmd = %d)", cmd);
+
+	return (-KGI_ERRNO(DRIVER, INVAL));
+}
+
+static kgi_error_t 
+kgim_display_check_mode(kgi_display_t *kgi_dpy,	kgi_timing_command_t cmd,
+	kgi_image_mode_t *img, kgi_u_t images, void *dev_mode, const kgi_resource_t
+	**r, kgi_u_t rsize)
+{
+	kgi_s_t cnt;
+	kgim_display_t *dpy = (kgim_display_t *) kgi_dpy;
+	kgim_display_mode_t *dpy_mode = dev_mode;
+
+	kgim_monitor_mode_t	*monitor_mode;
+	kgim_ramdac_mode_t	*dac_mode;
+	kgim_chipset_mode_t	*chipset_mode;
+	kgim_clock_mode_t	*clock_mode;
+
+	KRN_DEBUG(2, "kgim_display_check_mode()");
+
+	if (1 != images) {
+		KRN_ERROR("%i images not yet supported", images);
+		return (-KGI_ERRNO(DRIVER, NOSUP));
+	}
+
+	if (KGI_TC_PROPOSE == cmd) {
+		kgi_u_t i;
+
+		KRN_DEBUG(2, "KGI_TC_PROPOSE:");
+
+		kgim_memset(dpy_mode, 0, dpy->kgi.mode_size);
+
+		dev_mode = ((kgi_u8_t *) dev_mode) +
+				KGIM_ALIGN(sizeof(kgim_display_mode_t));
+
+		for (i = 0; i < __KGIM_MAX_NR_SUBSYSTEMS; i++) {
+			const kgim_meta_t *meta = dpy->subsystem[i].meta_lang;
+
+			if (meta && meta->mode_size) {
+				dpy_mode->subsystem_mode[i] = dev_mode;
+				dev_mode = ((kgi_u8_t *) dev_mode) +
+					KGIM_ALIGN(meta->mode_size);
+
+				KRN_DEBUG(2, "subsystem_mode %i @ %p", i,
+				dpy_mode->subsystem_mode[i]);
+			}
+		}
+
+		if (! img[0].fam) {
+			if (img[0].flags & KGI_IF_TEXT16) {
+				KRN_DEBUG(2, "Proposing default textmode");
+
+				img[0].fam = KGI_AM_TEXT;
+				kgim_strcpy(img[0].bpfa, (kgi_u8_t[]){4,4,8,0});
+
+			} else {
+				KRN_DEBUG(2, "Proposing default graphic mode");
+
+				img[0].fam = KGI_AM_COLOR_INDEX;
+				kgim_strcpy(img[0].bpfa, (kgi_u8_t[]){8,0});
+			}
+		}
+	}
+
+	chipset_mode	= dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_chipset];
+	dac_mode	= dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_ramdac];
+	clock_mode	= dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_clock];
+	monitor_mode	= dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_monitor];
+
+	if (KGI_TC_PROPOSE == cmd) {
+		KRN_DEBUG(2, "KGI_TC_PROPOSE(2):");
+
+		chipset_mode->crt	= monitor_mode;
+		dac_mode->crt		= monitor_mode;
+
+		img[0].out = &(monitor_mode->in);
+		KRN_DEBUG(2, "monitor_mode @ %p, dpm @ %p", monitor_mode,
+			&(monitor_mode->in));
+	}
+
+	KRN_DEBUG(3, "Getting ready to check mode against all subsystems....");
+
+	cnt = 10;
+	while (cnt-- && (KGI_TC_READY != cmd)) {
+		const kgim_meta_t *meta;
+
+		kgi_error_t error;
+
+#define	SUBSYSTEM_CHECK_MODE(sys)					\
+		meta = dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_lang;	\
+		error = (meta && meta->ModeCheck)			\
+			? meta->ModeCheck(				\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_data,\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_io,\
+				dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_##sys],\
+				cmd, img, images)			\
+			: KGI_EOK;					\
+		KRN_DEBUG(2, "system %i, io %p, mode %p, cmd %i, return %.8x", \
+			KGIM_SUBSYSTEM_##sys, 				\
+			dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_io,	\
+			dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_##sys],	\
+			cmd, error);
+
+		KRN_DEBUG(4, "Checking against clock...");
+		SUBSYSTEM_CHECK_MODE(clock)
+		if (error) {
+			KRN_ERROR("Clock check failed! (%.8x)", error);
+			return (error);
+		}
+
+		KRN_DEBUG(4, "Checking against ramdac...");
+		SUBSYSTEM_CHECK_MODE(ramdac)
+		if (error) {
+			KRN_ERROR("Ramdac check failed! (%.8x)", error);
+			return (error);
+		}
+
+		KRN_DEBUG(4, "Checking against chipset...");
+		SUBSYSTEM_CHECK_MODE(chipset)
+		if (error) {
+			KRN_ERROR("Chipset check failed! (%.8x)", error);
+			return error;
+		}
+
+		KRN_DEBUG(4, "Checking against clock(2)...");
+		SUBSYSTEM_CHECK_MODE(clock)
+		if (error) {
+			KRN_ERROR("Clock check 2 failed! (%.8x)", error);
+			return error;
+		}
+
+		KRN_DEBUG(4, "Checking against monitor...");
+		SUBSYSTEM_CHECK_MODE(monitor)
+
+		switch (error) {
+		case KGI_TC_LOWER:
+			KRN_DEBUG(2, "KGI_TC_LOWER:"); cmd = error; continue;
+		case KGI_TC_RAISE:
+			KRN_DEBUG(2, "KGI_TC_RAISE:"); cmd = error; continue;
+		case KGI_TC_CHECK:
+			KRN_DEBUG(2, "KGI_TC_CHECK:"); cmd = error; continue;
+		case KGI_TC_READY:
+			KRN_DEBUG(2, "KGI_TC_READY:"); cmd = error; continue;
+		default:
+			KRN_ERROR("Unknown command %.8x from monitor", error);
+			return (error);
+		}
+
+#undef	SUBSYSTEM_CHECK_MODE
+	}
+
+	if (cnt < 0) {
+		KRN_ERROR("Exceeded 10 tries for a good mode, bailing out....");
+		return (-EINVAL);
+	} else {
+		kgi_u_t index, subsys_index;
+		kgim_subsystem_type_t subsys;
+
+		KRN_DEBUG(4, "Setting up global resources and metadata "
+			"for %i subsystems", KGIM_LAST_SUBSYSTEM);
+		index = 0;
+		subsys = 0;
+		subsys_index = 0;
+		while (subsys < KGIM_LAST_SUBSYSTEM) {
+			const kgim_meta_t *meta;
+			void *meta_data, *meta_mode;
+			kgi_resource_t *resource;
+
+			if (rsize <= index) {
+				KRN_ERROR("rsize (%i) <= index (%i)",
+					rsize, index);
+				return (-ENOMEM);
+			}
+
+			meta = dpy->subsystem[subsys].meta_lang;
+			meta_data = dpy->subsystem[subsys].meta_data;
+			meta_mode = dpy_mode->subsystem_mode[subsys];
+
+			resource = (meta && meta->ModeResource)
+				? meta->ModeResource(meta_data, meta_mode,
+					img, images, subsys_index)
+				: NULL;
+
+			if (resource) {
+				KRN_DEBUG(2, "resource %i: %s io %p meta %p",
+					index, resource->name,
+					resource->meta_io, resource->meta);
+				r[index++] = resource;
+				subsys_index++;
+			} else {
+				subsys++;
+				subsys_index = 0;
+			}
+			continue;
+		}
+
+		KRN_DEBUG(4, "Setting up image resources and metadata "
+			"for %i subsystems", KGIM_LAST_SUBSYSTEM);
+		index = 0;
+		subsys = 0;
+		subsys_index = 0;
+		while (subsys < KGIM_LAST_SUBSYSTEM) {
+			const kgim_meta_t *meta;
+			void *meta_data, *meta_mode;
+			kgi_resource_t *resource;
+
+			if (__KGI_MAX_NR_IMAGE_RESOURCES <= index) {
+				KRN_ERROR("%i <= index",
+					__KGI_MAX_NR_IMAGE_RESOURCES);
+				return (-ENOMEM);
+			}
+
+			meta = dpy->subsystem[subsys].meta_lang;
+			meta_data = dpy->subsystem[subsys].meta_data;
+			meta_mode = dpy_mode->subsystem_mode[subsys];
+
+			resource = (meta && meta->ImageResource)
+				? meta->ImageResource(meta_data, meta_mode,
+					img, 0, subsys_index)
+				: NULL;
+
+			if (resource) {
+				KRN_DEBUG(2, "img resource %i: %s io %p meta %p",
+					index, resource->name,
+					resource->meta_io, resource->meta);
+				img[0].resource[index++] = resource;
+				subsys_index++;
+			} else {
+				subsys++;
+				subsys_index = 0;
+			}
+			continue;
+		}
+		return (KGI_EOK);
+	}
+}
+
+static void 
+kgim_display_set_mode(kgi_display_t *kgi_dpy, kgi_image_mode_t *img, kgi_u_t
+	images, void *dev_mode)
+{
+	kgim_display_t *dpy = (kgim_display_t *) kgi_dpy;
+	kgim_display_mode_t *dpy_mode = dev_mode;
+	const kgim_meta_t *meta;
+	
+	KRN_DEBUG(2, "kgim_display_set_mode()");
+
+#define	SUBSYSTEM_PREPARE_MODE(sys)					\
+		meta = dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_lang;	\
+		if (meta && meta->ModePrepare) {			\
+									\
+			KRN_DEBUG(3, "preparing " #sys);		\
+			meta->ModePrepare(				\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_data,\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_io,\
+				dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_##sys],\
+				img, images);				\
+		}
+
+		SUBSYSTEM_PREPARE_MODE(monitor)
+		SUBSYSTEM_PREPARE_MODE(ramdac)
+		SUBSYSTEM_PREPARE_MODE(clock)
+		SUBSYSTEM_PREPARE_MODE(chipset)
+
+#undef	SUBSYSTEM_PREPARE_MODE
+
+#define	SUBSYSTEM_ENTER_MODE(sys)					\
+		meta = dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_lang;	\
+		if (meta && meta->ModeEnter) {				\
+									\
+			meta->ModeEnter(				\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_data,\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_io,\
+				dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_##sys],\
+				img, images);				\
+		}
+
+		SUBSYSTEM_ENTER_MODE(monitor)
+		SUBSYSTEM_ENTER_MODE(ramdac)
+		SUBSYSTEM_ENTER_MODE(clock)
+		SUBSYSTEM_ENTER_MODE(chipset)
+
+#undef	SUBSYSTEM_ENTER_MODE
+}
+
+static void 
+kgim_display_unset_mode(kgi_display_t *kgi_dpy, kgi_image_mode_t *img, kgi_u_t
+	images, void *dev_mode)
+{
+	kgim_display_t *dpy = (kgim_display_t *) kgi_dpy;
+	kgim_display_mode_t *dpy_mode = dev_mode;
+	const kgim_meta_t *meta;
+
+	KRN_DEBUG(2, "kgim_display_unset_mode()");
+
+#define	SUBSYSTEM_LEAVE_MODE(sys)					\
+		meta = dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_lang;	\
+		if (meta && meta->ModeLeave) {				\
+			meta->ModeLeave(				\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_data,\
+				dpy->subsystem[KGIM_SUBSYSTEM_##sys].meta_io,\
+				dpy_mode->subsystem_mode[KGIM_SUBSYSTEM_##sys],\
+				img, images);				\
+		}
+
+		SUBSYSTEM_LEAVE_MODE(monitor)
+		SUBSYSTEM_LEAVE_MODE(ramdac)
+		SUBSYSTEM_LEAVE_MODE(clock)
+		SUBSYSTEM_LEAVE_MODE(chipset)
+
+#undef	SUBSYSTEM_LEAVE_MODE
+}
+
+static kgi_error_t 
+kgim_display_subsystem_init(kgim_display_t *dpy, kgim_subsystem_type_t system)
+{
+	const kgim_meta_t *meta = dpy->subsystem[system].meta_lang;
+	void *meta_data, *meta_io;
+	kgi_error_t error;
+
+	KRN_DEBUG(2, "kgim_display_subsystem_init()");
+
+	KRN_ASSERT(dpy);
+
+	if (NULL == meta) {
+		KRN_ERROR("No meta-language for subsystem %i", system);
+		return (-EINVAL);
+	}
+
+	KRN_DEBUG(2, "Initializing subsystem %i", system);
+
+	meta_data = meta->data_size ?
+		kgim_alloc(meta->data_size) : NULL;
+	meta_io   = meta->io_size   ?
+		kgim_alloc(meta->io_size)   : NULL;
+
+	if ((meta->data_size && (NULL == meta_data)) ||
+		(meta->io_size && (NULL == meta_io))) {
+		KRN_ERROR("Failed to allocate meta data and I/O context");
+		kgim_free(meta_io);
+		meta_io = NULL;
+		kgim_free(meta_data);
+		meta_data = NULL;
+
+		return (-ENOMEM);
+	}
+
+	/* 
+	 * Clear the area. KGI assumes a pointer is NULL or valid. If the 
+	 * meta blocks aren't filled with zeroes, an invalid pointer can have
+	 * any value.
+	 */
+	if (meta->data_size) kgim_memset(meta_data, 0, meta->data_size);
+	if (meta->io_size)   kgim_memset(meta_io, 0, meta->io_size);
+	
+	if ((0 == meta->io_size) && (KGIM_SUBSYSTEM_chipset != system)) {
+		KRN_ASSERT(NULL == meta_io);
+
+		KRN_DEBUG(3, "meta->io_size == 0; Assigning chipset's meta_io");
+
+		meta_io = dpy->subsystem[KGIM_SUBSYSTEM_chipset].meta_io;
+	}
+
+	KRN_DEBUG(2, "meta->InitModule = %p", meta->InitModule);
+
+	if (meta->InitModule) { 
+		error = meta->InitModule(meta_data, meta_io, &(dpy->options));
+
+		if (error) {
+			KRN_ERROR("Failed to initialize meta data (%.8x)",
+				error);
+
+			if (meta->io_size) {
+				kgim_free(meta_io);
+				meta_io = NULL;
+			}
+
+			kgim_free(meta_data);
+			meta_data = NULL;
+
+			return (error);
+		}
+
+		KRN_DEBUG(3, "Meta data initialized");
+	} else {
+		KRN_DEBUG(2, "No meta->InitModule() function for this device");
+	}
+
+	KRN_DEBUG(2, "meta->Init = %p", meta->Init);
+	KRN_DEBUG(2, "meta_data[%i]=%p meta_io[%i]=%p",
+		meta->data_size, meta_data, meta->io_size, meta_io);
+
+	if (meta->Init) {
+		error = meta->Init(meta_data, meta_io, &(dpy->options));
+
+		if (error) {
+			KRN_ERROR("Failed to initialize device (%.8x)", error);
+
+			if (meta->DoneModule) {
+				meta->DoneModule(meta_data, meta_io,
+					&(dpy->options));
+			}
+
+			if (meta->io_size) {
+				kgim_free(meta_io);
+				meta_io = NULL;
+			}
+
+			kgim_free(meta_data);
+			meta_data = NULL;
+
+			return (error);
+		}
+
+		KRN_DEBUG(2, "Device initialized");
+	} else {
+		KRN_DEBUG(2, "No meta->Init() function for this device");
+	}
+
+	dpy->subsystem[system].meta_data = meta_data;
+	dpy->subsystem[system].meta_io   = meta_io;
+	dpy->kgi.mode_size += KGIM_ALIGN(meta->mode_size);
+
+	KRN_DEBUG(2, "Subsystem %i initialized", system);
+
+	return (KGI_EOK);
+}
+
+static void 
+kgim_display_subsystem_done(kgim_display_t *dpy, kgim_subsystem_type_t system)
+{
+	const kgim_meta_t *meta = dpy->subsystem[system].meta_lang;
+	void *meta_data   = dpy->subsystem[system].meta_data;
+	void *meta_io     = dpy->subsystem[system].meta_io;
+
+	KRN_DEBUG(2, "kgim_display_subsystem_done()");
+
+	if (meta->Done)
+		meta->Done(meta_data, meta_io, &(dpy->options));
+
+	if (meta->DoneModule)
+		meta->DoneModule(meta_data, meta_io, &(dpy->options));
+	
+	if (meta->io_size) {
+		kgim_free(meta_io);
+		meta_io = NULL;
+		dpy->subsystem[system].meta_io = NULL;
+	}
+	kgim_free(meta_data);
+	meta_data = NULL;
+	dpy->subsystem[system].meta_data = NULL;
+	dpy->kgi.mode_size -= KGIM_ALIGN(meta->mode_size);
+}
+
+kgi_error_t 
+kgim_display_init(kgim_display_t *dpy)
+{
+	kgi_error_t error;
+
+	KRN_DEBUG(2, "kgim_display_init()");
+
+	dpy->kgi.mode_size = KGIM_ALIGN(sizeof(kgim_display_mode_t));
+
+	KRN_DEBUG(4, "Initializing chipset subsystem....");
+	if ((error = kgim_display_subsystem_init(dpy, KGIM_SUBSYSTEM_chipset))){
+		KRN_ERROR("Failed (%.8x) to initialize chipset", error);
+		goto chipset;
+	}
+	KRN_DEBUG(4, "Chipset subsystem initialized");
+
+	KRN_DEBUG(4, "Initializing ramdac subsystem....");
+	if ((error = kgim_display_subsystem_init(dpy, KGIM_SUBSYSTEM_ramdac))) {
+		KRN_ERROR("Failed (%.8x) to initialize ramdac", error);
+		goto ramdac;
+	}
+	KRN_DEBUG(4, "Ramdac subsystem initialized");
+
+	KRN_DEBUG(4, "Initializing clock subsystem....");
+	if ((error = kgim_display_subsystem_init(dpy, KGIM_SUBSYSTEM_clock))) {
+		KRN_ERROR("Failed (%.8x) to initialize clock", error);
+		goto clock;
+	}
+	KRN_DEBUG(4, "Clock subsystem initialized");
+
+	KRN_DEBUG(4, "Initializing monitor subsystem....");
+	if ((error = kgim_display_subsystem_init(dpy, KGIM_SUBSYSTEM_monitor))){
+		KRN_ERROR("Failed (%.8x) to initialize monitor", error);
+		goto monitor;
+	}
+	KRN_DEBUG(4, "Monitor subsystem initialized");
+
+	dpy->kgi.revision	= KGI_DISPLAY_REVISION;
+/* no KGIM_INVALID{_DISPLAY,} in module.h*/
+	dpy->kgi.id		= -1;
+	dpy->kgi.Command	= kgim_display_command;
+	dpy->kgi.CheckMode	= kgim_display_check_mode;
+	dpy->kgi.SetMode	= kgim_display_set_mode;
+	dpy->kgi.UnsetMode	= kgim_display_unset_mode;
+
+	if ((error = kgi_register_display(&(dpy->kgi),
+		dpy->options.misc->display))) {
+		KRN_ERROR("Failed (%d) to register display.", error);
+		goto display;
+	}
+
+	KRN_DEBUG(1, "%s %s driver loaded as display %i (%p)",
+		dpy->kgi.vendor, dpy->kgi.model, dpy->kgi.id, dpy);
+	return (KGI_EOK);
+
+	/* 
+	 * If there was some error during startup, we still have to
+	 * shut down properly.
+	 */
+display:
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_monitor);
+monitor:
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_clock);
+clock:
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_ramdac);
+ramdac:
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_chipset);
+chipset:
+	return (error);
+}
+
+void 
+kgim_display_done(kgim_display_t *dpy)
+{
+	KRN_DEBUG(2, "kgim_display_done()");
+
+	kgi_unregister_display(&dpy->kgi);
+
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_monitor);
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_clock);
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_ramdac);
+	kgim_display_subsystem_done(dpy, KGIM_SUBSYSTEM_chipset);
+}
+
+static int
+kgim_modevent(module_t mode, int type, void *unused)
+{
+	switch (type) {
+	case MOD_LOAD:
+	case MOD_UNLOAD:
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static moduledata_t kgim_mod = {
+	"kgim",
+	kgim_modevent,
+	0
+};
+
+DECLARE_MODULE(kgim, kgim_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
+MODULE_VERSION(kgim, 1);
diff -x CVS -x .svn -aurpN sys/dev/kgim/module.h sys/dev/kgim/module.h
--- sys/dev/kgim/module.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgim/module.h	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,575 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 1995-1998 Andreas Beck
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ *
+ */
+
+/*
+ * KGI kernel module internal interface definitions.
+ */
+
+#ifndef _kgi_module_h
+#define _kgi_module_h
+
+#define __KGI_STRINGIFY_(s) #s
+#define __KGI_STRINGIFY(s) __KGI_STRINGIFY_(s)
+
+/*
+ * Debugging management.
+ */
+
+#ifdef	KGIM_CHIPSET_DRIVER
+#	ifdef	CONFIG_KGIM_CHIPSET_DEBUG_LEVEL
+#		undef DEBUG_LEVEL
+#		define	DEBUG_LEVEL	CONFIG_KGIM_CHIPSET_DEBUG_LEVEL
+#	endif
+#endif
+
+#ifdef	KGIM_RAMDAC_DRIVER
+#	ifdef	CONFIG_KGIM_RAMDAC_DEBUG_LEVEL
+#		undef DEBUG_LEVEL
+#		define	DEBUG_LEVEL	CONFIG_KGIM_RAMDAC_DEBUG_LEVEL
+#	endif
+#endif
+
+#ifdef	KGIM_CLOCK_DRIVER
+#	ifdef	CONFIG_KGIM_CLOCK_DEBUG_LEVEL
+#		undef DEBUG_LEVEL
+#		define	DEBUG_LEVEL	CONFIG_KGIM_CLOCK_DEBUG_LEVEL
+#	endif
+#endif
+
+#ifdef	KGIM_MONITOR_DRIVER
+#	ifdef	CONFIG_KGIM_MONITOR_DEBUG_LEVEL
+#		undef DEBUG_LEVEL
+#		define	DEBUG_LEVEL	CONFIG_KGIM_MONITOR_DEBUG_LEVEL
+#	endif
+#endif
+
+#if (defined(DEBUG_LEVEL) && (DEBUG_LEVEL < 0))
+#undef DEBUG_LEVEL
+#endif
+
+#define	KGI_SYS_NEED_IO
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgi.h>
+
+/*
+ * Subsystems.
+ */
+typedef enum {
+	KGIM_SUBSYSTEM_monitor = 0,
+	KGIM_SUBSYSTEM_chipset,
+	KGIM_SUBSYSTEM_ramdac,
+	KGIM_SUBSYSTEM_clock,
+
+	KGIM_LAST_SUBSYSTEM,
+	__KGIM_MAX_NR_SUBSYSTEMS = 8
+} kgim_subsystem_type_t;
+
+#define	__KGIM_SUBSYSTEM		\
+	kgi_u_t		revision;	/* KGI/driver revision	*/\
+	kgi_ascii_t	vendor[64];	/* manufacturer		*/\
+	kgi_ascii_t	model[64];	/* model/trademark	*/\
+	kgi_u32_t	flags;		/* special capabilities	*/\
+	kgi_u_t		mode_size;	/* private mode size	*/
+
+#define	__KGIM_SUBSYSTEM_MODE
+
+typedef struct {
+	__KGIM_SUBSYSTEM
+} kgim_subsystem_t;
+
+
+/*
+ * Module internal I/O binding.
+ */
+
+#define	KGIM_IO_FN(s)	\
+typedef	kgi_u##s##_t kgim_io_in##s##_fn(void *ctx, kgi_u##s##_t reg); \
+typedef void kgim_io_out##s##_fn(void *ctx, kgi_u##s##_t val, kgi_size_t reg);\
+typedef kgi_u##s##_t kgim_io_get##s##_fn(void *ctx); \
+typedef void kgim_io_set##s##_fn(void *ctx, kgi_u##s##_t val);
+
+KGIM_IO_FN(8)
+KGIM_IO_FN(16)
+KGIM_IO_FN(32)
+
+#undef	KGIM_IO_FN
+
+typedef void kgim_io_ins8_fn(void *ctx, kgi_u8_t reg, void *buf, kgi_u_t count);
+typedef void kgim_io_outs8_fn(void *ctx, kgi_u8_t reg, void *buf, kgi_u_t count);
+typedef void kgim_io_init_fn(void *ctx);
+
+/*
+ * Monitor subsystem.
+ */
+#define	KGIM_MONITOR_REVISION	1
+
+typedef enum {
+	KGIM_MF_NORMAL		= 0x00000000,	/* normal monitor	*/
+	KGIM_MF_RIGHT_EYE	= 0x00000001,	/* stereo right screen	*/
+	KGIM_MF_LEFT_EYE	= 0x00000002,	/* stereo left screen	*/
+	KGIM_MF_STEREO		= 0x00000003,	/* is stereo?		*/
+
+	KGIM_MF_POWERSAVE	= 0x00000004,	/* can do powersaving	*/
+	KGIM_MF_PROPSIZE	= 0x00000008 	/* size depends on mode */
+} kgim_monitor_flags_t;
+
+typedef enum {
+	KGIM_MT_SIGNAL_MASK	= 0x40000000,	/* video signal type	*/
+		KGIM_MT_DIGITAL	= 0x00000000,	/* digital input	*/
+		KGIM_MT_ANALOG	= 0x40000000,	/* analog input		*/
+
+	KGIM_MT_COLORSPACE_MASK	= 0x1F000000,	/* color spaces		*/
+		KGIM_MT_MONO	= 0x00000000,	/* monochrome input	*/
+		KGIM_MT_RGB	= 0x00000000,	/* RGB input signal	*/
+		KGIM_MT_YUV	= 0x01000000,	/* YUV input signal	*/
+
+	KGIM_MT_TECHNOLOGY_MASK	= 0x000000FF,	/* display technology	*/
+		KGIM_MT_CRT	= 0x00000000,	/* Cathod Ray Tube	*/
+		KGIM_MT_LCD	= 0x00000001,	/* Liquid Crystal	*/
+		KGIM_MT_TFT	= 0x00000002,	/* Thin Film Transistor */
+		KGIM_MT_DSTN	= 0x00000003,	/* Double S.T. Nematic?	*/
+		KGIM_MT_PLASMA	= 0x00000004	/* Plasma		*/
+} kgim_monitor_type_t;
+
+typedef enum {
+	KGIM_ST_SYNC_SEPARATE 	= 0x0001,	/* normal separate sync	*/
+	KGIM_ST_SYNC_ON_RED	= 0x0002,	/* sync on r line	*/
+	KGIM_ST_SYNC_ON_GREEN	= 0x0004,	/* sync on g line	*/
+	KGIM_ST_SYNC_ON_BLUE	= 0x0008,	/* sync on b line	*/
+	KGIM_ST_SYNC_SERRATE	= 0x0010,	/* do hsync during vsync*/
+	KGIM_ST_SYNC_COMPOSITE	= 0x0020,	/* digital composite	*/
+	KGIM_ST_SYNC_TYPEMASK	= 0x003F,
+	KGIM_ST_SYNC_NORMAL	= KGIM_ST_SYNC_SERRATE | KGIM_ST_SYNC_SEPARATE,
+
+	KGIM_ST_SYNC_PEDESTRAL	= 0x0020,	/* need blank pedestral	*/
+	KGIM_ST_SYNC_0700_0300	= 0x0000,	/* <white>_<sync> level	*/
+	KGIM_ST_SYNC_0714_0286	= 0x0040,
+	KGIM_ST_SYNC_0100_0400	= 0x0080,
+	KGIM_ST_SYNC_UNKNOWNLEVEL = 0x00C0,	/* not defined by VESA!	*/
+	KGIM_ST_SYNC_SIGNALLEVEL = 0x00C0,	/* mask for signal level*/
+
+	KGIM_ST_SYNC_STANDBY	= 0x0100,	/* standby mode allowed	*/
+	KGIM_ST_SYNC_SUSPEND	= 0x0200,	/* suspend mode allowed */
+	KGIM_ST_SYNC_OFF	= 0x0400,	/* switch off allowed	*/
+	KGIM_ST_SYNC_VESA_DPMS	= 0x0700,	/* has (full) VESA-DPMS	*/
+
+	KGIM_ST_SYNC_SSYNC_RIGHT = 0x0000,	/* right image on SSYNC	*/
+	KGIM_ST_SYNC_SSYNC_LEFT	= 0x1000,	/* left image on SSYNC	*/
+	KGIM_ST_SYNC_MULTISYNC	= 0x2000	/* multisync monitor	*/
+} kgim_sync_type_t;
+
+#define	KGIM_MONITOR_MAX_HFREQ	8
+#define	KGIM_MONITOR_MAX_VFREQ	8
+
+typedef struct {
+	__KGIM_SUBSYSTEM
+
+	kgi_ucoord_t	maxdots;		/* maximum resolution	*/
+	kgi_ucoord_t	size;			/* physical size in mm	*/
+	kgim_monitor_type_t	type;		/* display type		*/
+	kgim_sync_type_t	sync;		/* type of syncing	*/
+	kgi_urange_t	dclk;			/* bandwidth		*/
+	kgi_urange_t	hfreq[KGIM_MONITOR_MAX_HFREQ];	/* horiz. freq.	*/
+	kgi_urange_t	vfreq[KGIM_MONITOR_MAX_VFREQ];	/* vert. freq.	*/
+
+	kgi_color_t	white;			/* white point		*/
+	kgi_u_t		gamma;			/* gamma value		*/
+} kgim_monitor_t;
+
+/*
+ * We assume a 'standard' CRT here. Most non-CRT displays appear to be
+ * compatible anyway.
+ */
+typedef struct {
+	kgi_u16_t		width;
+	kgi_u16_t		blankstart;
+	kgi_u16_t		syncstart;
+	kgi_u16_t		syncend;
+	kgi_u16_t		blankend;
+	kgi_u16_t		total;
+	kgi_s16_t		polarity;
+} kgim_monitor_timing_t;
+
+typedef enum {
+	KGI_MMF_MASK	= 0x00000000
+} kgim_monitor_mode_flags_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM_MODE
+
+	kgi_dot_port_mode_t	in;	/* input port		*/
+	kgi_ucoord_t		size;	/* physical size in mm	*/
+	kgim_monitor_mode_flags_t flags;/* special info		*/
+	kgim_monitor_timing_t	x,y;	/* timing values	*/
+	kgim_sync_type_t	sync;	/* sync operation mode	*/
+} kgim_monitor_mode_t;
+
+/*
+ * RAMDAC subsystem.
+ */
+#define	KGIM_RAMDAC_REVISION	1
+
+#define	KGIM_DAC_OUT8(ctx, val, reg)	(ctx)->DacOut8((ctx), (val), (reg))
+#define	KGIM_DAC_IN8(ctx, reg)		(ctx)->DacIn8((ctx), (reg))
+#define	KGIM_DAC_OUTS8(ctx, r, b, c)	(ctx)->DacOuts8((ctx), (r), (b), (c))
+#define	KGIM_DAC_INS8(ctx, r, b, c)	(ctx)->DacIns8((ctx), (r), (b), (c))
+
+typedef struct {
+	__KGIM_SUBSYSTEM
+
+	kgi_ucoord_t	maxdots;		/* maximum resolution	*/
+	kgi_urange_t	lclk;			/* lclk range		*/
+	kgi_urange_t	dclk;			/* dclk range		*/
+} kgim_ramdac_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM_MODE
+
+	const kgim_monitor_mode_t	*crt;
+} kgim_ramdac_mode_t;
+
+/*
+ * Clock subsystem.
+ */
+#define	KGIM_CLOCK_REVISION	1
+
+#define	__KGIM_MAX_NR_FIXED_CLOCKS	16
+#define	__KGIM_MAX_NR_PROG_CLOCKS	8
+
+typedef enum {
+	KGIM_CT_FIXED,
+	KGIM_CT_PROG
+} kgim_clock_type_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM
+
+	kgim_clock_type_t	type;
+	union
+	{
+		kgi_s_t		freq[__KGIM_MAX_NR_FIXED_CLOCKS];
+		kgi_urange_t	range[__KGIM_MAX_NR_PROG_CLOCKS];
+	} dclk;
+} kgim_clock_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM_MODE
+} kgim_clock_mode_t;
+
+/*
+ * Chipset subsystem.
+ */
+#define	KGIM_CHIPSET_REVISION	1
+
+typedef struct {
+    char *		DevName;
+
+    kgi_u8_t		BitTimeout;	/* usec */
+    kgi_u8_t		ByteTimeout;	/* usec */
+    kgi_u8_t		AcknTimeout;    /* usec */
+    kgi_u8_t 		StartTimeout;	/* usec */
+
+    kgi_u_t		SlaveAddr;
+    void	       *pI2CBus;
+} I2CDevRec;
+
+typedef struct {
+	kgi_error_t	(*WriteRead)(I2CDevRec *, kgi_u8_t*, kgi_u_t, kgi_u8_t *, kgi_u_t);
+	
+	kgi_error_t	(*PutByte)(I2CDevRec *, kgi_u8_t);
+	kgi_error_t	(*GetByte)(I2CDevRec *, kgi_u8_t* , kgi_u8_t);
+	kgi_error_t	(*Address)(I2CDevRec *, kgi_u_t);
+	kgi_error_t	(*Stop)(I2CDevRec *);
+
+	kgi_error_t	(*PutBits)(void *, kgi_u_t, kgi_u_t);
+	kgi_error_t	(*GetBits)(void *, kgi_u_t *, kgi_u_t *);
+
+	void		(*UDelay)(void *, kgi_u_t);
+	kgi_u8_t	HoldTime;
+	kgi_u8_t	BitTimeout;
+	kgi_u8_t	ByteTimeout;
+	kgi_u8_t	AcknTimeout;
+	kgi_u8_t	StartTimeout;
+	kgi_u8_t	RiseFallTime;
+	void 		* chipset_io;
+} kgim_i2c_io_t ; 
+
+typedef struct {
+	pcicfg_vaddr_t		pcidev;
+
+	kgim_io_out8_fn		*DacOut8;
+	kgim_io_in8_fn		*DacIn8;
+	kgim_io_outs8_fn	*DacOuts8;
+	kgim_io_ins8_fn		*DacIns8;
+
+	kgim_io_out8_fn		*ClkOut8;
+	kgim_io_in8_fn		*ClkIn8;
+
+	kgim_io_init_fn		*DDCInit;
+	kgim_io_init_fn		*DDCDone;
+	kgim_io_set8_fn		*DDCSetSCL;
+	kgim_io_get8_fn		*DDCGetSDA;
+	kgim_io_set8_fn		*DDCSetVSYNC;
+	kgim_io_get8_fn		*DDCGetVSYNC;
+	
+	kgim_i2c_io_t		DDC2_io;
+} kgim_chipset_io_t;
+
+#define	KGIM_PCIDEV(ctx)		(ctx)->pcidev
+
+#define	KGIM_DAC_OUT8(ctx, val, reg)	(ctx)->DacOut8((ctx), (val), (reg))
+#define	KGIM_DAC_IN8(ctx, reg)		(ctx)->DacIn8((ctx), (reg))
+#define	KGIM_DAC_OUTS8(ctx, r, b, c)	(ctx)->DacOuts8((ctx), (r), (b), (c))
+#define	KGIM_DAC_INS8(ctx, r, b, c)	(ctx)->DacIns8((ctx), (r), (b), (c))
+
+#define	KGIM_CLK_OUT8(ctx, val, reg)	(ctx)->ClkOut8((ctx), (val), (reg))
+#define	KGIM_CLK_IN8(ctx, reg)		(ctx)->ClkIn8((ctx), (reg))
+
+typedef enum {
+	KGIM_CF_NORMAL = 0
+} kgim_chipset_flags_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM
+
+	kgi_ucoord_t	maxdots;		/* maximum resolution	*/
+	kgi_u_t		memory;			/* (total) memory 	*/
+	kgi_urange_t	dclk;			/* DCLK range		*/
+
+	kgi_u32_t	vendor_id;		/* (PCI) vendor ID	*/
+ 	kgi_u32_t	device_id;		/* (PCI) device ID	*/
+} kgim_chipset_t;
+
+typedef struct {
+	__KGIM_SUBSYSTEM_MODE
+
+	const kgim_monitor_mode_t	*crt;
+} kgim_chipset_mode_t;
+
+/*
+ * Options handling.
+ */
+typedef struct {
+	pcicfg_vaddr_t	dev;
+	mem_paddr_t	base0;
+	mem_paddr_t	base1;
+	mem_paddr_t	base2;
+	mem_paddr_t	base3;
+	mem_paddr_t	base4;
+	mem_paddr_t	base5;
+	mem_paddr_t	base6;
+	mem_paddr_t	base7;
+	mem_paddr_t	baseR;
+} kgim_options_pci_t;
+
+typedef struct {
+	mem_paddr_t	law_base;
+	kgi_u_t		display;
+} kgim_options_misc_t;
+
+typedef struct {
+	const char	*chipset;
+	kgi_u_t		memory;
+} kgim_options_chipset_t;
+
+typedef struct {
+	kgi_u_t	lclk_min, lclk_max;
+	kgi_u_t	dclk_min, dclk_max;
+} kgim_options_ramdac_t;
+
+typedef struct {
+	kgi_u_t	fref;
+	kgi_u_t	fvco_min, fvco_max;
+} kgim_options_clock_t;
+
+#define KGIM_OPTIONS_MAX_TIMINGS	8
+#define KGIM_OPTIONS_MAX_RANGES		8
+
+struct kgim_options_monitor_s;
+typedef struct kgim_options_monitor_s kgim_options_monitor_t;
+
+typedef kgi_error_t kgim_monitor_init_module_fn
+     (kgim_monitor_t *monitor, const kgim_options_monitor_t *options);
+
+struct kgim_options_monitor_s {
+	kgi_u_t			timings;
+	kgim_monitor_timing_t	x[KGIM_OPTIONS_MAX_TIMINGS];
+	kgim_monitor_timing_t	y[KGIM_OPTIONS_MAX_TIMINGS];
+	
+	kgi_u_t			num_hfreq;
+	kgi_urange_t		hfreq[KGIM_OPTIONS_MAX_RANGES];
+	kgi_u_t			num_vfreq;
+	kgi_urange_t		vfreq[KGIM_OPTIONS_MAX_RANGES];
+	kgi_u_t			num_dclk;
+	kgi_urange_t		dclk[KGIM_OPTIONS_MAX_RANGES];
+	kgi_u_t			ddc;
+
+	kgim_sync_type_t	sync;
+	kgim_monitor_type_t	type;
+	
+	kgi_ucoord_t		size;
+
+	kgim_monitor_init_module_fn *init_module;
+};
+
+typedef struct {
+	const kgim_options_misc_t	*misc;
+	const kgim_options_pci_t	*pci;
+	const kgim_options_chipset_t	*chipset;
+	const kgim_options_ramdac_t	*ramdac;
+	const kgim_options_clock_t	*clock;
+	const kgim_options_monitor_t	*monitor;
+} kgim_options_t;
+
+#define	KGIM_DEFAULT(option, default) ((option) ? (option) : (default))
+
+/*
+ * Display driver global data.
+ */
+typedef struct kgim_meta_s kgim_meta_t;
+
+typedef struct {
+	kgi_display_t		kgi;
+
+	kgim_options_t		options;
+	kgim_options_misc_t	options_misc;
+	kgim_options_pci_t	options_pci;
+	kgim_options_chipset_t	options_chipset;
+	kgim_options_ramdac_t	options_ramdac;
+	kgim_options_clock_t	options_clock;
+	kgim_options_monitor_t	options_monitor;
+
+	struct {
+		const kgim_meta_t	*meta_lang;
+		void			*meta_io;
+		void			*meta_data;
+	} subsystem[__KGIM_MAX_NR_SUBSYSTEMS];
+} kgim_display_t;
+
+typedef struct {
+	void *subsystem_mode[__KGIM_MAX_NR_SUBSYSTEMS];
+} kgim_display_mode_t;
+
+/*
+ * Meta-languages.
+ */
+typedef kgi_error_t kgim_meta_init_module_fn (void *meta, void *meta_io,
+		const kgim_options_t *options);
+
+#define	KGIM_META_INIT_MODULE_FN(meta)					\
+	kgi_error_t meta##_init_module(meta##_t *, meta##_io_t *,	\
+		const kgim_options_t *);
+
+
+typedef void kgim_meta_done_module_fn(void *meta, void *meta_io,
+		const kgim_options_t *options);
+
+#define	KGIM_META_DONE_MODULE_FN(meta)					\
+	void meta##_done_module(meta##_t *, meta##_io_t *,		\
+		const kgim_options_t *);
+
+
+typedef kgi_error_t kgim_meta_init_fn(void *meta, void *meta_io,
+		const kgim_options_t *options);
+
+#define	KGIM_META_INIT_FN(meta)						\
+	kgi_error_t meta##_init(meta##_t *, meta##_io_t *,		\
+		const kgim_options_t *);
+
+
+typedef void kgim_meta_done_fn(void *meta, void *meta_io,
+		const kgim_options_t *options);
+
+#define	KGIM_META_DONE_FN(meta)						\
+	void meta##_done(meta##_t *, meta##_io_t *,			\
+		const kgim_options_t *);
+
+
+typedef kgi_error_t kgim_meta_mode_check_fn(void *meta, void *meta_io,
+		void *meta_mode, kgi_timing_command_t cmd,
+		kgi_image_mode_t *img, kgi_u_t images);
+
+#define	KGIM_META_MODE_CHECK_FN(meta)					\
+	kgi_error_t meta##_mode_check(meta##_t *, meta##_io_t *,	\
+		meta##_mode_t *, kgi_timing_command_t,			\
+		kgi_image_mode_t *, kgi_u_t);
+
+
+typedef kgi_resource_t *kgim_meta_mode_resource_fn(void *meta, void *meta_mode,
+		kgi_image_mode_t *img, kgi_u_t images, kgi_u_t index);
+
+#define	KGIM_META_MODE_RESOURCE_FN(meta)				\
+	kgi_resource_t *meta##_mode_resource(meta##_t *, meta##_mode_t *,\
+		kgi_image_mode_t *, kgi_u_t, kgi_u_t);
+
+
+typedef void kgim_meta_mode_prepare_fn(void *meta, void *meta_io,
+		void *meta_mode, kgi_image_mode_t *img, kgi_u_t images);
+
+#define	KGIM_META_MODE_PREPARE_FN(meta)					\
+	void meta##_mode_prepare(meta##_t *, meta##_io_t *,		\
+		meta##_mode_t *, kgi_image_mode_t *, kgi_u_t);
+
+
+typedef void kgim_meta_mode_enter_fn(void *meta, void *meta_io,
+		void *meta_mode, kgi_image_mode_t *img, kgi_u_t images);
+
+#define	KGIM_META_MODE_ENTER_FN(meta)					\
+	void meta##_mode_enter(meta##_t *, meta##_io_t *,		\
+		meta##_mode_t *, kgi_image_mode_t *, kgi_u_t);
+
+
+typedef void kgim_meta_mode_leave_fn(void *meta, void *meta_io,
+		void *meta_mode, kgi_image_mode_t *img, kgi_u_t images);
+
+#define	KGIM_META_MODE_LEAVE_FN(meta)					\
+	void meta##_mode_leave(meta##_t *, meta##_io_t *,		\
+		meta##_mode_t *, kgi_image_mode_t *, kgi_u_t);
+
+typedef kgi_resource_t *kgim_meta_image_resource_fn(void *meta, void *meta_mode,
+		kgi_image_mode_t *img, kgi_u_t image, kgi_u_t index);
+
+#define	KGIM_META_IMAGE_RESOURCE_FN(meta)				\
+	kgi_resource_t *meta##_image_resource(meta##_t *, meta##_mode_t *,\
+		kgi_image_mode_t *, kgi_u_t, kgi_u_t);
+		
+		
+/*
+ * IRQ handlers are not really part of a meta-language (yet).
+ * However, use this macro to get a consistent prototype definition.
+ */
+
+#define	KGIM_META_IRQ_HANDLER_FN(meta)					\
+	kgi_error_t meta##_irq_handler(meta##_t *, meta##_io_t *,	\
+		irq_system_t *);
+
+struct kgim_meta_s {
+	kgim_meta_init_module_fn	*InitModule;
+	kgim_meta_done_module_fn	*DoneModule;
+	kgim_meta_init_fn		*Init;
+	kgim_meta_done_fn		*Done;
+	kgim_meta_mode_check_fn		*ModeCheck;
+	kgim_meta_mode_resource_fn	*ModeResource;
+	kgim_meta_mode_prepare_fn	*ModePrepare;
+	kgim_meta_mode_enter_fn		*ModeEnter;
+	kgim_meta_mode_leave_fn		*ModeLeave;
+	kgim_meta_image_resource_fn	*ImageResource;
+
+	kgi_size_t			data_size;
+	kgi_size_t			io_size;
+	kgi_size_t			mode_size;
+};
+
+#define	KGIM_META(meta) \
+	extern const kgim_meta_t meta##_meta;
+
+#include <dev/kgim/modulelib.h>
+
+#endif /* #ifdef _kgi_module_h */
diff -x CVS -x .svn -aurpN sys/dev/kgim/modulecmd.h sys/dev/kgim/modulecmd.h
--- sys/dev/kgim/modulecmd.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgim/modulecmd.h	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,36 @@
+/*-
+ * Copyright (C) 1999-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * 
+ */
+
+/*
+ * KGI module specific command requests
+ */
+
+
+#ifndef _kgi_modulecmd_h
+#define	_kgi_modulecmd_h
+
+struct kgic_img_buffer_param_t {
+	kgi_u_t		index;		/* index of buffer		*/
+};
+
+struct kgic_img_buffer_result_t {
+	kgi_u_t		mmio;		/* mmio_region index to use	*/
+	kgi_u_t		mmio_offset;	/* offset into region (bytes)	*/
+	kgi_u_t		accel;		/* accelerator to use		*/
+
+	kgi_scoord_t	size;		/* application area size	*/
+	kgi_scoord_t	origin;		/* application area origin	*/
+	kgi_u_t		stride;		/* application area stride	*/
+
+	kgi_u_t	lpm[__KGI_MAX_NR_ATTRIBUTES];	/* left pixel masks	*/
+	kgi_u_t	rpm[__KGI_MAX_NR_ATTRIBUTES];	/* right pixel masks	*/
+	kgi_u_t	cpm[__KGI_MAX_NR_ATTRIBUTES];	/* common pixel masks	*/
+};
+
+#endif /* #ifdef _kgi_modulecmd_h */
diff -x CVS -x .svn -aurpN sys/dev/kgim/modulelib.h sys/dev/kgim/modulelib.h
--- sys/dev/kgim/modulelib.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgim/modulelib.h	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,59 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ *
+ */
+
+/*
+ * KGI kernel module library definitions
+ */
+
+#ifndef _kgi_modulelib_h
+#define _kgi_modulelib_h
+
+/*
+ * debugging framework overrides
+ */
+#if defined(__KERNEL__) && (defined(__MODULE__) || defined(MODULE))
+
+#undef	__krn_debug
+#undef	__krn_notice
+#undef	__krn_error
+#ifdef	KRN_DEBUG_ANSI_CPP
+#	define	__krn_debug	kgim_ansi_debug
+#	define	__krn_error	kgim_ansi_error
+#endif
+#ifdef	KRN_DEBUG_GNU_CPP
+#	define	__krn_debug	kgim_gnu_debug
+#	define	__krn_error	kgim_gnu_error
+#endif
+#	define	__krn_notice	kgim_notice
+#endif /* #if defined(__KERNEL__) && defined(__MODULE__) */
+
+extern void kgim_notice(const char *fmt, ...);
+
+extern void kgim_ansi_debug(int level, const char *fmt, ...);
+extern void kgim_ansi_error(const char *fmt, ...);
+
+extern void kgim_gnu_debug(const char *file, int line, const char *func, int level, const char *fmt, ...);
+extern void kgim_gnu_error(const char *file, int line, const char *func, const char *fmt, ...);
+
+extern kgi_u_t kgim_attr_bits(const kgi_u8_t *bpa);
+
+extern void	kgim_memset(void *p, kgi_u8_t val, kgi_size_t size);
+extern void	kgim_memcpy(void *dst, const void *src, kgi_size_t size);
+extern kgi_s_t	kgim_memcmp(const void *s1, const void *s2, kgi_size_t size);
+
+extern kgi_s_t	kgim_strcmp(const kgi_u8_t *s1, const kgi_u8_t *s2);
+extern kgi_u8_t	*kgim_strcpy(kgi_u8_t *dst, const kgi_u8_t *src);
+extern kgi_u8_t	*kgim_strncpy(kgi_u8_t *dst, const kgi_u8_t *src, kgi_size_t size);
+
+extern kgi_error_t kgim_display_init(kgim_display_t *dpy);
+extern void kgim_display_done(kgim_display_t *dpy);
+
+#define	KGIM_ABS(x)	(((x) < 0) ? -(x) : (x))
+
+#endif /* #ifdef _kgi_modulelib_h */
diff -x CVS -x .svn -aurpN sys/dev/kgy/kgy.h sys/dev/kgy/kgy.h
--- sys/dev/kgy/kgy.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgy/kgy.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,89 @@
+/*-
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI vidsw interface display driver.
+ */
+
+#ifndef _kgi_kgy_h
+#define _kgi_kgy_h
+
+#define BIT_REVERSE(byte)		\
+	((((byte) & 0x01) << 7) |	\
+	 (((byte) & 0x02) << 5) |	\
+	 (((byte) & 0x04) << 3) |	\
+	 (((byte) & 0x08) << 1) |	\
+	 (((byte) & 0x10) >> 1) |	\
+	 (((byte) & 0x20) >> 3) |	\
+	 (((byte) & 0x40) >> 5) |	\
+	 (((byte) & 0x80) >> 7))
+
+typedef struct {
+	kgi_u_t width;
+	kgi_u_t height;
+	kgi_u8_t  data[256 * 32];
+} dpysw_font_t;
+
+typedef struct dpysw_display_s {
+	kgi_display_t dpy;		/* Must remain on top of struct. */
+
+	video_adapter_t *adp;	
+	kgi_mode_t mode;
+
+	/* Fonts. */
+	dpysw_font_t fonts[4];
+	kgi_u8_t *curfont;
+
+	/* Display resources. */
+	kgi_mmio_region_t fb;
+
+	kgi_clut_t ilut;
+	kgi_marker_t ptr;
+
+	kgi_text16_t text16;
+} dpysw_display_t;
+
+typedef struct vidsw_mode_s {
+	kgi_dot_port_mode_t dpm;
+	video_info_t mode_info;
+	video_info_t oldmode_info;
+} vidsw_mode_t;
+
+extern dpysw_display_t dpysw_sc;
+
+extern void kgy_splash(video_adapter_t *adp);
+
+extern void dpysw_set_mode(kgi_display_t *dpy, kgi_image_mode_t *img,
+			   kgi_u_t images, void *dev_mode);
+
+extern void dpysw_unset_mode(kgi_display_t *dpy, kgi_image_mode_t *img,
+			     kgi_u_t images, void *dev_mode);
+
+extern int dpysw_check_mode(kgi_display_t *dpy, kgi_timing_command_t cmd,
+			    kgi_image_mode_t *img, kgi_u_t images,
+			    void *dev_mode, const kgi_resource_t **r,
+			    kgi_u_t rsize);
+
+extern void dpysw_load_font(kgi_text16_t *text16, kgi_u_t page,
+			    kgi_u_t fontsize, kgi_u_t fontwidth, kgi_u8_t *data,
+			    kgi_u_t ch, kgi_s_t count);
+
+extern void dpysw_save_font(kgi_text16_t *text16, kgi_u_t page,
+			    kgi_u_t fontsize, kgi_u_t fontwidth, kgi_u8_t *data,
+			    kgi_u_t ch, kgi_s_t count);
+
+extern void dpysw_show_font(kgi_text16_t *text16, kgi_u_t page);
+
+extern void dpysw_put_text16(kgi_text16_t *text16, kgi_u_t offset,
+			     const kgi_u16_t *text, kgi_u_t count);
+
+#endif /* _kgi_kgy_h */
diff -x CVS -x .svn -aurpN sys/dev/kgy/kgy_disp.c sys/dev/kgy/kgy_disp.c
--- sys/dev/kgy/kgy_disp.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgy/kgy_disp.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,484 @@
+/*-
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI vidsw interface display driver.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define KGI_DBG_LEVEL 2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/fbio.h>
+
+#include <dev/fb/fbreg.h>
+#include <dev/fb/vgareg.h>
+
+#define	KGI_SYS_NEED_IO
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgy/kgy.h>
+
+static int registered = 0;
+
+dpysw_display_t dpysw_sc;
+
+/* XXX FIXME */
+extern int vesa_load_ioctl(void);
+extern int vesa_unload_ioctl(void);
+
+/* Stub the ioctl install hook for vesa.c */
+int
+vesa_load_ioctl(void)
+{
+
+	return (0);
+}
+
+int
+vesa_unload_ioctl(void)
+{
+
+	return (0);
+}
+
+static kgi_error_t 
+dpysw_display_command(kgi_display_t *dpy, kgi_u_t cmd, void *data)
+{
+
+	return (EINVAL);
+}
+
+static void 
+dpysw_inc_refcount(kgi_display_t *dpy)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_DEBUG(2, "dpysw display refcount increment");
+
+	return;
+}
+
+static void 
+dpysw_dec_refcount(kgi_display_t *dpy)
+{
+
+	KRN_ASSERT(dpy);
+	KRN_DEBUG(2, "dpysw display refcount decrement");
+
+	return;
+}
+
+#if 0
+static void dpysw_ptr_set_shape(kgi_marker_t *m, kgi_u_t x, kgi_u_t y)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)m->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->set_hw_cursor_shape)
+		(sc->adp, (int)x, (int)y);
+
+	return;
+}
+#endif
+
+static void 
+dpysw_ptr_show(kgi_marker_t *m, kgi_u_t x, kgi_u_t y)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)m->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->set_hw_cursor)
+		(sc->adp, (int)x, (int)y);
+	
+	return;
+}
+
+static void 
+dpysw_ptr_hide(kgi_marker_t *m)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)m->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->set_hw_cursor)
+		(sc->adp, -1, -1);
+
+	return;
+}
+
+static void 
+dpysw_ptr_read(kgi_marker_t *m, kgi_u_t *x, kgi_u_t *y)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)m->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->read_hw_cursor)
+		(sc->adp, (int *)x, (int *)y);
+
+	return;
+}
+
+static void 
+dpysw_set_offset(kgi_mmio_region_t *r, kgi_size_t offset)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->set_win_org)
+		(sc->adp, (off_t) offset);
+
+	if (!error) {
+		r->win.phys = sc->adp->va_info.vi_window;
+		r->offset = offset;
+	}
+	
+	return;
+}
+
+static void 
+dpysw_set_ilut(kgi_clut_t *r, kgi_u_t table, kgi_u_t index, kgi_u_t count,
+	   kgi_attribute_mask_t am, const kgi_u16_t *data)
+{
+	int error;
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+	kgi_u8_t clut[256*3];
+	int i;
+
+	KRN_ASSERT(table == 0);
+	KRN_ASSERT(count == 256);
+	KRN_ASSERT(index == 0);
+	
+	/* All colors must change at once. */
+	if (!(am & KGI_AM_COLOR1) || !(am & KGI_AM_COLOR2) ||
+	    !(am & KGI_AM_COLOR3) || count != 256 || index != 0)
+		return;
+
+	/* XXX stupid convertion. */
+	for (i=0; i<256*3; i+=3) {
+		clut[i]   = data[i]   >> 8;
+		clut[i+1] = data[i+1] >> 8;
+		clut[i+2] = data[i+2] >> 8;
+	}
+
+	error = (*vidsw[sc->adp->va_index]->load_palette)
+		(sc->adp, clut);
+	
+	return;
+}
+
+static void 
+dpysw_get_ilut(kgi_clut_t *r, kgi_u_t table, kgi_u_t index, kgi_u_t 
+		count, kgi_attribute_mask_t am, const kgi_u16_t *data)
+{
+	int error;
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+
+	KRN_ASSERT(table == 0);
+	KRN_ASSERT(count == 256);
+	KRN_ASSERT(index == 0);
+	
+	/* All colors must change at once .*/
+	if (!(am & KGI_AM_COLOR1) || !(am & KGI_AM_COLOR2) ||
+	    !(am & KGI_AM_COLOR3) || count != 256 || index != 0)
+		return;
+
+	error = (*vidsw[sc->adp->va_index]->save_palette)
+		(sc->adp, (u_char *)data);
+	
+	return;
+}
+
+static int 
+dpysw_configure(int flags)
+{
+	int i;
+	video_adapter_t *adp, *vgadp = NULL;
+	video_info_t *vi;
+	kgi_display_t *dpy;
+	kgi_mode_t *mode;
+	kgi_mmio_region_t *fb;
+	kgi_clut_t *ilut;
+	kgi_marker_t *ptr;
+	kgi_text16_t *text16;
+	dpysw_display_t *sc = &dpysw_sc;
+
+	/* 
+	 * XXX find a VGA or VESA adapter. Should work with any other
+	 * kind of adapter. 
+	 */
+	for (i = 0; (adp = vid_get_adapter(i)) != NULL; ++i) {
+		/* Remember if we find VGA, then continue for VESA. */
+		if (adp->va_type == KD_VGA)
+			vgadp = adp;
+		if (adp->va_flags & V_ADP_VESA) {
+			KRN_DEBUG(1, "dpysw: Found VESA adapter!");
+			break;
+		}
+	}
+
+	if (!adp && vgadp)
+		adp = vgadp;
+
+	if (adp == NULL) {
+		KRN_ERROR("dpysw: no VGA adapter found!");
+		return (ENXIO);
+	}
+
+	memset(sc, 0, sizeof(dpysw_display_t));
+
+	sc->adp = adp;
+	dpy = &sc->dpy;
+
+        dpy->revision = KGI_DISPLAY_REVISION;
+	snprintf(dpy->vendor, KGI_MAX_VENDOR_STRING, "KGI FreeBSD");
+	snprintf(dpy->model, KGI_MAX_VENDOR_STRING, "dpysw");
+	
+	dpy->flags = 0;
+	dpy->mode_size = sizeof(vidsw_mode_t);
+
+	mode = &sc->mode;
+
+	dpy->mode = mode;
+	dpy->id = -1;
+	dpy->graphic = 0;
+	dpy->IncRefcount = dpysw_inc_refcount;
+	dpy->DecRefcount = dpysw_dec_refcount;
+
+	dpy->CheckMode = dpysw_check_mode;
+	dpy->SetMode = dpysw_set_mode;
+	dpy->UnsetMode = dpysw_unset_mode;
+	dpy->Command = dpysw_display_command;
+
+	dpy->focus = NULL;
+
+	/* Initialize mode struct from current mode info. */
+	mode->revision 		= KGI_MODE_REVISION;
+	mode->dev_mode 		= NULL;
+	mode->images 		= 1;
+	mode->img[0].out 	= NULL;
+	mode->img[0].flags 	= KGI_IF_TEXT16;
+	mode->img[0].virt.x 	= adp->va_info.vi_width;
+	mode->img[0].virt.y 	= adp->va_info.vi_height;
+	mode->img[0].size.x 	= adp->va_info.vi_width;
+	mode->img[0].size.y 	= adp->va_info.vi_height;
+	mode->img[0].frames 	= 1;
+	mode->img[0].tluts 	= 0;
+	mode->img[0].aluts 	= 0;
+	mode->img[0].ilutm 	= 0;
+	mode->img[0].alutm 	= 0;
+	mode->img[0].fam 	= 0;
+	mode->img[0].cam 	= 0;
+
+	/* Initialize mmio struct common resource. */
+	fb = &sc->fb;
+
+	fb->meta 		= dpy;
+	fb->type 		= KGI_RT_MMIO_FRAME_BUFFER;
+	fb->prot 		= KGI_PF_APP_RWS | KGI_PF_LIB_RWS | KGI_PF_DRV_RWS;
+	fb->name 		= "Frame buffer";
+	fb->access 		= 8 + 16 + 32 + 64;
+	fb->align 		= 8 + 16;
+	fb->win.size 		= (kgi_size_t)adp->va_window_size;
+	fb->win.virt 		= (kgi_virt_addr_t)adp->va_window;	/* XXX */
+	fb->win.bus 		= (kgi_bus_addr_t)0;			/* XXX */
+	fb->win.phys 		= (kgi_phys_addr_t)adp->va_mem_base;
+	fb->size 		= (kgi_size_t)adp->va_mem_size;
+	fb->offset 		= 0;
+	fb->SetOffset 		= dpysw_set_offset;
+		
+	/* Initialize ilut struct. */
+	ilut = &sc->ilut;
+	
+	ilut->meta 		= dpy;
+	ilut->type 		= KGI_RT_ILUT_CONTROL;
+	ilut->prot 		= KGI_PF_DRV_RWS;
+	ilut->name 		= "ILUT control";
+	ilut->Set 		= dpysw_set_ilut;
+	ilut->Get 		= dpysw_get_ilut;
+	ilut->entries		= 256;
+	ilut->tables		= 1;
+		
+	/* Initialize marker struct. */
+	ptr = &sc->ptr;
+	
+	ptr->meta 		= dpy;
+	ptr->type 		= KGI_RT_POINTER_CONTROL;
+	ptr->prot 		= KGI_PF_DRV_RWS;
+	ptr->name 		= "Pointer control";
+	ptr->modes 		= KGI_MM_TEXT16;
+#if 0
+	ptr->SetShape 		= dpysw_ptr_set_shape;
+#endif
+	ptr->Show 		= dpysw_ptr_show;
+	ptr->Hide 		= dpysw_ptr_hide;
+	ptr->Read 		= dpysw_ptr_read;
+
+	text16 = &sc->text16;
+	
+	/* text16 control. */
+	text16->meta		= dpy;
+	text16->meta_io		= NULL;
+	text16->type		= KGI_RT_TEXT16_CONTROL;
+	text16->prot		= KGI_PF_DRV_RWS;
+	text16->name		= "Text16 control";
+	text16->PutText16	= dpysw_put_text16;
+	
+	/* Initialize KGI mode from current mode. */
+	vi = &sc->adp->va_info;
+	if (vi->vi_flags & V_INFO_GRAPHICS) {
+		switch (vi->vi_mem_model) {
+		case V_INFO_MM_PACKED:
+			mode->img[0].fam = KGI_AM_I;
+			mode->img[0].cam = KGI_AM_COLOR_INDEX;
+			mode->img[0].bpfa[0] = vi->vi_depth;
+			mode->img[0].bpfa[1] = 0;
+			break;
+		case V_INFO_MM_DIRECT:
+			mode->img[0].fam = KGI_AM_RGB;
+			mode->img[0].cam = KGI_AM_COLORS;
+			mode->img[0].bpfa[0] = vi->vi_pixel_fsizes[0];
+			mode->img[0].bpfa[1] = vi->vi_pixel_fsizes[1];
+
+			mode->img[0].bpfa[2] = vi->vi_pixel_fsizes[2];
+			mode->img[0].bpfa[3] = 0;
+			break;
+		case V_INFO_MM_PLANAR:		/* XXX reject planar modes. */
+		default:
+			return (ENODEV);
+			/* NOT REACHED. */
+		}
+
+		ptr->shapes 	= 1;
+		ptr->size.x 	= 64;
+		ptr->size.y 	= 64;
+
+		/* Per image resource. */
+		mode->resource[0] = (kgi_resource_t *) &sc->fb;
+		mode->resource[1] = (kgi_resource_t *) &sc->ilut;
+		mode->resource[2] = (kgi_resource_t *) &sc->ptr;
+
+	} else {
+		if (vi->vi_mem_model != V_INFO_MM_TEXT)
+			return (ENODEV);
+
+		if (vi->vi_flags & V_INFO_COLOR) {
+			mode->img[0].fam = KGI_AM_TEXT;
+			
+			mode->img[0].bpfa[0] = 4;	/* BG color. */
+			mode->img[0].bpfa[1] = 4;	/* FG color. */
+			mode->img[0].bpfa[2] = 8;	/* Texture.  */
+			mode->img[0].bpfa[3] = 0;
+			
+			/* XXX change mode. */
+		} else {
+			mode->img[0].fam = KGI_AM_TEXT | KGI_AM_BLINK;
+
+			mode->img[0].bpfa[0] = 3;	/* Index.    */
+			mode->img[0].bpfa[1] = 4;	/* FG color. */
+			mode->img[0].bpfa[2] = 8;	/* Texture.  */
+			mode->img[0].bpfa[3] = 1;	/* Blink.    */
+			mode->img[0].bpfa[4] = 0;
+
+			/* XXX change mode. */
+		}
+		text16->meta_io		= (void *)adp->va_window;
+		text16->size.x		= adp->va_info.vi_width;
+		text16->size.y		= adp->va_info.vi_height;
+		text16->virt.x		= adp->va_info.vi_width;
+		text16->virt.y		= adp->va_info.vi_height;
+		text16->cell.x		= vi->vi_cwidth;
+		text16->cell.y		= vi->vi_cheight;
+		text16->font.x		= vi->vi_cwidth;
+		text16->font.y		= vi->vi_cheight;
+		
+		/* Per image resource. */
+		mode->resource[0] = (kgi_resource_t *) &sc->fb;
+		mode->resource[1] = (kgi_resource_t *) &sc->text16;
+	}
+
+	if (kgi_register_display(dpy, 0)) {
+		KRN_NOTICE("Could not register vidsw display.\n");
+		return (ENXIO);
+	}
+
+	registered = 1;
+
+	kgy_splash(adp);
+
+	return (0);
+}
+
+static int 
+dpysw_load(void)
+{
+	int error = 0;
+	int s;
+
+	if (registered)
+		return (0);
+
+	s = spltty();
+	error = dpysw_configure(0);
+	splx(s);
+
+	return error;
+}
+
+static int 
+dpysw_unload(void)
+{
+	int s;
+
+	if (!registered)
+		return (0);
+
+	s = spltty();
+	kgi_unregister_display(&dpysw_sc.dpy);
+	splx(s);
+
+	return (0);
+}
+
+static int 
+dpysw_mod_event(module_t mod, int type, void *data)
+{
+	switch (type) {
+	case MOD_LOAD:
+		return dpysw_load();
+	case MOD_UNLOAD:
+		return dpysw_unload();
+	default:
+		break;
+	}
+	return (0);
+}
+
+static moduledata_t dpysw_mod = {
+	"dpysw",
+	dpysw_mod_event,
+	NULL,
+};
+
+/* Add 1 to MIDDLE to take place after VESA module */
+DECLARE_MODULE(dpysw, dpysw_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE + 1);
+MODULE_VERSION(dpysw, 1);
diff -x CVS -x .svn -aurpN sys/dev/kgy/kgy_mode.c sys/dev/kgy/kgy_mode.c
--- sys/dev/kgy/kgy_mode.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgy/kgy_mode.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,355 @@
+/*-
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI vidsw interface display driver
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define KGI_DBG_LEVEL 3
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/fbio.h>
+
+#include <dev/fb/fbreg.h>
+#include <dev/fb/vgareg.h>
+
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgy/kgy.h>
+
+/* 
+ * This is the mode_info used for the console,
+ * it is statically allocated to avoid malloc at init.
+ */
+static video_info_t console_info;
+
+#define	print_img_mode(lvl,img)	KRN_DEBUG(lvl,				\
+	"%ix%i (%ix%i), %i frames, fam=%.8x, bpam (IFTB) = %i%i%i%i",	\
+	img[0].size.x, img[0].size.y, img[0].virt.x, img[0].virt.y,	\
+	img[0].frames, img[0].fam, img[0].bpfa[0], img[0].bpfa[1],	\
+	img[0].bpfa[2], img[0].bpfa[3])
+
+void dpysw_set_mode(kgi_display_t *dpy, kgi_image_mode_t *img, kgi_u_t images,
+	  void *dev_mode)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)dpy;
+	video_info_t *next = &((vidsw_mode_t *)dev_mode)->mode_info;
+	video_info_t *previous = &((vidsw_mode_t *)dev_mode)->oldmode_info;
+	kgi_mmio_region_t *fb;
+	kgi_text16_t *text16;
+	int error = 0;
+
+	/* Set current adapter mode info as previous mode info. */
+	*previous = sc->adp->va_info;
+
+	/* Set video mode from previously checked mode. */
+	error = (*vidsw[sc->adp->va_index]->set_mode)(sc->adp, next->vi_mode);
+	
+	if (error != 0) {
+		KRN_DEBUG(1, "Could not set mode (mode=%d, err=%d).",
+			  next->vi_mode, error);
+		goto error;
+	}
+
+	/* 
+	 * Set the framebuffer characteristics accordingly to the new mode set.
+	 */
+	fb = &sc->fb;
+	text16 = &sc->text16;
+
+	if (next->vi_flags & V_INFO_LINEAR) {
+		fb->win.size = (kgi_size_t)next->vi_buffer_size;
+		fb->win.virt = (kgi_virt_addr_t)sc->adp->va_buffer;
+		fb->win.bus = (kgi_bus_addr_t)0;	/* XXX */
+		fb->win.phys = (kgi_phys_addr_t)next->vi_buffer;
+		fb->size = (kgi_size_t)next->vi_buffer_size;
+
+		text16->meta_io = (void *)sc->adp->va_buffer;
+	} else {
+		fb->win.size = (kgi_size_t)next->vi_window_size;
+		fb->win.virt = (kgi_virt_addr_t)sc->adp->va_window;
+		fb->win.bus = (kgi_bus_addr_t)0;	/* XXX */
+		fb->win.phys = (kgi_phys_addr_t)next->vi_window;
+		fb->size = (kgi_size_t)next->vi_buffer_size/next->vi_planes;
+
+		text16->meta_io = (void *)sc->adp->va_window;
+	}
+	fb->offset = 0;
+
+ error:
+	return;
+}
+
+void dpysw_unset_mode(kgi_display_t *dpy, kgi_image_mode_t *img, kgi_u_t images,
+	  void *dev_mode)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)dpy;
+	video_info_t *next = &((vidsw_mode_t *)dev_mode)->oldmode_info;
+	kgi_mmio_region_t *fb;
+	kgi_text16_t *text16;
+	int error = 0;
+
+	/* Restore previous mode. */
+	error = (*vidsw[sc->adp->va_index]->set_mode)(sc->adp,
+						      next->vi_mode);
+	
+	if (error != 0) {
+		KRN_DEBUG(1, "Could not restore mode (mode=%d,err=%d).",
+			   next->vi_mode, error);
+		goto error;
+	}
+
+	/* 
+	 * Set the framebuffer characteristics accordingly to the new mode set.
+	 */
+	fb = &sc->fb;
+	text16 = &sc->text16;
+
+	if (next->vi_flags & V_INFO_LINEAR) {
+		fb->win.size = (kgi_size_t)next->vi_buffer_size;
+		fb->win.virt = (kgi_virt_addr_t)sc->adp->va_buffer;
+		fb->win.bus = (kgi_bus_addr_t)0;	/* XXX */
+		fb->win.phys = (kgi_phys_addr_t)next->vi_buffer;
+		fb->size = (kgi_size_t)next->vi_buffer_size;
+
+		text16->meta_io = (void *)sc->adp->va_buffer;
+	} else {
+		fb->win.size = (kgi_size_t)next->vi_window_size;
+		fb->win.virt = (kgi_virt_addr_t)sc->adp->va_window;
+		fb->win.bus = (kgi_bus_addr_t)0;	/* XXX */
+		fb->win.phys = (kgi_phys_addr_t)next->vi_window;
+		fb->size = (kgi_size_t)next->vi_buffer_size/next->vi_planes;
+
+		text16->meta_io = (void *)sc->adp->va_window;
+	}
+	fb->offset = 0;
+
+ error:
+	return;
+}
+
+static int 
+dpysw_try_mode(dpysw_display_t *sc, video_info_t *mode_info)
+{
+	int error, flags;
+
+	error = (*vidsw[sc->adp->va_index]->query_mode)(sc->adp, mode_info);
+
+	/* If VESA fails, try standard VGA. */
+	if (error) {
+		/* Save flags. */
+		flags = mode_info->vi_flags;
+
+		/* Remove VESA flags. */
+		mode_info->vi_flags &= ~(V_INFO_VESA | V_INFO_LINEAR);
+
+		error = (*vidsw[sc->adp->va_index]->query_mode)(sc->adp, mode_info);
+		
+		if (error) {
+			/* Restore flags. */
+			mode_info->vi_flags = flags;
+
+			return (KGI_ERRNO(CHIPSET, INVAL));
+		}
+	}
+
+	return (KGI_EOK);
+}
+
+#define	print_img_mode(lvl,img)	KRN_DEBUG(lvl,				\
+	"%ix%i (%ix%i), %i frames, fam=%.8x, bpam (IFTB) = %i%i%i%i",	\
+	img[0].size.x, img[0].size.y, img[0].virt.x, img[0].virt.y,	\
+	img[0].frames, img[0].fam, img[0].bpfa[0], img[0].bpfa[1],	\
+	img[0].bpfa[2], img[0].bpfa[3])
+
+int
+dpysw_check_mode(kgi_display_t *dpy, kgi_timing_command_t cmd,
+	kgi_image_mode_t *img, kgi_u_t images, void *dev_mode, 
+	const kgi_resource_t **r, kgi_u_t rsize)
+{
+#define	DEFAULT(x)	if (! (x)) { x = sc->mode.x; }
+#define	MATCH(x)	((x) == sc->mode.x)
+	dpysw_display_t *sc = (dpysw_display_t *)dpy;
+	video_info_t *mode_info;
+
+	kgi_text16_t *text16;
+	kgi_u_t bpp, bpf, bpc;
+
+	mode_info = (!dev_mode ? &console_info :
+		     &((vidsw_mode_t *)dev_mode)->mode_info);
+
+	bzero(mode_info, sizeof(*mode_info));
+
+	if (images != 1) {
+		KRN_DEBUG(2, "%i image layers are not supported.", images);
+		return (KGI_EINVAL);
+	}
+
+	/*	For unsupported image flags, bail out. */
+	if (img[0].flags & (KGI_IF_VIRTUAL | KGI_IF_VISIBLE | 
+		KGI_IF_TILE_X | KGI_IF_STEREO)) {
+		KRN_DEBUG(1, "Image flags %.8x not supported", img[0].flags);
+		return (KGI_ERRNO(CHIPSET, INVAL));
+	}
+
+	switch (cmd) {
+	case KGI_TC_PROPOSE:
+		KRN_DEBUG(3, "dpysw: proposing original mode for:");
+		print_img_mode(3, img);
+		DEFAULT(img[0].virt.x);
+		DEFAULT(img[0].virt.y);
+		DEFAULT(img[0].size.x);
+		DEFAULT(img[0].size.y);
+		DEFAULT(img[0].frames);
+		DEFAULT(img[0].tluts);
+		DEFAULT(img[0].iluts);
+		DEFAULT(img[0].aluts);
+		if (! img[0].fam) {
+			img[0].fam  = sc->mode.img[0].fam;
+			img[0].cam  = sc->mode.img[0].cam;
+			memcpy(img[0].bpfa, sc->mode.img[0].bpfa,
+			       sizeof(img[0].bpfa));
+			memcpy(img[0].bpca, sc->mode.img[0].bpca,
+			       sizeof(img[0].bpca));
+		}
+		/*	Fall through. */
+	case KGI_TC_CHECK:
+		KRN_DEBUG(3, "dpysw: checking mode:");
+		print_img_mode(3, img);
+
+		if (img[0].fam == KGI_AM_TEXT ||
+		    img[0].flags & KGI_IF_TEXT16) {
+			KRN_DEBUG(2, "Checking a textmode...");
+
+			/* Common attributes are not possible. */
+			if (img[0].cam) {				
+				KRN_DEBUG(1, "Common attributes %.8x not supported",
+					  img[0].cam);
+				return (KGI_ERRNO(CHIPSET, INVAL));
+			}
+			
+			bpp = 0;
+		
+			/* If any of the sizes is null, set default image sizes. */
+			if ((0 == img[0].size.x) || (0 == img[0].size.y)) {
+				img[0].size.x = 80;
+				img[0].size.y = 25;
+			}
+			mode_info->vi_cwidth = 8;
+			mode_info->vi_cheight = 16;
+
+			text16 = &sc->text16;
+
+			text16->size.x		= img[0].size.x;
+			text16->size.y		= img[0].size.y;
+			text16->virt.x		= img[0].size.x;
+			text16->virt.y		= img[0].size.y;
+			text16->cell.x		= mode_info->vi_cwidth;
+			text16->cell.y		= mode_info->vi_cheight;
+			text16->font.x		= mode_info->vi_cwidth;
+			text16->font.y		= mode_info->vi_cheight;
+
+			KRN_NOTICE("text16 set up: size %ix%i, virt %ix%i",
+				   text16->size.x, text16->size.y,
+				   text16->virt.x, text16->virt.y);
+	
+			/* Per image resource. */
+			img[0].resource[0] = (kgi_resource_t *) &sc->text16;
+
+		} else {
+			KRN_DEBUG(2, "Checking a graphic mode...");
+			
+			/* Not a textmode. */
+			bpf = kgi_attr_bits(img[0].bpfa);
+			bpc = kgi_attr_bits(img[0].bpca);
+			bpp = (bpc + bpf * img[0].frames);
+			
+			KRN_DEBUG(2, "bpf = %i, bpc = %i, bpp = %i",
+				  bpf, bpc, bpp);
+			
+			/* 
+			 * Try VESA linear framebuffered mode first, then VGA standard
+			 * modes.
+			 */
+			mode_info->vi_flags |= V_INFO_GRAPHICS | V_INFO_VESA |
+				V_INFO_LINEAR;
+			
+			/*	Check if common attributes are supported. */
+			if (img[0].cam) {
+				KRN_DEBUG(1, "Common attributes %.8x not supported", 
+					  img[0].cam);
+				return (KGI_ERRNO(CHIPSET, INVAL));
+			}
+
+			img[0].resource[0] = (kgi_resource_t *) &sc->ilut;
+			img[0].resource[1] = (kgi_resource_t *) &sc->ptr;
+		}
+		
+		if (img[0].fam & (KGI_AM_COLORS | KGI_AM_COLOR_INDEX))
+			mode_info->vi_flags |= V_INFO_COLOR;
+
+		KRN_DEBUG(2, "dpysw: querying for cwidth = %i, cheight = %i, flags = 0x%x, ",
+			  mode_info->vi_cwidth, mode_info->vi_cheight,
+			  mode_info->vi_flags);
+
+		mode_info->vi_depth = bpp;
+		
+		/* First, try to set the visible size. */
+		mode_info->vi_width = img[0].size.x;
+		mode_info->vi_height = img[0].size.y;
+
+		KRN_DEBUG(2, "dpysw: Visible: width = %i, height = %i, depth = %i ",
+			  mode_info->vi_width, mode_info->vi_height,
+			  mode_info->vi_depth);
+
+		if (dpysw_try_mode(sc, mode_info)) {		
+			/* Try to set the virtual size otherwise. */
+			mode_info->vi_width = img[0].virt.x;
+			mode_info->vi_height = img[0].virt.y;
+
+			KRN_DEBUG(2, "dpysw: Virtual: width = %i, height = %i, depth = %i ",
+				  mode_info->vi_width, mode_info->vi_height,
+				  mode_info->vi_depth);
+			
+			if (dpysw_try_mode(sc, mode_info)) {
+				return (KGI_ERRNO(CHIPSET, INVAL));
+			}
+		}
+
+		KRN_DEBUG(1, "VESA/VGA mode found %dx%dx%d",
+			  mode_info->vi_width, mode_info->vi_height,
+			  mode_info->vi_depth);
+
+		/* Common resource to all kind of modes. */
+		if ((0 < rsize) && r) {
+			r[0] = (kgi_resource_t *) &sc->fb;
+		}
+		break;		
+	default:
+		KRN_INTERNAL_ERROR;
+		return (KGI_ERRNO(CHIPSET, UNKNOWN));
+	}
+
+	return (KGI_EOK);
+}
diff -x CVS -x .svn -aurpN sys/dev/kgy/kgy_splash.c sys/dev/kgy/kgy_splash.c
--- sys/dev/kgy/kgy_splash.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgy/kgy_splash.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,252 @@
+/*-
+ * Copyright (C) 2002-2005 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI textmode colour splash screen.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define KGI_DBG_LEVEL 2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/fbio.h>
+
+#include <dev/fb/fbreg.h>
+#include <dev/fb/vgareg.h>
+
+#define	KGI_SYS_NEED_IO
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgy/kgy.h>
+
+#if defined(__i386__) && !defined(KGI_NOSPLASH)
+
+#define outb_p(data,port) outb(port, data)
+#define inb_p(port) inb(port)
+
+/*
+ * This a Quick&Dirty(TM) Hack to be able to slowdown the printk 
+ * to follow the early kernel boot messages in case there are 
+ * kernel-Ooops's before we have scrollback.
+ */
+static kgi_u32_t msg[] = {
+	0x44333212, 0x12111111, 0x12121112, 0x11121112, 0x12111111,
+	0x12122212, 0x12113444, 0x45454545, 0x55555555, 0x55555555,
+	0x43433323, 0x33222111, 0x11111111, 0x11111111, 0x12211111,
+	0x11112111, 0x11112344, 0x45555555, 0x45545454, 0x55555555,
+	0x46643636, 0x66366611, 0x61121662, 0x16161212, 0x66622266,
+	0x32623262, 0x66626664, 0x46664666, 0x54455666, 0x45656554,
+	0x46464626, 0x22262265, 0x61226236, 0x36262223, 0x62263644,
+	0x64643464, 0x64446446, 0x46445644, 0x64454644, 0x65636354,
+	0x46462646, 0x66366632, 0x62326666, 0x36363412, 0x66643655,
+	0x63636465, 0x66456664, 0x46654645, 0x65354666, 0x54646565,
+	0x56564633, 0x36464444, 0x63436226, 0x22622222, 0x61233643,
+	0x64646364, 0x63456556, 0x46534654, 0x64543644, 0x65464544,
+	0x46653626, 0x66463434, 0x66646336, 0x22621212, 0x61122266,
+	0x34365632, 0x66646436, 0x36663666, 0x33454666, 0x54463464,
+	0x53334242, 0x23444333, 0x33334333, 0x22211111, 0x11111123,
+	0x33332122, 0x21223333, 0x34335343, 0x43454545, 0x44434333,
+	0x45353544, 0x33344444, 0x34545432, 0x32221211, 0x11111123,
+	0x34443302, 0x32323234, 0x45353535, 0x34545454, 0x54444432,
+	0x54534454, 0x54233410, 0x10320202, 0x32444321, 0x11111122,
+	0x31211202, 0x00102223, 0x33344444, 0x44444444, 0x44445443,
+	0x45454545, 0x31331066, 0x66666666, 0x60023032, 0x11122006,
+	0x66666666, 0x66112033, 0x22366664, 0x34343444, 0x44444432,
+	0x55445533, 0x21066666, 0x11101116, 0x66661101, 0x12036666,
+	0x61123033, 0x66666101, 0x32666661, 0x01011212, 0x12121212,
+	0x45454442, 0x26666010, 0x10110112, 0x12120012, 0x00666601,
+	0x00120303, 0x11121101, 0x32666661, 0x01011212, 0x12121212,
+	0x44444432, 0x26666111, 0x01101666, 0x66661102, 0x30666613,
+	0x00330166, 0x66666310, 0x31666661, 0x01111122, 0x21222122,
+	0x44343432, 0x21166666, 0x11111012, 0x66660102, 0x12206666,
+	0x61111101, 0x16666103, 0x21666661, 0x11121212, 0x12323212,
+	0x33222322, 0x20011166, 0x66666666, 0x66632344, 0x31110206,
+	0x66666666, 0x66662131, 0x31666660, 0x01101111, 0x11233322,
+	0x12221212, 0x00101210, 0x12001222, 0x33334444, 0x53311312,
+	0x22311332, 0x12121202, 0x02020201, 0x11111111, 0x11111211,
+	0x11222121, 0x11211111, 0x11111233, 0x33455555, 0x45433344,
+	0x33333321, 0x11111121, 0x11011111, 0x11111011, 0x11111111,
+	0x16661616, 0x16661116, 0x66126336, 0x65564646, 0x66445666,
+	0x36363636, 0x11621662, 0x12166611, 0x66321166, 0x61116612,
+	0x11612626, 0x26111116, 0x11636365, 0x45565655, 0x65554563,
+	0x26262626, 0x61616111, 0x11236226, 0x11611161, 0x16161161,
+	0x34643666, 0x36623236, 0x66446465, 0x66466655, 0x64443363,
+	0x16661616, 0x16616166, 0x12116216, 0x11611161, 0x16161161,
+	0x45645656, 0x56444446, 0x44656564, 0x46565644, 0x64222262,
+	0x16261616, 0x21616116, 0x11116116, 0x11612161, 0x26161161,
+	0x55655646, 0x56663456, 0x54656456, 0x63565632, 0x62121262,
+	0x16161616, 0x12611660, 0x11116111, 0x66121166, 0x62126611,
+	0x55555555, 0x55554554, 0x55555555, 0x55555443, 0x23242124,
+	0x21414333, 0x43333333, 0x33333332, 0x23322323, 0x22312111,
+	0x55555555, 0x55555555, 0x55555555, 0x55555555, 0x55555555,
+	0x55555545, 0x44544544, 0x55444454, 0x44444454, 0x44422424
+};
+
+static kgi_rgb_color_t msg_col[8] = 
+{
+	{ 0, 0, 0}, { 0, 0,13}, { 0, 0,26}, { 0, 0,38},
+	{ 0, 0,51}, { 0, 0,63}, {24, 0,24}, {63,63, 0}
+};
+
+static kgi_rgb_color_t def_col[8] =
+{
+	{ 0, 0, 0}, { 0, 0,42}, { 0,42, 0}, { 0,42,42},
+	{42, 0, 0}, {42, 0,42}, {42,42, 0}, {42,42,42}
+};
+
+static kgi_rgb_color_t curr_col[8] = { };
+
+static void 
+set_col(void)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		outb_p((i == 6) ? 0x14 : i, 0x3C8);
+		outb_p(curr_col[i].r, 0x3C9);
+		outb_p(curr_col[i].g, 0x3C9);
+		while (inb_p(0x3DA) & 1);
+		while (!(inb_p(0x3DA) & 1));
+		outb_p(curr_col[i].b, 0x3C9);
+	}
+
+	if (inb_p(0x3DA) & 8) 
+		while (inb_p(0x3DA) & 8);
+
+	while (!(inb_p(0x3DA) & 8));
+}
+
+static void 
+show_msg(kgi_u16_t *fb, kgi_u_t sizex, kgi_u_t sizey)
+{
+	int line = 0, firstrow = (sizex - 80)/2, i;
+
+	fb += ((sizey - 25)/2)*sizex;
+
+	curr_col[7] = def_col[7];
+	set_col();
+
+	while (line < 25) {
+		int row;
+		kgi_u16_t *p = fb + firstrow;
+
+		for (row = 0; row < 10; row++) {
+			int attr = msg[line*10+row];
+
+			#define SETBG(x) *p = (*p & 0x00FF) | 0x0700\
+						| ((x) & 0xF000); p++
+
+			SETBG(attr>>16);	SETBG(attr>>12);
+			SETBG(attr>>8);		SETBG(attr>>4);
+			SETBG(attr);		SETBG(attr<<4);
+			SETBG(attr<<8);		SETBG(attr<<12);
+		}
+
+		fb += sizex;
+		line++;
+	}
+
+	for (i = 0; i < 100; i++) {
+		int reg;
+
+		for (reg = 0; reg < 7; reg++) {
+			curr_col[reg].r = msg_col[reg].r*i/100;
+			curr_col[reg].g = msg_col[reg].g*i/100;
+			curr_col[reg].b = msg_col[reg].b*i/100;
+		}
+
+		curr_col[7].r = (msg_col[7].r-def_col[7].r)*i/100+def_col[7].r;
+		curr_col[7].g = (msg_col[7].g-def_col[7].g)*i/100+def_col[7].g;
+		curr_col[7].b = (msg_col[7].b-def_col[7].b)*i/100+def_col[7].b;
+		set_col();
+	}
+
+	for (i = 0; i < 100; i++) {
+		curr_col[6].r = (63 - msg_col[6].r)*i/100 + msg_col[6].r;
+		curr_col[6].g = (63 - msg_col[6].g)*i/100 + msg_col[6].g;
+		curr_col[6].b = ( 0 - msg_col[6].b)*i/100 + msg_col[6].b;
+		set_col();
+	}
+
+	for (i = 0; i < 100; i++) {
+		curr_col[6].r = (msg_col[6].r - 63)*i/100 + 63;
+		curr_col[6].g = (msg_col[6].g - 63)*i/100 + 63;
+		curr_col[6].b = (msg_col[6].b -  0)*i/100 +  0;
+		set_col();
+	}
+}
+
+static void 
+hide_msg(kgi_u16_t *fb, kgi_u_t sizex, kgi_u_t sizey)
+{
+	int i;
+
+	for (i = 100; i >= 0; i--) {
+		int reg;
+
+		for (reg = 0; reg < 7; reg++) {
+			curr_col[reg].r = msg_col[reg].r*i/100;
+			curr_col[reg].g = msg_col[reg].g*i/100;
+			curr_col[reg].b = msg_col[reg].b*i/100;
+		}
+
+		curr_col[7].r = (msg_col[7].r-def_col[7].r)*i/100+def_col[7].r;
+		curr_col[7].g = (msg_col[7].g-def_col[7].g)*i/100+def_col[7].g;
+		curr_col[7].b = (msg_col[7].b-def_col[7].b)*i/100+def_col[7].b;
+
+		set_col();
+	}
+
+	i = sizex*sizey;
+
+	while (i--) {
+		*fb = (*fb & 0x00FF) | 0x0700;
+		fb++;
+	}
+
+	for (i = 0; i < 8; i++) 
+		curr_col[i] = def_col[i];
+
+	set_col();
+}
+
+#endif /* __i386__ && !KGI_NOSPLASH */
+
+#define ORIG_VIDEO_COLS (adp->va_info.vi_width)
+#define ORIG_VIDEO_LINES (adp->va_info.vi_height)
+
+void 
+kgy_splash(video_adapter_t *adp)
+{
+
+#if defined(__i386__) && !defined(KGI_NOSPLASH)
+
+	show_msg((kgi_u16_t *)adp->va_window, ORIG_VIDEO_COLS, ORIG_VIDEO_LINES);
+	kgi_udelay(1000000);
+
+	hide_msg((kgi_u16_t *)adp->va_window, ORIG_VIDEO_COLS, ORIG_VIDEO_LINES);
+
+#endif /* __i386__ && !KGI_NOSPLASH */
+
+	return;
+}
diff -x CVS -x .svn -aurpN sys/dev/kgy/kgy_text16.c sys/dev/kgy/kgy_text16.c
--- sys/dev/kgy/kgy_text16.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kgy/kgy_text16.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,88 @@
+/*-
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI vidsw interface display driver
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/fbio.h>
+
+#include <dev/fb/fbreg.h>
+#include <dev/fb/vgareg.h>
+
+#define	KGI_SYS_NEED_IO
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#include <dev/kgy/kgy.h>
+
+void dpysw_load_font(kgi_text16_t *r, kgi_u_t page, kgi_u_t size,
+		     kgi_u_t width, kgi_u8_t *data, kgi_u_t ch, kgi_s_t count)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->load_font)
+		(sc->adp, (int) page, (int)size, (int)width, (u_char *)data,
+		 (int)ch, (int)count);
+	
+	return;
+}
+
+void dpysw_save_font(kgi_text16_t *r, kgi_u_t page, kgi_u_t size, kgi_u_t width,
+			 kgi_u8_t *data, kgi_u_t ch, kgi_s_t count)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->save_font)
+		(sc->adp, (int) page, (int)size, (int)width, (u_char *)data,
+		 (int)ch, (int)count);
+	
+	return;
+}
+
+void 
+dpysw_show_font(kgi_text16_t *r, kgi_u_t page)
+{
+	dpysw_display_t *sc = (dpysw_display_t *)r->meta;
+	int error;
+
+	error = (*vidsw[sc->adp->va_index]->show_font)
+		(sc->adp, (int) page);
+	
+	return;
+}
+
+void 
+dpysw_put_text16(kgi_text16_t *text16, kgi_u_t offset, const kgi_u16_t *text,
+	  kgi_u_t count)
+{
+	register kgi_u16_t *fb = text16->meta_io;
+	KRN_ASSERT(offset < 4096);
+	KRN_ASSERT(offset + count < 4096);
+	mem_put16((mem_vaddr_t) (fb + offset), text, count);
+}
diff -x CVS -x .svn -aurpN sys/dev/kii/event.h sys/dev/kii/event.h
--- sys/dev/kii/event.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/event.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,62 @@
+/*-
+ * Copyright (C) 2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * IT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * /dev/event resource mapper definition
+ */
+
+#ifndef _kii_event_h
+#define	_kii_event_h
+
+#define	EVENT_MAJOR	61
+#define	EVENT_NAME	"event"
+
+typedef struct event_file_s	event_file_t;
+typedef struct event_device_s	event_device_t;
+
+/*
+ * A device represents the actual device.
+ */
+#define	EVENT_DEVICE_SIZE	PAGE_SIZE
+
+#define	EVENT_QUEUE_SIZE	PAGE_SIZE
+
+struct event_device_s {
+	kii_u_t		id;
+	kii_device_t	kii;
+	struct mtx	cmd_mutex;
+	event_file_t	*files;
+};
+
+/*
+ * A file is a particular virtual view of a device.
+ */
+typedef enum {
+	EVENT_FF_CLIENT_IDENTIFIED	= 0x00000001,
+	EVENT_FF_SESSION_LEADER		= 0x00000002,
+	EVENT_FF_QUEUE_OVERRUN		= 0x00000004
+} event_file_flags_t;
+
+struct event_file_s {
+	event_file_t	*next;
+
+	unsigned long refcnt;
+	event_file_flags_t	flags;
+
+	kii_u_t		device_id;
+	kii_u_t		previous;
+
+	event_device_t	*device;
+
+	struct	{
+		kii_u_t		head, tail, size;
+		kii_u8_t	*buffer;
+	}		queue;
+};
+
+#endif /* #ifndef _kii_event_h */
diff -x CVS -x .svn -aurpN sys/dev/kii/kii.h sys/dev/kii/kii.h
--- sys/dev/kii/kii.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kii.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,489 @@
+/*-
+ * Copyright (C) 1995-1996 Andreas Beck
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2002-2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * KII manager interface definitions.
+ */
+
+#ifndef _KII_KII_H
+#define _KII_KII_H
+
+#include <dev/kgi/system.h>
+
+KGI_SYS_DECLARE_INTEGRAL_TYPES(kii)
+
+typedef struct { 
+	kii_s_t x,y;
+} kii_scoord_t;
+
+typedef struct {
+	kii_u8_t major, minor, patch, extra;
+} kii_version_t;
+
+#include <dev/kii/kiierr.h>
+
+#ifdef KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kiisyms.h>
+#endif
+
+typedef enum {
+	KII_IC_NULL = 0,
+
+	KII_IC_KEYBOARD = 0,		/* Character input devices.	*/
+		KII_IT_KEYBOARD,	/* A simple keyboard.		*/
+		KII_IT_VOICE,		/* Voice recognition. 		*/
+
+	KII_IC_2DPOINTER = 0x10000000,	/* Simple 2D pointing devices.	*/
+		KII_IT_MOUSE,		/* All kinds of mice.		*/
+		KII_IT_TRACKBALL,	/* A mouse on it's back. ;-)	*/
+		KII_IT_DIGITIZER,	/* Digitizer boards with pen.	*/
+		KII_IT_LIGHTPEN,	/* Are there any left?		*/
+		KII_IT_JOYSTICK,	/* The thing used for gaming.	*/
+
+	KII_IC_3DPOINTER = 0x20000000,	/* 3D pointing devices.	 	*/
+		KII_IT_3DMOUSE,
+
+	KII_IC_CONTROLLER = 0x30000000,	/* Any other stuff.		*/
+		KII_IT_DATAGLOVE,
+		KII_IT_VR_HELMET,
+
+	KII_IC_KEYPAD = 0x40000000,	/* Character input but no kbd.	*/
+
+	KII_IC_MASK = 0x70000000	/* Mask to get class.		*/
+} kii_type_t;
+
+typedef enum {
+	KII_EV_NOTHING	= 0x00000000,
+	KII_EV_COMMAND,
+	KII_EV_BROADCAST,
+	KII_EV_DEVICE_INFO,
+
+	KII_EV_RAW_DATA,
+
+	KII_EV_KEY_PRESS,
+	KII_EV_KEY_RELEASE,
+	KII_EV_KEY_REPEAT,
+	KII_EV_KEY_STATE,
+
+	KII_EV_PTR_RELATIVE,
+	KII_EV_PTR_ABSOLUTE,
+	KII_EV_PTR_BUTTON_PRESS,
+	KII_EV_PTR_BUTTON_RELEASE,
+	KII_EV_PTR_STATE,
+
+	KII_EV_VAL_RELATIVE,
+	KII_EV_VAL_ABSOLUTE,
+	KII_EV_VAL_STATE,
+
+	KII_EV_LAST
+} kii_event_type_t;
+
+
+typedef enum {
+	KII_KBD_KEYMAP0		= 0x00000000,
+	KII_KBD_KEYMAP_FIRST	= 0x00000000,
+	KII_KBD_KEYMAP_LAST	= 0x000000FF,
+	KII_KBD_MIN_KEYCODE	= 0x00000100,
+	KII_KBD_MAX_KEYCODE	= 0x00000102,
+	KII_KBD_MAX_MAPSIZE	= 0x00000103,
+	KII_KBD_MAPSIZE		= 0x00000104,
+	KII_KBD_CLICK		= 0x00000105,
+	KII_KBD_BELL_PITCH	= 0x00000106,
+	KII_KBD_BELL_DURATION	= 0x00000107,
+	KII_KBD_AUTO_RATE	= 0x00000108,
+	KII_KBD_AUTO_DELAY	= 0x00000109,
+	KII_KBD_LEDS		= 0x0000010A,
+
+	KII_PTR_BUTTON0		= 0x00000110,
+	KII_PTR_ACCEL_MUL	= 0x00000120,
+	KII_PTR_ACCEL_DIV	= 0x00000121,
+	KII_PTR_ACCEL_TRESHOLD	= 0x00000122,
+
+	KII_LAST
+} kii_enum_t;
+
+typedef enum {
+	/* Event masks. */
+	KII_EM_NOTHING			= (1 << KII_EV_NOTHING),
+	KII_EM_COMMAND			= (1 << KII_EV_COMMAND),
+	KII_EM_BROADCAST		= (1 << KII_EV_BROADCAST),
+	KII_EM_DEVICE_INFO		= (1 << KII_EV_DEVICE_INFO),
+
+	KII_EM_RAW_DATA			= (1 << KII_EV_RAW_DATA),
+
+	KII_EM_KEY_PRESS		= (1 << KII_EV_KEY_PRESS),
+	KII_EM_KEY_RELEASE		= (1 << KII_EV_KEY_RELEASE),
+	KII_EM_KEY_REPEAT		= (1 << KII_EV_KEY_REPEAT),
+	KII_EM_KEY_STATE		= (1 << KII_EV_KEY_STATE),
+
+	KII_EM_PTR_RELATIVE		= (1 << KII_EV_PTR_RELATIVE),
+	KII_EM_PTR_ABSOLUTE		= (1 << KII_EV_PTR_ABSOLUTE),
+	KII_EM_PTR_BUTTON_PRESS		= (1 << KII_EV_PTR_BUTTON_PRESS),
+	KII_EM_PTR_BUTTON_RELEASE	= (1 << KII_EV_PTR_BUTTON_RELEASE),
+	KII_EM_PTR_STATE		= (1 << KII_EV_PTR_STATE),
+
+	KII_EM_VAL_RELATIVE		= (1 << KII_EV_VAL_RELATIVE),
+	KII_EM_VAL_ABSOLUTE		= (1 << KII_EV_VAL_ABSOLUTE),
+	KII_EM_VAL_STATE		= (1 << KII_EV_VAL_STATE),
+
+	KII_EM_KEY	= KII_EM_KEY_PRESS | KII_EM_KEY_RELEASE |
+		KII_EM_KEY_REPEAT,
+	KII_EM_KEYBOARD	= KII_EM_KEY | KII_EM_KEY_STATE,
+
+	KII_EM_PTR_MOVE	= KII_EM_PTR_RELATIVE | KII_EM_PTR_ABSOLUTE,
+	KII_EM_PTR_BUTTON = KII_EM_PTR_BUTTON_PRESS | KII_EM_PTR_BUTTON_RELEASE,
+	KII_EM_POINTER	= KII_EM_PTR_MOVE | KII_EM_PTR_BUTTON | 
+		KII_EM_PTR_STATE,
+
+	KII_EM_VALUATOR	= KII_EM_VAL_RELATIVE | KII_EM_VAL_ABSOLUTE |
+		KII_EM_VAL_STATE,
+
+	KII_EM_ALL	= ((1 << KII_EV_LAST) - 1) & ~KII_EM_NOTHING
+} kii_event_mask_t;
+
+
+#define	KII_KBD_KEYMAP(n)	(KII_KBD_KEYMAP0 + (n))
+#define	KII_PTR_BUTTON(n)	(KII_PTR_BUTTON0 + (n))
+
+/*
+ * There may be up to 16 modifiers. You don't have more then ten fingers
+ * anyway.
+ */
+#define	KII_MODIFIER(sym)		((sym) & 15)
+
+#define	KII_IS_NORMAL_MODIFIER(sym)	(((sym) & ~15) == K_FIRST_NORMAL)
+#define	KII_IS_LOCKED_MODIFIER(sym)	(((sym) & ~15) == K_FIRST_LOCKED)
+#define	KII_IS_STICKY_MODIFIER(sym)	(((sym) & ~15) == K_FIRST_STICKY)
+
+#define	KII_IS_MODIFIER(sym)		(KII_IS_NORMAL_MODIFIER(sym) || \
+					 KII_IS_LOCKED_MODIFIER(sym) || \
+					 KII_IS_STICKY_MODIFIER(sym))
+
+
+
+
+/*
+ * The event structs.
+ * 
+ *  NOTE We depend on __KII_MODIFIER_DATA being declared _directly_ after
+ * __KII_COMMON_DATA.
+ */
+#define	__KII_MODIFIER_DATA\
+	kii_u16_t	effect;		/* current modifiers in effect	*/\
+	kii_u16_t	normal;		/* normal modifiers		*/\
+	kii_u16_t	locked;		/* locked modifiers		*/\
+	kii_u16_t	sticky		/* sticky modifiers		*/
+
+#define	__KII_COMMON_DATA\
+	kii_u8_t	size;		/* size of event in bytes	*/\
+	kii_u8_t	type;		/* type of this event		*/\
+	kii_u8_t	focus;		/* focus this is reported from	*/\
+	kii_u8_t	device;		/* who sent this		*/\
+	kii_u32_t	time;		/* timestamp			*/\
+	kii_u_t		dontdispatch	/* 1 if no put_event            */
+
+/*
+ * This information is reported with all events. Use the <any> field
+ * in a kii_event structure to access these fields.
+ */ 
+typedef struct {
+	__KII_COMMON_DATA;
+} kii_any_event_t;
+
+/*
+ * The recipient must not store references to the data.
+ * If the data information is needed afterwards, copy it!
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	kii_u32_t	code;		/* Command/request code.		*/
+	kii_u8_t	data[1];	/* Command related data.		*/
+} kii_cmd_event_t;
+
+/*
+ * This reports a block of raw data received from the device. The
+ * maximum number of bytes is limited so that the event struct is
+ * not more than 256 bytes.
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	kii_u8_t	data[255 - sizeof(kii_any_event_t)];
+} kii_raw_event_t;
+
+/*
+ * Key events should be used to report events obtained from keys
+ * and other switches. 
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	__KII_MODIFIER_DATA;
+	kii_u32_t	sym;		/* Action(effective, keycode)	*/
+	kii_u32_t	code;		/* Key pressed.			*/
+} kii_key_event_t;
+
+/*
+ * This is used to report change of pointer position. Depending
+ * on the event type, the values are either absolute or relative.
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	__KII_MODIFIER_DATA;	/* Current state of modifiers.*/
+	kii_s32_t	x, y;		/* Absolute/relative position.*/
+	kii_s32_t	wheel;		/* Absolute/relative wheel.	*/
+
+	kii_u32_t	dummy[2];	/* Reserved (future extensions)	*/ 
+} kii_pmove_event_t;
+
+/*
+ * Button events are sent to report a change in pointer button state: 
+ * Bit#0 = primary button (usually left)
+ * Bit#1 = secondary button (usually right)
+ * Bit#2 = tertiary buttin (usually middle)
+ * All further button in some "logical" ordering from then on.
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	__KII_MODIFIER_DATA;	/* Current state of modifiers.	*/
+	kii_u32_t	state;		/* New button state.		*/
+	kii_u32_t	button;		/* Button(s) that caused event.	*/
+} kii_pbutton_event_t;
+
+/*
+ * Valuator events report a change of up to 32 of the input device
+ * valuators. Only a range of 32 valuators beginning from first
+ * can be reported with one event. For performance reasons, only
+ * changed values are reported in value[] thus you can't use
+ * (num - first) as index to get info for valuator (num).
+ */
+typedef struct {
+	__KII_COMMON_DATA;
+
+	kii_u32_t	first;		/* First valuator reported.	*/
+	kii_u32_t	changed;	/* Valuators that are reported.	*/
+	kii_u32_t	value[32];	/* Absolute/relative values.	*/
+} kii_val_event_t;
+
+typedef union {
+	kii_u8_t		size;		/* Size of this event.	*/
+
+	kii_any_event_t		any;		/* Access COMMON_DATA.	*/
+	kii_cmd_event_t		cmd;		/* Command/broadcast.	*/
+	kii_raw_event_t		raw;		/* Raw data event.	*/
+	kii_val_event_t		val;		/* Valuator change.	*/
+	kii_key_event_t		key;		/* Key press/release.	*/
+	kii_pmove_event_t	pmove;		/* Pointer move.		*/
+	kii_pbutton_event_t	pbutton;	/* Pointer buttons.	*/
+} kii_event_t;
+
+#ifdef	_KERNEL
+
+#define	KII_MAX_KEYMAP_MEMORY	32768	/* bytes			*/
+#define	KII_MAX_NR_FOCUSES	CONFIG_KGII_MAX_NR_FOCUSES
+#define	KII_MAX_NR_CONSOLES	CONFIG_KGII_MAX_NR_CONSOLES
+#define	KII_MAX_NR_DEVICES	CONFIG_KGII_MAX_NR_DEVICES
+#define	KII_MAX_NR_INPUTS	CONFIG_KGII_MAX_NR_INPUTS
+
+#define	KII_INVALID_FOCUS	INVALID_FOCUS
+#define	KII_INVALID_CONSOLE	INVALID_CONSOLE
+#define	KII_INVALID_INPUT	INVALID_INPUT
+#define	KII_INVALID_DEVICE	INVALID_DEVICE
+
+typedef struct kii_input_s kii_input_t;
+
+#define KII_MAX_VENDOR_STRING	64
+#define KII_MAX_MODEL_STRING	64
+
+struct kii_input_s {
+	kii_input_t		*next;	/* Next in linked list.		*/
+	kii_u_t			focus;	/* The focus we belong to.	*/
+	kii_u_t			id;	/* Unique input device ID.	*/
+	kii_event_mask_t	events;	/* Event types generated.	*/
+	kii_event_mask_t	report;	/* Events to report.		*/
+
+	kii_ascii_t	vendor[KII_MAX_VENDOR_STRING];	/* Who built this device.	*/
+	kii_ascii_t	model[KII_MAX_MODEL_STRING];	/* What model.			*/
+
+	int	(*Command)(kii_input_t *, kii_u_t cmd, void *);
+	int	(*Poll)(kii_input_t *);
+	void	(*Parse)(kii_input_t *, kii_event_t *, int);
+
+	kii_private_t	priv;
+};
+
+#define	KII_VALID_FOCUS_ID(x)	((x) < KII_MAX_NR_FOCUSES)
+#define	KII_VALID_CONSOLE_ID(x)	((x) < KII_MAX_NR_CONSOLES)
+#define	KII_VALID_INPUT_ID(x)	((x) < KII_MAX_NR_INPUTS)
+#define	KII_VALID_DEVICE_ID(x)	((x) < KII_MAX_NR_DEVICES)
+
+typedef struct {
+	kii_unicode_t	diacr;
+	kii_unicode_t	base;
+	kii_unicode_t	combined;
+} kii_dead_combination_t;
+
+typedef struct {
+	kii_u_t	 fn_buf_size;	/* Size of fn_key string buffer.	*/
+	kii_ascii_t *fn_buf;	/* fn_key string buffer.		*/
+
+	kii_u_t	fn_str_size;	/* Size of function key string buffer.	*/
+	kii_ascii_t **fn_str;	/* ptr to arr of ptrs to strings.	*/
+
+	kii_u_t	keymin, keymax;	/* Min/Max key values accepted.		*/
+	kii_u_t	keymap_size;	/* Size of keymap array.			*/
+	kii_unicode_t **keymap;	/* The keymaps.				*/
+
+	kii_u_t	combine_size;
+	kii_dead_combination_t *combine;
+} kii_keymap_t;
+
+typedef enum {
+	KII_FF_SCROLL_LOCK		= 0x00000001,
+	KII_FF_CAPS_SHIFT		= 0x00000002,
+	KII_FF_NUM_LOCK			= 0x00000004,
+	KII_FF_LED_FLAGS		= 0x000000FF,
+	KII_FF_HAS_POINTER		= 0x00000100,
+	KII_FF_PROCESS_BH		= 0x00000200,
+	KII_FF_SYSTEM_REQUEST	= 0x00000400
+} kii_focus_flags_t;
+
+typedef enum {
+	KII_DF_SCROLL_LOCK	= 0x00000001,
+	KII_DF_CAPS_SHIFT	= 0x00000002,
+	KII_DF_NUM_LOCK		= 0x00000004,
+	KII_DF_LED_FLAGS	= 0x000000FF,
+	KII_DF_FOCUSED		= 0x00000100,
+	KII_DF_CONSOLE		= 0x00000200,
+	KII_DF_CLONED		= 0x00000400
+} kii_device_flags_t;
+
+typedef struct kii_device_s kii_device_t;
+
+struct kii_device_s {
+	kii_u_t			id;
+	kii_u_t			focus_id;
+	void			*tty;
+	kii_device_flags_t	flags;
+	kii_event_mask_t	event_mask;
+	kii_private_t		priv;
+
+	void	(*MapDevice)(kii_device_t *);
+	kii_s_t	(*UnmapDevice)(kii_device_t *);
+
+	void (*HandleEvent)(kii_device_t *, kii_event_t *);
+
+	kii_scoord_t	ptr;
+	kii_scoord_t	ptr_min;
+	kii_scoord_t	ptr_max;
+
+	kii_private_t	spawnpid;
+	kii_private_t	spawnsig;
+};
+
+typedef struct {
+	kii_u_t		id;		/* Unique focus ID.		*/
+	kii_device_t	*focus;		/* Focused device.		*/
+	kii_u_t		curr_console;	/* Current device.		*/
+	kii_u_t		last_console;	/* Last device focused on.	*/
+	kii_u_t		want_console;	/* Device to focus on.		*/
+
+	kii_input_t	*inputs;	/* Input devices.		*/
+
+	__KII_MODIFIER_DATA;		/* Modifier information.		*/
+	kii_u_t		down_mod[16];	/* Modifier counters.		*/
+	kii_keymap_t	kmap;		/* Key map info.			*/
+
+	kii_focus_flags_t flags;	/* Focus-global flags.		*/
+
+	kii_u_t		ptr_buttons;	/* Pointer button state.		*/
+	kii_scoord_t	ptr;		/* Pointer hot spot position.	*/
+	kii_scoord_t	ptr_max;	/* Pointer hot spot window.	*/
+	kii_scoord_t	ptr_min;	/* Pointer hot spot window.	*/
+
+	kii_unicode_t	npadch;		/* keysym assembled on keypad.	*/
+	kii_unicode_t	dead;		/* Pending dead/compose keysym.	*/
+	void		*pt_regs;	/* Argument for show_regs.	*/
+
+	kii_u_t		next_input_id;
+	kii_u8_t	*console_map;
+	kii_u8_t	*graphic_map;
+	kii_u8_t	focus_graph[KII_MAX_NR_CONSOLES];
+} kii_focus_t;
+
+typedef enum {
+	KII_SYNC_LED_FLAGS    = 0x00000001,
+	KII_SYNC_PTR_POSITION = 0x00000002,
+	KII_SYNC_PTR_WINDOW	  = 0x00000004,
+	KII_SYNC_PTR_BUTTONS  = 0x00000008
+} kii_sync_flags_t;
+
+
+
+extern kii_device_t *kiidevice[KII_MAX_NR_DEVICES];
+extern kii_focus_t  *kiifocus[KII_MAX_NR_FOCUSES];
+
+extern void kii_bottomhalf(void);
+
+/* XXX currently implemented by kip. */
+extern void kii_handle_input(kii_event_t *event);
+
+extern void kii_action(kii_focus_t *f, kii_event_t *event);
+extern void kii_put_event(kii_focus_t *f, kii_event_t *event);
+
+extern kii_error_t kii_register_input(kii_u_t focus, kii_input_t *dev, int reset);
+extern void kii_unregister_input(kii_input_t *dev);
+
+extern kii_error_t kii_register_device(kii_device_t *dev, kii_u_t index);
+extern void kii_unregister_device(kii_device_t *dev);
+
+extern kii_device_t *kii_clone_console(kii_u_t source, kii_u_t target);
+extern kii_error_t kii_delete_clone(kii_u_t dev_id);
+
+extern void kii_map_device(kii_u_t dev_id);
+extern kii_s_t kii_unmap_device(kii_u_t dev_id);
+
+/*
+ * The proper prototype is int kii_focus_of_task(struct task_struct *);
+ * However, including the scheduler is not desireable.
+ */
+extern kii_s_t kii_focus_of_task(void *);
+extern kii_device_t *kii_current_focus(kii_u_t focus_id);
+extern kii_s_t kii_console_device (kii_s_t focus_id);
+extern void kii_poll_device(kii_u_t dev_id, kii_event_t *event);
+
+extern const kii_ascii_t *kiidev_get_fnstring(kii_device_t *dev, kii_u_t key);
+extern kii_focus_t *kiidev_focus(kii_s_t dev_id);
+extern void kiidev_sync(kii_device_t *dev, kii_sync_flags_t what);
+extern void kiidev_set_pointer_window(kii_device_t *dev, 
+	kii_s_t minx, kii_s_t maxx, kii_s_t miny, kii_s_t maxy);
+
+extern kii_unicode_t keymap_get_keysym(kii_keymap_t *k, kii_u_t shift, kii_u_t key);
+extern kii_s_t keymap_set_keysym(kii_keymap_t *k, kii_u_t shift, kii_u_t key, kii_unicode_t sym);
+extern kii_s_t keymap_set_default(kii_u_t shift, kii_u_t key, kii_unicode_t sym);
+extern const kii_ascii_t *keymap_get_fnstring(kii_keymap_t *k, kii_u_t key);
+extern kii_error_t keymap_set_fnstring(kii_keymap_t *k, kii_u_t key, const kii_ascii_t *s);
+
+extern kii_keymap_t default_kii_keymap;
+extern void keymap_reset(kii_keymap_t *k);
+extern kii_unicode_t keymap_toggled_case(kii_unicode_t sym);
+extern kii_unicode_t keymap_combine_dead(kii_keymap_t *k,
+					 kii_unicode_t diacr, kii_unicode_t base);
+extern kii_s_t keymap_set_default_keysym(kii_u_t shift, kii_u_t key,
+					 kii_unicode_t sym);
+
+#endif /* #ifdef _KERNEL */
+
+#include <dev/kii/kiicmd.h>
+
+#endif /* #ifdef _KII_KII_H */
diff -x CVS -x .svn -aurpN sys/dev/kii/kii_action.c sys/dev/kii/kii_action.c
--- sys/dev/kii/kii_action.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kii_action.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,339 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KII console input manager
+ */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define KGI_SYS_NEED_MALLOC
+#define KGI_SYS_NEED_PROC
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+static int vt_dont_switch = 0;	/* XXX should be in vt.c */
+
+/*
+ * Kernel input actions.
+ */
+
+static void 
+make_sound(kii_focus_t *f, kii_u_t frequency, kii_u_t duration)
+{
+
+	KRN_DEBUG(2, "make_sound() not implemented yet!");
+}
+
+/*
+ * This routine runs with all interrupts enabled and does all the things
+ * that may have to be done in response to a handled event, but may take
+ * a reasonably long time.
+ */
+void 
+kii_bottomhalf(void)
+{
+	kii_u_t i;
+
+	for (i = 0; i < KII_MAX_NR_FOCUSES; i++) {
+		kii_s_t dev;
+		kii_focus_t *f;
+
+		f = kiifocus[i];
+		if (f == NULL)
+			continue;
+
+		if (vt_dont_switch)
+			goto ignore;
+
+		/* 
+		 * If the focus has no dev or what we have differs from what
+		 * we want (console vs graphic), then force switch.
+		 */
+		if (f->focus == NULL)
+			goto apply;
+
+		if (!((f->flags & KII_FF_PROCESS_BH) &&
+		      KII_VALID_DEVICE_ID(f->want_console) &&
+		      (f->want_console != f->focus->id)))
+			goto ignore;
+
+	apply:	
+		if (KII_VALID_CONSOLE_ID(f->want_console))
+			dev = f->console_map[f->want_console];
+		else
+			dev = f->graphic_map[f->want_console - KII_MAX_NR_CONSOLES];
+		
+		/*
+		 * Only check for kiidevice not wanting to introduce
+		 * on kgidevice. If the kgi device doesn't exist
+		 * unmap will fail anyway.
+		 */
+		if (kiidevice[dev] == NULL) {
+			/* 
+			 * Converted from a KRN_ERROR to KRN_DEBUG
+			 * to avoid verbosity with syscons.
+			 */
+			KRN_DEBUG(20, "Invalid device %i (console %i)", 
+				  dev, f->want_console);
+			f->want_console = KII_INVALID_CONSOLE;
+			continue;
+		}
+
+		f->flags &= ~KII_FF_PROCESS_BH;
+
+		switch (kii_unmap_device(dev)) {
+		case KII_EINVAL:
+			f->want_console = KII_INVALID_CONSOLE;
+		case KII_EAGAIN:
+			continue;
+		case KII_EOK:
+			break;
+		default:
+			KRN_INTERNAL_ERROR;
+		}
+
+		/* 
+		 * Don't bother about KGI device, allow usage of /dev/event alone.
+		 */
+		kgi_unmap_device(dev);
+#ifdef dont_bother
+		switch (kgi_unmap_device(dev)) {
+		case KII_EINVAL:
+			f->want_console = KII_INVALID_CONSOLE;
+		case KII_EAGAIN:
+			KRN_DEBUG(2, "Could not unmap kgi device %i", dev);
+
+			/* Map at least the input to let a chance to blind commands. */
+			kii_map_device(f->curr_console);
+			continue;
+		case KII_EOK:
+			break;
+		default:
+			KRN_INTERNAL_ERROR;
+		}
+#endif
+
+		kii_map_device(dev);
+		kgi_map_device(dev);
+
+		f->last_console = f->curr_console;
+		f->curr_console = f->want_console;
+
+	ignore:
+		f->want_console = KII_INVALID_CONSOLE;
+	}
+}
+
+static void 
+do_bottomhalf(void)
+{
+	
+	/* Wakeup the KGI daemon to process the event. */
+	kgi_wakeup(&kgiproc);
+}
+
+static void 
+do_special(kii_focus_t *f, kii_event_t *event)
+{
+	u_int curdev;
+
+	if (event->any.type != KII_EV_KEY_PRESS) 
+		return;
+
+	KRN_DEBUG(6, "Doing special key sym=%.4x code=%d effect=%d", event->key.sym,
+		  event->key.code, event->key.effect);
+
+	switch(event->key.sym) {
+	case K_VOID:
+	case K_ENTER:
+		return;
+	case K_CONS:
+		if (!KII_VALID_CONSOLE_ID(f->want_console) &&
+			KII_VALID_CONSOLE_ID(f->last_console)) {
+			f->want_console = f->last_console;
+			f->flags |= KII_FF_PROCESS_BH;
+			do_bottomhalf();
+		}
+		return;
+	case K_CAPS:
+		f->flags ^= KII_FF_CAPS_SHIFT;
+		return;
+	case K_BOOT:		
+		if ((curdev = kgi_current_devid(0)) != -1) {
+			kgi_unmap_device(curdev);
+		}
+		kgi_map_device(0);
+
+		shutdown_nice(0);
+
+		/* NOT REACHED */
+	case K_CAPSON:
+		f->flags |= KII_FF_CAPS_SHIFT;
+		return;
+	case K_COMPOSE:
+		f->dead = K_COMPOSE;
+		return;
+	case K_DECRCONSOLE: {
+		register kii_s_t start, search;
+
+		if (!KII_VALID_CONSOLE_ID(f->curr_console)) {
+			search = (start = KII_MAX_NR_CONSOLES - 1) - 1;
+		} else {
+			search = ((start = f->curr_console) > 0)
+				? f->curr_console - 1 : KII_MAX_NR_CONSOLES - 1;
+		}
+
+		while ((search != start) && !(
+			(KII_VALID_DEVICE_ID(f->console_map[search]) &&
+				kiidevice[f->console_map[search]]) ||
+			(KII_VALID_DEVICE_ID(f->graphic_map[search]) &&
+				kiidevice[f->graphic_map[search]]))) {
+
+			if (--search <  0) 
+				search = KII_MAX_NR_CONSOLES - 1;			
+		}
+		if ((search != start) && 
+			!KII_VALID_CONSOLE_ID(f->want_console)) {
+			f->want_console = search;
+			f->flags |= KII_FF_PROCESS_BH;
+			do_bottomhalf();
+		}
+		return;
+	}
+	case K_INCRCONSOLE: {
+		register kii_s_t start, search;
+
+		if (!KII_VALID_CONSOLE_ID(f->curr_console)) {
+			search = (start = 0) + 1;
+		} else {
+			KRN_ASSERT(KII_VALID_CONSOLE_ID(f->curr_console));
+			search = ((start = f->curr_console) <
+				KII_MAX_NR_DEVICES - 1) 
+				? f->curr_console + 1 : 0;
+		}
+
+		while ((search != start) && !(
+			(KII_VALID_DEVICE_ID(f->console_map[search]) &&
+				kiidevice[f->console_map[search]]) ||
+			(KII_VALID_DEVICE_ID(f->graphic_map[search]) &&
+				kiidevice[f->graphic_map[search]]))) {
+
+			if (++search >= KII_MAX_NR_CONSOLES) 
+				search = 0;
+		}
+
+		if ((search != start) &&
+			!KII_VALID_CONSOLE_ID(f->want_console)) {
+			f->want_console = search;
+			f->flags |= KII_FF_PROCESS_BH;
+			do_bottomhalf();
+		}
+		return;
+	}
+	case K_SPAWNCONSOLE:
+		KRN_ASSERT(sizeof(pid_t) <= sizeof(kii_u_t));
+		if (f->focus && ((pid_t) f->focus->spawnpid.priv_u)) {
+
+#ifdef notavail	/* XXX */
+			if (kill_proc(((pid_t) f->focus->spawnpid.priv_u), 
+				f->focus->spawnsig.priv_u, 1)) {
+				f->focus->spawnpid.priv_u = 0;
+			}
+#endif
+		}
+		event->any.type = KII_EV_NOTHING;
+		return;
+	case K_TOGGLESCREEN:
+		if (KII_VALID_DEVICE_ID(f->curr_console)) {
+			f->want_console = f->curr_console;
+			f->flags |= KII_FF_PROCESS_BH;
+			do_bottomhalf();
+		}
+		return;
+	case K_SYSTEM_REQUEST:
+
+		f->flags |= KII_FF_SYSTEM_REQUEST;
+		
+		if ((curdev = kgi_current_devid(0)) != -1) 
+			kgi_unmap_device(curdev);
+
+		kgi_map_device(0);
+
+		kdb_enter(KDB_WHY_UNSET, "KII escape to debugger.");
+
+		if (curdev) {
+			kgi_unmap_device(0);
+			kgi_map_device(curdev);
+		}
+
+		f->flags &= ~KII_FF_SYSTEM_REQUEST;
+
+		return;
+	default:
+		return;
+	}
+
+	/* NOT REACHED */
+}
+
+void 
+kii_action(kii_focus_t *f, kii_event_t *event)
+{
+	kii_u_t sym = event->key.sym;
+
+	if ((1 << event->any.type) & ~(KII_EM_KEY_PRESS | KII_EM_KEY_RELEASE)) 
+		return;	
+
+	KRN_DEBUG(6, "Key %s, code 0x%.2x, sym %.2x", 
+		(event->key.type == KII_EV_KEY_PRESS) ? "down" : "up",
+		event->key.code, event->key.sym);
+
+	switch (event->key.sym & K_TYPE_MASK) {
+	case K_TYPE_SPECIAL:
+		if (sym < K_LAST_SPECIAL)
+			do_special(f, event); 
+		return;
+	case K_TYPE_CONSOLE:
+		sym -= K_FIRST_CONSOLE;
+		if (KII_VALID_DEVICE_ID(sym) &&
+			(event->key.type == KII_EV_KEY_PRESS)) {
+			if (KII_VALID_CONSOLE_ID(f->want_console)) {
+				if (f->want_console == sym) {
+					f->flags |= KII_FF_PROCESS_BH;
+					do_bottomhalf();
+				} else {
+					make_sound(f, 444, 250);
+					/* BEEP! */
+				}
+			} else {
+				f->want_console = sym;
+				f->flags |= KII_FF_PROCESS_BH;
+				do_bottomhalf();
+			}
+		}
+		return;
+	}
+}
diff -x CVS -x .svn -aurpN sys/dev/kii/kii_core.c sys/dev/kii/kii_core.c
--- sys/dev/kii/kii_core.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kii_core.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,676 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KII input manager
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <sys/kbio.h>
+#include <dev/kbd/kbdreg.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+static kii_s_t initialized = 0;
+
+/*
+ * Input device administration.
+ */
+kii_focus_t  *kiifocus[KII_MAX_NR_FOCUSES];
+kii_device_t *kiidevice[KII_MAX_NR_DEVICES];
+
+static kii_u_t 
+kii_next_input_id(kii_focus_t *f)
+{
+	kii_u_t input_id = f->next_input_id;
+	kii_input_t *input;
+
+	do {
+		if (KII_MAX_NR_INPUTS <= ++input_id) 
+			input_id = 0;
+
+		input = f->inputs;
+		while (input && (input->id != input_id)) 
+			input = input->next;
+
+		if (input == NULL) 
+			return (input_id);	
+
+	} while (input_id != f->next_input_id);
+
+	return (KII_INVALID_INPUT);
+}
+
+/*
+ * Register an input device to a focus. We keep KII_IC_2DPOINTER devices
+ * first in the linked list to tell easily if a has a pointer.
+ * return values:
+ * 	KII_EOK successful
+ * 	KII_EINVAL parameters invalid
+ */
+kii_s_t
+kii_register_input(kii_u_t focus, kii_input_t *dev, int reset)
+{
+	kii_focus_t *f;
+	kii_input_t *prev;
+	kii_u_t input_id;
+
+	/*
+	 * Auto-assign to the next focus that needs one of these.
+	 */
+	if (dev && (focus == KII_INVALID_FOCUS)) {
+		focus = 0;
+		while (KII_VALID_FOCUS_ID(focus)) {
+			if (kiifocus[focus] == NULL) 
+				break;
+
+			prev = (kiifocus[focus])->inputs;
+			while (prev != NULL) {
+				if ((dev->events & prev->events & KII_EM_POINTER) ||
+					(dev->events & prev->events & KII_EM_KEY)) {
+						prev = NULL;  
+						break; 
+				}
+				if (prev->next == NULL) 
+					break;
+
+				prev = prev->next;
+			}
+			if (prev != NULL)
+				break;
+
+			focus++;
+		} 
+	}
+
+	if (!(dev && KII_VALID_FOCUS_ID(focus))) {
+		KRN_ERROR("Invalid parameters: focus = %i, dev = %p",
+			focus, dev);
+		return (KII_EINVAL);
+	}
+
+	f = kiifocus[focus];
+	if (!f || reset) {
+ 		kii_s_t i;
+
+		KRN_DEBUG(2, "Allocating focus %i...", focus);
+		f = kiifocus[focus] = kgi_kmalloc(sizeof(kii_focus_t));
+		if (!f) { 
+			KRN_ERROR("Focus %i allocation failed.", focus);
+			return (KII_ENOMEM);
+		}
+		memset(f, 0, sizeof(*f));
+		f->id = focus;
+		f->curr_console = 
+		f->last_console = 
+		f->want_console = KII_INVALID_CONSOLE;
+		f->dead = f->npadch = K_VOID;
+		f->console_map = console_map[f->id];
+		f->graphic_map = graphic_map[f->id];
+		keymap_reset(&f->kmap);
+
+ 		i = 0;
+		while ((i < KII_MAX_NR_CONSOLES) && !(
+			(KII_VALID_DEVICE_ID(f->console_map[i]) &&	
+				kiidevice[f->console_map[i]]) ||
+			(KII_VALID_DEVICE_ID(f->graphic_map[i]) &&
+				kiidevice[f->graphic_map[i]]))) {
+			i++;
+		}
+		
+		if ((KII_VALID_DEVICE_ID(f->graphic_map[i]) &&
+			kiidevice[f->graphic_map[i]])) {
+			KRN_DEBUG(3, "Found valid KII graphic map %d", i);
+			f->curr_console = i;
+			f->focus = kiidevice[f->graphic_map[i]];
+		}
+
+		if ((KII_VALID_DEVICE_ID(f->console_map[i]) &&
+			kiidevice[f->console_map[i]])) {
+			KRN_DEBUG(3, "Found valid KII console map %d", i);
+			f->curr_console = i;
+			f->focus = kiidevice[f->console_map[i]];
+		}
+
+		if (f->focus) {
+			f->focus->flags |= KII_DF_FOCUSED;
+			if (f->focus->MapDevice) {
+				(f->focus->MapDevice)(f->focus);
+			}
+		}
+
+		KRN_DEBUG(2, "Focus %i allocated, focused on console %i",
+			focus, f->curr_console);
+	}
+	
+	input_id = kii_next_input_id(f);
+	if (input_id == KII_INVALID_INPUT) {
+		KRN_ERROR("Could not get valid input ID.");
+		return (KII_EBUSY);
+	}
+	dev->id = input_id;
+	dev->focus = f->id;
+
+	if ((prev = f->inputs)) {
+		while (prev->next && (prev->next->events & KII_EM_POINTER)) 
+			prev = prev->next;
+
+		dev->next  = prev->next;
+		prev->next = dev;
+	} else {
+		dev->next  = NULL;
+		f->inputs  = dev;
+	}
+
+	f->flags |= (dev->events & KII_EM_POINTER) ? KII_FF_HAS_POINTER : 0;
+	return (KII_EOK);
+}
+
+/*
+ * Unregister a previously registered input device from its focus.
+ * If dev is not valid or dev was not registered, we do nothing.
+ */
+void 
+kii_unregister_input(kii_input_t *dev)
+{
+	kii_input_t *prev;
+	kii_focus_t *f; 
+
+	if (! (dev && KII_VALID_FOCUS_ID(dev->focus) && 
+		(f = kiifocus[dev->focus]))) {
+		KRN_ERROR("Invalid paramters: dev = %p, focus = %i",
+			dev, dev ? dev->focus : KII_INVALID_FOCUS);
+		return;
+	}
+	KRN_ASSERT(dev->focus == f->id);
+
+	if (dev != f->inputs) {
+		prev = f->inputs;
+		while (prev && (prev->next != dev)) 
+			prev = prev->next;
+
+		if (prev) {
+			prev->next = dev->next;
+			dev->next  = NULL;
+			dev->focus = KII_INVALID_FOCUS;
+			dev->id    = KII_INVALID_INPUT;
+
+		} else {
+			/*
+			 * The device is not listed in that focus. 
+			 * We better report...
+			 */
+			KRN_ERROR("Device %p ('%s %s') not in list?",
+				dev, dev->vendor, dev->model);
+			return;
+		}
+
+	} else {	/* if (dev != f->inputs) ... */
+		f->inputs  = dev->next;
+		dev->next  = NULL;
+		dev->focus = KII_INVALID_FOCUS;
+		dev->id    = KII_INVALID_INPUT;
+
+		/*
+		 * Even if there are no input devices left, just to keep
+		 * the focus hanging around. However, free the keymap
+		 * and reset it to the default one.
+		 */
+		if (!f->inputs) 
+			keymap_reset(&f->kmap);
+	}
+
+	f->flags &= ~KII_FF_HAS_POINTER;
+	f->flags |= (f->inputs && (KII_EM_POINTER & f->inputs->events)) 
+			? KII_FF_HAS_POINTER : 0;
+}
+
+/*
+ * Clone a console device e.g. copy the source to the target device
+ * then register.
+ */
+kii_device_t *
+kii_clone_console(kii_u_t source, kii_u_t target)
+{
+	kii_device_t *src = NULL, *dest = NULL;
+	kii_s_t error;
+
+	if (!(KII_VALID_CONSOLE_ID(source) && KII_VALID_CONSOLE_ID(target)))
+		return (NULL);
+
+	if (!((src = kiidevice[source]) && (src->flags & KII_DF_CONSOLE)))
+		return (NULL);
+
+	if (target == source)
+		return (src);
+
+	if (!(dest = kgi_kmalloc(sizeof(kii_device_t))))
+		return (NULL);
+
+	*dest = *src;
+
+	dest->id = KII_INVALID_DEVICE;
+	dest->focus_id = KII_INVALID_FOCUS;
+	dest->flags &= ~KII_DF_FOCUSED;
+	dest->flags |= KII_DF_CLONED;
+
+	error = kii_register_device(dest, target);
+
+	if (error) {
+		KRN_DEBUG(2, "Registration of cloned KII console failed.");
+		kgi_kfree(dest);
+		return (NULL);
+	}
+
+	return (dest);
+}
+
+/* 
+ * Delete a clone previously created by kii_clone_console().
+ */
+kii_s_t 
+kii_delete_clone(kii_u_t dev_id)
+{
+	kii_device_t *dev;
+
+	if (!KII_VALID_CONSOLE_ID(dev_id))
+		return (KII_EINVAL);
+
+	if (!((dev = kiidevice[dev_id]) && (dev->flags & KII_DF_CLONED)))
+		return (KII_EINVAL);
+
+	kii_unregister_device(dev);
+
+	kgi_kfree(dev);
+
+	return (KII_EOK);
+}
+
+kii_s_t 
+kii_register_device(kii_device_t *dev, kii_u_t index)
+{
+	kii_u_t focus, console;
+	kii_u8_t *map;
+
+	KRN_ASSERT(dev);
+	if (!(dev && KII_VALID_CONSOLE_ID(index))) {
+		KRN_ERROR("Invalid arguments %p, %i", 
+			dev, index);
+		return (KII_EINVAL);
+	}
+	dev->id = (dev->flags & KII_DF_CONSOLE) 
+		? index : index + KII_MAX_NR_CONSOLES;
+
+	KRN_ASSERT(sizeof(console_map) == sizeof(graphic_map));
+	map = (dev->flags & KII_DF_CONSOLE) ? console_map[0] : graphic_map[0];
+	index = 0;
+	while ((index < sizeof(console_map)) && (map[index] != dev->id)) 
+		index++;
+
+	focus   = index / KII_MAX_NR_CONSOLES;
+	console = index % KII_MAX_NR_CONSOLES;
+	if (!(KII_VALID_FOCUS_ID(focus) && KII_VALID_CONSOLE_ID(console) &&
+		KII_VALID_DEVICE_ID(map[index]) && (map[index] == dev->id))) {
+		KRN_ERROR("No %s device allowed (device-id %i)",
+			(dev->flags & KII_DF_CONSOLE) ? "console" : "graphic",
+			dev->id);
+		dev->id = KII_INVALID_DEVICE;
+		return (KII_ENODEV);
+	}
+	if (kiidevice[dev->id]) {
+		KRN_ERROR("Device %i (%s %i-%i) is busy", dev->id,
+			(dev->flags & KII_DF_CONSOLE) ? "console" : "graphic",
+			focus, console);
+		dev->id = KII_INVALID_DEVICE;
+		return (KII_EBUSY);
+	}
+
+	dev->focus_id = focus_map[dev->id];
+
+	kiidevice[dev->id] = dev;
+
+	KRN_DEBUG(2, "KII device %i registered.", dev->id);
+
+	return (KII_EOK);
+}
+
+void 
+kii_unregister_device(kii_device_t *dev)
+{
+	KRN_ASSERT(dev);
+	KRN_ASSERT(KII_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(dev == kiidevice[dev->id]);
+	KRN_ASSERT(!(dev->flags & KII_DF_FOCUSED));
+
+	KRN_DEBUG(2, "KII device %i unregistered.", dev->id);
+
+	kiidevice[dev->id] = NULL;
+	dev->focus_id = KII_INVALID_FOCUS;
+	dev->id = KII_INVALID_DEVICE;
+}
+
+void 
+kii_map_device(kii_u_t dev_id)
+{
+	kii_device_t *dev;
+	kii_focus_t *f;
+
+	if (!(KII_VALID_DEVICE_ID(dev_id) && (dev = kiidevice[dev_id]) &&
+		KII_VALID_FOCUS_ID(focus_map[dev_id]) && 
+		(f = kiifocus[focus_map[dev_id]]))) {
+		KRN_ERROR("No target or focus for device %i, no map done.", dev_id);
+		return;
+	}
+	KRN_ASSERT(f->focus == NULL);
+	KRN_DEBUG(3, "Mapping device %i on focus %i", dev->id, f->id);
+
+	f->focus = dev;
+	f->curr_console = dev_id % KII_MAX_NR_CONSOLES;
+
+	f->ptr.x = dev->ptr.x;
+	f->ptr.y = dev->ptr.y;
+	f->ptr_min.x = dev->ptr_min.x;
+	f->ptr_min.y = dev->ptr_min.y;
+	f->ptr_max.x = dev->ptr_max.x;
+	f->ptr_max.y = dev->ptr_max.y;
+
+	dev->flags |= KII_DF_FOCUSED;
+
+	if (dev->MapDevice) 
+		(dev->MapDevice)(dev);
+
+	return;
+}
+
+/*
+ * Do necessary actions to prepare mapping of device <dev>.
+ */
+kii_s_t 
+kii_unmap_device(kii_u_t dev_id)
+{
+	kii_s_t err;
+	kii_focus_t *f;
+	kii_device_t *dev;
+
+	if (!(KII_VALID_DEVICE_ID(dev_id) && kiidevice[dev_id] &&
+		KII_VALID_FOCUS_ID(focus_map[dev_id]) &&
+		(f = kiifocus[focus_map[dev_id]]))) {
+		KRN_ERROR("No target or focus for device %i, no unmap done.", dev_id);
+		return (KII_EINVAL);
+	}
+
+	if (!(dev = f->focus))
+		return (KII_EOK);
+
+	KRN_DEBUG(3, "Unmapping device %i from focus %i", dev->id, f->id);
+
+	if (dev->UnmapDevice) {
+		if ((err = dev->UnmapDevice(dev))) {
+			return (err);
+		}
+	}
+
+	f->focus = NULL;
+
+	dev->ptr.x     = f->ptr.x;
+	dev->ptr.y     = f->ptr.y;
+	dev->ptr_min.x = f->ptr_min.x;
+	dev->ptr_min.y = f->ptr_min.y;
+	dev->ptr_max.x = f->ptr_max.x;
+	dev->ptr_max.y = f->ptr_max.y;
+
+	dev->flags &= ~KII_DF_FOCUSED;
+
+	return (KII_EOK);
+}
+
+kii_device_t *
+kii_current_focus(kii_u_t focus_id)
+{
+
+	KRN_ASSERT(KII_VALID_FOCUS_ID(focus_id));
+
+	return (kiifocus[focus_id] ? kiifocus[focus_id]->focus : NULL);
+}
+
+void 
+kii_put_event(kii_focus_t *f, kii_event_t *event)
+{
+
+	KRN_ASSERT(f && event);
+
+	if (f->focus && (f->focus->event_mask & (1 << event->any.type))) 
+		(f->focus->HandleEvent)(f->focus, event);
+}
+
+/*
+ * Poll the device e.g. all the inputs of its focus if any.
+ */
+void 
+kii_poll_device(kii_u_t dev_id, kii_event_t *event)
+{
+	kii_focus_t *f;
+	kii_device_t *dev;
+	kii_input_t *input;
+	int scancode = -1;
+
+	/* Raz the event for no event. */
+	bzero(event, sizeof(event));
+
+	if (!(KII_VALID_DEVICE_ID(dev_id) && kiidevice[dev_id] &&
+		KII_VALID_FOCUS_ID(focus_map[dev_id]) &&
+		(f = kiifocus[focus_map[dev_id]]))) {
+		return;
+	}
+	if (!(dev = f->focus)) 
+		return;
+
+	/* Poll the focus inputs. Stop at first that has data. */
+	for (input = f->inputs; input; input = input->next) {
+		if (input->Poll) {
+			scancode = input->Poll(input);
+			if (scancode != -1)
+				break;
+		}
+	}
+
+	if (scancode == -1)
+		return;
+
+	/* Set dontdispatch to avoid re-entrance into KII code. */
+	event->any.dontdispatch = 1;
+
+	if (input->Parse)
+		input->Parse(input, event, scancode);
+}
+
+#if 0
+int 
+kii_focus_of_task(void *task_ptr)
+{
+	struct task_struct *task = task_ptr;
+	kii_focus_t *f;
+
+	if (! task) {
+
+		return KII_EINVAL;
+	}
+
+	/*
+	 * Try to determine the focus that delivers input to this task.
+	 * In case there is no controlling tty for this process, try
+	 * to take the parent's tty.
+	 */
+	while (!task->tty && (task->parent || task->real_parent)) {
+
+		struct task_struct *next;
+		next = task->parent ? task->parent : task->real_parent;
+		if (next == task) {
+
+			break;
+		}
+		task = next;
+	}
+
+	/*
+	 * If even the parent had no controlling tty, we don't know
+	 * what 'workplace group' this process belongs to, and cannot
+	 * determine the focus to use. It's just a best effort...
+	 */
+	if (! task->tty) {
+
+		return KII_EINVAL;
+	}
+	f = kiidev_focus(
+		minor(task->tty->device) -
+		task->tty->driver.minor_start);
+
+	return f ? f->id : KII_EINVAL;
+}
+#endif
+
+kii_s_t 
+kii_console_device(kii_s_t focus)
+{
+	kii_focus_t *f;
+	int console;
+
+	if (!KII_VALID_FOCUS_ID(focus))
+		return (KII_EINVAL);
+
+	f = kiifocus[focus];
+
+	if (f && KII_VALID_CONSOLE_ID(f->curr_console)) {
+		KRN_ASSERT(KII_VALID_CONSOLE_ID(f->curr_console));
+		return (f->console_map[f->curr_console]);
+	}
+
+
+	for (console = 0; console < KII_MAX_NR_CONSOLES; console++) {
+		if (KII_VALID_DEVICE_ID(console_map[focus][console])) {
+			return (console_map[focus][console]);
+		}
+	}
+	return (KII_EINVAL);
+}
+
+void 
+kiidev_set_pointer_window(kii_device_t *dev, kii_s_t minx, kii_s_t maxx,
+	  kii_s_t miny, kii_s_t maxy)
+{
+	
+	KRN_ASSERT(dev && KII_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(minx < maxx);
+	KRN_ASSERT(miny < maxy);
+
+	dev->ptr_min.x = minx;
+	dev->ptr_min.y = miny;
+	dev->ptr_max.x = maxx;
+	dev->ptr_max.y = maxy;
+
+	if (dev->ptr.x < minx)	dev->ptr.x = minx;
+	if (dev->ptr.x >= maxx)	dev->ptr.x = maxx - 1;
+	if (dev->ptr.y < miny)	dev->ptr.y = miny;
+	if (dev->ptr.y >= maxy)	dev->ptr.y = maxy - 1;
+
+	if (dev->flags & KII_DF_FOCUSED) {	
+		kii_focus_t *f = kiifocus[dev->focus_id];
+		KRN_ASSERT(KII_VALID_FOCUS_ID(dev->focus_id) &&
+			kiifocus[dev->focus_id]);
+
+		f->ptr_min.x = minx;
+		f->ptr_min.y = miny;
+		f->ptr_max.x = maxx;
+		f->ptr_max.y = maxy;
+		f->ptr.x = dev->ptr.x;
+		f->ptr.y = dev->ptr.y;
+	}
+}
+
+void 
+kiidev_sync(kii_device_t *dev, kii_sync_flags_t what)
+{
+	
+	KRN_DEBUG(4, "kiidev_sync() not implemented yet!");
+}
+
+const 
+kii_ascii_t *kiidev_get_fnstring(kii_device_t *dev, kii_u_t key)
+{
+	
+	KRN_ASSERT(dev && KII_VALID_DEVICE_ID(dev->id));
+	KRN_ASSERT(KII_VALID_FOCUS_ID(dev->focus_id) && kiifocus[dev->focus_id]);
+
+	return (keymap_get_fnstring(&(kiifocus[dev->focus_id]->kmap), key));
+}
+
+kii_focus_t *
+kiidev_focus(kii_s_t dev_id)
+{
+	kii_u8_t *map;
+	kii_s_t index;
+
+	/*
+	 * If there is a (console) device registered for this ID, we
+	 * take a shortcut to tell which focus serves this device.
+	 */
+	if (!KII_VALID_DEVICE_ID(dev_id)) 
+		return (NULL);
+
+	if (kiidevice[dev_id]) {
+		KRN_ASSERT(kiidevice[dev_id]->id == dev_id);
+		KRN_ASSERT(KII_VALID_FOCUS_ID(kiidevice[dev_id]->focus_id));
+		return (kiifocus[kiidevice[dev_id]->focus_id]);
+	}
+
+	/* Now we have to search which focus we belong to... */
+	map = console_map[0];
+	index = sizeof(console_map) - 1;
+	while ((0 <= index) && (map[index] != dev_id)) 
+		index--;
+
+	return ((index < 0) ? NULL : kiifocus[index / KII_MAX_NR_CONSOLES]);
+}
+
+/*
+ * Backdoor for the keyboard drivers.
+ */
+int
+kii_configure(int flags)
+{
+
+	if (!initialized) {
+		memset(kiifocus, 0, sizeof(kiifocus));
+		memset(kiidevice, 0, sizeof(kiidevice));	
+		initialized = 1;
+	}
+
+	return (KII_EOK);
+}
+
diff -x CVS -x .svn -aurpN sys/dev/kii/kiicmd.h sys/dev/kii/kiicmd.h
--- sys/dev/kii/kiicmd.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kiicmd.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,131 @@
+/*-
+ * Copyright (C) 2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * KII command definitions
+ */
+
+#ifndef _kii_command_h
+#define	_kii_command_h
+
+/*
+ * Null command data. No input, no output.
+ */
+typedef struct {
+} kiic_null_t;
+
+#define	kiic_null_result_t	kiic_null_t
+#define	kiic_null_request_t	kiic_null_t
+
+#define KIIC_UNION(type, command)			\
+typedef union						\
+{ 							\
+	kiic_##type##_##command##_request_t request;	\
+	kiic_##type##_##command##_result_t  result;	\
+} kiic_##type##_##command##_union_t;
+
+/*
+ * Mapper commands.
+ */
+typedef struct {
+	kii_ascii_t	client[64];
+	kii_version_t	client_version;
+} kiic_mapper_identify_request_t;
+
+typedef struct {
+	kii_ascii_t	mapper[64];
+	kii_version_t	mapper_version;
+} kiic_mapper_identify_result_t;
+
+KIIC_UNION(mapper, identify);
+
+typedef kiic_null_request_t kiic_mapper_get_keymap_info_request_t;
+
+typedef struct {
+	kii_u_t	fn_buf_size;
+	kii_u_t fn_str_size;
+
+	kii_u_t	keymin, keymax;
+	kii_u_t keymap_size;
+
+	kii_u_t combine_size;
+} kiic_mapper_get_keymap_info_result_t;
+
+KIIC_UNION(mapper, get_keymap_info);
+
+typedef struct {
+	kii_u_t	keymap, keymin, keymax;
+} kiic_mapper_get_keymap_request_t, kiic_mapper_set_keymap_result_t;
+
+typedef struct {
+	kii_u_t	keymap, keymin, keymax;
+	kii_unicode_t	map[256];
+} kiic_mapper_get_keymap_result_t, kiic_mapper_set_keymap_request_t;
+
+KIIC_UNION(mapper, get_keymap);
+KIIC_UNION(mapper, set_keymap);
+
+typedef struct {
+	kii_u_t device_id;
+} kiic_mapper_attach_request_t;
+
+typedef kiic_null_result_t kiic_mapper_attach_result_t;
+
+KIIC_UNION(mapper, attach);
+
+typedef struct {
+	kii_u_t unit;
+} kiic_mapper_get_unit_request_t;
+
+typedef struct {
+	kii_u_t unit;
+} kiic_mapper_get_unit_result_t;
+
+KIIC_UNION(mapper, get_unit);
+
+/*
+ * KII command encoding
+ */
+
+/* Include ioccom.h for _IOxx definitions */
+#include <sys/ioccom.h>
+
+#define KIIC_IO(type, command, callback, code) \
+	KIIC_##type##_##command = _IO(KIIC_##type##_COMMAND >> 8, code)
+
+#define KIIC_IOR(type, command, callback, code) \
+	KIIC_##type##_##command = _IOR(KIIC_##type##_COMMAND >> 8, code, kiic_##callback##_result_t)
+
+#define KIIC_IOW(type, command, callback, code) \
+	KIIC_##type##_##command = _IOW(KIIC_##type##_COMMAND >> 8, code, kiic_##callback##_request_t)
+
+#define KIIC_IOWR(type, command, callback, code) \
+	KIIC_##type##_##command = _IOWR(KIIC_##type##_COMMAND >> 8, code, kiic_##callback##_union_t)
+	
+
+typedef enum {
+	KIIC_MAPPER_COMMAND	= 0x00000000,	/* ext. mapper commands	*/
+	KIIC_IOR (MAPPER, IDENTIFY,		mapper_identify,	0x0001),
+	KIIC_IO  (MAPPER, MAP_DEVICE,		null,			0x0002),
+	KIIC_IO  (MAPPER, UNMAP_DEVICE,		null,			0x0003),
+	KIIC_IOR (MAPPER, GET_KEYMAP_INFO,	mapper_get_keymap_info,	0x0004),
+	KIIC_IOWR(MAPPER, GET_KEYMAP,		mapper_get_keymap,	0x0005),
+	KIIC_IOWR(MAPPER, SET_KEYMAP,		mapper_set_keymap,	0x0006),
+	KIIC_IOW (MAPPER, ATTACH,		mapper_attach,		0x0007),
+	KIIC_IOWR(MAPPER, GET_UNIT,		mapper_get_unit,	0x0008),
+	KIIC_TYPE_MASK		= 0x0000FF00,
+	KIIC_NR_MASK		= 0x000000FF,
+	KIIC_COMMAND_MASK	= KIIC_TYPE_MASK | KIIC_NR_MASK
+} kii_command_t;
+
+#define	KIIC_COMMAND(cmd)	((cmd) & KIIC_COMMAND_MASK)
+#define	KIIC_SIZE(cmd)		(IOCPARM_LEN(cmd))
+#define	KIIC_READ(cmd)		((cmd) & IOC_OUT)
+#define	KIIC_WRITE(cmd)		((cmd) & IOC_IN)
+
+#endif /* #ifndef _kii_command_h */
diff -x CVS -x .svn -aurpN sys/dev/kii/kiierr.h sys/dev/kii/kiierr.h
--- sys/dev/kii/kiierr.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kiierr.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,53 @@
+/*-
+ * Copyright (C) 2000 Steffen Seeger
+ * Copyright (C) 2002 Nicholas
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * KII error codes.
+ */
+
+#ifndef	_kiierr_h
+#define	_kiierr_h
+
+#define KII_EAGAIN	EAGAIN
+#define KII_EPROTO	ENOTSUP
+#define KII_ENXIO	ENXIO
+#define KII_EBADF	EBADF
+#define KII_EINVAL	EINVAL
+#define KII_ENOMEM	ENOMEM
+#define KII_EPERM	EPERM
+#define KII_EFAULT	EFAULT
+#define KII_EBUSY	EBUSY
+#define KII_ENODEV	ENODEV
+
+enum __kii_error {
+	KII_EOK	= 0,
+	KII_NOMEM,
+	KII_INVAL,
+	KII_NOSUP,
+	KII_NODEV,
+	KII_FAILED,
+	KII_DLL_ERROR,
+	KII_NOT_IMPLEMENTED,
+	KII_UNKNOWN,
+
+	KII_NO_FOCUS,
+
+	KII_LIB		= 0x01000000,
+	KII_KII		= 0x02000000,
+	KII_DRIVER	= 0x03000000,
+	KII_DEVICE	= 0x03000000,
+
+	KII_ERROR_SUBSYSTEM = 0x7F000000,
+
+	__KII_LAST_ERROR
+};
+
+#define	KII_ERRNO(system, code)	((KII_##system) | (KII_##code))
+
+#endif /* #ifndef _kiierr_h */
diff -x CVS -x .svn -aurpN sys/dev/kii/kiisyms.h sys/dev/kii/kiisyms.h
--- sys/dev/kii/kiisyms.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kiisyms.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,571 @@
+/*- 
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ */
+
+/*
+ * KII keysym definitions.
+ */
+
+#ifndef	_kii_kiisyms_h
+#define	_kii_kiisyms_h
+
+#define	KII_MAX_NR_SHIFT	16
+
+#ifdef	KII_NEED_MODIFIER_KEYSYMS
+
+enum __kii_ledtypes {
+	KBD_LED_SCROLL_LOCK	= 0x00000001,
+	KBD_LED_CAPS_LOCK	= 0x00000002,
+	KBD_LED_NUM_LOCK	= 0x00000004
+};
+
+enum __kii_modifiers {
+	KII_MK_SHIFT,
+	KII_MK_ALTGR,
+	KII_MK_CTRL,
+	KII_MK_ALT,
+	KII_MK_SHIFTL,
+	KII_MK_SHIFTR,
+	KII_MK_CTRLL,
+	KII_MK_CTRLR
+};
+
+enum __kii_modifier_masks {
+#define	KII_MASK(x)	KII_MM_##x = (1 << KII_MK_##x)
+	KII_MASK(SHIFT),
+	KII_MASK(ALTGR),
+	KII_MASK(CTRL),
+	KII_MASK(ALT),
+	KII_MASK(SHIFTL),
+	KII_MASK(SHIFTR),
+	KII_MASK(CTRLL),
+	KII_MASK(CTRLR),
+#undef	KII_MASK
+	KII_MM_ALL = (1 << KII_MAX_NR_SHIFT) - 1
+};
+
+enum __kii_keytypes {
+	K_TYPE_LATIN = 0x0000,	/* Must be (and is) zero! */
+
+	K_TYPE_FUNCTION	= 0xF100,
+		K_FIRST_FUNCTION = K_TYPE_FUNCTION,
+		K_F1 = K_FIRST_FUNCTION,
+		K_F2,
+		K_F3,
+		K_F4,
+		K_F5,
+		K_F6,
+		K_F7,
+		K_F8,
+		K_F9,
+		K_F10,
+		K_F11,
+		K_F12,
+		K_F13,
+		K_F14,
+		K_F15,
+		K_F16,
+		K_F17,
+		K_F18,
+		K_F19,
+		K_F20,
+		K_FIND,
+		K_INSERT,
+		K_REMOVE,
+		K_SELECT,
+		K_PGUP,
+		K_PGDN,
+		K_MACRO,
+		K_HELP,
+		K_DO,
+		K_PAUSE,
+		K_F21,
+		K_F22,
+		K_F23,
+		K_F24,
+		K_F25,
+		K_F26,
+		K_F27,
+		K_F28,
+		K_F29,
+		K_F30,
+		K_F31,
+		K_F32,
+		K_F33,
+		K_F34,
+		K_F35,
+		K_F36,
+		K_F37,
+		K_F38,
+		K_F39,
+		K_F40,
+		K_F41,
+		K_F42,
+		K_F43,
+		K_F44,
+		K_F45,
+		K_F46,
+		K_F47,
+		K_F48,
+		K_F49,
+		K_F50,
+		K_F51,
+		K_F52,
+		K_F53,
+		K_F54,
+		K_F55,
+		K_F56,
+		K_F57,
+		K_F58,
+		K_F59,
+		K_F60,
+		K_F61,
+		K_F62,
+		K_F63,
+		K_F64,
+		K_F65,
+		K_F66,
+		K_F67,
+		K_F68,
+		K_F69,
+		K_F70,
+		K_F71,
+		K_F72,
+		K_F73,
+		K_F74,
+		K_F75,
+		K_F76,
+		K_F77,
+		K_F78,
+		K_F79,
+		K_F80,
+		K_F81,
+		K_F82,
+		K_F83,
+		K_F84,
+		K_F85,
+		K_F86,
+		K_F87,
+		K_F88,
+		K_F89,
+		K_F90,
+		K_F91,
+		K_F92,
+		K_F93,
+		K_F94,
+		K_F95,
+		K_F96,
+		K_F97,
+		K_F98,
+		K_F99,
+		K_F100,
+		K_F101,
+		K_F102,
+		K_F103,
+		K_F104,
+		K_F105,
+		K_F106,
+		K_F107,
+		K_F108,
+		K_F109,
+		K_F110,
+		K_F111,
+		K_F112,
+		K_F113,
+		K_F114,
+		K_F115,
+		K_F116,
+		K_F117,
+		K_F118,
+		K_F119,
+		K_F120,
+		K_F121,
+		K_F122,
+		K_F123,
+		K_F124,
+		K_F125,
+		K_F126,
+		K_F127,
+		K_F128,
+		K_F129,
+		K_F130,
+		K_F131,
+		K_F132,
+		K_F133,
+		K_F134,
+		K_F135,
+		K_F136,
+		K_F137,
+		K_F138,
+		K_F139,
+		K_F140,
+		K_F141,
+		K_F142,
+		K_F143,
+		K_F144,
+		K_F145,
+		K_F146,
+		K_F147,
+		K_F148,
+		K_F149,
+		K_F150,
+		K_F151,
+		K_F152,
+		K_F153,
+		K_F154,
+		K_F155,
+		K_F156,
+		K_F157,
+		K_F158,
+		K_F159,
+		K_F160,
+		K_F161,
+		K_F162,
+		K_F163,
+		K_F164,
+		K_F165,
+		K_F166,
+		K_F167,
+		K_F168,
+		K_F169,
+		K_F170,
+		K_F171,
+		K_F172,
+		K_F173,
+		K_F174,
+		K_F175,
+		K_F176,
+		K_F177,
+		K_F178,
+		K_F179,
+		K_F180,
+		K_F181,
+		K_F182,
+		K_F183,
+		K_F184,
+		K_F185,
+		K_F186,
+		K_F187,
+		K_F188,
+		K_F189,
+		K_F190,
+		K_F191,
+		K_F192,
+		K_F193,
+		K_F194,
+		K_F195,
+		K_F196,
+		K_F197,
+		K_F198,
+		K_F199,
+		K_F200,
+		K_F201,
+		K_F202,
+		K_F203,
+		K_F204,
+		K_F205,
+		K_F206,
+		K_F207,
+		K_F208,
+		K_F209,
+		K_F210,
+		K_F211,
+		K_F212,
+		K_F213,
+		K_F214,
+		K_F215,
+		K_F216,
+		K_F217,
+		K_F218,
+		K_F219,
+		K_F220,
+		K_F221,
+		K_F222,
+		K_F223,
+		K_F224,
+		K_F225,
+		K_F226,
+		K_F227,
+		K_F228,
+		K_F229,
+		K_F230,
+		K_F231,
+		K_F232,
+		K_F233,
+		K_F234,
+		K_F235,
+		K_F236,
+		K_F237,
+		K_F238,
+		K_F239,
+		K_F240,
+		K_F241,
+		K_F242,
+		K_F243,
+		K_F244,
+		K_F245,
+		K_UNDO,
+		K_LAST_FUNCTION,
+
+		K_PRIOR = K_PGUP,
+		K_NEXT  = K_PGDN,
+
+	K_TYPE_SPECIAL	= 0x0000F200,
+		K_FIRST_SPECIAL = K_TYPE_SPECIAL,
+		K_VOID = K_FIRST_SPECIAL,
+		K_HOLE = K_VOID,
+		K_ENTER,
+		K_SH_REGS,
+		K_SH_MEM,
+		K_SH_STAT,
+		K_BREAK,
+		K_CONS,
+		K_CAPS,
+		K_NUM,
+		K_HOLD,
+		K_SCROLLFORW,
+		K_SCROLLBACK,
+		K_BOOT,
+		K_CAPSON,
+		K_COMPOSE,
+		K_SAK,
+		K_DECRCONSOLE,
+		K_INCRCONSOLE,
+		K_SPAWNCONSOLE,
+		K_BARENUMLOCK,
+		K_TOGGLESCREEN,
+		K_SYSTEM_REQUEST,
+		/* Here under, added for FreeBSD */
+		K_HALT,
+		K_POWERDOWN,
+		K_SUSPEND,
+		K_STANDBY,
+		K_PANIC,
+		K_LAST_SPECIAL,
+
+		K_NOSUCHMAP = K_TYPE_SPECIAL + 127,
+
+	K_TYPE_NUMPAD = 0x0000F300,
+		K_FIRST_NUMPAD = K_TYPE_NUMPAD,
+		K_P0 = K_FIRST_NUMPAD,
+		K_P1,
+		K_P2,
+		K_P3,
+		K_P4,
+		K_P5,
+		K_P6,
+		K_P7,
+		K_P8,
+		K_P9,
+		K_PPLUS,
+		K_PMINUS,
+		K_PSTAR,
+		K_PSLASH,
+		K_PENTER,
+		K_PCOMMA,
+		K_PDOT,
+		K_PPLUSMINUS,
+		K_PARENL,
+		K_PARENR,
+		K_LAST_NUMPAD,
+
+		K_PASTERISK = K_PSTAR,
+
+	K_TYPE_DEAD = 0x0000F400,
+		K_FIRST_DEAD = K_TYPE_DEAD,
+		K_DGRAVE = K_FIRST_DEAD,
+		K_DACUTE,
+		K_DCIRCM,
+		K_DTILDE,
+		K_DDIERE,
+		K_DCEDIL,
+
+		K_LAST_DEAD,
+
+	K_TYPE_CONSOLE 	= 0x0000F500,
+		K_FIRST_CONSOLE = K_TYPE_CONSOLE,
+		K_LAST_CONSOLE = K_FIRST_CONSOLE + CONFIG_KGII_MAX_NR_CONSOLES,
+
+	K_TYPE_CURSOR 	= 0x0000F600,
+		K_FIRST_CURSOR = K_TYPE_CURSOR,
+		K_DOWN	= K_FIRST_CURSOR,
+		K_LEFT,
+		K_RIGHT,
+		K_UP,
+		/* Here under, added for FreeBSD. */
+		K_HOME,
+		K_END,
+		K_LAST_CURSOR,
+
+	K_TYPE_SHIFT	= 0x0000F700,
+		K_FIRST_SHIFT = K_TYPE_SHIFT,
+		K_FIRST_NORMAL = K_FIRST_SHIFT,
+		K_NORMAL_SHIFT = K_FIRST_NORMAL,
+		K_NORMAL_ALTGR,
+		K_NORMAL_CTRL,
+		K_NORMAL_ALT,
+		K_NORMAL_SHIFTL,
+		K_NORMAL_SHIFTR,
+		K_NORMAL_CTRLL,	
+		K_NORMAL_CTRLR,
+		K_LAST_NORMAL  = K_FIRST_NORMAL + KII_MAX_NR_SHIFT,
+
+		K_FIRST_LOCKED = K_LAST_NORMAL,
+		K_LOCKED_SHIFT = K_FIRST_LOCKED,
+		K_LOCKED_CTRL,
+		K_LOCKED_ALT,
+		K_LOCKED_ALTGR,
+		K_LOCKED_SHIFTL,
+		K_LOCKED_SHIFTR,
+		K_LOCKED_CTRLL,
+		K_LOCKED_CTRLR,
+		K_LAST_LOCKED  = K_FIRST_LOCKED + KII_MAX_NR_SHIFT,
+
+		K_FIRST_STICKY = K_LAST_LOCKED,
+		K_STICKY_SHIFT = K_FIRST_STICKY,
+		K_STICKY_CTRL,
+		K_STICKY_ALT,
+		K_STICKY_ALTGR,
+		K_STICKY_SHIFTL,
+		K_STICKY_SHIFTR,
+		K_STICKY_CTRLL,
+		K_STICKY_CTRLR,
+		K_LAST_STICKY  = K_FIRST_STICKY + KII_MAX_NR_SHIFT,
+
+		K_LAST_SHIFT = K_LAST_STICKY,
+
+	K_TYPE_META	= 0x0000F800,
+		K_LAST_META,
+
+	K_TYPE_ASCII	= 0x0000F900,
+		K_FIRST_ASCII = K_TYPE_ASCII,
+		K_LAST_ASCII,
+
+	K_TYPE_MASK	= 0x0000FF00,
+	K_VALUE_MASK	= 0x000000FF
+};
+#define	K_SYM(type, val)	((type) | (val))
+#define	K_TYPE(x)	((x) & K_TYPE_MASK)
+#define	K_VALUE(x)	((x) & K_VALUE_MASK)
+#endif
+
+/* Symbols of type special. */
+#define	KS_VOID		"Void"
+#define	KS_HOLE		"Hole"
+#define	KS_ENTER	"Enter"
+#define	KS_SH_REGS	"SH-Regs"
+#define	KS_SH_MEM	"SH-Mem"
+#define	KS_SH_STAT	"SH-Stat"
+#define	KS_BREAK	"Break"
+#define	KS_CONS		"Cons"
+#define	KS_CAPS		"Caps"
+#define	KS_NUM		"Num"
+#define	KS_HOLD		"Hold"
+#define	KS_SCROLLFORW	"ScrollForw"
+#define	KS_SCROLLBACK	"ScrollBack"
+#define	KS_BOOT		"Boot"
+#define	KS_CAPSON	"CapsON"
+#define	KS_COMPOSE	"Compose"
+#define	KS_SAK		"SAK"
+#define	KS_DECRCONSOLE	"DecrCons"
+#define	KS_INCRCONSOLE	"IncrCons"
+#define	KS_SPAWNCONSOLE	"SpawnCons"
+#define	KS_BARENUMLOCK	"BareNumLock"
+#define	KS_TOGGLESCREEN	"ToggleScreen"
+#define	KS_SYSTEM_REQUEST "SysRequest"
+#define KS_HALT		"Halt"
+#define KS_POWERDOWN	"PowerDown"
+#define KS_SUSPEND	"Suspend"
+#define KS_PANIC	"Panic"
+#define KS_HOME		"Home"
+#define KS_END		"End"
+
+/* Symbols of type function. */
+#define KS_F1		"F1"
+#define KS_F2		"F2"
+#define KS_F3		"F3"
+#define KS_F4		"F4"
+#define KS_F5		"F5"
+#define KS_F6		"F6"
+#define KS_F7		"F7"
+#define KS_F8		"F8"
+#define KS_F9		"F9"
+#define KS_F10		"F10"
+#define KS_F11		"F11"
+#define KS_F12		"F12"
+#define KS_F13		"F13"
+#define KS_F14		"F14"
+#define KS_F15		"F15"
+#define KS_F16		"F16"
+#define KS_F17		"F17"
+#define KS_F18		"F18"
+#define KS_F19		"F19"
+#define KS_F20		"F20"
+#define KS_FIND		"Find"
+#define KS_INSERT	"Insert"
+#define KS_REMOVE	"Remove"
+#define KS_SELECT	"Select"
+#define KS_PGUP		"PgUp"
+#define KS_PGDN		"PgDown"
+#define KS_MACRO	"Macro"
+#define KS_HELP		"Help"
+#define KS_DO		"Do"
+#define KS_PAUSE	"Pause"
+
+/* Symbols of type NumPad. */
+#define KS_P0		"P0"
+#define KS_P1		"P1"
+#define KS_P2		"P2"
+#define KS_P3		"P3"
+#define KS_P4		"P4"
+#define KS_P5		"P5"
+#define KS_P6		"P6"
+#define KS_P7		"P7"
+#define KS_P8		"P8"
+#define KS_P9		"P9"
+#define KS_PPLUS	"P+"
+#define KS_PMINUS	"P-"
+#define KS_PSTAR	"P*"
+#define KS_PSLASH	"P/"
+#define KS_PENTER	"PRet"
+#define KS_PCOMMA	"PComma"
+#define KS_PDOT		"P."
+#define KS_PPLUSMINUS	"P+/-"
+#define KS_PARENL	"P("
+#define KS_PARENR	"P)"
+
+/* Symbols of type shift. */
+#define KS_NORMAL_SHIFT		"Shift"
+#define KS_NORMAL_CTRL		"Ctrl"
+#define KS_NORMAL_ALT		"Alt"
+#define KS_NORMAL_ALTGR		"AltGr"
+#define KS_NORMAL_SHIFTL	"ShiftL"
+#define KS_NORMAL_SHIFTR	"ShiftR"
+#define KS_NORMAL_CTRLL		"CtrlL"
+#define KS_NORMAL_CTRLR		"CtrlR"
+
+#define KS_LOCKED_SHIFT		"L-Shift"
+#define KS_LOCKED_CTRL		"L-Ctrl"
+#define KS_LOCKED_ALT		"L-Alt"
+#define KS_LOCKED_ALTGR		"L-AltGr"
+#define KS_LOCKED_SHIFTL	"L-ShiftL"
+#define KS_LOCKED_SHIFTR	"L-ShiftR"
+#define KS_LOCKED_CTRLL		"L-CtrlL"
+#define KS_LOCKED_CTRLR		"L-CtrlR"
+
+#define KS_STICKY_SHIFT		"S-Shift"
+#define KS_STICKY_CTRL		"S-Ctrl"
+#define KS_STICKY_ALT		"S-Alt"
+#define KS_STICKY_ALTGR		"S-AltGr"
+#define KS_STICKY_SHIFTL	"S-ShiftL"
+#define KS_STICKY_SHIFTR	"S-ShiftR"
+#define KS_STICKY_CTRLL		"S-CtrlL"
+#define KS_STICKY_CTRLR		"S-CtrlR"
+
+extern char *keysyms_pretty_print(int sym);
+
+#endif /* ifdef _kii_kiisyms_h */
diff -x CVS -x .svn -aurpN sys/dev/kii/kiu_event.c sys/dev/kii/kiu_event.c
--- sys/dev/kii/kiu_event.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kii/kiu_event.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,785 @@
+/*-
+* Copyright (C) 2000 Steffen Seeger
+* Copyright (C) 2001 Nicholas Souchu - Alcve
+* Copyright (C) 2002-2003 Nicholas Souchu
+* 
+* This file is distributed under the terms and conditions of the 
+* MIT/X public license. Please see the file COPYRIGHT.MIT included
+* with this software for details of these terms and conditions.
+* Alternatively you may distribute this file under the terms and
+* conditions of the GNU General Public License. Please see the file 
+* COPYRIGHT.GPL included with this software for details of these terms
+* and conditions.
+*/
+
+/*
+ * /dev/event special device file driver 
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/conf.h>
+#include <sys/proc.h>
+#include <sys/time.h>
+#include <sys/tty.h>
+#include <sys/file.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/fcntl.h>
+#include <sys/unistd.h>
+#include <sys/poll.h>
+#include <sys/uio.h>
+
+#define	KGI_SYS_NEED_IO
+#define KII_NEED_MODIFIER_KEYSYMS
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kii/event.h>
+
+static struct cdevsw kiu_cdevsw;
+
+#define	EVENT_MAX_IO_BUF_SIZE	PAGE_SIZE
+#define	EVENT_MAX_NR_DEVICES	64
+#define	EVENT_MAX_NR_IMAGES	64
+
+struct wq_entry {
+	struct thread *td;
+
+	TAILQ_ENTRY(wq_entry) others;
+};
+
+TAILQ_HEAD(wait_queue, wq_entry);
+
+/* per-device static global data. */
+struct event_entry {
+	unsigned int	cnt;
+	event_device_t	*ptr;
+	pid_t		pid;
+	gid_t		gid;
+};
+
+/* per-device global data. */
+struct event_entry event_dev[EVENT_MAX_NR_DEVICES];
+
+/* Maximum number of opened event files. */
+#define EVENT_MAX_NR_FILES	16
+
+/* 
+ * Array of event files. One per process opening a device.
+ * Each event file entry maintains per-process data along its
+ * interaction with the event device.
+ */
+static event_file_t *event_files[EVENT_MAX_NR_FILES];
+
+static kii_s_t event_device_init(kii_s_t device_id, struct thread *td);
+static void event_device_done(kii_u_t device_id, kii_u_t previous);
+
+static kii_u_t 
+event_device_unit(struct cdev *dev, struct thread *td)
+{
+	kii_u_t unit = -1;
+
+	if (dev2unit(dev))
+		unit = dev2unit(dev) - 1;
+	else
+		if (td)
+			unit = dev2unit(td->td_proc->p_pgrp->pg_session->s_ttyp->t_dev);
+		else
+			unit = 0;
+	
+	return (unit);
+}
+
+/*
+ * Command resource.
+ */
+static int 
+event_command(event_file_t *file, unsigned int cmd, void *data,
+			  struct thread *td)
+{
+	
+	switch (cmd) {
+	case KIIC_MAPPER_IDENTIFY: {
+		/*
+		 * For now only force client identification and
+		 * identify myself (no compatibility checks).
+		 */
+		kiic_mapper_identify_result_t *out = data;
+
+		if (file->flags & EVENT_FF_CLIENT_IDENTIFIED) 
+			return (KII_EPROTO);
+
+		file->flags |= EVENT_FF_CLIENT_IDENTIFIED;
+
+		memset(out->mapper, 0, sizeof(out->mapper));
+		strncpy(out->mapper, EVENT_NAME, sizeof(out->mapper));
+		out->mapper_version.major = 0;
+		out->mapper_version.minor = 9;
+		out->mapper_version.patch = 0;
+		out->mapper_version.extra = 0;
+		/* XXX #warning tell client if it is session leader or not. */
+
+		return (KII_EOK); 
+		}
+	}
+	/* All commands below require identification. */
+	if (!(file->flags & EVENT_FF_CLIENT_IDENTIFIED)) {
+		KRN_DEBUG(1, "cmd = %.8x, but client has not yet identified", cmd);
+		return (KII_EPROTO);
+	}
+#define	MUST_BE_SESSION_LEADER					\
+	if (! (file->flags & EVENT_FF_SESSION_LEADER)) {	\
+								\
+		KRN_DEBUG(1, "client is not session leader");	\
+		return KII_EPROTO;				\
+	}
+	switch (cmd) {
+	case KIIC_MAPPER_MAP_DEVICE: {
+		kii_device_t *prev;
+
+		MUST_BE_SESSION_LEADER
+
+		prev = kii_current_focus(file->device->kii.focus_id);
+		if (prev) {
+			KRN_DEBUG(1, "unmapping previous device");
+			switch (kii_unmap_device(prev->id)) {
+			case KII_EOK:
+				file->previous = prev->id;
+				break;
+			default:
+				KRN_DEBUG(1, "can't unmap current");
+				return (KII_EBUSY);
+			}
+		KRN_DEBUG(1, "mapping new device");
+		kii_map_device(file->device->kii.id);
+		return (KII_EOK);
+		}
+		}
+	case KIIC_MAPPER_UNMAP_DEVICE:
+		MUST_BE_SESSION_LEADER
+		return (kii_unmap_device(file->device->kii.id));
+	case KIIC_MAPPER_GET_KEYMAP_INFO: {
+		kii_focus_t *focus = kiidev_focus(file->device->kii.id);
+		kiic_mapper_get_keymap_info_result_t *out = data;
+
+		memset(out, 0, sizeof(*out));
+
+		if (NULL == focus) 
+			return (KII_EINVAL);
+
+		out->fn_buf_size  = focus->kmap.fn_buf_size;
+		out->fn_str_size  = focus->kmap.fn_str_size;
+		out->keymin       = focus->kmap.keymin;
+		out->keymax       = focus->kmap.keymax;
+		out->keymap_size  = focus->kmap.keymap_size;
+		out->combine_size = focus->kmap.combine_size;
+
+		return (KII_EOK);
+		}
+	case KIIC_MAPPER_GET_KEYMAP: {
+		kiic_mapper_get_keymap_request_t local = 
+			*(kiic_mapper_get_keymap_request_t *)data;
+		kii_focus_t *focus = kiidev_focus(file->device->kii.id);
+		kiic_mapper_get_keymap_request_t *in = &local;
+		kiic_mapper_get_keymap_result_t *out = data;
+		kii_u_t cnt;
+
+		if ((NULL == focus) ||
+			(focus->kmap.keymap_size <= in->keymap) ||
+			(in->keymin > focus->kmap.keymax) ||
+			(in->keymax < focus->kmap.keymin)){
+			return (KII_EINVAL);
+		}
+		out->keymap = in->keymap;
+		out->keymin = (in->keymin < focus->kmap.keymin)
+			? focus->kmap.keymin : in->keymin;
+		out->keymax = (in->keymax > focus->kmap.keymax)
+			? focus->kmap.keymax : in->keymax;
+		if (out->keymax < out->keymin) 
+			out->keymax = out->keymin;
+
+		cnt = out->keymax - out->keymin + 1;
+
+		KRN_DEBUG(1, "put keymap %i, keys %i-%i, cnt %i",
+			out->keymap, out->keymin, out->keymax, cnt);
+
+		if (sizeof(out->map)/sizeof(out->map[0]) < cnt) {
+			KRN_DEBUG(1, "keymap request > %i keys",
+				sizeof(out->map)/sizeof(out->map[0]));
+			return (KII_EINVAL);
+		}
+
+		if (focus->kmap.keymap[out->keymap]) {
+			kii_unicode_t *map;
+
+			KRN_DEBUG(1, "map %i @ %p", out->keymap,
+				focus->kmap.keymap[out->keymap]);
+			map = focus->kmap.keymap[out->keymap] +
+				(out->keymin - focus->kmap.keymin);
+			memcpy(out->map, map,cnt*sizeof(kii_unicode_t));
+		} else {
+			KRN_DEBUG(1, "map does not exist, %i VOIDs",cnt);
+			while (cnt--) 
+				out->map[cnt] = K_VOID;
+		}
+		return (KII_EOK);
+		}
+	default:
+		KRN_DEBUG(1, "command %.4x not (yet) implemented", cmd);
+		return (KII_ENXIO);
+	}
+}
+
+/* ioctl() services. */
+static int 
+event_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int flags,    
+	  struct thread *td)
+{
+	kii_u_t unit;
+	event_file_t *file;
+	int io_result = KGI_EOK;
+
+	/* Unit 0 is used to get a free /dev/event unit. */
+	if (!dev2unit(dev)) {
+		kiic_mapper_get_unit_request_t local = 
+			*(kiic_mapper_get_unit_request_t *)data;
+		kiic_mapper_get_unit_result_t *out = (void *)data;
+
+		if (cmd != KIIC_MAPPER_GET_UNIT)
+			return (KII_EINVAL);
+
+		/* First try the suggested unit. */
+		unit = local.unit;
+		if (!KII_VALID_DEVICE_ID(unit) || event_files[unit]) {
+			/* Then try the unit corresponding to the thread VT. */
+			unit = event_device_unit(dev, td);
+			
+			/* If the VT unit is not free lookup one. */
+			if (event_files[unit]) {
+				for (unit=0; unit<EVENT_MAX_NR_FILES; unit++)
+					if (!event_files[unit])
+						break;
+				if (unit >= EVENT_MAX_NR_FILES)
+					return (KII_ENODEV);
+			}
+		}
+			
+		file = kgi_kmalloc(sizeof(*file));
+		if (NULL == file) {
+			KRN_DEBUG(1, "failed to allocate event_file");
+			return (KII_ENOMEM);
+		}
+		memset(file, 0, sizeof(*file));
+		file->previous = KII_INVALID_DEVICE;
+
+		event_files[unit] = file;
+		unit ++;
+		KRN_DEBUG(1, "allocating /dev/event%i", unit);
+
+		/* Create the dev entry. */
+		make_dev(&kiu_cdevsw, unit, UID_ROOT, GID_WHEEL,
+			 0600, EVENT_NAME "%d", unit);
+	
+		out->unit = unit;
+		return (KGI_EOK);
+	}
+
+	/* Unit should not have been opened if file is null. */
+	unit = dev2unit(dev) - 1;
+	file = event_files[unit];
+
+	/* Attach the process to a specific graph device. */
+	if (cmd == KIIC_MAPPER_ATTACH) {
+		kiic_mapper_attach_request_t *in;
+
+		if (file->device) {
+			KRN_ERROR("ioctl() failed: device already attached");
+			return (KII_EINVAL);
+		}
+
+		/* 
+		 * If the application provides an invalid device_id
+		 * we are supposed to take the default device provided
+		 * by the thread tty minor.
+		 */
+		in = (kiic_mapper_attach_request_t *)data;
+
+		if (!KII_VALID_DEVICE_ID(in->device_id))
+			in->device_id = unit;
+
+		if ((io_result = event_device_init(in->device_id, td))) {
+			KRN_DEBUG(2, "failed to initialize event device %i",
+				  in->device_id);
+			return (io_result);
+		}
+
+		file->device_id = in->device_id;
+		file->device = event_dev[in->device_id].ptr;
+
+		if (event_dev[in->device_id].pid == td->td_proc->p_pid) 
+			file->flags |= EVENT_FF_SESSION_LEADER;
+
+		file->next = event_dev[in->device_id].ptr->files;
+		event_dev[in->device_id].ptr->files = file;
+
+		KRN_DEBUG(2, "ioctl: attached event device %i", in->device_id);
+		return (KGI_EOK);
+	}
+
+	if (!file->device) {
+		KRN_ERROR("ioctl() failed: no device attached");
+		return KII_ENXIO;
+	}
+
+	mtx_lock(&file->device->cmd_mutex);
+
+	switch (cmd & KIIC_TYPE_MASK) {
+	case KIIC_MAPPER_COMMAND:
+		io_result = event_command(file, cmd, data, td);
+		break;
+	default:
+		KRN_DEBUG(1, "command type %.4x not (yet) implemented",
+			  (kii_u_t)(cmd & KIIC_TYPE_MASK));
+		io_result = (KGI_EINVAL);
+		goto unlock;
+	}
+
+unlock:
+	mtx_unlock(&file->device->cmd_mutex);
+	return (io_result);
+}
+
+/*
+ * kii_device functions.
+ */
+static void 
+event_map_kii(kii_device_t *dev)
+{
+
+	KRN_DEBUG(2, "event_device %i mapped", dev->id);
+}
+
+static kii_s_t 
+event_unmap_kii(kii_device_t *dev)
+{
+
+	KRN_DEBUG(2, "event_device %i unmapped", dev->id);
+	return (KII_EOK);
+}
+
+static struct wait_queue waitqueue = TAILQ_HEAD_INITIALIZER(waitqueue);
+
+static void 
+event_handle_event(kii_device_t *dev, kii_event_t *ev)
+{
+	event_device_t *device = dev->priv.priv_ptr;
+	event_file_t *file;
+
+	KRN_DEBUG(3, "type %i, size %i, time %i", 
+		ev->any.type, ev->any.size, ev->any.time);
+
+	mtx_lock(&device->cmd_mutex);
+
+	for (file = device->files; file; file = file->next) {
+		kii_u_t new_head = file->queue.head + ev->size;
+
+		KRN_ASSERT(device->files->device_id == file->device_id);
+		KRN_ASSERT(file->queue.tail < file->queue.size);
+		KRN_ASSERT(file->queue.tail <= file->queue.head);
+
+		KRN_DEBUG(3, "queuing for file %p, head %i, tail %i",
+			file, file->queue.head, file->queue.tail);
+
+		if (new_head < file->queue.size) {
+			KRN_ASSERT(file->queue.head < file->queue.size);
+			memcpy(file->queue.buffer + file->queue.head,
+				ev, ev->size);
+			file->queue.head = new_head;
+			continue;
+		}
+
+		if (file->queue.tail <= (new_head - file->queue.size)) {
+			KRN_DEBUG(1, "queue overrun (file %p), event dropped",
+				file);
+			file->flags |= EVENT_FF_QUEUE_OVERRUN;
+			continue;
+		}
+
+		if (file->queue.size < file->queue.head) {
+			KRN_ASSERT(file->queue.head < 2*file->queue.size);
+
+			memcpy(file->queue.buffer + file->queue.head - 
+				file->queue.size, ev, ev->size);
+			file->queue.head = new_head;
+			continue;
+		}
+
+		memcpy(file->queue.buffer + file->queue.head, ev,
+			file->queue.size - file->queue.head);
+		memcpy(file->queue.buffer, ev,
+			new_head - file->queue.size);
+		file->queue.head = new_head;
+	}
+
+	KRN_ASSERT(device->files);
+
+	mtx_unlock(&device->cmd_mutex);
+
+	wakeup(&waitqueue);
+}
+
+/*
+ * event_device functions.
+ */
+static int 
+event_read(struct cdev *dev, struct uio *uio, int ioflag)
+{
+	event_file_t *file;
+	int error, count;
+	struct wq_entry wait;
+
+	/* 
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 */
+	if (!dev2unit(dev))
+		return (EINVAL);
+
+	file = event_files[dev2unit(dev) - 1];
+
+	if (!file->device)
+		return (EINVAL);
+
+	mtx_lock(&file->device->cmd_mutex);
+
+	error = 0;
+	if (file->queue.head == file->queue.tail) {
+		TAILQ_INSERT_TAIL(&waitqueue, &wait, others);
+
+		while (!error && (file->queue.head == file->queue.tail)) {
+			error = msleep((caddr_t)&waitqueue, &file->device->cmd_mutex,
+				       PWAIT | PCATCH, "kiuvent", 0);
+		}
+
+		TAILQ_REMOVE(&waitqueue, &wait, others);
+
+		if (error)
+			goto unlock;
+	}
+
+	count = (uio->uio_resid > file->queue.head - file->queue.tail) ?
+		file->queue.head - file->queue.tail : uio->uio_resid;
+
+	KRN_ASSERT(count > 0);
+
+	/* XXX Can't lock while using uiomove. */
+	mtx_unlock(&file->device->cmd_mutex);
+
+	while (count) {
+		if (uio->uio_resid > 0) {
+			if ((error = uiomove(&file->queue.buffer[file->queue.tail], 1, uio)))
+				return error;
+		}
+		count --;
+		file->queue.tail++;
+		if (file->queue.tail < file->queue.size) 
+			continue;
+
+		KRN_ASSERT(file->queue.tail <= file->queue.head);
+		file->queue.tail -= file->queue.size;
+		file->queue.head -= file->queue.size;
+	}
+
+	return (0);
+
+ unlock:
+	mtx_unlock(&file->device->cmd_mutex);
+	return (error);
+}
+
+static int 
+event_poll(struct cdev *dev, int poll, struct thread *td)
+{
+	event_file_t *file;
+
+	/* 
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 */
+	if (!dev2unit(dev))
+		return (EINVAL);
+
+	file = event_files[dev2unit(dev) - 1];
+
+	return ((file->queue.tail == file->queue.head) ? 0 : (POLLIN | POLLRDNORM));
+}
+
+static kii_s_t 
+event_device_init(kii_s_t device_id, struct thread *td)
+{
+	int err;
+	event_device_t *device;
+
+	KRN_ASSERT(device_id >= 0);
+
+	if (event_dev[device_id].ptr) {
+		KRN_DEBUG(1, "event_device %i already initialized", device_id);
+		event_dev[device_id].cnt++;
+		return (KII_EOK);
+	}
+	if (event_dev[device_id].cnt) {
+		KRN_DEBUG(1, "event_device %i has pending (mmap) references",
+				  device_id);
+		return (KII_EBUSY);
+	}
+	KRN_ASSERT(event_dev[device_id].pid == 0);
+	KRN_ASSERT(event_dev[device_id].gid == 0);
+
+	if (NULL == (device = kgi_kmalloc(sizeof(*device)))) {
+		KRN_DEBUG(1, "failed to allocate event_device %i", device_id);
+		return (KII_ENOMEM);
+	}
+	memset(device, 0, sizeof(*device));
+
+	device->kii.id		= KII_INVALID_DEVICE;
+	device->kii.focus_id	= KII_INVALID_FOCUS;
+	device->kii.MapDevice	= event_map_kii;
+	device->kii.UnmapDevice	= event_unmap_kii;
+	device->kii.HandleEvent	= event_handle_event;
+	device->kii.event_mask	= KII_EM_KEY | KII_EM_POINTER;
+	device->kii.priv.priv_ptr = device;
+
+	if (KII_EOK != (err = kii_register_device(&device->kii, device_id))) {
+		KRN_DEBUG(1, "failed to register kii_device (index %i)", device_id);
+		kgi_kfree(device);
+		return (err);
+	}
+	KRN_DEBUG(2, "registered kii_device %i on focus %i", 
+		device->kii.id, device->kii.focus_id);
+
+	mtx_init(&device->cmd_mutex, "kiu mutex lock", NULL, MTX_DEF);
+
+	event_dev[device_id].pid = td->td_proc->p_pid;
+	event_dev[device_id].gid = td->td_proc->p_pgrp->pg_id;
+	event_dev[device_id].ptr = device;
+	event_dev[device_id].cnt++;
+
+	KRN_DEBUG(1, "event_device %i initialized", device_id);
+
+	return (KII_EOK);
+}
+
+static void 
+event_device_done(kii_u_t device_id, kii_u_t previous)
+{
+	event_device_t *device = event_dev[device_id].ptr;
+
+	KRN_ASSERT(device_id >= 0);
+
+	if (--event_dev[device_id].cnt) {
+		KRN_DEBUG(1, "event %i closed", device_id);
+		return;
+	}
+
+	if (KII_VALID_DEVICE_ID(device->kii.id)) {
+		KRN_DEBUG(1, "device still registered (id %i)",
+			  device->kii.id);
+
+		if (device->kii.flags & KII_DF_FOCUSED) {
+			kii_unmap_device(device->kii.id);
+			if (KII_VALID_DEVICE_ID(previous))
+			    kii_map_device(previous);
+		}
+		kii_unregister_device(&device->kii);
+	}
+
+	mtx_destroy(&device->cmd_mutex);
+
+	kgi_kfree(device);
+	event_dev[device_id].ptr = NULL;
+
+	KRN_ASSERT(event_dev[device_id].cnt == 0);
+	KRN_ASSERT(event_dev[device_id].pid == 0);
+	KRN_ASSERT(event_dev[device_id].gid == 0);
+
+	KRN_DEBUG(1, "event %i finally closed", device_id);
+}
+
+static int 
+event_open(struct cdev *dev, int flag, int mode, struct thread *td)
+{
+	event_file_t *file;
+	void *queue_buffer;
+
+	KRN_DEBUG(1, "open() /dev/event%i", dev2unit(dev));
+
+	/* 
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 * See event_ioctl().
+	 */
+	if (!dev2unit(dev))
+		return (0);
+
+	if (!(file = event_files[dev2unit(dev) - 1])) {
+		KRN_DEBUG(1, "open: unit not allocated");
+		return (ENODEV);
+	}
+		
+	/* 
+	 * Event files are statically allocated.
+	 * A event file can be opened only once.
+	 * Device is not initialized here but at attachement
+	 * (see graph_command()).
+	 */
+	if (file->refcnt) {
+		KRN_DEBUG(1, "open: failed, already opened");
+		return (EBUSY);
+	}
+
+	queue_buffer = kgi_kmalloc(EVENT_QUEUE_SIZE);
+	if (NULL == queue_buffer) {
+		KRN_DEBUG(1, "failed to allocate queue_buffer");
+		return (ENOMEM);
+	}
+
+	file->queue.buffer = queue_buffer;
+	file->queue.size = EVENT_QUEUE_SIZE;
+	file->refcnt++;
+
+	return (0);
+}
+
+static int 
+event_release(struct cdev *dev, int flags, int mode, struct thread *td)
+{
+	kii_u_t unit;
+	event_file_t *file;
+
+	/* 
+	 * Avoid further operations on unit 0,
+	 * It's just there to allocate a free unit number.
+	 */
+	if (!dev2unit(dev))
+		return (0);
+
+	unit = dev2unit(dev) - 1;
+	if (!(file = event_files[unit])) {
+		KRN_DEBUG(1, "release: unit not allocated");
+		return (ENODEV);
+	}
+
+	KRN_DEBUG(1, "closing /dev/event%i (refcnt %li)", unit, file->refcnt);
+
+	/* 
+	 * Only remove the file from the device list of files
+	 * if a device was registered.
+	 */
+	if (file->device) {
+		if (event_dev[file->device_id].ptr->files == file) {
+			event_dev[file->device_id].ptr->files = file->next;
+		} else {
+			event_file_t *prev = event_dev[file->device_id].ptr->files;
+			while (prev->next != file) {
+				prev = prev->next;
+			}
+			KRN_ASSERT(prev->next == file);
+			
+			prev->next = file->next;
+		}
+		file->next = NULL;
+
+		if (td->td_proc->p_pid == event_dev[file->device_id].pid) {
+			KRN_DEBUG(1, "session leader (pid %i) closed event_device %i",
+				  event_dev[file->device_id].pid, file->device_id);
+			event_dev[file->device_id].pid = 0;
+			event_dev[file->device_id].gid = 0;
+		}
+
+		event_device_done(file->device_id, file->previous);
+	}
+
+	kgi_kfree(file->queue.buffer);
+	file->queue.buffer = NULL;
+	file->device = NULL;
+
+	file->refcnt--;
+	KRN_ASSERT(file->refcnt == 0);
+
+	kgi_kfree(file);
+	event_files[unit] = NULL;
+
+	destroy_dev(dev);
+
+	return (0);
+}
+
+static int 
+dev_event_init(void)
+{
+	memset(&event_dev, 0, sizeof(event_dev));
+	memset(event_files, 0, sizeof(event_files));
+
+	TAILQ_INIT(&waitqueue);
+	
+	/* Unit 0 is named /dev/event */
+	make_dev(&kiu_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, EVENT_NAME);
+
+	/* Other units are created later through /dev/event. */
+	return (0);
+}
+
+static struct cdevsw kiu_cdevsw = {
+	.d_open =	event_open,
+	.d_close =	event_release,
+	.d_read =	event_read,
+	.d_ioctl =	event_ioctl,
+	.d_poll =	event_poll,
+	.d_name =	EVENT_NAME,
+	.d_flags =	0,
+	.d_version =	D_VERSION
+};
+
+static int
+kiu_modevent(module_t mod, int type, void *unused)
+{
+	int error = ENXIO;
+
+	switch (type) {
+	case MOD_LOAD:
+		error = dev_event_init();
+		break;
+	case MOD_UNLOAD:
+		/* XXX dev_event_done(); Destroy devs! */
+	default:
+		break;
+	}
+
+	return (error);
+}
+
+static moduledata_t kiu_mod = {
+	"kiu",
+	kiu_modevent,
+	0
+};
+
+DECLARE_MODULE(kiu, kiu_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
+MODULE_VERSION(kiu, 1);
diff -x CVS -x .svn -aurpN sys/dev/kip/default-keymap-de sys/dev/kip/default-keymap-de
--- sys/dev/kip/default-keymap-de	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/default-keymap-de	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,262 @@
+/*	Do not edit this file! It was automatically generated by
+**		loadkeys --mktable keymap.kmap > keymap.c
+*/
+
+#define	NR_KEYS	128
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_00[NR_KEYS] =
+{
+	0xf200,	0x001b,	0x0031,	0x0032,	0x0033,	0x0034,	0x0035,	0x0036,
+	0x0037,	0x0038,	0x0039,	0x0030,	0x00df,	0xf401,	0x007f,	0x0009,
+	0x0071,	0x0077,	0x0065,	0x0072,	0x0074,	0x007a,	0x0075,	0x0069,
+	0x006f,	0x0070,	0x00fc,	0x002b,	0xf201,	0xf702,	0x0061,	0x0073,
+	0x0064,	0x0066,	0x0067,	0x0068,	0x006a,	0x006b,	0x006c,	0x00f6,
+	0x00e4,	0x005e,	0xf700,	0x0023,	0x0079,	0x0078,	0x0063,	0x0076,
+	0x0062,	0x006e,	0x006d,	0x002c,	0x002e,	0x002d,	0xf700,	0xf30c,
+	0xf703,	0x0020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0x003c,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf20f,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_01[NR_KEYS] =
+{
+	0xf200,	0x001b,	0x0021,	0x0022,	0x00b6,	0x0024,	0x0025,	0x0026,
+	0x002f,	0x0028,	0x0029,	0x003d,	0x003f,	0xf400,	0x007f,	0x0009,
+	0x0051,	0x0057,	0x0045,	0x0052,	0x0054,	0x005a,	0x0055,	0x0049,
+	0x004f,	0x0050,	0x00dc,	0x002a,	0xf201,	0xf702,	0x0041,	0x0053,
+	0x0044,	0x0046,	0x0047,	0x0048,	0x004a,	0x004b,	0x004c,	0x00d6,
+	0x00c4,	0x00b0,	0xf700,	0x0027,	0x0059,	0x0058,	0x0043,	0x0056,
+	0x0042,	0x004e,	0x004d,	0x003b,	0x003a,	0x005f,	0xf700,	0xf30c,
+	0xf703,	0x0020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
+	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf208,	0xf203,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0x003e,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_02[NR_KEYS] =
+{
+	0xf200,	0xf216,	0xf200,	0x00b2,	0x00b3,	0x0024,	0xf200,	0xf200,
+	0x007b,	0x005b,	0x005d,	0x007d,	0x005c,	0xf200,	0xf200,	0xf200,
+	0x0040,	0x0077,	0x0065,	0x0072,	0x0074,	0x007a,	0x0075,	0x0069,
+	0x006f,	0x0070,	0xf200,	0x007e,	0xf201,	0xf702,	0x0061,	0x0073,
+	0x0064,	0x0066,	0x0067,	0x0068,	0x006a,	0x006b,	0x006c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0079,	0x0078,	0x0063,	0x0076,
+	0x0062,	0x006e,	0x00b5,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf540,	0xf541,	0xf542,	0xf543,	0xf544,
+	0xf545,	0xf546,	0xf547,	0xf548,	0xf549,	0xf208,	0xf202,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0x007c,	0xf54a,
+	0xf54b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_04[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0x0000,	0x001b,	0x001c,	0x001d,	0x001e,
+	0x001f,	0x007f,	0xf200,	0xf200,	0x001f,	0xf200,	0x0008,	0xf200,
+	0x0011,	0x0017,	0x0005,	0x0012,	0x0014,	0x001a,	0x0015,	0x0009,
+	0x000f,	0x0010,	0x001b,	0x001d,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0x0007,	0x0000,	0xf700,	0x001c,	0x0019,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf20e,	0x007f,	0xf700,	0xf30c,
+	0xf703,	0x0000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0x001c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf205,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_05[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0x0000,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0x001f,	0xf200,	0xf200,	0xf200,
+	0x0011,	0x0017,	0x0005,	0x0012,	0x0014,	0x001a,	0x0015,	0x0009,
+	0x000f,	0x0010,	0xf200,	0xf200,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0019,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf200,	0x001f,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_06[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0x001d,	0xf200,	0x001c,	0xf200,	0xf200,	0xf200,
+	0xf200,	0x0017,	0x0005,	0x0012,	0x0014,	0x001a,	0x0015,	0x0009,
+	0x000f,	0x0010,	0xf200,	0xf200,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0019,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_08[NR_KEYS] =
+{
+	0xf200,	0xf81b,	0xf831,	0xf832,	0xf833,	0xf834,	0xf835,	0xf836,
+	0xf837,	0xf838,	0xf839,	0xf830,	0xf82d,	0xf83d,	0xf87f,	0xf809,
+	0xf871,	0xf877,	0xf865,	0xf872,	0xf874,	0xf87a,	0xf875,	0xf869,
+	0xf86f,	0xf870,	0xf85b,	0xf85d,	0xf80d,	0xf702,	0xf861,	0xf873,
+	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf83b,
+	0xf827,	0xf860,	0xf700,	0xf85c,	0xf879,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf82c,	0xf82e,	0xf82f,	0xf700,	0xf30c,
+	0xf703,	0xf820,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
+	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf209,	0xf907,
+	0xf908,	0xf909,	0xf30b,	0xf904,	0xf905,	0xf906,	0xf30a,	0xf901,
+	0xf902,	0xf903,	0xf900,	0xf30f,	0xf206,	0xf200,	0xf83c,	0xf50a,
+	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0x001c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_0A[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf840,	0xf877,	0xf865,	0xf872,	0xf874,	0xf87a,	0xf875,	0xf869,
+	0xf86f,	0xf870,	0xf200,	0xf200,	0xf201,	0xf702,	0xf861,	0xf873,
+	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf879,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_0C[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf81a,	0xf815,	0xf809,
+	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
+	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf819,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
+	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf50a,
+	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf20f,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t *default_kii_keymap_maps[16] =
+{
+	default_kii_keymap_00,	default_kii_keymap_01,
+	default_kii_keymap_02,	NULL,
+	default_kii_keymap_04,	default_kii_keymap_05,
+	default_kii_keymap_06,	NULL,
+	default_kii_keymap_08,	NULL,
+	default_kii_keymap_0A,	NULL,
+	default_kii_keymap_0C,
+};
+
+/*	Philosophy: most people do not define more strings, but they who do
+**	often want quite a lot of string space. So, we statically allocate
+**	the default and allocate dynamically in chunks of 512 bytes.
+*/
+#ifndef CONFIG_KDB
+static
+#endif
+char *default_kii_keymap_fnstr[30] =
+{
+	"\033[[A",
+	"\033[[B",
+	"\033[[C",
+	"\033[[D",
+	"\033[[E",
+	"\033[17~",
+	"\033[18~",
+	"\033[19~",
+	"\033[20~",
+	"\033[21~",
+	"\033[23~",
+	"\033[24~",
+	"\033[25~",
+	"\033[26~",
+	"\033[28~",
+	"\033[29~",
+	"\033[31~",
+	"\033[32~",
+	"\033[33~",
+	"\033[34~",
+	"\033[1~",
+	"\033[2~",
+	"\033[3~",
+	"\033[4~",
+	"\033[5~",
+	"\033[6~",
+	"\033[M",
+	NULL,
+	NULL,
+	"\033[P",
+};
+
+kii_keymap_t default_kii_keymap =
+{
+	0,		/* fn_buf_size		*/
+	NULL,		/* fn_buf		*/
+	30,		/* fn_str_size		*/
+	default_kii_keymap_fnstr,
+	0, 127,		/* keymin/keymax	*/
+	16,		/* keymap_size		*/
+	default_kii_keymap_maps,
+	0,		/* combine_size		*/
+	NULL,		/* combine		*/
+};
diff -x CVS -x .svn -aurpN sys/dev/kip/default-keymap-us sys/dev/kip/default-keymap-us
--- sys/dev/kip/default-keymap-us	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/default-keymap-us	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,261 @@
+/*	Do not edit this file! It was automatically generated by
+**		loadkeys --mktable keymap.kmap > keymap.c
+*/
+
+#define	NR_KEYS	128
+
+#define GC(index) (0xF500 + KII_MAX_NR_CONSOLES + (index))
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_00[NR_KEYS] =
+{
+	0xf200,	0x001b,	0x0031,	0x0032,	0x0033,	0x0034,	0x0035,	0x0036,
+	0x0037,	0x0038,	0x0039,	0x0030,	0x002d,	0x003d,	0x007f,	0x0009,
+	0x0071,	0x0077,	0x0065,	0x0072,	0x0074,	0x0079,	0x0075,	0x0069,
+	0x006f,	0x0070,	0x005b,	0x005d,	0xf201,	0xf702,	0x0061,	0x0073,
+	0x0064,	0x0066,	0x0067,	0x0068,	0x006a,	0x006b,	0x006c,	0x003b,
+	0x0027,	0x0060,	0xf700,	0x005c,	0x007a,	0x0078,	0x0063,	0x0076,
+	0x0062,	0x006e,	0x006d,	0x002c,	0x002e,	0x002f,	0xf700,	0xf30c,
+	0xf703,	0x0020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0x003c,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_01[NR_KEYS] =
+{
+	0xf200,	0x001b,	0x0021,	0x0040,	0x0023,	0x0024,	0x0025,	0x005e,
+	0x0026,	0x002a,	0x0028,	0x0029,	0x005f,	0x002b,	0x007f,	0x0009,
+	0x0051,	0x0057,	0x0045,	0x0052,	0x0054,	0x0059,	0x0055,	0x0049,
+	0x004f,	0x0050,	0x007b,	0x007d,	0xf201,	0xf702,	0x0041,	0x0053,
+	0x0044,	0x0046,	0x0047,	0x0048,	0x004a,	0x004b,	0x004c,	0x003a,
+	0x0022,	0x007e,	0xf700,	0x007c,	0x005a,	0x0058,	0x0043,	0x0056,
+	0x0042,	0x004e,	0x004d,	0x003c,	0x003e,	0x003f,	0xf700,	0xf30c,
+	0xf703,	0x0020,	0xf207,	0xf10c,	0xf10d,	0xf10e,	0xf10f,	0xf110,
+	0xf111,	0xf112,	0xf113,	0xf11e,	0xf11f,	0xf208,	0xf203,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0x003e,	0xf120,
+	0xf121,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_02[NR_KEYS] =
+{
+	0xf200,	0xf01b,	0xf200,	0x0040,	0xf200,	0x0024,	0xf200,	0xf200,
+	0x007b,	0x005b,	0x005d,	0x007d,	0x005c,	0xf200,	0x007f,	0xf009,
+	0x0040,	0x0077,	0x0065,	0x0072,	0x0074,	0x007a,	0x0075,	0x0069,
+	0x006f,	0x0070,	0xf200,	0x007e,	0xf201,	0xf702,	0x0061,	0x0073,
+	0x0064,	0x0066,	0x0067,	0x0068,	0x006a,	0x006b,	0x006c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0079,	0x0078,	0x0063,	0x0076,
+	0x0062,	0x006e,	0x00b5,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	GC(0),	GC(1),	GC(2),	GC(3),	GC(4),
+	GC(5),	GC(6),	GC(7),	GC(8),	GC(9),	0xf208,	0xf202,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0x007c,	GC(10),
+	GC(11), 0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+#ifndef CONFIG_KDB
+static
+#endif
+kii_unicode_t default_kii_keymap_04[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0x0000,	0x001b,	0x001c,	0x001d,	0x001e,
+	0x001f,	0x007f,	0xf200,	0xf200,	0x001f,	0xf200,	0x0008,	0xf200,
+	0x0011,	0x0017,	0x0005,	0x0012,	0x0014,	0x0019,	0x0015,	0x0009,
+	0x000f,	0x0010,	0x001b,	0x001d,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0x0007,	0x0000,	0xf700,	0x001c,	0x001a,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf20e,	0x007f,	0xf700,	0xf30c,
+	0xf703,	0x0000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
+	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf10a,
+	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0x001c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf205,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_05[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0x0000,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0x001f,	0xf200,	0xf200,	0xf200,
+	0x0011,	0x0017,	0x0005,	0x0012,	0x0014,	0x001a,	0x0015,	0x0009,
+	0x000f,	0x0010,	0xf200,	0xf200,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0019,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf200,	0x001f,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_06[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0x001d,	0xf200,	0x001c,	0xf200,	0xf200,	0xf200,
+	0xf200,	0x0017,	0x0005,	0x0012,	0x0014,	0x001a,	0x0015,	0x0009,
+	0x000f,	0x0010,	0xf200,	0xf200,	0xf201,	0xf702,	0x0001,	0x0013,
+	0x0004,	0x0006,	0x0007,	0x0008,	0x000a,	0x000b,	0x000c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0x0019,	0x0018,	0x0003,	0x0016,
+	0x0002,	0x000e,	0x000d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_08[NR_KEYS] =
+{
+	0xf200,	0xf81b,	0xf831,	0xf832,	0xf833,	0xf834,	0xf835,	0xf836,
+	0xf837,	0xf838,	0xf839,	0xf830,	0xf82d,	0xf83d,	0xf87f,	0xf809,
+	0xf871,	0xf877,	0xf865,	0xf872,	0xf874,	0xf87a,	0xf875,	0xf869,
+	0xf86f,	0xf870,	0xf85b,	0xf85d,	0xf80d,	0xf702,	0xf861,	0xf873,
+	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf83b,
+	0xf827,	0xf860,	0xf700,	0xf85c,	0xf879,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf82c,	0xf82e,	0xf82f,	0xf700,	0xf30c,
+	0xf703,	0xf820,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
+	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf209,	0xf907,
+	0xf908,	0xf909,	0xf30b,	0xf904,	0xf905,	0xf906,	0xf30a,	0xf901,
+	0xf902,	0xf903,	0xf900,	0xf30f,	0xf206,	0xf200,	0xf83c,	0xf50a,
+	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0x001c,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_0A[NR_KEYS] =
+{
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf840,	0xf877,	0xf865,	0xf872,	0xf874,	0xf87a,	0xf875,	0xf869,
+	0xf86f,	0xf870,	0xf200,	0xf200,	0xf201,	0xf702,	0xf861,	0xf873,
+	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,	0xf86b,	0xf86c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf879,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf30f,	0xf206,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t default_kii_keymap_0C[NR_KEYS] =
+{
+	0xf200,	0xf215,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,	0xf81a,	0xf815,	0xf809,
+	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,	0xf702,	0xf801,	0xf813,
+	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,	0xf80b,	0xf80c,	0xf200,
+	0xf200,	0xf200,	0xf700,	0xf200,	0xf819,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf700,	0xf30c,
+	0xf703,	0xf200,	0xf207,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,
+	0xf505,	0xf506,	0xf507,	0xf508,	0xf509,	0xf208,	0xf200,	0xf307,
+	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
+	0xf302,	0xf303,	0xf300,	0xf20c,	0xf206,	0xf200,	0xf200,	0xf50a,
+	0xf50b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
+	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
+	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf20f,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static kii_unicode_t *default_kii_keymap_maps[16] =
+{
+	default_kii_keymap_00,	default_kii_keymap_01,
+	default_kii_keymap_02,	NULL,
+	default_kii_keymap_04,	default_kii_keymap_05,
+	default_kii_keymap_06,	NULL,
+	default_kii_keymap_08,	NULL,
+	default_kii_keymap_0A,	NULL,
+	default_kii_keymap_0C,
+};
+
+/*	Philosophy: most people do not define more strings, but they who do
+**	often want quite a lot of string space. So, we statically allocate
+**	the default and allocate dynamically in chunks of 512 bytes.
+*/
+#ifndef CONFIG_KDB
+static
+#endif
+char *default_kii_keymap_fnstr[30] =
+{
+	"\033[[A",
+	"\033[[B",
+	"\033[[C",
+	"\033[[D",
+	"\033[[E",
+	"\033[17~",
+	"\033[18~",
+	"\033[19~",
+	"\033[20~",
+	"\033[21~",
+	"\033[23~",
+	"\033[24~",
+	"\033[25~",
+	"\033[26~",
+	"\033[28~",
+	"\033[29~",
+	"\033[31~",
+	"\033[32~",
+	"\033[33~",
+	"\033[34~",
+	"\033[1~",
+	"\033[2~",
+	"\033[3~",
+	"\033[4~",
+	"\033[5~",
+	"\033[6~",
+	"\033[M",
+	NULL,
+	NULL,
+	"\033[P",
+};
+
+kii_keymap_t default_kii_keymap =
+{
+	0,		/* fn_buf_size		*/
+	NULL,		/* fn_buf		*/
+	30,		/* fn_str_size		*/
+	default_kii_keymap_fnstr,
+	0, 127,		/* keymin/keymax	*/
+	16,		/* keymap_size		*/
+	default_kii_keymap_maps,
+	0,		/* combine_size		*/
+	NULL,		/* combine		*/
+};
diff -x CVS -x .svn -aurpN sys/dev/kip/kip.h sys/dev/kip/kip.h
--- sys/dev/kip/kip.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,23 @@
+/*-
+ * Copyright (C) 2003 Nicolas Souchu
+ *
+ * This file is distributed under the terms and conditions of the
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * FreeBSD KII kbd driver header
+ */
+
+#ifndef _DEV_KGI_KIP_H
+#define _DEV_KGI_KIP_H
+
+/* Enable KII registration of a freshly registered kbd. */
+void kip_kbd_register(keyboard_t *kbd, int index);
+
+#endif /* !_DEV_KGI_KIP_H */
diff -x CVS -x .svn -aurpN sys/dev/kip/kip_defaults.c sys/dev/kip/kip_defaults.c
--- sys/dev/kip/kip_defaults.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip_defaults.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,31 @@
+/*-
+ * Copyright (C) 1996-2000 Steffen Seeger
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * default keymap data structures
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kii/kii.h>
+
+#ifndef CONFIG_KGII_KEYMAP
+/* #define	CONFIG_KGII_KEYMAP	"default-keymap-de" */
+#define	CONFIG_KGII_KEYMAP	<dev/kip/default-keymap-us>
+#endif
+#include CONFIG_KGII_KEYMAP
diff -x CVS -x .svn -aurpN sys/dev/kip/kip_kbdriver.c sys/dev/kip/kip_kbdriver.c
--- sys/dev/kip/kip_kbdriver.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip_kbdriver.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,510 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * FreeBSD kbd KII driver.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define KGI_DBG_LEVEL 1
+#endif
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <sys/malloc.h>
+#include <sys/kbio.h>
+#include <dev/kbd/kbdreg.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kip/kip.h>
+
+#define MAX_KBD_DRIVERS	4
+#define	MAX_NR_KEYS	128
+
+typedef struct kbdriver_softc {
+	keyboard_t	*kbd;
+	kii_u_t		prev_scancode;
+	kii_u8_t	keys[MAX_NR_KEYS];
+	kii_input_t	kii_input;
+} kbdriver_softc;
+
+static int kbdriver_nr		= 0;
+static kii_s_t initialized  = 0;
+static kbdriver_softc kbdriver_data[MAX_KBD_DRIVERS];
+
+/*
+ * Scancode to keycode translation.
+ *
+ * This is now user-settable. The keycodes 1-88,96-111,119 are fairly
+ * standard, and should probably not be changed - changing might confuse X.
+ * X also interprets scancode 0x5d (KEY_Begin). For 1-88 keycode equals
+ * scancode.
+ */
+
+#define E0_KPENTER 96
+#define E0_RCTRL   97
+#define E0_KPSLASH 98
+#define E0_PRSCR   99
+#define E0_RALT    100
+#define E0_BREAK   101  /* (control-pause) */
+#define E0_HOME    102
+#define E0_UP      103
+#define E0_PGUP    104
+#define E0_LEFT    105
+#define E0_RIGHT   106
+#define E0_END     107
+#define E0_DOWN    108
+#define E0_PGDN    109
+#define E0_INS     110
+#define E0_DEL     111
+
+#define E1_PAUSE   119
+
+/* 
+ * The keycodes below are randomly located in 89-95,112-118,120-127.
+ * They could be thrown away (and all occurrences below replaced by 0),
+ * but that would force many users to use the `setkeycodes' utility, where
+ * they needed not before. It does not matter that there are duplicates, as
+ * long as no duplication occurs for any single keyboard.
+ */
+
+#define SC_LIM 89
+
+#define FOCUS_PF1 85           /* actual code! */
+#define FOCUS_PF2 89
+#define FOCUS_PF3 90
+#define FOCUS_PF4 91
+#define FOCUS_PF5 92
+#define FOCUS_PF6 93
+#define FOCUS_PF7 94
+#define FOCUS_PF8 95
+#define FOCUS_PF9 120
+#define FOCUS_PF10 121
+#define FOCUS_PF11 122
+#define FOCUS_PF12 123
+
+#define JAP_86     124
+
+/*
+ * tfj@olivia.ping.dk: The four keys are located over the numeric 
+ * keypad, and are labelled A1-A4. It's an rc930 keyboard, from
+ * Regnecentralen/RC International, Now ICL. Scancodes: 59, 5a, 5b, 5c.
+ */
+
+#define RGN1 124
+#define RGN2 125
+#define RGN3 126
+#define RGN4 127
+
+
+/* BTC. */
+#define E0_MACRO   112
+/* LK450. */
+#define E0_F13     113
+#define E0_F14     114
+#define E0_HELP    115
+#define E0_DO      116
+#define E0_F17     117
+#define E0_KPMINPLUS 118
+
+/*
+ * kkoller@nyx10.cs.du.edu: My OmniKey generates e0 4c for the "OMNI" 
+ * key and the right alt key does nada.
+ */
+
+#define E0_OK	124
+
+/*
+ * New microsoft keyboard is rumoured to have
+ * e0 5b (left window button),	LBANNER or Windows_L
+ * e0 5c (right window button),	RBANNER or Windows_R
+ * e0 5d (menu button).		RMENU   or TaskMan
+ */
+
+#define E0_MSLW	125
+#define E0_MSRW	126
+#define E0_MSTM	127
+
+
+static kii_u8_t high_keys[128 - SC_LIM] = {
+	RGN1, RGN2, RGN3, RGN4, 0, 0, 0,                   /* 0x59-0x5f */
+	0, 0, 0, 0, 0, 0, 0, 0,                            /* 0x60-0x67 */
+	0, 0, 0, 0, 0, FOCUS_PF11, 0, FOCUS_PF12,          /* 0x68-0x6f */
+	0, 0, 0, FOCUS_PF2, FOCUS_PF9, 0, 0, FOCUS_PF3,    /* 0x70-0x77 */
+	FOCUS_PF4, FOCUS_PF5, FOCUS_PF6, FOCUS_PF7,        /* 0x78-0x7b */
+	FOCUS_PF8, JAP_86, FOCUS_PF10, 0                   /* 0x7c-0x7f */
+};
+
+static kii_u8_t e0_keys[128] = {
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x00-0x07 */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x08-0x0f */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x10-0x17 */
+	0, 0, 0, 0, E0_KPENTER, E0_RCTRL, 0, 0,		/* 0x18-0x1f */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x20-0x27 */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x28-0x2f */
+	0, 0, 0, 0, 0, E0_KPSLASH, 0, E0_PRSCR,		/* 0x30-0x37 */
+	E0_RALT, 0, 0, 0, 0, E0_F13, E0_F14, E0_HELP,	/* 0x38-0x3f */
+	E0_DO, E0_F17, 0, 0, 0, 0, E0_BREAK, E0_HOME,	/* 0x40-0x47 */
+	E0_UP, E0_PGUP, 0, E0_LEFT, E0_OK, E0_RIGHT, E0_KPMINPLUS, E0_END,/* 0x48-0x4f */
+	E0_DOWN, E0_PGDN, E0_INS, E0_DEL, 0, 0, 0, 0,	/* 0x50-0x57 */
+	0, 0, 0, E0_MSLW, E0_MSRW, E0_MSTM, 0, 0,	/* 0x58-0x5f */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x60-0x67 */
+	0, 0, 0, 0, 0, 0, 0, E0_MACRO,			/* 0x68-0x6f */
+	0, 0, 0, 0, 0, 0, 0, 0,				/* 0x70-0x77 */
+	0, 0, 0, 0, 0, 0, 0, 0				/* 0x78-0x7f */
+};
+
+
+/*
+ * The parser takes scancodes from the RAW output of a FreeBSD kbd driver.
+ */
+static void 
+kbdriver_parser(kii_input_t *input, kii_event_t *event, int scancode)
+{
+	kbdriver_softc *sc;
+	kii_u8_t release;
+	kii_u_t keycode;
+
+	event->any.focus = input->focus;
+	event->any.device = input->id;
+	event->any.time = 0;	/* XXX no jiffies. */
+	sc = input->priv.priv_ptr; 
+
+	/* 
+	 * Perform raw treatment at end to enable switches before delivery of key.
+	 */
+	if (input->report & KII_EM_RAW_DATA) {
+		event->raw.type	  = KII_EV_RAW_DATA;
+		event->raw.size	  = sizeof(kii_any_event_t) + 4;
+		*(int *)&event->raw.data = scancode;
+
+		kii_handle_input(event);
+	}
+
+	scancode &= 0xFF;
+
+	if (scancode == 0xE0 || scancode == 0xE1) {
+		sc->prev_scancode = scancode;
+		goto end;
+	}
+
+	release = scancode & 0x80;
+	scancode &= 0x7F;
+
+	if (sc->prev_scancode) {
+		/*
+		 * Usually it will be 0xe0, but a Pause key generates
+		 * e1 1d 45 e1 9d c5 when pressed, and nothing when
+		 * released.
+		 */
+		if (sc->prev_scancode != 0xe0) {
+			if (sc->prev_scancode == 0xe1 && scancode == 0x1d) {
+				sc->prev_scancode = 0x100;
+				goto end;	
+			} else {
+				if (sc->prev_scancode == 0x100 &&
+					scancode == 0x45) {	
+					keycode = E1_PAUSE;
+					sc->prev_scancode = 0;
+				} else {
+					KRN_ERROR("unknown E1 sequence");
+					sc->prev_scancode = 0;
+					goto end;
+				}
+			}
+
+		} else {	/* if (sc->prev_scancode != 0xe0) { ... */
+			sc->prev_scancode = 0;
+
+			/*
+			 * The keyboard maintains its own internal caps
+			 * lock and num lock status. In caps lock mode
+			 * E0 AA precedes make code and E0 2A follows
+			 * break code. In num lock mode, E0 2A precedes
+			 * make code and E0 AA follows break code. We do
+			 * our own book-keeping, so we just ignore these.
+			 *
+			 * For my keyboard there is no caps lock mode,
+			 * but there are both Shift-L and Shift-R modes.
+			 * The former mode generates E0 2A / E0 AA pairs,
+			 * the latter E0 B6 / E0 36 pairs. So, we should
+			 * also ignore the latter. -- aeb@cwi.nl
+			 */
+			if (scancode == 0x2a || scancode == 0x36) 
+				goto end;
+
+			if (e0_keys[scancode])
+				keycode = e0_keys[scancode];
+			else {
+				KRN_ERROR("unknown scancode e0 %02x", scancode);
+				goto end;
+			}
+		}
+
+	} else {  /* if (sc->prev_scancode) ... */
+		if (scancode >= SC_LIM) {
+			/*
+			 * This happens with the FOCUS 9000 keyboard.
+			 * Its keys PF1..PF12 are reported to generate
+			 *  55 73 77 78 79 7a 7b 7c 74 7e 6d 6f. Moreover,
+			 * unless repeated, they do not generate key-down
+			 * events, so we have to zero <release> below.
+			 *
+ 			 * Also, Japanese 86/106 keyboards are reported
+			 * to generate 0x73 and 0x7d for \ - and \ |
+			 * respectively.  
+			 * 
+			 * Also, some Brazilian keyboard is reported to
+			 * produce 0x73 and 0x7e for \ ? and KP-dot,
+			 * respectively.
+			 */
+			keycode = high_keys[scancode - SC_LIM];
+
+			if (!keycode) {
+				KRN_ERROR("unknown scancode %2x", scancode);
+				goto end;
+			}
+		} else 
+			 keycode = scancode;
+	}
+
+	event->key.size = sizeof(kii_key_event_t);
+	event->key.code = keycode;
+
+	if (release) {
+		event->key.type = KII_EV_KEY_RELEASE;
+
+		/* XXX test_and_clear_bit. */
+		if (sc->keys[keycode]) {
+			sc->keys[keycode] = 0;
+
+			/*
+			 * Unexpected, but this can happen: maybe this
+			 * was a key release for a FOCUS 9000 PF key;
+			 */
+			if (keycode >= SC_LIM || keycode == 85) {				
+				event->key.type = KII_EV_KEY_PRESS;
+				if (input->report & KII_EV_KEY_PRESS) {					
+					kii_handle_input(event);
+				}
+				event->key.type = KII_EV_KEY_RELEASE;
+			}
+		}
+	} else {
+		/* XXX test_and_set_bit. */
+		event->key.type = sc->keys[keycode] ?
+				KII_EV_KEY_REPEAT : KII_EV_KEY_PRESS;
+		sc->keys[keycode] = 1;
+	}
+
+	if (input->report & (1 << event->key.type))
+		kii_handle_input(event);
+
+ end:	
+	return;
+}
+
+static int 
+kbdriver_event(keyboard_t *kbd, int evt, void *arg)
+{
+	kbdriver_softc *sc;
+	kii_event_t event;
+	int c;
+
+	sc = (kbdriver_softc *)arg;
+
+	switch (evt) {
+	case KBDIO_KEYINPUT:
+		break;
+	case KBDIO_UNLOADING: /* XXX */
+	default:
+		return (EINVAL);
+	}
+
+	while ((*kbdsw[kbd->kb_index]->check_char)(kbd)) {
+		c = (*kbdsw[kbd->kb_index]->read_char)(kbd, FALSE);
+
+		if (c == NOKEY)
+			break;
+
+		if (c == ERRKEY)	/* XXX: ring bell? */
+			continue;
+
+		bzero(&event, sizeof(event));
+		kbdriver_parser(&sc->kii_input, &event, c);
+	}
+
+	return (0);
+}
+
+/* 
+ * Get a scancode if any.
+ */
+static int
+kbdriver_poll(kii_input_t *input)
+{
+	kbdriver_softc *sc;
+	keyboard_t *kbd;
+	int c;
+
+	sc = input->priv.priv_ptr;
+ 	kbd = sc->kbd;
+	c = (*kbdsw[(kbd)->kb_index]->read)((kbd), 0);
+
+	return (c);
+}
+
+void
+kip_kbd_register(keyboard_t *kbd, int index) 
+{
+	kbdriver_softc *sc;
+	kii_error_t kii_error;
+	int kbd_mode, ka;
+
+	sc = &kbdriver_data[index];
+	
+	if (!sc->kbd) {
+		sc->kbd = kbd;
+		/*
+		 * Try to get exclusive access to this kbd.
+		 */
+		KRN_DEBUG(1, "Attempting to allocate keyboard %s%d", 
+				kbd->kb_name, kbd->kb_unit);
+
+		KBD_UNBUSY(kbd);
+		KBD_VALID(kbd);
+		KBD_DEACTIVATE(kbd);
+		ka = kbd_allocate(kbd->kb_name, kbd->kb_unit, (void *)&sc->kbd,
+				 kbdriver_event, sc);
+
+		KRN_DEBUG(3, "kbd_allocate() returned '%d'", ka);
+		
+		/* Check if allocation succeeded. */
+		if (ka >= 0) {
+			/*
+			 * Put the keyboard in raw mode so that we'll
+			 * directly receive the scancodes from the lower
+			 * layers.
+			 */
+			kbd_mode = K_RAW;
+			(*kbdsw[kbd->kb_index]->ioctl)(kbd, KDSKBMODE,
+						       (caddr_t)&kbd_mode);
+
+			snprintf(sc->kii_input.vendor, KII_MAX_VENDOR_STRING,
+				 "KII FreeBSD keyboard");
+			snprintf(sc->kii_input.model, KII_MAX_VENDOR_STRING,
+				 kbd->kb_name);
+
+			sc->kii_input.events = KII_EM_KEY | KII_EM_RAW_DATA;
+			sc->kii_input.report = KII_EM_KEY | KII_EM_RAW_DATA;
+			sc->kii_input.priv.priv_ptr = sc;
+			sc->kii_input.Poll = kbdriver_poll;
+			sc->kii_input.Parse = kbdriver_parser;
+
+			/* 
+			 * Register the keyboard to a focus. If the kbd unit doesn't match
+			 * the current focus, then we assume that kbd is a slave of kbdmux
+			 * and reassign the focus found from kbd unit with the current kbd.
+			 */
+			if (kbd->kb_unit != kbdriver_nr) {
+				kii_error = kii_register_input(kbd->kb_unit, &sc->kii_input, 1);
+				KRN_DEBUG(1, "KII device %d, keyboard %s%d \
+						registered on focus %d with error %d",
+				    	index, kbd->kb_name, kbd->kb_unit, kbd->kb_unit, 
+						kii_error);
+			} else {
+				kii_error = kii_register_input(kbdriver_nr, &sc->kii_input, 0);
+				KRN_DEBUG(1, "KII device %d, keyboard %s%d \
+						registered on focus %d with error %d",
+				    	index, kbd->kb_name, kbd->kb_unit, kbdriver_nr, 
+						kii_error);
+			}
+
+			kbdriver_nr++;
+
+		} else {
+			/* Free the kbdriver_data entry. */
+			sc->kbd = NULL;
+		}		
+	}
+}
+
+static void
+kbdriver_init(void)
+{
+
+	if (initialized)
+		return;
+
+	initialized = 1;
+
+	/* RAZ the allocation area especially to have kbd field NULL. */
+	bzero(kbdriver_data, sizeof(kbdriver_data));
+	kbdriver_nr = 0;
+
+	return;
+}
+
+static int
+kbdriver_modevent(module_t mod, int type, void *unused)
+{
+	kbdriver_softc *sc = NULL;
+	int s;
+
+	switch (type) {
+	case MOD_LOAD:
+		/* Grab any kbd already registered. */
+		kbdriver_init();
+		break;
+	case MOD_UNLOAD:
+		s = spltty();
+
+		while (kbdriver_nr > 0) {
+			sc = &kbdriver_data[kbdriver_nr];
+
+			if (sc->kbd && KBD_IS_VALID(sc->kbd)) {
+				kii_unregister_input(&sc->kii_input);
+
+				kbd_release(sc->kbd, (void *)sc);
+
+				KRN_NOTICE("%s: keyboard %d unregistered",
+					__FUNCTION__, kbdriver_nr);
+			}
+			sc->kbd = NULL;
+			kbdriver_nr--;
+		}
+
+		splx(s);
+		break;
+	default:
+		break;
+	}
+
+	return (0);
+};
+
+static moduledata_t kbdriver_mod = {
+	"kbdriver",
+	kbdriver_modevent,
+	0
+};
+
+DECLARE_MODULE(kbdriver, kbdriver_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
+MODULE_VERSION(kbdriver, 1);
diff -x CVS -x .svn -aurpN sys/dev/kip/kip_keymap.c sys/dev/kip/kip_keymap.c
--- sys/dev/kip/kip_keymap.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip_keymap.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,326 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KII keymap manager.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <sys/kbio.h>
+#include <dev/kbd/kbdreg.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+/*
+ * Keymap lookup stuff.
+ */
+
+void 
+keymap_reset(kii_keymap_t *k)
+{
+	kii_u_t i;
+
+	if (k && (k != &default_kii_keymap)) {
+#		define	LOCAL_FREE(x)				\
+			if (k->x != default_kii_keymap.x) {	\
+								\
+				kgi_kfree(k->x);			\
+				KRN_TRACE(0, k->x = NULL);	\
+			}
+
+		LOCAL_FREE(fn_buf)
+		LOCAL_FREE(fn_str)
+		for (i = 0; i < k->keymap_size; i++)
+			LOCAL_FREE(keymap[i]);
+
+		LOCAL_FREE(keymap)
+
+		memcpy(k, &default_kii_keymap, sizeof(*k));
+#		undef 	LOCAL_FREE
+	}
+}
+
+kii_s_t 
+keymap_set_keysym(kii_keymap_t *k, kii_u_t shift, kii_u_t key,
+	  kii_unicode_t sym)
+{
+	kii_unicode_t *newmap;
+	kii_u_t i, size;
+
+	KRN_ASSERT(k);
+
+	if ((k == NULL) || (k->keymap_size <= shift) || (key < k->keymin) ||
+		(k->keymax < key)) {
+		return (KII_EINVAL);
+	}
+	if (k->keymap[shift] &&
+		(k->keymap[shift] != default_kii_keymap.keymap[shift])) {
+		k->keymap[shift][key] = sym;
+		return( KII_EOK);
+	}
+
+	if ((sym == K_VOID) && (k->keymap[shift] == NULL)) 
+		return (KII_EOK);
+
+	size = sizeof(kii_keymap_t) + k->fn_buf_size;
+	for (i = 0; i < k->keymap_size; i++) {
+		if (k->keymap[i]) {
+			size += sizeof(kii_unicode_t) * (k->keymax-k->keymin+1);
+		}
+	}
+	size += sizeof(void *) * (k->fn_str_size + k->keymap_size);
+	size += sizeof(kii_dead_combination_t) * k->combine_size;
+	size += sizeof(kii_unicode_t) * (k->keymax-k->keymin+1);
+	if (KII_MAX_KEYMAP_MEMORY < size) 
+		return (KII_ENOMEM);
+
+	if (k->keymap == default_kii_keymap.keymap) {
+		kii_unicode_t **newarr;
+
+		size = sizeof(k->keymap[0]) * k->keymap_size;
+		if (!(newarr = kgi_kmalloc(size))) {
+			return (KII_ENOMEM);
+		}
+		memcpy(newarr, k->keymap, size);
+		k->keymap = newarr;
+		KRN_DEBUG(2, "allocated new keymap array (%i slots)", 
+			k->keymap_size);
+	}
+	size = k->keymax - k->keymin + 1;
+	if (!(newmap = kgi_kmalloc(sizeof(kii_unicode_t) * size))) 
+		return (KII_ENOMEM);
+
+	KRN_DEBUG(2, "%s keymap %i", 
+		default_kii_keymap.keymap[shift] ? "reallocated" : "allocated",
+		shift);
+	i = size;
+	if (default_kii_keymap.keymap[shift]) {
+		while (i--) {
+			newmap[i] = default_kii_keymap.keymap[shift][i];
+		}
+	} else {
+		while (i--) {
+			newmap[i] = K_VOID;
+		}
+	}
+	newmap[key] = sym;
+	k->keymap[shift] = newmap;
+	KRN_ASSERT(k->keymap[shift] != default_kii_keymap.keymap[shift]);
+	return (KII_EOK);
+}
+
+kii_s_t keymap_set_default_keysym(kii_u_t shift, kii_u_t key,
+	  kii_unicode_t sym)
+{
+	kii_keymap_t *k = &default_kii_keymap;
+	kii_unicode_t *newmap;
+	kii_u_t i;
+
+	if ((k->keymap_size <= shift) || (key < k->keymin) ||
+		(k->keymax < key)) {
+		return (KII_EINVAL);
+	}
+	if (k->keymap[shift]) {
+		k->keymap[shift][key] = sym;
+		return (KII_EOK);
+	}
+	
+	if (sym == K_VOID) 
+		return (KII_EOK);
+
+	newmap = kgi_kmalloc((k->keymax - k->keymin + 1) * sizeof(kii_unicode_t));
+	if (newmap == NULL) 
+		return (KII_ENOMEM);
+	
+	for (i = k->keymax - k->keymin; i; i--) 
+		newmap[i] = K_VOID;
+	
+	newmap[key] = sym;
+	k->keymap[shift] = newmap;
+	return (KII_EOK);
+}
+
+kii_unicode_t 
+keymap_get_keysym(kii_keymap_t *k, kii_u_t shift, kii_u_t key)
+{
+	kii_unicode_t *map, sym;
+
+	if ((key < k->keymin) || (k->keymax < key)) 
+		return (K_VOID);
+
+	key -= k->keymin;
+	map = (shift < k->keymap_size) ? k->keymap[shift] : NULL;
+	sym = map ? map[key] : K_VOID;
+
+	if ((k->keymap[0][key] & K_TYPE_MASK) == K_TYPE_SHIFT) 
+		sym = k->keymap[0][key];
+
+	return (sym);
+}
+
+kii_unicode_t 
+keymap_combine_dead(kii_keymap_t *k, kii_unicode_t diacr, kii_unicode_t base)
+{
+	kii_u_t i;
+
+	for (i = 0; i < k->combine_size; i++) {
+		if ((k->combine[i].diacr == diacr) && 
+			(k->combine[i].base == base)) {
+			return (k->combine[i].combined);
+		}
+	}
+	switch (K_TYPE(base)) {
+	case K_TYPE_SPECIAL:
+	case K_TYPE_SHIFT:
+		return (K_VOID);
+	default:
+		return (diacr);
+	}
+}
+
+const kii_ascii_t *
+keymap_get_fnstring(kii_keymap_t *k, kii_u_t key)
+{
+
+	return ((key < k->fn_str_size) ? k->fn_str[key] : NULL);
+}
+
+kii_s_t 
+keymap_set_fnstring(kii_keymap_t *k, kii_u_t key, const kii_ascii_t *s)
+{
+
+	KRN_DEBUG(2, "keymap_set_fnstring() not implemented yet!");
+	return (KII_EINVAL);
+}
+
+struct __kii_keymap_translation_t { kii_unicode_t val1, val2, xor; };
+
+static const struct __kii_keymap_translation_t keymap_range_translation[] = {
+	{ 0x0041, 0x005a,  0x0020 }, { 0x0061, 0x007a,  0x0020 },
+	{ 0x00c0, 0x00de,  0x0020 }, { 0x00e0, 0x00fe,  0x0020 },
+	{ 0x0100, 0x012f,  0x0001 }, { 0x0132, 0x0137,  0x0001 },
+	{ 0x014a, 0x0177,  0x0001 }, { 0x0182, 0x0185,  0x0001 },
+	{ 0x01a0, 0x01a5,  0x0001 }, { 0x01e0, 0x01ef,  0x0001 },
+	{ 0x01fa, 0x01ff,  0x0001 }, { 0x0200, 0x0217,  0x0001 },
+	{ 0x0391, 0x039f,  0x0020 }, { 0x03a0, 0x03ab,  0x0060 },
+	{ 0x03b1, 0x03bf,  0x0020 }, { 0x03c0, 0x03cb,  0x0060 },
+	{ 0x03e2, 0x03ef,  0x0001 }, { 0x0401, 0x040f,  0x0050 },
+	{ 0x0410, 0x041f,  0x0020 }, { 0x0420, 0x042f,  0x0060 },
+	{ 0x0430, 0x043f,  0x0020 }, { 0x0440, 0x044f,  0x0060 },
+	{ 0x0451, 0x045f,  0x0050 }, { 0x0460, 0x0481,  0x0001 },
+	{ 0x0490, 0x04bf,  0x0001 }, { 0x04d0, 0x04f9,  0x0001 },
+	{ 0x0531, 0x053f,  0x0050 }, { 0x0540, 0x054f,  0x0030 },
+	{ 0x0550, 0x0556,  0x00d0 }, { 0x0561, 0x056f,  0x0050 },
+	{ 0x0570, 0x057f,  0x0030 }, { 0x0580, 0x0586,  0x00d0 },
+	{ 0x1e00, 0x1e59,  0x0001 }, { 0x1ea0, 0x1ef9,  0x0001 },
+	{ 0x1f00, 0x1f15,  0x0008 }, { 0x1f18, 0x1f1d,  0x0008 },
+	{ 0x1f20, 0x1f45,  0x0008 }, { 0x1f48, 0x1f4d,  0x0008 },
+	{ 0x1f68, 0x1f60,  0x0008 }, { 0xff21, 0xff3a,  0x0060 },
+	{ 0xff41, 0xff5a,  0x0060 }
+};
+
+static const struct __kii_keymap_translation_t keymap_pair_translation[] = {
+	{ 0x0139, 0x013a,  0x0003 }, { 0x013b, 0x013c,  0x0007 },
+	{ 0x013d, 0x013e,  0x0003 }, { 0x013f, 0x0140,  0x007f },
+	{ 0x0141, 0x0142,  0x0003 }, { 0x0143, 0x0144,  0x0007 },
+	{ 0x0145, 0x0146,  0x0003 }, { 0x0147, 0x0148,  0x000f },
+	{ 0x0178, 0x00ff,  0x0187 }, { 0x0179, 0x017a,  0x0003 },
+	{ 0x017b, 0x017c,  0x0007 }, { 0x017d, 0x017e,  0x0003 },
+	{ 0x0181, 0x0253,  0x03d2 }, { 0x0186, 0x0254,  0x03d2 },
+	{ 0x0187, 0x0188,  0x000f }, { 0x018a, 0x0257,  0x03dd },
+	{ 0x018b, 0x018c,  0x0007 }, { 0x018e, 0x0258,  0x03d6 },
+	{ 0x018f, 0x0259,  0x03d6 }, { 0x0190, 0x025b,  0x03cb },
+	{ 0x0191, 0x0192,  0x0003 }, { 0x0193, 0x0260,  0x03f3 },
+	{ 0x0194, 0x0263,  0x03f7 }, { 0x0196, 0x0269,  0x03ff },
+	{ 0x0197, 0x0268,  0x03ff }, { 0x0198, 0x0199,  0x0001 },
+	{ 0x019c, 0x026f,  0x03f3 }, { 0x019d, 0x0272,  0x03ef },
+	{ 0x01a7, 0x01a8,  0x000f }, { 0x01a9, 0x0283,  0x032a },
+	{ 0x01ac, 0x01ad,  0x0001 }, { 0x01ae, 0x0288,  0x0326 },
+	{ 0x01af, 0x01b0,  0x001f }, { 0x01b1, 0x028a,  0x033b },
+	{ 0x01b2, 0x028b,  0x0339 }, { 0x01b3, 0x01b4,  0x0007 },
+	{ 0x01b5, 0x01b6,  0x0003 }, { 0x01b7, 0x0292,  0x0325 },
+	{ 0x01b8, 0x01b9,  0x0001 }, { 0x01bc, 0x01bd,  0x0001 },
+	{ 0x01c4, 0x01c6,  0x0002 }, { 0x01c7, 0x01c9,  0x000e },
+	{ 0x01ca, 0x01cc,  0x0006 }, { 0x01cd, 0x01ce,  0x0003 },
+	{ 0x01cf, 0x01d0,  0x001f }, { 0x01d1, 0x01d2,  0x0003 },
+	{ 0x01d3, 0x01d4,  0x0007 }, { 0x01d5, 0x01d6,  0x0003 },
+	{ 0x01d7, 0x01d8,  0x000f }, { 0x01d9, 0x01da,  0x0003 },
+	{ 0x01db, 0x01dc,  0x0007 }, { 0x01de, 0x01df,  0x0001 },
+	{ 0x01f1, 0x01f3,  0x0002 }, { 0x01f4, 0x01f5,  0x0001 },
+	{ 0x0386, 0x03ac,  0x002a }, { 0x0388, 0x03ad,  0x0025 },
+	{ 0x0389, 0x03ae,  0x0027 }, { 0x038a, 0x03af,  0x0025 },
+	{ 0x038c, 0x03cc,  0x0040 }, { 0x038e, 0x03cd,  0x0043 },
+	{ 0x038f, 0x03ce,  0x0041 }, { 0x04c1, 0x04c2,  0x0003 },
+	{ 0x04c3, 0x04c4,  0x0007 }, { 0x04c7, 0x04c8,  0x000f },
+	{ 0x04cb, 0x04cc,  0x0007 }, { 0x1f59, 0x1f51,  0x0008 },
+	{ 0x1f5b, 0x1f53,  0x0008 }, { 0x1f5d, 0x1f55,  0x0008 },
+	{ 0x1f5f, 0x1f57,  0x0008 }, { 0x1fba, 0x1f70,  0x00ca },
+	{ 0x1fbb, 0x1f71,  0x00ca }, { 0x1fc8, 0x1f72,  0x00ba },
+	{ 0x1fc9, 0x1f73,  0x00ba }, { 0x1fca, 0x1f74,  0x00be },
+	{ 0x1fcb, 0x1f75,  0x00be }, { 0x1fda, 0x1f76,  0x00ac },
+	{ 0x1fdb, 0x1f77,  0x00ac }, { 0x1fea, 0x1f7a,  0x0090 },
+	{ 0x1feb, 0x1f7b,  0x0090 }, { 0x1fec, 0x1fe5,  0x0009 },
+	{ 0x1ff8, 0x1f78,  0x0080 }, { 0x1ff9, 0x1f79,  0x0080 },
+	{ 0x1ffa, 0x1f7c,  0x0086 }, { 0x1ffb, 0x1f7d,  0x0086 },
+	{ 0x2112, 0x2113,  0x0001 }, { 0x2130, 0x212f,  0x001f }
+};
+
+kii_unicode_t 
+keymap_toggled_case(kii_unicode_t sym)
+{
+	kii_u_t i, size;
+
+	size = sizeof(keymap_pair_translation) /
+		sizeof(keymap_pair_translation[0]);
+
+	for (i = 0; i < size; i++) {
+		if ((keymap_pair_translation[i].val1 == sym) || 
+			(keymap_pair_translation[i].val2 == sym)) {
+			return (sym ^ keymap_pair_translation[i].xor);
+		}
+	}
+
+	size = sizeof(keymap_range_translation) /
+		   sizeof(keymap_range_translation[0]);
+
+	for (i = 0; i < size; i++) {
+		if ((keymap_range_translation[i].val1 <= sym) &&
+			(sym <= keymap_range_translation[i].val2)) {
+			return (sym ^ keymap_range_translation[i].xor);
+		}
+	}
+
+	if ((0x24b6 <= sym) && (sym <= 0x24cf))
+		return (sym + 26);
+	
+	if ((0x24d0 <= sym) && (sym <= 0x24e9)) 
+		return (sym - 26);
+	
+	return (sym);
+}
diff -x CVS -x .svn -aurpN sys/dev/kip/kip_modifiers.c sys/dev/kip/kip_modifiers.c
--- sys/dev/kip/kip_modifiers.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip_modifiers.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,298 @@
+/*-
+ * Copyright (C) 1998-2000 Steffen Seeger
+ * Copyright (C) 2002 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KII parser.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	2
+#endif
+
+#define	KGI_SYS_NEED_IO
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <sys/kbio.h>
+#include <dev/kbd/kbdreg.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+static void 
+do_modifier(kii_focus_t *f, kii_event_t *event)
+{
+	register kii_unicode_t ksym = event->key.sym;
+	kii_u_t effect = f->effect;
+
+	KRN_DEBUG(6, "old modifiers: %.2x %.2x %.2x %.2x, modifier key %.4x",
+		f->effect, f->normal, f->locked, f->sticky, ksym);
+
+	/*
+	 * The effect of STICKY and LOCKED modifiers is toggled whenever
+	 * they are pressed.
+	 */
+	if ((K_FIRST_STICKY <= ksym) && (ksym < K_LAST_STICKY)) {
+		KRN_DEBUG(3, "sticky modifer key");
+
+		if (event->key.type == KII_EV_KEY_PRESS) {
+			f->sticky ^= 1 << (ksym - K_FIRST_STICKY);	
+		}
+	}
+
+	if ((K_FIRST_LOCKED <= ksym) && (ksym < K_LAST_LOCKED)) {
+		KRN_DEBUG(3, "locked modifier key");
+		if (event->key.type == KII_EV_KEY_PRESS)
+			f->locked ^= 1 << (ksym - K_FIRST_LOCKED);
+	}
+
+	/*
+	 * If a NORMAL modifier is pressed at least once, it goes into
+	 * effect and clears the effect of the corresponding LOCKED
+	 * modifier. Thus there is no effect in the EFFECTIVE modifiers.
+	 * The effect of the NORMAL modifier is not cleared until the
+	 * last is released (if pressed multiple times), which clears
+	 * the effect of the corresponding LOCKED modifier too.
+	 */
+	if ((K_FIRST_NORMAL <= ksym) && (ksym < K_LAST_NORMAL)) {
+		register kii_u_t mask = 1 << (ksym - K_FIRST_NORMAL);
+
+		KRN_DEBUG(3, "normal modifier key");
+
+		if (event->key.type == KII_EV_KEY_PRESS) {
+			f->down_mod[ksym - K_FIRST_NORMAL]++;
+			f->normal |=  mask;
+			f->locked &= ~mask;
+		} else {
+			KRN_ASSERT(event->key.type == KII_EV_KEY_RELEASE);
+			KRN_ASSERT(f->down_mod[ksym - K_FIRST_NORMAL] > 0);
+
+			if (! --(f->down_mod[ksym - K_FIRST_NORMAL])) {
+				f->normal &= ~mask;
+				f->locked &= ~mask;
+			}
+		}
+	}
+
+	f->effect = f->normal ^ f->locked ^ f->sticky;
+
+	if ((event->any.type == KII_EV_KEY_RELEASE) && (f->effect != effect) && 
+		(f->npadch != K_VOID)) {
+		kii_event_t npadch;
+		struct timeval tv;
+
+		getmicrotime(&tv);
+
+		npadch.key.type = KII_EV_KEY_PRESS;
+		npadch.key.time = tv.tv_sec * 1000000 + tv.tv_usec;
+		npadch.key.code = 0xFFFF;
+		npadch.key.sym  = f->npadch;
+		npadch.key.effect = f->effect;
+		npadch.key.normal = f->normal;
+		npadch.key.locked = f->locked; 
+		npadch.key.sticky = f->sticky;
+
+		if (!event->any.dontdispatch)
+			kii_put_event(f, &npadch);
+	}
+
+	KRN_DEBUG(3, "new modifers: %.2x %.2x %.2x %.2x", f->effect, 
+		f->normal, f->locked, f->sticky);
+}
+
+static void 
+do_ascii(kii_focus_t *f, kii_event_t *event)
+{
+	kii_s_t base = 10, value = event->key.sym - K_FIRST_ASCII;
+
+	KRN_DEBUG(3, "doing ascii key %.4x", event->key.sym);
+
+	if (value >= 10) {
+		value -= 10;
+		base = 16;
+	}
+
+	f->npadch = (f->npadch == K_VOID) ? value : (f->npadch*base + value);
+	f->npadch %= (base == 16) ? 0x10000 : 100000;
+}
+
+static kii_unicode_t kii_dead_key[K_LAST_DEAD - K_FIRST_DEAD] = {
+	0x0060,	/* ` grave	*/
+	0x0027,	/* ' acute	*/
+	0x005e,	/* ^ circumflex	*/
+	0x007e,	/* ~ tilde	*/
+	0x0022,	/* " diaeresis	*/
+	0x002c	/* , cedilla	*/
+};
+
+static void 
+do_dead(kii_focus_t *f, kii_event_t *event)
+{
+	kii_unicode_t dead = kii_dead_key[event->key.sym - K_FIRST_DEAD];
+
+	KRN_DEBUG(3, "dead key %.4x", dead);
+	f->dead = (f->dead == event->key.sym) ? K_VOID : dead;
+}
+
+static void 
+do_action(kii_focus_t *f, kii_event_t *event)
+{
+	kii_u_t sym = event->key.sym;
+
+	if ((1 << event->any.type) & ~(KII_EM_KEY_PRESS | KII_EM_KEY_RELEASE)) 
+		return;
+
+	KRN_DEBUG(6, "key %s, code 0x%.2x, sym %.2x", 
+		(event->key.type == KII_EV_KEY_PRESS) ? "down" : "up",
+		event->key.code, event->key.sym);
+
+	switch (event->key.sym & K_TYPE_MASK) {
+#if defined(CONFIG_KDB)
+	case K_TYPE_FUNCTION:
+		if ((sym == K_PAUSE) && kdb_on)
+			kdb(KDB_REASON_KEYBOARD, 0, f->pt_regs);
+		return;
+#endif /* CONFIG_KDB */
+	case K_TYPE_SHIFT:
+		if (sym < K_LAST_SHIFT) 
+			do_modifier(f, event);
+		return;
+	case K_TYPE_ASCII:
+		if ((sym < K_LAST_ASCII) && (event->key.type == KII_EV_KEY_PRESS))
+			do_ascii(f, event);
+		return;
+	case K_TYPE_DEAD:
+		if ((sym < K_LAST_DEAD) && (event->key.type == KII_EV_KEY_PRESS ||
+			 event->key.type == KII_EV_KEY_REPEAT)) {
+			do_dead(f, event);
+		}
+		return;
+	}
+}
+
+void 
+kii_handle_input(kii_event_t *event)
+{
+	kii_focus_t *f;
+	kii_u_t mask;
+	char *sym_string;
+
+	mask = 1 << event->any.type;	
+	sym_string = NULL;
+		
+	KRN_ASSERT(KII_VALID_FOCUS_ID(event->any.focus));
+
+	f = kiifocus[event->any.focus];
+	KRN_ASSERT(f != NULL);
+
+	if (mask & (KII_EM_KEY | KII_EM_POINTER)) {
+		event->key.effect = f->effect;
+		event->key.normal = f->normal;
+		event->key.locked = f->locked;
+		event->key.sticky = f->sticky;
+	}
+
+	if ((mask & KII_EM_KEY) && (event->key.code < 0x8000)) {
+		event->key.sym = keymap_get_keysym(&f->kmap, f->effect,
+			event->key.code);
+
+		if (f->flags & KII_FF_CAPS_SHIFT)
+			event->key.sym = keymap_toggled_case(event->key.sym);
+
+		sym_string = keysyms_pretty_print(event->key.sym);
+		KRN_DEBUG(6, "key %i %s, sym %.4x <%s>", event->key.code,
+			(event->key.type == KII_EV_KEY_PRESS) ? "down" : "up",
+			event->key.sym, sym_string);
+	}
+
+#ifdef	CONFIG_MAGIC_SYSRQ
+	if (f->flags & KII_FF_SYSTEM_REQUEST) {
+		do_sysrq(f, event);
+	}
+#endif
+
+	if (mask & (KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT)) {
+		kii_event_t composed;
+
+		switch (f->dead) {
+		case K_VOID:
+			break;
+		case K_COMPOSE:
+			f->dead = event->key.sym;
+			break;
+		default:
+			switch (K_TYPE(event->key.sym)) {
+			case K_TYPE_FUNCTION:	/* Fall thru. */
+			case K_TYPE_SPECIAL:	/* Fall thru. */
+			case K_TYPE_NUMPAD: 	/* Fall thru. */
+			case K_TYPE_CONSOLE:	/* Fall thru. */
+			case K_TYPE_CURSOR: 	/* Fall thru. */		
+			case K_TYPE_SHIFT: 		/* Fall thru. */
+			case K_TYPE_META: 		/* Fall thru. */
+				break;
+			default:
+				composed.key = event->key;
+				composed.key.code = 0xFFFF;
+				composed.key.sym = keymap_combine_dead(&f->kmap,
+					f->dead, event->key.sym);
+				KRN_DEBUG(2, "composed %.4x + %.4x -> %.4x",
+					f->dead, event->key.sym,
+					composed.key.sym);
+				f->dead = (K_TYPE(event->key.sym) ==
+					K_TYPE_DEAD) ? event->key.sym : K_VOID;
+				if (!event->any.dontdispatch)
+					kii_put_event(f, &composed);
+			}
+		}
+	}
+
+	if (mask & (KII_EM_PTR_RELATIVE | KII_EM_PTR_ABSOLUTE)) {
+		if (mask & KII_EM_PTR_RELATIVE) {
+			f->ptr.x += event->pmove.x;
+			f->ptr.y += event->pmove.y;
+		} else {	/* mask & KII_EM_PTR_ABSOLUTE	*/
+			f->ptr.x = event->pmove.x;
+			f->ptr.y = event->pmove.y;
+		}
+
+#define	DO_CLIP(dir)							\
+		if (f->ptr.dir < f->ptr_min.dir) {			\
+			f->ptr.dir = f->ptr_min.dir;			\
+		}							\
+		if (f->ptr.dir >= f->ptr_max.dir) {			\
+			f->ptr.dir = f->ptr_max.dir - 1;	        \
+		}							\
+		if (f->focus)	f->focus->ptr.dir = f->ptr.dir;
+
+		DO_CLIP(x)
+		DO_CLIP(y)
+#undef	DO_CLIP
+	}
+
+	/* Local actions. */
+	do_action(f, event);
+
+	/* Global actions. */
+	kii_action(f, event);
+
+	if (!event->any.dontdispatch)
+		kii_put_event(f, event);
+}
diff -x CVS -x .svn -aurpN sys/dev/kip/kip_symbols.c sys/dev/kip/kip_symbols.c
--- sys/dev/kip/kip_symbols.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/kip/kip_symbols.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,177 @@
+/*-
+ * Copyright (C 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KII keysyms pretty-printer.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+#define	KGI_SYS_NEED_IO
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kiisyms.h>
+
+char *modifier_str[] = {
+	"Shift", "Ctrl", "Alt", "AltGr", "ShiftL", "ShiftR",
+	"CtrlL", "CtrlR", NULL
+};
+
+char *type_function_str[] = {
+	KS_F1,
+	KS_F2,
+	KS_F3,
+	KS_F4,
+	KS_F5,
+	KS_F6,
+	KS_F7,
+	KS_F8,
+	KS_F9,
+	KS_F10,
+	KS_F11,
+	KS_F12,
+	KS_F13,
+	KS_F14,
+	KS_F15,
+	KS_F16,
+	KS_F17,
+	KS_F18,
+	KS_F19,
+	KS_F20,
+	KS_FIND,
+	KS_INSERT,
+	KS_REMOVE,
+	KS_SELECT,
+	KS_PGUP,
+	KS_PGDN,
+	KS_MACRO,
+	KS_HELP,
+	KS_DO,
+	KS_PAUSE,
+	NULL
+};
+
+char *type_numpad_str[] = {
+	KS_P0,
+	KS_P1,
+	KS_P2,
+	KS_P3,
+	KS_P4,
+	KS_P5,
+	KS_P6,
+	KS_P7,
+	KS_P8,
+	KS_P9,
+	KS_PPLUS,
+	KS_PMINUS,
+	KS_PSTAR,
+	KS_PSLASH,
+	KS_PENTER,
+	KS_PCOMMA,
+	KS_PDOT,
+	KS_PPLUSMINUS,
+	KS_PARENL,
+	KS_PARENR,
+	NULL
+};
+
+char *type_special_str[] = {
+	KS_VOID,
+	KS_ENTER,
+	KS_SH_REGS,
+	KS_SH_MEM,
+	KS_SH_STAT,
+	KS_BREAK,
+	KS_CONS,
+	KS_CAPS,
+	KS_NUM,
+	KS_HOLD,
+	KS_SCROLLFORW,
+	KS_SCROLLBACK,
+	KS_BOOT,
+	KS_CAPSON,
+	KS_COMPOSE,
+	KS_SAK,
+	KS_DECRCONSOLE,
+	KS_INCRCONSOLE,
+	KS_SPAWNCONSOLE,
+	KS_BARENUMLOCK,
+	KS_TOGGLESCREEN,
+	KS_SYSTEM_REQUEST,
+	NULL
+};
+
+char *type_shift_normal_str[] = {
+	KS_NORMAL_SHIFT,
+	KS_NORMAL_CTRL,
+	KS_NORMAL_ALT,
+	KS_NORMAL_ALTGR,
+	KS_NORMAL_SHIFTL,
+	KS_NORMAL_SHIFTR,
+	KS_NORMAL_CTRLL,	
+	KS_NORMAL_CTRLR,
+	NULL
+};
+
+char *type_shift_locked_str[] = {
+	KS_LOCKED_SHIFT,
+	KS_LOCKED_CTRL,
+	KS_LOCKED_ALT,
+	KS_LOCKED_ALTGR,
+	KS_LOCKED_SHIFTL,
+	KS_LOCKED_SHIFTR,
+	KS_LOCKED_CTRLL,
+	KS_LOCKED_CTRLR,
+	NULL
+};
+
+char *type_shift_sticky_str[] = {
+	KS_STICKY_SHIFT,
+	KS_STICKY_CTRL,
+	KS_STICKY_ALT,
+	KS_STICKY_ALTGR,
+	KS_STICKY_SHIFTL,
+	KS_STICKY_SHIFTR,
+	KS_STICKY_CTRLL,
+	KS_STICKY_CTRLR,
+	NULL
+};
+
+char *
+keysyms_pretty_print(int sym)
+{
+	sym &= 0xFFFF;
+
+	if ((sym >= K_FIRST_FUNCTION) && (sym < K_LAST_FUNCTION))
+		return (type_function_str[sym - K_FIRST_FUNCTION]);
+	else if ((sym >= K_FIRST_SPECIAL) && (sym < K_LAST_SPECIAL))
+		return (type_special_str[sym - K_FIRST_SPECIAL]);		
+	else if ((sym >= K_FIRST_NUMPAD) && (sym < K_LAST_NUMPAD))
+		return (type_numpad_str[sym - K_FIRST_NUMPAD]);
+	else if ((sym >= K_FIRST_NORMAL) && (sym < K_LAST_NORMAL))
+		return (type_shift_normal_str[sym - K_FIRST_NORMAL]);
+	else if ((sym >= K_FIRST_LOCKED) && (sym < K_LAST_LOCKED))
+		return (type_shift_locked_str[sym - K_FIRST_LOCKED]);
+	else if ((sym >= K_FIRST_STICKY) && (sym < K_LAST_STICKY))
+		return (type_shift_sticky_str[sym - K_FIRST_STICKY]);
+	else
+		return (NULL);
+};
diff -x CVS -x .svn -aurpN sys/dev/pci/vga_pci.c sys/dev/pci/vga_pci.c
--- sys/dev/pci/vga_pci.c	2009-08-22 13:07:11.000000000 +0800
+++ sys/dev/pci/vga_pci.c	2009-10-01 10:42:00.000000000 +0800
@@ -30,6 +30,10 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_kgi.h"
+
+#ifndef KGI_IGNORE_VGAPCI
+
 /*
  * Simple driver for PCI VGA display devices.  Drivers such as agp(4) and
  * drm(4) should attach as children of this device.
@@ -426,3 +430,5 @@ static driver_t vga_pci_driver = {
 static devclass_t vga_devclass;
 
 DRIVER_MODULE(vgapci, pci, vga_pci_driver, vga_devclass, 0, 0);
+#endif /* KGI_IGNORE_VGAPCI */
+
diff -x CVS -x .svn -aurpN sys/dev/sce/sce_bootconsole.c sys/dev/sce/sce_bootconsole.c
--- sys/dev/sce/sce_bootconsole.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/sce/sce_bootconsole.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,394 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * KGI FreeBSD boot console.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+#include "opt_syscons.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/cons.h>
+#include <sys/consio.h>
+#include <sys/fbio.h>
+#include <sys/kernel.h>
+#include <sys/linker.h>
+#include <sys/module.h>
+#include <sys/bus.h>
+
+#include <dev/fb/fbreg.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kii.h>
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+#include <dev/kgc/kgc_emuxterm.h>
+#include <dev/kgc/kgc_emudumb.h>
+#include <dev/sce/sce_syscons.h>
+
+#include "scroller_if.h"
+#include "render_if.h"
+
+/* Define here for early init without allocation. */
+static sce_console scecons;
+static kgi_u16_t sce_buf[CONFIG_KGII_CONSOLEBUFSIZE];
+
+/* Prototypes */
+static void console_printk(char *b, unsigned count);
+static void do_reset(kgi_console_t *cons);
+static int event2char(kii_device_t *dev, kii_event_t *ev);
+static void sce_handle_kii_event(kii_device_t *dev, kii_event_t *ev);
+
+/* Console */
+static cn_probe_t	sce_cnprobe;
+static cn_init_t	sce_cninit;
+static cn_term_t	sce_cnterm;
+static cn_getc_t	sce_cngetc;
+static cn_checkc_t	sce_cncheckc;
+static cn_putc_t	sce_cnputc;
+
+/*
+ * Define manually until we activate the CONSOLE_DRIVER macro.
+ * Use of CONSOLE_DRIVER(sce) currently causes a panic at RENDER_INIT
+ * in sce_cninit.
+ */
+static struct consdev sce_consdev = {
+	sce_cnprobe, sce_cninit, sce_cnterm, sce_cngetc,
+	sce_cncheckc, sce_cnputc, 0};
+
+/*
+ * This is a printk() implementation based on the scroll->* functions. 
+ */
+static void 
+console_printk(char *b, unsigned count)
+{
+	kgi_console_t *cons;
+	kgi_u_t c;
+	static int printing = 0;
+
+	cons = (kgi_console_t *)&scecons;
+
+	if (printing || cons == NULL) 
+		return;
+
+	printing = 1;
+
+	SCROLLER_MARK(cons->scroller);
+
+	while (count--) {
+		c = *(b++);
+
+		/* Is it a printable character? */
+		if (c >= 32) {
+			if (cons->flags & KGI_CF_NEED_WRAP) {
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				if (CONSOLE_MODE(cons, KGI_CM_AUTO_WRAP)) {
+					SCROLLER_LF(cons->scroller);
+				}
+				SCROLLER_CR(cons->scroller);
+				SCROLLER_MARK(cons->scroller);
+			}
+
+			SCROLLER_WRITE(cons->scroller, c);
+
+		} else {
+			switch (c) {
+			case ASCII_LF:
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				SCROLLER_LF(cons->scroller);
+				SCROLLER_MARK(cons->scroller);
+				/* FALL THROUGH */
+			case ASCII_CR:
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				SCROLLER_CR(cons->scroller);
+				SCROLLER_MARK(cons->scroller);
+				break;
+			case ASCII_BS:
+				SCROLLER_MODIFIED_MARK(cons->scroller);
+				SCROLLER_BS(cons->scroller);
+				SCROLLER_MARK(cons->scroller);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	if (cons->flags & KGI_CF_NEED_WRAP) 
+		SCROLLER_MODIFIED_WRAP(cons->scroller);
+	else 
+		SCROLLER_MODIFIED_MARK(cons->scroller);
+	
+	SCROLLER_SYNC(cons->scroller);
+	printing = 0;
+}
+
+static void 
+do_reset(kgi_console_t *cons)
+{
+	scroller_t scroll;
+	
+	scroll = (scroller_t)cons->scroller;	
+	cons->kii.event_mask = KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT | KII_EM_POINTER;
+
+	SCROLLER_RESET(scroll);
+
+	SCROLLER_UPDATE_ATTR(scroll);
+	SCROLLER_GOTOXY(scroll, 0, 0);
+	SCROLLER_ERASE_DISPLAY(scroll, 2);
+
+	SCROLLER_SYNC(scroll);
+}
+
+static int 
+event2char(kii_device_t *dev, kii_event_t *ev)
+{
+	kgi_console_t *cons;
+	int s;
+
+	cons = (kgi_console_t *)dev->priv.priv_ptr;
+	/* Forward to sysmouse pointer events. */
+ 	if ((1 << ev->any.type) & KII_EM_POINTER) {
+ 		sce_sysmouse_event(ev);
+ 		return (-1);
+ 	}
+	
+	if (((1 << ev->any.type) & ~(KII_EM_KEY_PRESS | KII_EM_KEY_REPEAT)) ||
+		(ev->key.sym == K_VOID)) {
+		return (-1);
+	}
+
+	s = spltty();
+	switch (ev->key.sym & K_TYPE_MASK) {
+	case K_TYPE_LATIN:
+		return (ev->key.sym & K_VALUE_MASK);
+	case K_TYPE_SPECIAL:
+		switch (ev->key.sym) {
+		case K_ENTER:
+			return ('\n');
+			break;
+		case K_SCROLLFORW:
+			SCROLLER_FORWARD(cons->scroller, 0);
+			SCROLLER_SYNC(cons->scroller);
+			break;
+		case K_SCROLLBACK:
+			SCROLLER_BACKWARD(cons->scroller, 0);
+			SCROLLER_SYNC(cons->scroller);
+			break;
+		default:
+			break;
+		}
+	}
+	splx(s);
+
+	return (-1);
+}
+
+static void 
+sce_handle_kii_event(kii_device_t *dev, kii_event_t *ev)
+{
+	int discard;
+
+	discard = event2char(dev, ev);
+}
+
+/*
+ * Console probe.
+ */
+static void
+sce_cnprobe(struct consdev *cp)
+{
+	int i, unit;
+
+	/*
+	 * sce is the internal console of the system.
+	 */
+	unit = 0;
+	cp->cn_pri = CN_INTERNAL;
+
+	/* See if this driver is disabled in probe hint. */ 
+	if ((resource_int_value("sce", unit, "disabled", &i)) == 0 && i)
+		cp->cn_pri = CN_DEAD;
+
+	if (cp->cn_pri == CN_DEAD)
+		return;
+	
+	strcpy(cp->cn_name, "ttyv0");
+}
+
+/*
+ * Console init
+ * Setup up the console with KGI's renderer, input interface & scroller.
+ */
+static void
+sce_cninit(struct consdev *cp)
+{
+	kgi_console_t *cons;
+	
+	cons = (kgi_console_t *)&scecons;	
+	memset(cons, 0, sizeof(*cons));
+
+	/* 
+	 * Use backdoors at early initializations.
+	 */
+	textscroller_configure(cons);
+	gfbrndr_configure(cons);
+
+	/* Reserve the first cons as boot console. */
+	sce_consoles[0] = &scecons;
+
+	cons->kii.flags |= KII_DF_CONSOLE;
+	cons->kii.priv.priv_ptr = cons;
+	cons->kii.HandleEvent	= &sce_handle_kii_event;
+
+	cons->meta_console = (void *)cp;
+
+	/* 
+	 * Init the renderer for the KGI device registered to device 0
+	 */
+	if (RENDER_INIT((render_t)cons->render, 0))   
+		panic("Could not init renderer!");
+
+	if (kii_register_device(&(cons->kii), 0))  
+		panic("Could not register input!");
+
+	if (SCROLLER_INIT((scroller_t)cons->scroller, sce_buf)) 
+		panic("Could not reset scroller state!");
+
+	cons->refcnt++;
+
+	kii_map_device(cons->kii.id);
+	
+	do_reset(cons);
+	
+	console_initialized = 1;
+}
+
+/*
+ * Console finish
+ */
+static void
+sce_cnterm(struct consdev *cp)
+{
+
+	return;
+}
+
+/*
+ * Console get char
+ */
+static int
+sce_cngetc(struct consdev *cp)
+{
+	int c;
+
+	while ((c = sce_cncheckc(cp)) == -1)
+		;
+
+	return (c);
+}
+
+/*
+ * Console check for char
+ */
+static int
+sce_cncheckc(struct consdev *cp)
+{
+	kii_event_t event;
+	int s, c;
+
+	s = spltty();
+
+	kii_poll_device(0, &event);
+	c = event2char(&scecons.type.any.kii, &event);
+
+	splx(s);
+
+	return (c);
+}
+
+/*
+ * Console put char
+ */
+static void
+sce_cnputc(struct consdev *cp, int c)
+{
+	char cc;
+
+ 	cc = (char)c;
+	console_printk(&cc, 1);
+}
+
+/* 
+ * Early initialization of sce. Configure the video drivers.
+ */
+static void
+scecn_vid_init(void)
+{	
+	/*
+	 * Access the video adapter driver through the back door!
+	 * Video adapter drivers need to be configured before syscons.
+	 * However, when syscons is being probed as the low-level console,
+	 * they have not been initialized yet.  We force them to initialize
+	 * themselves here.
+	 */
+	vid_configure(VIO_PROBE_ONLY);
+}
+SYSINIT(sce, SI_SUB_KGI, SI_ORDER_MIDDLE, scecn_vid_init, NULL);
+
+static int
+scecn_mod_event(module_t mod, int type, void *data)
+{
+
+	switch (type) {
+	case MOD_LOAD:
+		memset(sce_consoles, 0, sizeof(sce_consoles));		
+		sce_cnprobe(&sce_consdev);
+		sce_cninit(&sce_consdev);
+		cnadd(&sce_consdev);
+		break;
+	case MOD_UNLOAD:
+		return (ENXIO);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static moduledata_t scecn_mod = {
+	"scecn",
+	scecn_mod_event,
+	NULL,
+};
+
+/* SI_ORDER_ANY to init after VESA if present */
+DECLARE_MODULE(scecn, scecn_mod, SI_SUB_DRIVERS, SI_ORDER_ANY);
+MODULE_VERSION(scecn, 1);
diff -x CVS -x .svn -aurpN sys/dev/sce/sce_scmouse.c sys/dev/sce/sce_scmouse.c
--- sys/dev/sce/sce_scmouse.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/sce/sce_scmouse.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,243 @@
+/*-
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/* 
+ * KII syscons mouse emulation input.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+#include "opt_syscons.h"
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	1
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/consio.h>
+#include <sys/fbio.h>
+#include <sys/limits.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mouse.h>
+#include <sys/proc.h>
+#include <sys/random.h>
+#include <sys/signalvar.h>
+#include <sys/syslog.h>
+#include <sys/time.h>
+#include <sys/tty.h>
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+
+#include <dev/kgc/kgc_emuxterm.h>
+#include <dev/kgc/kgc_emudumb.h>
+
+#include <dev/sce/sce_syscons.h>
+
+struct sce_mouse {
+	kii_u_t		last;
+	kii_input_t	input;
+	kii_u_t		opened;
+};
+
+static int sce_ctlclose(struct cdev *dev, int flag, int mode, struct thread *td);
+static int sce_ctlioctl(struct cdev *dev, u_long cmd, caddr_t data, int flag,
+		struct thread *td);
+static int sce_ctlopen(struct cdev *dev, int flag, int mode, struct thread *td);
+
+static struct cdevsw scectl_cdevsw = {
+	.d_flags 	= D_NEEDGIANT,
+	.d_close 	= sce_ctlclose,
+	.d_ioctl 	= sce_ctlioctl,
+	.d_open	 	= sce_ctlopen,
+	.d_version  = D_VERSION,
+	.d_name 	= "scectl"
+};
+
+static struct sce_mouse sce_mouses[KII_MAX_NR_FOCUSES];
+
+static int
+mouse_event(struct sce_mouse *mouse, mouse_info_t *info)
+{
+	kii_event_t event;
+
+	bzero(&event, sizeof(event));
+	event.any.focus  = mouse->input.focus;
+	event.any.device = mouse->input.id;
+
+	switch (info->operation) {
+	case MOUSE_ACTION: /* Fall thru. */
+	case MOUSE_MOTION_EVENT:
+		event.pmove.size = sizeof(kii_pmove_event_t);
+
+		event.pmove.dummy[0] = event.pmove.dummy[1] = 0;
+
+		event.pmove.x = info->u.data.x;
+		event.pmove.y = info->u.data.y;
+		event.pmove.wheel = info->u.data.z;
+
+		event.pbutton.type = KII_EV_PTR_RELATIVE;
+
+		break;
+	case MOUSE_BUTTON_EVENT:
+		if ((info->u.event.id & MOUSE_BUTTONS) == 0)
+			return (EINVAL);
+
+		if (info->u.event.value < 0)
+			return (EINVAL);
+
+		event.pbutton.size = sizeof(kii_pbutton_event_t);
+
+		if (info->u.event.value > 0)
+			event.pbutton.state |= info->u.event.id;
+		else
+			event.pbutton.state &= ~info->u.event.id;
+
+		event.pbutton.button = mouse->last ^ event.pbutton.state;
+
+		mouse->last = event.pbutton.state;
+
+		event.pbutton.type = (event.pbutton.button & event.pbutton.state)
+			? KII_EV_PTR_BUTTON_PRESS : KII_EV_PTR_BUTTON_RELEASE;
+		break;
+	default:
+		break;
+	}
+
+	if (event.pbutton.type && (mouse->input.report & 
+			(1 << event.pbutton.type))) {		
+		KRN_DEBUG(2, "%s", 
+			  (event.pbutton.type == KII_EV_PTR_BUTTON_PRESS)
+			  ? "KII_EV_PTR_BUTTON_PRESS" 
+			  : "KII_EV_PTR_BUTTON_RELEASE");
+
+		kii_handle_input(&event);
+	}
+
+	return (0);
+}
+
+static int
+sce_ctlclose(struct cdev *dev, int flag, int mode, struct thread *td)
+{
+
+	KRN_DEBUG(2, "sce_ctlclose: dev:%s, vty:,%d\n", 
+			devtoname(dev), dev2unit(dev));
+
+	sce_mouses[dev2unit(dev)].opened = 0;
+
+	return (0);
+}
+
+static int
+sce_ctlioctl(struct cdev *dev, u_long cmd, caddr_t data, int flag,
+			 struct thread *td)
+{
+	struct sce_mouse *mouse;
+	mouse_info_t *info;
+	int error;
+
+	mouse = &sce_mouses[dev2unit(dev)];	
+	error = 0;
+
+	switch (cmd) {
+	case CONS_MOUSECTL: /* Control mouse arrow. */
+		info = (mouse_info_t*)data;
+
+		random_harvest(info, sizeof(mouse_info_t), 2, 0, RANDOM_MOUSE);
+
+		switch (info->operation) {
+		case MOUSE_MODE: /* Fall thru. */
+		case MOUSE_SHOW: /* Fall thru. */
+		case MOUSE_HIDE: /* Fall thru. */
+		case MOUSE_MOVEABS: /* Fall thru. */
+		case MOUSE_MOVEREL: /* Fall thru. */
+		case MOUSE_GETINFO: /* Fall thru. */
+			return (EINVAL);
+			/* Send out mouse event on /dev/sysmouse. */
+		case MOUSE_ACTION: /* Fall thru. */
+		case MOUSE_MOTION_EVENT:
+			error = mouse_event(mouse, info);
+			break;
+		case MOUSE_BUTTON_EVENT:
+			if (((info->u.event.id & MOUSE_BUTTONS) == 0) ||
+			    (info->u.event.value < 0))
+				return (EINVAL);
+				
+			error = mouse_event(mouse, info);
+			break;
+		case MOUSE_MOUSECHAR: /* Fall thru. */
+		default:
+			return (EINVAL);
+		}
+
+		return (error);
+	}
+
+	return (ENOIOCTL);
+}
+
+static int
+sce_ctlopen(struct cdev *dev, int flag, int mode, struct thread *td)
+{
+	struct sce_mouse *mouse;
+
+	KRN_DEBUG(2, "sce_ctlopen: dev:%s, vty:%d\n",
+			devtoname(dev), dev2unit(dev));
+
+	mouse = &sce_mouses[dev2unit(dev)];
+
+	if (mouse->opened)
+		return (EBUSY);
+
+	snprintf(mouse->input.vendor, KII_MAX_VENDOR_STRING, "FreeBSD");
+	snprintf(mouse->input.model, KII_MAX_VENDOR_STRING, "consolectl");
+	
+	mouse->input.focus = KII_INVALID_FOCUS;
+	mouse->input.id = KII_INVALID_DEVICE;
+	mouse->input.events = KII_EM_POINTER & ~KII_EM_PTR_ABSOLUTE;
+	mouse->input.report = KII_EM_PTR_RELATIVE | KII_EM_PTR_BUTTON;
+	mouse->input.priv.priv_ptr = mouse;
+	
+	if (kii_register_input(dev2unit(dev), &mouse->input, 0))
+		KRN_ERROR("Could not register sce_mouse %d", dev2unit(dev));
+
+	mouse->opened = 1;
+
+	return (0);
+}
+
+int 
+sce_mouse_init()
+{
+	int focus;
+
+	bzero(sce_mouses, sizeof(sce_mouses));
+	make_dev(&scectl_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, "consolectl");
+	for (focus = 1; focus < KII_MAX_NR_FOCUSES; focus++) {
+		make_dev(&scectl_cdevsw, focus, UID_ROOT, GID_WHEEL, 0600,
+				 "consolectl" "%d", focus);
+	}
+
+	return (0);
+}
diff -x CVS -x .svn -aurpN sys/dev/sce/sce_syscons.h sys/dev/sce/sce_syscons.h
--- sys/dev/sce/sce_syscons.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/sce/sce_syscons.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,176 @@
+/*-
+ * Copyright (c) 1995-1998 Sren Schmidt
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The DragonFly Project
+ * by Sascha Wildner <saw@online.de>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * From FreeBSD: /head/sys/dev/syscons/syscons.h r189617
+ */
+
+#ifndef _DEV_SYSCONS_SYSCONS_H_
+#define	_DEV_SYSCONS_SYSCONS_H_
+
+#include <sys/lock.h>
+#include <sys/mutex.h>
+
+/* machine-dependent part of the header */
+
+#ifdef PC98
+#include <pc98/cbus/sc_machdep.h>
+#elif defined(__i386__)
+/* nothing for the moment */
+#endif
+
+/* default values for configuration options */
+
+#ifndef MAXCONS
+#define MAXCONS		24
+#endif
+
+#ifdef SC_NO_SYSMOUSE
+#undef SC_NO_CUTPASTE
+#define SC_NO_CUTPASTE	1
+#endif
+
+#ifdef SC_NO_MODE_CHANGE
+#undef SC_PIXEL_MODE
+#endif
+
+/* Always load font data if the pixel (raster text) mode is to be used. */
+#ifdef SC_PIXEL_MODE
+#undef SC_NO_FONT_LOADING
+#endif
+
+/* 
+ * If font data is not available, the `arrow'-shaped mouse cursor cannot
+ * be drawn.  Use the alternative drawing method.
+ */
+#ifdef SC_NO_FONT_LOADING
+#undef SC_ALT_MOUSE_IMAGE
+#define SC_ALT_MOUSE_IMAGE 1
+#endif
+
+#ifndef SC_CURSOR_CHAR
+#define SC_CURSOR_CHAR	(0x07)
+#endif
+
+#ifndef SC_MOUSE_CHAR
+#define SC_MOUSE_CHAR	(0xd0)
+#endif
+
+#if SC_MOUSE_CHAR <= SC_CURSOR_CHAR && SC_CURSOR_CHAR < (SC_MOUSE_CHAR + 4)
+#undef SC_CURSOR_CHAR
+#define SC_CURSOR_CHAR	(SC_MOUSE_CHAR + 4)
+#endif
+
+#ifndef SC_DEBUG_LEVEL
+#define SC_DEBUG_LEVEL	0
+#endif
+
+#define DPRINTF(l, p)	if (SC_DEBUG_LEVEL >= (l)) printf p
+
+#ifndef __sparc64__
+#define SC_DRIVER_NAME	"sce"
+#else
+/*
+ * Use a different driver name on sparc64 so it does not get confused
+ * with the system controller devices which are also termed 'sc' in OFW.
+ */
+#define SC_DRIVER_NAME	"sce"
+#endif
+#define SC_VTY(dev)	(((sc_ttysoftc *)tty_softc(tp))->st_index)
+#define SC_DEV(sc, vty)	((sc)->dev[(vty) - (sc)->first_vty])
+#define SC_STAT(tp)	(*((scr_stat **)&((sc_ttysoftc *)tty_softc(tp))->st_stat))
+
+/* printable chars */
+#ifndef PRINTABLE
+#define PRINTABLE(ch)	((ch) > 0x1b || ((ch) > 0x0d && (ch) < 0x1b) \
+			 || (ch) < 0x07)
+#endif
+
+/* macros for "intelligent" screen update */
+#define mark_for_update(scp, x)	{\
+			  	    if ((x) < scp->start) scp->start = (x);\
+				    else if ((x) > scp->end) scp->end = (x);\
+				}
+#define mark_all(scp)		{\
+				    scp->start = 0;\
+				    scp->end = scp->xsize * scp->ysize - 1;\
+				}
+
+/* vty status flags (scp->status) */
+#define UNKNOWN_MODE	0x00010		/* unknown video mode */
+#define SWITCH_WAIT_REL	0x00080		/* waiting for vty release */
+#define SWITCH_WAIT_ACQ	0x00100		/* waiting for vty ack */
+#define BUFFER_SAVED	0x00200		/* vty buffer is saved */
+#define CURSOR_ENABLED 	0x00400		/* text cursor is enabled */
+#define MOUSE_MOVED	0x01000		/* mouse cursor has moved */
+#define MOUSE_CUTTING	0x02000		/* mouse cursor is cutting text */
+#define MOUSE_VISIBLE	0x04000		/* mouse cursor is showing */
+#define GRAPHICS_MODE	0x08000		/* vty is in a graphics mode */
+#define PIXEL_MODE	0x10000		/* vty is in a raster text mode */
+#define SAVER_RUNNING	0x20000		/* screen saver is running */
+#define VR_CURSOR_BLINK	0x40000		/* blinking text cursor */
+#define VR_CURSOR_ON	0x80000		/* text cursor is on */
+#define MOUSE_HIDDEN	0x100000	/* mouse cursor is temporarily hidden */
+
+/* misc defines */
+#define FALSE		0
+#define TRUE		1
+
+/*
+   The following #defines are hard-coded for a maximum text
+   resolution corresponding to a maximum framebuffer
+   resolution of 1600x1200 with an 8x8 font...
+*/
+#define	COL		200
+#define	ROW		150
+
+#define PCBURST		128
+
+#define SCEVT_COLD 0
+#define SCEVT_WARM 1
+
+typedef struct {
+	union {	/* keep it first */
+		kgi_console_t any;
+		kgi_console_dumb_t dumb;
+		kgi_console_xterm_t xterm;
+	} type;
+} sce_console;
+
+typedef struct sce_ttysoftc {
+	int unit;
+} sce_ttysoftc;
+
+extern sce_console *sce_consoles[CONFIG_KGII_MAX_NR_CONSOLES];
+
+extern int sce_mouse_init(void);
+extern int sce_sysmouse_init(void);
+extern void sce_sysmouse_event(kii_event_t *ev);
+
+#endif /* !_DEV_SYSCONS_SYSCONS_H_ */
diff -x CVS -x .svn -aurpN sys/dev/sce/sce_sysmouse.c sys/dev/sce/sce_sysmouse.c
--- sys/dev/sce/sce_sysmouse.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/sce/sce_sysmouse.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,278 @@
+/*-
+ * Copyright (c) 1999 Kazutaka YOKOTA <yokota@zodiac.mech.utsunomiya-u.ac.jp>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer as
+ *    the first lines of this file unmodified.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * From FreeBSD: sys/dev/syscons/sysmouse.c -r196539M
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+#include "opt_syscons.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/priv.h>
+#include <sys/serial.h>
+#include <sys/tty.h>
+#include <sys/kernel.h>
+#include <sys/consio.h>
+#include <sys/mouse.h>
+
+#include <dev/kgi/system.h>
+#include <dev/kgi/debug.h>
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+#include <dev/kii/kii.h>
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_emuxterm.h>
+#include <dev/kgc/kgc_emudumb.h>
+
+#include <dev/sce/sce_syscons.h>
+
+#ifndef SC_NO_SYSMOUSE
+
+typedef struct {
+	struct tty *tty;
+	int level;	/* sysmouse protocol level. */
+	mousestatus_t status;
+}sce_sysmouse;
+
+static tsw_close_t		sce_smclose;
+static tsw_ioctl_t		sce_smioctl;
+static tsw_param_t		sce_smparam;
+
+static struct ttydevsw scesm_ttydevsw = {
+	.tsw_flags		= TF_NOPREFIX,
+	.tsw_close		= sce_smclose,
+	.tsw_ioctl		= sce_smioctl,
+	.tsw_param		= sce_smparam,
+
+};
+
+static sce_sysmouse sysmouse;
+
+static void
+sce_smclose(struct tty *tp)
+{
+	int s;
+
+	s = spltty();
+	sysmouse.level = 0;
+	sysmouse.tty = NULL;
+	splx(s);
+
+	return;
+}
+
+static int
+sce_smioctl(struct tty *tp, u_long cmd, caddr_t data, struct thread *td)
+{
+	mousehw_t *hw;
+	mousemode_t *mode;
+	int s;
+
+	switch (cmd) {
+	case MOUSE_GETHWINFO: /* Get device information. */
+		hw = (mousehw_t *)data;
+		hw->buttons = 10; /* XXX unknown. */
+		hw->iftype = MOUSE_IF_SYSMOUSE;
+		hw->type = MOUSE_MOUSE;
+		hw->model = MOUSE_MODEL_GENERIC;
+		hw->hwid = 0;
+		return (0);
+	case MOUSE_GETMODE:	/* Get protocol/mode. */
+		mode = (mousemode_t *)data;
+		mode->level = sysmouse.level;
+		switch (mode->level) {
+		case 0: /* Emulate MouseSystems protocol. */
+			mode->protocol = MOUSE_PROTO_MSC;
+			mode->rate = -1;		/* Unknown. */
+			mode->resolution = -1;	/* Unknown. */
+			mode->accelfactor = 0;	/* Disabled. */
+			mode->packetsize = MOUSE_MSC_PACKETSIZE;
+			mode->syncmask[0] = MOUSE_MSC_SYNCMASK;
+			mode->syncmask[1] = MOUSE_MSC_SYNC;
+			break;
+		case 1: /* sysmouse protocol. */
+			mode->protocol = MOUSE_PROTO_SYSMOUSE;
+			mode->rate = -1;
+			mode->resolution = -1;
+			mode->accelfactor = 0;
+			mode->packetsize = MOUSE_SYS_PACKETSIZE;
+			mode->syncmask[0] = MOUSE_SYS_SYNCMASK;
+			mode->syncmask[1] = MOUSE_SYS_SYNC;
+			break;
+		}
+		return (0);
+	case MOUSE_SETMODE:	/* Set protocol/mode. */
+		mode = (mousemode_t *)data;
+		if (mode->level == -1)
+			; 	/* Don't change the current setting. */
+		else if ((mode->level < 0) || (mode->level > 1))
+			return (EINVAL);
+		else
+			sysmouse.level = mode->level;
+		return (0);
+	case MOUSE_GETLEVEL: /* Get operation level. */
+		*(int *)data = sysmouse.level;
+		return (0);
+	case MOUSE_SETLEVEL: /* Set operation level. */
+		if ((*(int *)data  < 0) || (*(int *)data > 1))
+			return (EINVAL);
+		sysmouse.level = *(int *)data;
+		return (0);
+	case MOUSE_GETSTATUS: /* Get accumulated mouse events. */
+		s = spltty();
+		*(mousestatus_t *)data = sysmouse.status;
+		sysmouse.status.flags = 0;
+		sysmouse.status.obutton = sysmouse.status.button;
+		sysmouse.status.dx = 0;
+		sysmouse.status.dy = 0;
+		sysmouse.status.dz = 0;
+		splx(s);
+		return (0);
+#ifdef notyet
+	case MOUSE_GETVARS:	/* Get internal mouse variables. */
+	case MOUSE_SETVARS:	/* Set internal mouse variables. */
+		return (ENODEV);
+#endif
+	case MOUSE_READSTATE: /* Read status from the device. */
+	case MOUSE_READDATA:  /* Read data from the device.   */
+		return (ENODEV);
+	}
+
+	return (ENOIOCTL);
+}
+
+static int
+sce_smparam(struct tty *tp, struct termios *t)
+{
+
+	/*
+	 * Set the output baud rate to zero. The mouse device supports
+	 * no output, so we don't want to waste buffers.
+	 */
+	t->c_ispeed = TTYDEF_SPEED;
+	t->c_ospeed = B0;
+	
+	return (0);
+}
+
+void 
+sce_sysmouse_event(kii_event_t *ev)
+{	
+	
+	/* MOUSE_BUTTON?DOWN -> MOUSE_MSC_BUTTON?UP */
+	static int butmap[8] = {
+	    MOUSE_MSC_BUTTON1UP | MOUSE_MSC_BUTTON2UP | MOUSE_MSC_BUTTON3UP,
+	    MOUSE_MSC_BUTTON2UP | MOUSE_MSC_BUTTON3UP,
+	    MOUSE_MSC_BUTTON1UP | MOUSE_MSC_BUTTON3UP,
+	    MOUSE_MSC_BUTTON3UP,
+	    MOUSE_MSC_BUTTON1UP | MOUSE_MSC_BUTTON2UP,
+	    MOUSE_MSC_BUTTON2UP,
+	    MOUSE_MSC_BUTTON1UP,
+	    0,
+	};
+	/* XXX FIXME */
+	sce_sysmouse *sysm;
+	u_char buf[8];
+	int i, x, y, z;
+
+	sysm = &sysmouse;
+
+	switch (ev->pbutton.type) {
+	case KII_EV_PTR_RELATIVE:
+        sysm->status.button = 0;
+		x = ev->pmove.x;
+		y = ev->pmove.y;
+		z = ev->pmove.wheel;
+		break;
+	case KII_EV_PTR_BUTTON_PRESS: /* Fall thru. */
+	case KII_EV_PTR_BUTTON_RELEASE:
+		x = y = z = 0;
+		sysm->status.button |= ev->pbutton.state;
+		break;
+	default:
+		return;
+	}
+
+	sysm->status.dx += x;
+	sysm->status.dy += y;
+	sysm->status.dz += z;
+	sysm->status.flags |= ((x || y || z) ? MOUSE_POSCHANGED : 0)
+			      | (ev->pbutton.button);
+	if (sysm->status.flags == 0)
+		return;
+
+	if ((sysm->tty == NULL) || !tty_opened(sysm->tty))
+		return;
+
+	/* The first five bytes are compatible with MouseSystems' */
+	buf[0] = MOUSE_MSC_SYNC
+		 | butmap[sysm->status.button & MOUSE_STDBUTTONS];
+	x = imax(imin(x, 255), -256);
+	buf[1] = x >> 1;
+	buf[3] = x - buf[1];
+	y = -imax(imin(y, 255), -256);
+	buf[2] = y >> 1;
+	buf[4] = y - buf[2];
+
+	tty_lock(sysm->tty);
+	for (i = 0; i < MOUSE_MSC_PACKETSIZE; ++i)
+		ttydisc_rint(sysm->tty, (char)buf[i], 0);
+	
+	if (sysm->level >= 1) {		
+		/* Extended part. */
+        z = imax(imin(z, 127), -128);
+        buf[5] = (z >> 1) & 0x7f;
+        buf[6] = (z - (z >> 1)) & 0x7f;
+        /* Buttons 4-10 */
+        buf[7] = (~sysm->status.button >> 3) & 0x7f;
+        for (i = MOUSE_MSC_PACKETSIZE; i < MOUSE_SYS_PACKETSIZE; ++i)
+			ttydisc_rint(sysm->tty, (char)buf[i], 0);				
+	}	
+
+	ttydisc_rint_done(sysm->tty);
+	tty_unlock(sysm->tty);
+
+	return;
+}
+
+int 
+sce_sysmouse_init(void)
+{
+
+	bzero(&sysmouse, sizeof(sce_sysmouse));	
+	sysmouse.tty = tty_alloc(&scesm_ttydevsw, NULL);
+	tty_makedev(sysmouse.tty, NULL, "sysmouse");
+
+	return (0);
+}
+SYSINIT(sce_sysmouse, SI_SUB_DRIVERS, SI_ORDER_MIDDLE, sce_sysmouse_init, NULL);
+
+#endif /* !SC_NO_SYSMOUSE */
diff -x CVS -x .svn -aurpN sys/dev/sce/sce_vtconsole.c sys/dev/sce/sce_vtconsole.c
--- sys/dev/sce/sce_vtconsole.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/dev/sce/sce_vtconsole.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,486 @@
+/*-
+ * Copyright (C) 1995-2000 Steffen Seeger
+ * Copyright (C) 2003 Nicholas Souchu
+ * 
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+ /*
+  * KGI console driver.
+  */
+  
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_kgi.h"
+
+/* 
+ * XXX FIXME 
+ * I think this FIXME may be referring to the use of compile time terminal
+ * emulator selection?
+ */
+#define KGC_TERM_XTERM
+
+#ifndef KGI_DBG_LEVEL
+#define	KGI_DBG_LEVEL	4
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/callout.h>
+#include <sys/conf.h>
+#include <sys/cons.h>
+#include <sys/kernel.h>
+#include <sys/linker.h>
+#include <sys/module.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mutex.h>
+#include <sys/proc.h>
+#include <sys/priv.h>
+#include <sys/random.h>
+#include <sys/signalvar.h>
+#include <sys/syslog.h>
+#include <sys/time.h>
+#include <sys/tty.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/kbio.h>
+
+#define KGI_SYS_NEED_MALLOC
+#include <dev/kgi/system.h>
+#include <dev/kgi/kgii.h>
+#include <dev/kgi/kgi.h>
+
+#define KII_NEED_MODIFIER_KEYSYMS
+#include <dev/kii/kii.h>
+
+#include <dev/kgc/kgc_console.h>
+#include <dev/kgc/kgc_textbuf.h>
+#include <dev/kgc/kgc_scroller.h>
+#include <dev/kgc/kgc_render.h>
+#include <dev/kgc/kgc_gfbrndr.h>
+#include <dev/kgc/kgc_emuxterm.h>
+#include <dev/kgc/kgc_emudumb.h>
+
+#include <dev/sce/sce_syscons.h>
+
+#include "scroller_if.h"
+#include "render_if.h"
+
+static int first_minor_allocated = 0;
+sce_console *sce_consoles[CONFIG_KGII_MAX_NR_CONSOLES];
+
+/* Prototypes */
+static void assign_parser(kgi_console_t *cons, int do_reset);
+static void sce_handle_kii_event(kii_device_t *dev, kii_event_t *e);
+static int sce_close_vt(int unit);
+static int sce_ttytounit(struct tty *tp);
+static int sce_init_vt(struct tty *tp);
+static struct tty* sce_create_tty(int unit);
+
+/* TTY */
+static tsw_ioctl_t		sce_tswioctl;
+static tsw_open_t		sce_tswopen;
+static tsw_outwakeup_t	sce_tswoutwakeup;
+
+static struct ttydevsw scevt_ttydevsw = {
+	.tsw_ioctl		= sce_tswioctl,
+	.tsw_open		= sce_tswopen,
+	.tsw_outwakeup	= sce_tswoutwakeup
+};
+
+static d_ioctl_t scevt_ioctl;
+
+static struct cdevsw scevt_devsw = {
+	.d_version	= D_VERSION,
+	.d_flags	= D_NEEDGIANT,
+	.d_ioctl	= scevt_ioctl,
+	.d_name		= "scevt"
+};
+
+/*
+ * XXX
+ * This should handle assignment of registered terminal emulators later.
+ * For now we only enter the neccessary fields for the dumb or xterm parser.
+ */
+static void 
+assign_parser(kgi_console_t *cons, int do_reset)
+{
+
+	KRN_ASSERT(cons);
+
+	cons->kii.MapDevice		= kgc_map_kii;
+	cons->kii.UnmapDevice	= kgc_unmap_kii;
+	cons->kii.HandleEvent	= &sce_handle_kii_event;
+	cons->kii.event_mask	= KII_EM_POINTER;
+#ifdef KGC_TERM_XTERM
+	cons->DoWrite = &xterm_do_write;
+	xterm_do_reset(cons, do_reset);
+#else
+#ifndef KGC_TERM_DUMB
+#error KGC_TERM_DUMB not defined
+#endif
+	cons->DoWrite = &dumb_do_write;
+	dumb_do_reset(cons, do_reset);
+#endif
+}
+
+static void 
+sce_handle_kii_event(kii_device_t *dev, kii_event_t *e)
+{
+
+	/* Forward to sysmouse pointer events */
+ 	if ((1 << e->any.type) & KII_EM_POINTER) {
+ 		sce_sysmouse_event(e);
+ 		return;
+ 	}
+#ifdef KGC_TERM_XTERM
+	xterm_handle_kii_event(dev, e);
+#else
+#ifndef KGC_TERM_DUMB
+#error KGC_TERM_DUMB not defined
+#endif
+	dumb_handle_kii_event(dev, e);
+#endif
+}
+
+/*
+ * Create a console & associate a TTY with it.
+ */
+static int
+sce_init_vt(struct tty *tp)
+{	
+	kgi_u_t unit;
+	kgi_console_t *cons;
+	kgi_error_t err;
+
+	unit = sce_ttytounit(tp);
+	if (unit >= CONFIG_KGII_MAX_NR_CONSOLES) {
+		KRN_ERROR("Reached maximum amount of consoles.");
+		return (ENXIO);
+	}
+
+	cons = (kgi_console_t *)sce_consoles[unit];
+
+	if (cons == NULL) {
+		KRN_DEBUG(3, "Creating virtual terminal %d", unit);
+		cons = kgi_kmalloc(sizeof(sce_console));
+		if (cons == NULL) {
+			KRN_ERROR("Failed: Not enough memory.");
+			return (ENOMEM);
+		}
+		memset(cons, 0, sizeof(sce_console));
+
+		/* If the minor is null, the console was not initialized. */
+		if (unit == 0)
+			first_minor_allocated = 1;
+	}	
+	
+	cons->kii.tty = tp;
+	cons->kii.flags |= KII_DF_CONSOLE;
+	cons->kii.priv.priv_ptr = cons;
+
+	/*
+	 * Check if console is setup & attach KGI's scroller and renderer
+	 * classes to it.
+	 */
+	if (sce_consoles[unit] == NULL) {
+		err = kii_register_device(&(cons->kii), unit);
+		if (err != KII_EOK) {
+			KRN_ERROR("Failed: Could not register input on %d %d", unit, err);
+			goto fail_reg_device;
+		}
+
+		/*
+		 * Allocate a new render instance based on the render class
+		 * registered to our display.
+		 */
+		cons->render = kgc_render_alloc(unit, NULL);
+		if (cons->render == NULL) {			
+			KRN_ERROR("Failed: Could not allocate render device %d", unit);
+			goto fail_render_alloc;
+		}
+
+		((render_t) cons->render)->cons = cons;	/* XXX */
+		if (RENDER_INIT((render_t)cons->render, 0)) {			
+			KRN_ERROR("Failed: Could not initialize renderer!");
+			goto fail_render_init;
+		}
+
+		/*
+		 * Allocate a new scroller instance based on the scroller class
+		 * registered to our display.
+		 */
+		cons->scroller = kgc_scroller_alloc(unit, NULL);
+		if (cons->scroller == NULL) {			
+			KRN_ERROR("Failed: Could not allocate scroller device %d", unit);
+			goto fail_scroller_alloc;
+		}
+
+		((render_t)cons->scroller)->cons = cons; /* XXX */		
+		if (SCROLLER_INIT((scroller_t)cons->scroller, NULL)) {
+			KRN_ERROR("Failed: Could not reset console");
+			goto fail_scroller_init;
+		}
+
+		if (kii_current_focus(cons->kii.focus_id) == NULL)
+			kii_map_device(cons->kii.id);
+
+		/*
+		 * Initialization OK.
+		 */
+		sce_consoles[unit] = (sce_console *)cons;
+		KRN_DEBUG(4, "Virtual terminal console %i allocated.", unit);
+	}
+
+	assign_parser(cons, (unit) ? 1 : 0);
+
+	return (KGI_EOK);
+
+ fail_scroller_init: /* Fall thru. */
+	kgc_scroller_release(unit);
+ fail_scroller_alloc: /* Fall thru. */
+	RENDER_DONE((render_t)cons->render);
+ fail_render_init: /* Fall thru. */
+	kgc_render_release(unit);
+ fail_render_alloc: /* Fall thru. */
+	kii_unregister_device(&(cons->kii));
+ fail_reg_device:
+	if ((cons && unit) || (cons && first_minor_allocated)) {
+		kgi_kfree(cons);
+		sce_consoles[unit] = NULL;
+		first_minor_allocated = 0;
+	}
+	
+	return (ENXIO);	
+}
+
+/*
+ * Cleanup and remove virtual terminals.
+ */
+static int
+sce_close_vt(int unit)
+{
+	kgi_console_t *cons;
+	
+	cons = (kgi_console_t *)sce_consoles[unit];
+
+	unit = sce_ttytounit(cons->kii.tty);
+	if (unit >= CONFIG_KGII_MAX_NR_CONSOLES) {
+		KRN_ERROR("Bad console %i", unit);
+		return (EINVAL);
+	}
+	
+	if (cons && (unit || first_minor_allocated)) {
+		KRN_DEBUG(2, "Freeing console %i", unit);
+
+		if (cons->kii.flags & KII_DF_FOCUSED)
+			kii_unmap_device(cons->kii.id);
+
+		kii_unregister_device(&cons->kii);
+
+		SCROLLER_DONE((scroller_t)cons->scroller);
+		cons->scroller = NULL;
+		kgc_scroller_release(unit);
+
+		RENDER_DONE((render_t)cons->render);
+		cons->render = NULL;
+		kgc_render_release(unit);
+
+		sce_consoles[unit] = NULL;
+		kgi_kfree(cons);
+
+		if ((unit == 0) && first_minor_allocated)
+			first_minor_allocated = 0;
+	}
+	return (KGI_EOK);
+}
+
+/*
+ * Get unit number of TTY device.
+ */
+static inline int 
+sce_ttytounit(struct tty *tp)
+{
+
+	return (((sce_ttysoftc* )tty_softc(tp))->unit);
+}
+
+/*
+ * Allocate and create TTY device.
+ */
+static struct tty *
+sce_create_tty(int unit)
+{
+	struct tty *tp;
+	struct sce_ttysoftc *sc; /* Used to store device unit. */
+	
+	/* Allocate ttysoftc. */
+	sc = malloc(sizeof(sce_ttysoftc), M_DEVBUF, M_WAITOK);
+	sc->unit = unit;	
+	
+	/* Allocate TTY & store device number. */
+	KRN_DEBUG(5, "Allocating TTY %i", unit);
+	tp = tty_alloc(&scevt_ttydevsw, sc);
+	
+	/* Create TTY device node. */
+	tty_makedev(tp, NULL, "v%r", unit);
+	
+	return (tp);
+}
+
+static int
+sce_tswioctl(struct tty *tp, u_long cmd, caddr_t data, struct thread *td)
+{
+
+	switch (cmd) {
+		/* Translate from KII to KBD format. */
+	case GIO_KEYMAP: /* Get keyboard translation table. */					 
+	case PIO_KEYMAP: /* Set keyboard translation table. */
+	case GIO_KEYMAPENT:	/* Get keyboard translation table entry. */
+	case PIO_KEYMAPENT:	/* Set keyboard translation table entry. */
+	case GIO_DEADKEYMAP: /* Get accent key translation table. */
+	case PIO_DEADKEYMAP: /* Set accent key translation table. */
+	case GETFKEY:		 /* Get functionkey string. */
+	case SETFKEY:		 /* Set functionkey string. */
+		return (ENOTTY);
+	default:
+		break;
+	}
+
+	/* Leave ioctl up to the TTY system. */
+	return (ENOIOCTL);
+}
+
+/* 
+ * TTY open routine. 
+ */
+static int
+sce_tswopen(struct tty *tp)
+{
+	int unit;
+	kgi_ucoord_t sz, rz;
+	kgi_console_t *cons;
+
+	/* 
+	 * Set the window dimensions of the TTY if they're not already set.
+	 */
+	unit = sce_ttytounit(tp);
+	cons = (kgi_console_t *)sce_consoles[unit];
+	if (cons == NULL)
+		return (ENXIO);
+
+	if (tp->t_winsize.ws_col == 0 || tp->t_winsize.ws_row == 0) {
+		SCROLLER_GET(cons->scroller, &sz, 0, 0, 0, 0, 0, 0);
+		RENDER_GET(cons->render, &rz, 0, 0);
+
+		tp->t_winsize.ws_col = sz.x;
+		tp->t_winsize.ws_xpixel = rz.x;	
+		tp->t_winsize.ws_row = sz.y;
+		tp->t_winsize.ws_ypixel = rz.y;
+	}
+
+	return (0);
+}
+
+/*
+ * Receive data from the TTY system and pass it to the KGC terminal layer.
+ */
+static void 
+sce_tswoutwakeup(struct tty *tp)
+{
+ 	int unit;
+	kgi_console_t *cons;
+	size_t len;
+	u_char buf[PCBURST];
+
+	unit = sce_ttytounit(tp);
+	cons = (kgi_console_t *)sce_consoles[unit];
+	if (cons == NULL)
+		return;
+
+ 	kiidev_sync(&(cons->kii), KII_SYNC_LED_FLAGS);
+	
+	KRN_DEBUG(8, "Receiving data from TTY %d", unit);
+
+	for (;;) {
+		/* Fill the buffer. */
+		len = ttydisc_getc(tp, buf, sizeof(buf));
+		KRN_DEBUG(8, "%d bytes in buffer.", len);
+		if (len == 0)
+			break;
+		cons->DoWrite(cons, buf, len);
+	}	
+}
+
+static int
+scevt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int flag,
+		struct thread *td)
+{
+
+	return (sce_tswioctl(dev->si_drv1, cmd, data, td));
+}
+
+/*
+ * Load the syscons emulator virtual console.
+ */
+static int
+scevt_mod_event(module_t mod, int type, void *data)
+{
+	int err, unit;
+	struct cdev *dev;
+	struct tty *tp;
+	static int scevt_init = SCEVT_COLD;
+
+	switch (type) {
+	case MOD_LOAD:
+		/* 
+		 * XXX 
+		 * MAXCONS used here should be auto at kbd plug?
+		 */
+		if (scevt_init == SCEVT_COLD ) {
+			for (unit = 0; unit < MAXCONS; unit++) {
+				tp = sce_create_tty(unit);
+				sce_init_vt(tp);
+			}
+			dev = make_dev(&scevt_devsw, 0, UID_ROOT, GID_WHEEL, 0600, "scevt");
+			scevt_init = SCEVT_WARM;
+#ifndef SC_NO_SYSMOUSE
+			sce_mouse_init();
+			sce_sysmouse_init();
+#endif
+		}		
+		return (0);
+	case MOD_UNLOAD:
+		if (scevt_init == SCEVT_WARM) {
+			for (unit = 0; unit < MAXCONS; unit++) {
+				err = sce_close_vt(unit);
+				if (err != KGI_EOK)
+					KRN_ERROR("Failed to remove console %d", unit);
+			}
+			scevt_init = SCEVT_COLD;
+		}
+		return (ENXIO);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static moduledata_t scevt_mod = {
+	"scevt",
+	scevt_mod_event,
+	NULL,
+};
+
+DECLARE_MODULE(scevt, scevt_mod, SI_SUB_DRIVERS, SI_ORDER_ANY);
+MODULE_VERSION(scevt, 1);
+
diff -x CVS -x .svn -aurpN sys/i386/conf/KGI sys/i386/conf/KGI
--- sys/i386/conf/KGI	1970-01-01 08:00:00.000000000 +0800
+++ sys/i386/conf/KGI	2009-10-01 10:41:59.000000000 +0800
@@ -0,0 +1,60 @@
+include	GENERIC
+ident	KGI
+
+# KGI (Kernel Graphic Interface)
+options	KGI_COMPAT		# Enables KGI compatibility.
+options	KGI_DBG_LEVEL=0		# KGI debug output level.
+
+# Restrict building of dev/pci/vga_pci.c to avoid probing.
+options	KGI_IGNORE_VGAPCI	
+
+# Text based splash screen at loader.
+#options KGI_NOSPLASH
+
+# Graphics console setup:
+# Define one of the following modes for the console display resolution:
+#options	KGC_RENDER_1280x1024
+#options	KGC_RENDER_1024x768 
+options		KGC_RENDER_800x600 
+#options	KGC_RENDER_640x480 
+#options	KGC_RENDER_640x400 
+#options	KGC_RENDER_320x240 
+#options	KGC_RENDER_320x200 
+
+# Define a colour mode (bpp);
+options	KGC_RENDER_16BITS	# Use 16bit mode.
+
+# Enable console background - currently 8bit only:
+#options	KGC_RENDER_BACKGROUND
+
+# The default font to be used by the KGI console. See dev/kgc/kgc_gfbdflt.c
+# Currently nothing else other than kgc_bold8x16 is in the kernel.
+options	KGC_DEFAULT_FONT=kgc_bold8x16
+
+# KGI core.
+device	kgi	# Kernel Graphic Interface core system (includes KII)
+
+# KGI KIP (Kernel Input Parser)
+# It works on top of kbd in RAW mode. Scancodes are translated by
+# kip maps.
+device	kip	# Default KIP.
+
+# Input and graphic user interfaces (e.g /dev/graphic and /dev/event)
+device	kgu	# KGI graphic user interface.
+device	kiu	# KGI input user interface.
+device	kgc	# Kernel graphic console.
+device	kgy	# KGI VESA compatible display.
+device	kgim	# KGI module driver interface.
+
+# Experimental FreeBSD adapter implementation on top of KGI.
+#device		kga		# FreeBSD compatible adapter (broken)
+
+# Syscons emulation.
+device	sce
+
+# Disable sc and splash
+nodevice	sc
+nodevice	splash
+
+# FreeBSD's VESA mod
+options	VESA
diff -x CVS -x .svn -aurpN sys/i386/isa/vesa.c sys/i386/isa/vesa.c
--- sys/i386/isa/vesa.c	2009-08-22 13:07:24.000000000 +0800
+++ sys/i386/isa/vesa.c	2009-10-01 10:41:59.000000000 +0800
@@ -206,6 +206,7 @@ static int vesa_bios_init(void);
 static void vesa_clear_modes(video_info_t *info, int color);
 static vm_offset_t vesa_map_buffer(u_int paddr, size_t size);
 static void vesa_unmap_buffer(vm_offset_t vaddr, size_t size);
+extern int vesa_configure(int flags);
 
 #if 0
 static int vesa_get_origin(video_adapter_t *adp, off_t *offset);
@@ -851,7 +852,7 @@ vesa_unmap_buffer(vm_offset_t vaddr, siz
 
 /* entry points */
 
-static int
+int
 vesa_configure(int flags)
 {
 	video_adapter_t *adp;
diff -x CVS -x .svn -aurpN sys/isa/vga_isa.c sys/isa/vga_isa.c
--- sys/isa/vga_isa.c	2009-08-22 13:06:59.000000000 +0800
+++ sys/isa/vga_isa.c	2009-10-01 10:42:00.000000000 +0800
@@ -30,6 +30,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_vga.h"
 #include "opt_fb.h"
 #include "opt_syscons.h"	/* should be removed in the future, XXX */
+#include "opt_kgi.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -106,10 +107,12 @@ isavga_probe(device_t dev)
 	device_set_desc(dev, "Generic ISA VGA");
 	error = vga_probe_unit(device_get_unit(dev), &adp, device_get_flags(dev));
 	if (error == 0) {
+#ifndef KGI_COMPAT
 		bus_set_resource(dev, SYS_RES_IOPORT, 0,
 				 adp.va_io_base, adp.va_io_size);
 		bus_set_resource(dev, SYS_RES_MEMORY, 0,
 				 adp.va_mem_base, adp.va_mem_size);
+#endif
 #if 0
 		isa_set_port(dev, adp.va_io_base);
 		isa_set_portsize(dev, adp.va_io_size);
@@ -125,8 +128,9 @@ isavga_attach(device_t dev)
 {
 	vga_softc_t *sc;
 	int unit;
-	int rid;
 	int error;
+#ifndef KGI_COMPAT
+	int rid;
 
 	unit = device_get_unit(dev);
 	sc = device_get_softc(dev);
@@ -137,6 +141,10 @@ isavga_attach(device_t dev)
 	rid = 0;
 	bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,
 				 0, ~0, 0, RF_ACTIVE | RF_SHAREABLE);
+#endif
+
+	unit = device_get_unit(dev);
+	sc = device_get_softc(dev);
 
 	error = vga_attach_unit(unit, sc, device_get_flags(dev));
 	if (error)
diff -x CVS -x .svn -aurpN sys/sys/conf.h sys/sys/conf.h
--- sys/sys/conf.h	2009-08-22 13:07:34.000000000 +0800
+++ sys/sys/conf.h	2009-10-01 10:42:00.000000000 +0800
@@ -170,6 +170,7 @@ typedef int dumper_t(
 #define D_PSEUDO	0x00200000	/* make_dev() can return NULL */
 #define D_NEEDGIANT	0x00400000	/* driver want Giant */
 #define	D_NEEDMINOR	0x00800000	/* driver uses clone_create() */
+#define D_KGI_PAGING	0x01600000	/* is a KGI pager backend */
 
 /*
  * Version numbers.
diff -x CVS -x .svn -aurpN sys/sys/fbio.h sys/sys/fbio.h
--- sys/sys/fbio.h	2009-08-22 13:07:34.000000000 +0800
+++ sys/sys/fbio.h	2009-10-01 10:42:00.000000000 +0800
@@ -85,8 +85,9 @@
 #define	FBTYPE_MDICOLOR		28	/* cg14 */
 #define	FBTYPE_TCXCOLOR		29	/* SUNW,tcx */
 #define	FBTYPE_CREATOR		30
+#define	FBTYPE_KGI		31
 
-#define	FBTYPE_LASTPLUSONE	31	/* max number of fbs (change as add) */
+#define	FBTYPE_LASTPLUSONE	32	/* max number of fbs (change as add) */
 
 /*
  * Frame buffer descriptor as returned by FBIOGTYPE.
@@ -269,6 +270,7 @@ struct video_info {
 #define V_INFO_GRAPHICS	(1 << 1)
 #define V_INFO_LINEAR	(1 << 2)
 #define V_INFO_VESA	(1 << 3)
+#define V_INFO_KGI	(1 << 4)
     int			vi_width;
     int			vi_height;
     int			vi_cwidth;
@@ -314,6 +316,7 @@ struct video_adapter {
 #define KD_PC98		6		/* PC-98 display */
 #define KD_TGA		7		/* TGA */
 #define KD_TGA2		8		/* TGA2 */
+#define KD_KGI		9		/* KGI */
     char		*va_name;
     int			va_unit;
     int			va_minor;
@@ -331,6 +334,7 @@ struct video_adapter {
 #define V_ADP_INITIALIZED (1 << 17)
 #define V_ADP_REGISTERED (1 << 18)
 #define V_ADP_ATTACHED	(1 << 19)
+#define V_ADP_KGI	(1 << 20)
     vm_offset_t		va_io_base;
     int			va_io_size;
     vm_offset_t		va_crtc_addr;
diff -x CVS -x .svn -aurpN sys/sys/kernel.h sys/sys/kernel.h
--- sys/sys/kernel.h	2009-08-22 13:07:34.000000000 +0800
+++ sys/sys/kernel.h	2009-10-01 10:42:00.000000000 +0800
@@ -106,7 +106,8 @@ enum sysinit_sub_id {
 	SI_SUB_MTX_POOL_DYNAMIC	= 0x1AC0000,	/* dynamic mutex pool */
 	SI_SUB_LOCK		= 0x1B00000,	/* various locks */
 	SI_SUB_EVENTHANDLER	= 0x1C00000,	/* eventhandler init */
-	SI_SUB_VNET_PRELINK	= 0x1E00000,	/* vnet init before modules */
+	SI_SUB_KGI		= 0x1D00000,	/* KGI */
+	SI_SUB_VNET_PRELINK	= 0x1E00000,	/* vnet init before modules !/ */
 	SI_SUB_KLD		= 0x2000000,	/* KLD and module setup */
 	SI_SUB_CPU		= 0x2100000,	/* CPU resource(s)*/
 	SI_SUB_KDTRACE		= 0x2140000,	/* Kernel dtrace hooks */
@@ -166,6 +167,7 @@ enum sysinit_sub_id {
 	SI_SUB_KTHREAD_VM	= 0xe800000,	/* vm daemon*/
 	SI_SUB_KTHREAD_BUF	= 0xea00000,	/* buffer daemon*/
 	SI_SUB_KTHREAD_UPDATE	= 0xec00000,	/* update daemon*/
+	SI_SUB_KTHREAD_KGI	= 0xed00000,	/* kgi daemon*/
 	SI_SUB_KTHREAD_IDLE	= 0xee00000,	/* idle procs*/
 	SI_SUB_SMP		= 0xf000000,	/* start the APs*/
 	SI_SUB_RUN_SCHEDULER	= 0xfffffff	/* scheduler*/
diff -x CVS -x .svn -aurpN sys/sys/mman.h sys/sys/mman.h
--- sys/sys/mman.h	2009-08-22 13:07:34.000000000 +0800
+++ sys/sys/mman.h	2009-10-01 10:42:00.000000000 +0800
@@ -59,6 +59,7 @@
  */
 #define	MAP_SHARED	0x0001		/* share changes */
 #define	MAP_PRIVATE	0x0002		/* changes are private */
+#define	MAP_KGI		0x0004		/* KGI mmapping */
 #if __BSD_VISIBLE
 #define	MAP_COPY	MAP_PRIVATE	/* Obsolete */
 #endif
diff -x CVS -x .svn -aurpN sys/vm/kgi_pager.c sys/vm/kgi_pager.c
--- sys/vm/kgi_pager.c	1970-01-01 08:00:00.000000000 +0800
+++ sys/vm/kgi_pager.c	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,351 @@
+/*-
+ * Copyright (C) 2002, 2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * FreeBSD KGI pager
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/lock.h>
+#include <sys/proc.h>
+#include <sys/mutex.h>
+#include <sys/mman.h>
+#include <sys/sx.h>
+
+#include <sys/sysproto.h>
+#include <sys/filedesc.h>
+#include <sys/proc.h>
+#include <sys/vnode.h>
+#include <sys/fcntl.h>
+#include <sys/file.h>
+#include <sys/mman.h>
+#include <sys/conf.h>
+#include <sys/stat.h>
+#include <sys/vmmeter.h>
+#include <sys/sysctl.h>
+
+#include <vm/vm.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+#include <vm/uma.h>
+
+#include <vm/kgi_pager.h>
+
+static void kgi_pager_init(void);
+static vm_object_t kgi_pager_alloc(void *handle, vm_ooffset_t size,
+		vm_prot_t prot, vm_ooffset_t foff, struct ucred *cred);
+static void kgi_pager_dealloc(vm_object_t object);
+static int kgi_pager_getpages(vm_object_t object, vm_page_t *m,
+		int count, int reqpage);
+static void kgi_pager_putpages(vm_object_t object, vm_page_t *m, int count,
+		boolean_t sync, int *rtvals);
+static boolean_t kgi_pager_haspage(vm_object_t object, vm_pindex_t pindex,
+		int *before, int *after);
+
+/* list of device pager objects */
+static struct pagerlst kgi_pager_object_list;
+static struct vmalst kgi_pager_vma_list;
+
+/* protect against object creation */
+static struct sx kgi_pager_sx;
+/* protect list manipulation */
+static struct mtx kgi_pager_mtx;
+
+static uma_zone_t fakepg_zone;
+static uma_zone_t vma_zone;
+
+static vm_area_t kgi_pager_vma_allocate(vm_ooffset_t foff, vm_ooffset_t size,
+		vm_prot_t prot);
+static void kgi_pager_deallocate_vma(vm_area_t vma);
+static vm_page_t kgi_pager_getfake(void);
+static void kgi_pager_putfake(vm_page_t m);
+
+static void
+kgi_pager_init(void)
+{
+	TAILQ_INIT(&kgi_pager_object_list);
+	TAILQ_INIT(&kgi_pager_vma_list);
+	sx_init(&kgi_pager_sx, "kgi_pager create");
+	mtx_init(&kgi_pager_mtx, "kgi_pager list", NULL, MTX_DEF);
+	fakepg_zone = uma_zcreate("KGIP fakepg", sizeof(struct vm_page),
+				  NULL, NULL, NULL, NULL, UMA_ALIGN_PTR,
+				  UMA_ZONE_NOFREE|UMA_ZONE_VM);
+	vma_zone = uma_zcreate("KGIP vma", sizeof(struct vm_area_struct),
+			       NULL, NULL, NULL, NULL, UMA_ALIGN_PTR,
+			       UMA_ZONE_NOFREE|UMA_ZONE_VM);
+	return;
+}
+
+static vm_object_t
+kgi_pager_alloc(void *handle, vm_ooffset_t size, vm_prot_t prot,
+		vm_ooffset_t foff, struct ucred *cred)
+{
+	vm_object_t object;
+	vm_area_t vma;
+	struct cdev *dev;
+	struct cdevsw *csw;
+	int err = 0;
+
+	/*
+	 * Make sure this device can be mapped.
+	 */
+	dev = (struct cdev *)handle;
+	csw = dev_refthread(dev);
+	if (csw == NULL)
+		return (NULL);
+
+	mtx_lock(&Giant);
+	/*
+	 * Offset should be page aligned.
+	 */
+	if (foff & PAGE_MASK) {
+		mtx_unlock(&Giant);
+		return (NULL);
+	}
+
+	size = round_page(size);
+
+	/* Allocate a new vm area */
+	vma = kgi_pager_vma_allocate(foff, size, prot);
+
+	/* Map the area to the resource.
+	 * graph_mmap should check the protection.
+	 */
+	err = graph_mmap(dev, vma);
+
+	/* XXX handle error */
+
+	/*
+	 * Lock to prevent object creation race condition.
+	 */
+	sx_xlock(&kgi_pager_sx);
+
+	/*
+	 * Create an object for every mapping.
+	 * Allocate object and associate it with the pager.
+	 * The idea is to have only one reference to the object and
+	 * get kgi_pager_dealloc() called for every release of a mapping.
+	 * True, it duplicates the role of the object but for now
+	 * this is best to keep compatibility without too much changes in
+	 * the existing code.
+	 */
+	object = vm_object_allocate(OBJT_KGI, OFF_TO_IDX(foff + size));
+	object->handle = vma;
+	TAILQ_INIT(&object->un_pager.kgip.kgip_pglist);
+	mtx_lock(&kgi_pager_mtx);
+	TAILQ_INSERT_TAIL(&kgi_pager_object_list, object, pager_object_list);
+	mtx_unlock(&kgi_pager_mtx);
+
+	vma->vm_object = object;
+	TAILQ_INSERT_TAIL(&kgi_pager_vma_list, vma, pager_vma_list);
+
+	sx_xunlock(&kgi_pager_sx);
+	mtx_unlock(&Giant);
+	dev_relthread(dev);
+	return (object);
+}
+
+/* 
+ * The object shall be locked.
+ */
+static void
+kgi_pager_dealloc(vm_object_t object)
+{
+	vm_area_t vma = (vm_area_t )object->handle;
+	vm_page_t m;
+
+	mtx_lock(&kgi_pager_mtx);
+	TAILQ_REMOVE(&kgi_pager_object_list, object, pager_object_list);
+	mtx_unlock(&kgi_pager_mtx);
+
+	while ((m = TAILQ_FIRST(&vma->vm_object->un_pager.kgip.kgip_pglist)) != 0) {
+		TAILQ_REMOVE(&vma->vm_object->un_pager.kgip.kgip_pglist, m, pageq);
+		kgi_pager_putfake(m);
+	}
+
+	kgi_pager_deallocate_vma(vma);
+}
+
+
+/* KGI pager manages its own pages since the swapper is not supposed
+ * to see them. The pages are listed in their object and also pointed
+ * by the buffers that use them in the sublayers of KGI. This why
+ * the new allocated page is passed to the nopage hook of KGI.
+ */
+static int
+kgi_pager_getpages(vm_object_t object, vm_page_t *m, int count, int reqpage)
+{
+	vm_area_t vma;
+	vm_offset_t offset;
+	vm_paddr_t paddr;
+	vm_page_t page;
+	int i, ret;
+	int prot;
+
+	VM_OBJECT_LOCK_ASSERT(object, MA_OWNED);
+	vma = object->handle;
+	offset = m[reqpage]->pindex;
+	VM_OBJECT_UNLOCK(object);
+	prot = PROT_READ;	/* XXX should pass in? */
+
+	/* Get a new page */
+	page = kgi_pager_getfake();
+
+	/* Get the corresponding physical address from KGI graphic resource */
+	ret = vma->vm_ops->nopage(vma, page, (vm_offset_t) offset << PAGE_SHIFT, 
+							  &paddr, prot);
+
+	KASSERT(ret == 0,("kgi_pager_getpage: map function returns error"));
+
+	/*
+	 * Replace the passed in reqpage page with our own fake page and free up
+	 * all of the original pages. The KGI pager allocates one page at a time
+	 * which is certainly not optimal XXX.
+	 */
+	page->phys_addr = paddr;
+
+	VM_OBJECT_LOCK(object);
+	TAILQ_INSERT_TAIL(&object->un_pager.kgip.kgip_pglist, page, pageq);
+	vm_page_lock_queues();
+	for (i = 0; i < count; i++) {
+		vm_page_free(m[i]);
+	}
+	vm_page_unlock_queues();
+	vm_page_insert(page, object, offset);
+	m[reqpage] = page;
+
+	return (VM_PAGER_OK);
+}
+
+static void
+kgi_pager_putpages(vm_object_t object, vm_page_t *m, int count,
+		   boolean_t sync, int *rtvals)
+{
+	panic("kgi_pager_putpage called");
+}
+
+static boolean_t
+kgi_pager_haspage(vm_object_t object, vm_pindex_t pindex,
+		  int *before, int *after)
+{
+	if (before != NULL)
+		*before = 0;
+	if (after != NULL)
+		*after = 0;
+	return (TRUE);
+}
+
+struct pagerops kgipagerops = {
+	.pgo_init 		= kgi_pager_init,
+	.pgo_alloc 		= kgi_pager_alloc,
+	.pgo_dealloc 	= kgi_pager_dealloc,
+	.pgo_getpages 	= kgi_pager_getpages,
+	.pgo_putpages 	= kgi_pager_putpages,
+	.pgo_haspage 	= kgi_pager_haspage
+};
+
+static vm_area_t 
+kgi_pager_vma_allocate(vm_ooffset_t foff, vm_ooffset_t size, vm_prot_t prot)
+{
+	vm_area_t vma;
+
+	/* Allocate a new vm area */
+	vma = (vm_area_t )uma_zalloc(vma_zone, M_WAITOK);
+	bzero(vma, sizeof(struct vm_area_struct));
+
+	/* Initialize the area */
+	vma->vm_offset = foff;
+	vma->vm_size = size;
+	vma->vm_prot = prot;
+
+	return (vma);
+}
+
+void
+kgi_pager_remove(vm_area_t vma, vm_page_t m)
+{
+	
+	VM_OBJECT_LOCK(vma->vm_object);
+	vm_page_lock_queues();
+
+	vm_page_busy(m);
+	pmap_remove_all(m);
+	vm_page_remove(m);
+
+	vm_page_unlock_queues();
+
+	TAILQ_REMOVE(&vma->vm_object->un_pager.kgip.kgip_pglist, m, pageq);
+	VM_OBJECT_UNLOCK(vma->vm_object);
+
+	/* Not optimal, should improve with a pool of pages of the pager. XXX */
+	kgi_pager_putfake(m);
+}
+
+void
+kgi_pager_remove_all(vm_area_t vma)
+{
+	vm_page_t m;
+	int num = 0;
+
+	while ((m = TAILQ_FIRST(&vma->vm_object->un_pager.kgip.kgip_pglist)) != 0) {
+		kgi_pager_remove(vma, m);
+		num ++;
+	}
+
+	printf("%d pages removed from vm area %p\n", num, vma);
+}
+
+static void
+kgi_pager_deallocate_vma(vm_area_t vma)
+{
+	/* Free the vma */
+	uma_zfree(vma_zone, vma);
+}
+
+static vm_page_t
+kgi_pager_getfake(void)
+{
+	vm_page_t m;
+
+	m = uma_zalloc(fakepg_zone, M_WAITOK);
+
+	/* Compared to the device pager, KGI pages have a PV entry
+	 * thus PG_FICTITIOUS is not used.
+	 */
+	m->flags = VPO_BUSY;
+	m->valid = VM_PAGE_BITS_ALL;
+	m->dirty = 0;
+	m->busy = 0;
+	m->queue = PQ_NONE;
+	m->object = NULL;
+
+	/* XXX HACK HACK HACK. This is MD code! */
+	TAILQ_INIT(&m->md.pv_list);
+
+	/* Force the page non pageable */
+	m->wire_count = 1;
+	m->hold_count = 0;
+
+	return (m);
+}
+
+static void
+kgi_pager_putfake(vm_page_t m)
+{
+	uma_zfree(fakepg_zone, m);
+}
diff -x CVS -x .svn -aurpN sys/vm/kgi_pager.h sys/vm/kgi_pager.h
--- sys/vm/kgi_pager.h	1970-01-01 08:00:00.000000000 +0800
+++ sys/vm/kgi_pager.h	2009-10-01 10:42:00.000000000 +0800
@@ -0,0 +1,76 @@
+/*-
+ * Copyright (C) 2002, 2004 Nicholas Souchu
+ *
+ * This file is distributed under the terms and conditions of the 
+ * MIT/X public license. Please see the file COPYRIGHT.MIT included
+ * with this software for details of these terms and conditions.
+ * Alternatively you may distribute this file under the terms and
+ * conditions of the GNU General Public License. Please see the file 
+ * COPYRIGHT.GPL included with this software for details of these terms
+ * and conditions.
+ */
+
+/*
+ * FreeBSD KGI pager.
+ */
+
+#ifndef	_KGI_PAGER_
+#define	_KGI_PAGER_
+
+#include <sys/queue.h>
+
+/* Head of the list of vma areas managed by the pager. */
+TAILQ_HEAD(vmalst, vm_area_struct);
+
+typedef struct vm_area_struct * vm_area_t;
+
+struct vm_operations_struct {
+	void (*open)(vm_area_t vma);
+	void (*close)(vm_area_t vma);
+	int (*nopage)(vm_area_t vma, vm_page_t m, vm_offset_t ooffset,
+		      vm_paddr_t *paddr, int prot);
+	void(*unmap)(vm_area_t vma);
+};
+
+/* The vm_area_struct is used to keep somehow compatibility with
+ * Linux interface. This is also to keep graph_mapping_t as independent
+ * of OS as possible.
+ *
+ * A vma is associated to each KGI pager VM object. The VMA struct somehow
+ * duplicates the role of the object but adds the fields which
+ * we don't want to add to the object structure.
+ */
+struct vm_area_struct {
+	TAILQ_ENTRY(vm_area_struct) pager_vma_list;
+
+	vm_ooffset_t vm_offset;		/* offset inside the object given at
+					 * allocation */
+	vm_ooffset_t vm_size;		/* size of the mapped area */
+	vm_prot_t vm_prot;		/* area protection */
+
+	vm_object_t vm_object;		/* the object of this area */
+
+	struct vm_operations_struct *vm_ops; /* hook operations of the underlying
+					      * mapping type (mmio, accel...) */
+
+	void *vm_private_data;		/* actually the graph map, but void *
+					 * to avoid type dependency */
+
+	int vm_unit;			/* minor of the graphic dev */
+	int vm_type;			/* type of the corresponding kgi resource */
+};
+
+/* 
+ * Functions provided by the KGI device (accel or mmio for example).
+ */
+extern int graph_mmap(struct cdev *dev, vm_area_t vma);
+extern void graph_munmap(vm_area_t vma);
+
+/* 
+ * Lowlevel routines provided to KGI devices to perform VM
+ * operations.
+ */
+extern void kgi_pager_remove(vm_area_t vma, vm_page_t m);
+extern void kgi_pager_remove_all(vm_area_t vma);
+
+#endif /* _KGI_PAGER_ */
diff -x CVS -x .svn -aurpN sys/vm/vm.h sys/vm/vm.h
--- sys/vm/vm.h	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm.h	2009-10-01 10:42:00.000000000 +0800
@@ -89,7 +89,7 @@ typedef u_char vm_prot_t;	/* protection 
 #define	VM_PROT_DEFAULT		VM_PROT_ALL
 
 enum obj_type { OBJT_DEFAULT, OBJT_SWAP, OBJT_VNODE, OBJT_DEVICE, OBJT_PHYS,
-		OBJT_DEAD, OBJT_SG };
+		OBJT_KGI, OBJT_DEAD, OBJT_SG };
 typedef u_char objtype_t;
 
 union vm_map_object;
diff -x CVS -x .svn -aurpN sys/vm/vm_fault.c sys/vm/vm_fault.c
--- sys/vm/vm_fault.c	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm_fault.c	2009-10-01 10:42:00.000000000 +0800
@@ -471,9 +471,10 @@ readrest:
 			      fs.pindex < fs.entry->lastr + VM_FAULT_READ)) &&
 			    (fs.first_object == fs.object ||
 			     (is_first_object_locked = VM_OBJECT_TRYLOCK(fs.first_object))) &&
-			    fs.first_object->type != OBJT_DEVICE &&
-			    fs.first_object->type != OBJT_PHYS &&
-			    fs.first_object->type != OBJT_SG) {
+			    (fs.first_object->type != OBJT_DEVICE) &&
+			    (fs.first_object->type != OBJT_PHYS) &&
+				(fs.first_object->type != OBJT_SG) &&
+			    (fs.first_object->type != OBJT_KGI)) {
 				vm_pindex_t firstpindex, tmppindex;
 
 				if (fs.first_pindex < 2 * VM_FAULT_READ)
diff -x CVS -x .svn -aurpN sys/vm/vm_mmap.c sys/vm/vm_mmap.c
--- sys/vm/vm_mmap.c	2009-09-30 10:43:22.000000000 +0800
+++ sys/vm/vm_mmap.c	2009-10-01 10:42:00.000000000 +0800
@@ -372,6 +372,11 @@ mmap(td, uap)
 		} else if (vp->v_type != VCHR || (fp->f_flag & FWRITE) != 0) {
 			maxprot |= VM_PROT_WRITE;
 		}
+		/* Recognize a KGI backend. */
+		if ((vp->v_type == VCHR) && 
+			(vp->v_rdev->si_devsw->d_flags & D_KGI_PAGING)) {
+			flags |= MAP_KGI;
+		}
 		handle = (void *)vp;
 		handle_type = OBJT_VNODE;
 	}
@@ -1148,11 +1153,12 @@ vm_mmap_vnode(struct thread *td, vm_size
     struct vnode *vp, vm_ooffset_t *foffp, vm_object_t *objp)
 {
 	struct vattr va;
+	void *handle;
 	vm_object_t obj;
 	vm_offset_t foff;
 	struct mount *mp;
 	struct ucred *cred;
-	int error, flags;
+	int error, flags, type;
 	int vfslocked;
 
 	mp = vp->v_mount;
@@ -1178,7 +1184,14 @@ vm_mmap_vnode(struct thread *td, vm_size
 			vp = (struct vnode*)obj->handle;
 			vget(vp, LK_SHARED, td);
 		}
+		type = OBJT_VNODE;
+		handle = vp;
 	} else if (vp->v_type == VCHR) {
+		if (flags & MAP_KGI)
+			type = OBJT_KGI;
+		else
+			type = OBJT_DEVICE;
+		handle = vp->v_rdev;
 		error = vm_mmap_cdev(td, objsize, prot, maxprotp, flagsp,
 		    vp->v_rdev, foffp, objp);
 		if (error == 0)
@@ -1212,9 +1225,9 @@ vm_mmap_vnode(struct thread *td, vm_size
 	objsize = round_page(va.va_size);
 	if (va.va_nlink == 0)
 		flags |= MAP_NOSYNC;
-	obj = vm_pager_allocate(OBJT_VNODE, vp, objsize, prot, foff, td->td_ucred);
+	obj = vm_pager_allocate(type, handle, objsize, prot, foff, td->td_ucred);
 	if (obj == NULL) {
-		error = ENOMEM;
+		error = ((type == OBJT_DEVICE || type == OBJT_KGI) ? EINVAL : ENOMEM);
 		goto done;
 	}
 	*objp = obj;
diff -x CVS -x .svn -aurpN sys/vm/vm_object.h sys/vm/vm_object.h
--- sys/vm/vm_object.h	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm_object.h	2009-10-01 10:42:00.000000000 +0800
@@ -142,6 +142,15 @@ struct vm_object {
 		struct {
 			int swp_bcount;
 		} swp;
+
+		/*
+		 * KGI pager
+		 *
+		 *	kgip_pglist - list of allocated pages.
+		 */
+		struct {
+			TAILQ_HEAD(, vm_page) kgip_pglist;
+		} kgip;
 	} un_pager;
 	struct uidinfo *uip;
 	vm_ooffset_t charge;
diff -x CVS -x .svn -aurpN sys/vm/vm_page.h sys/vm/vm_page.h
--- sys/vm/vm_page.h	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm_page.h	2009-10-01 10:42:00.000000000 +0800
@@ -99,6 +99,7 @@ TAILQ_HEAD(pglist, vm_page);
 struct vm_page {
 	TAILQ_ENTRY(vm_page) pageq;	/* queue info for FIFO queue or free list (P) */
 	TAILQ_ENTRY(vm_page) listq;	/* pages in same object (O) 	*/
+	TAILQ_ENTRY(vm_page) kgiq;	/* pages in same kgi buf (O) 	*/
 	struct vm_page *left;		/* splay tree link (O)		*/
 	struct vm_page *right;		/* splay tree link (O)		*/
 
diff -x CVS -x .svn -aurpN sys/vm/vm_pager.c sys/vm/vm_pager.c
--- sys/vm/vm_pager.c	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm_pager.c	2009-10-01 10:42:00.000000000 +0800
@@ -161,7 +161,8 @@ struct pagerops *pagertab[] = {
 	&devicepagerops,	/* OBJT_DEVICE */
 	&physpagerops,		/* OBJT_PHYS */
 	&deadpagerops,		/* OBJT_DEAD */
-	&sgpagerops		/* OBJT_SG */
+	&sgpagerops,		/* OBJT_SG */
+	&kgipagerops		/* OBJT_KGI */
 };
 
 static const int npagers = sizeof(pagertab) / sizeof(pagertab[0]);
diff -x CVS -x .svn -aurpN sys/vm/vm_pager.h sys/vm/vm_pager.h
--- sys/vm/vm_pager.h	2009-08-22 13:07:20.000000000 +0800
+++ sys/vm/vm_pager.h	2009-10-01 10:42:00.000000000 +0800
@@ -71,6 +71,7 @@ extern struct pagerops vnodepagerops;
 extern struct pagerops devicepagerops;
 extern struct pagerops physpagerops;
 extern struct pagerops sgpagerops;
+extern struct pagerops kgipagerops;
 
 /*
  * get/put return values
diff -x CVS -x .svn -aurpN usr.sbin/moused/moused.c usr.sbin/moused/moused.c
--- usr.sbin/moused/moused.c	2009-08-22 13:08:30.000000000 +0800
+++ usr.sbin/moused/moused.c	2009-10-01 10:42:04.000000000 +0800
@@ -1,48 +1,48 @@
-/**
- ** Copyright (c) 1995 Michael Smith, All rights reserved.
- **
- ** Redistribution and use in source and binary forms, with or without
- ** modification, are permitted provided that the following conditions
- ** are met:
- ** 1. Redistributions of source code must retain the above copyright
- **    notice, this list of conditions and the following disclaimer as
- **    the first lines of this file unmodified.
- ** 2. Redistributions in binary form must reproduce the above copyright
- **    notice, this list of conditions and the following disclaimer in the
- **    documentation and/or other materials provided with the distribution.
- ** 3. All advertising materials mentioning features or use of this software
- **    must display the following acknowledgment:
- **      This product includes software developed by Michael Smith.
- ** 4. The name of the author may not be used to endorse or promote products
- **    derived from this software without specific prior written permission.
- **
- **
- ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY
- ** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- ** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR
- ** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- ** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- ** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- ** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- ** EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- **
- **/
+/*-
+ * Copyright (c) 1995 Michael Smith, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer as
+ *    the first lines of this file unmodified.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgment:
+ *      This product includes software developed by Michael Smith.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
-/**
- ** MOUSED.C
- **
- ** Mouse daemon : listens to a serial port, the bus mouse interface, or
- ** the PS/2 mouse port for mouse data stream, interprets data and passes
- ** ioctls off to the console driver.
- **
- ** The mouse interface functions are derived closely from the mouse
- ** handler in the XFree86 X server.  Many thanks to the XFree86 people
- ** for their great work!
- **
- **/
+/*
+ * MOUSED.C
+ *
+ * Mouse daemon : listens to a serial port, the bus mouse interface, or
+ * the PS/2 mouse port for mouse data stream, interprets data and passes
+ * ioctls off to the console driver.
+ *
+ * The mouse interface functions are derived closely from the mouse
+ * handler in the XFree86 X server.  Many thanks to the XFree86 people
+ * for their great work!
+ *
+ */
 
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
@@ -1035,8 +1035,10 @@ moused(void)
     int c;
     int i;
 
-    if ((rodent.cfd = open("/dev/consolectl", O_RDWR, 0)) == -1)
-	logerr(1, "cannot open /dev/consolectl");
+	if ((rodent.cfd = open("/dev/consolectl", O_RDWR, 0)) == -1) {
+		if ((rodent.cfd = open("/dev/consolectl1", O_RDWR, 0)) == -1)
+			logerrx(1, "cannot open any /dev/consolectl");
+	}
 
     if (!nodaemon && !background) {
 	pfh = pidfile_open(pidfile, 0600, &mpid);
